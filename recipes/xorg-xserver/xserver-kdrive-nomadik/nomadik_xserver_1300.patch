---
 Makefile.am                       |    6 
 Xext/Makefile.am                  |    6 
 Xext/xcalibrate.c                 |   47 
 configure.ac                      |   51 
 dix/dixfonts.c                    |    2 
 dix/window.c                      |  142 ++
 exa/exa.c                         |    6 
 exa/exa_offscreen.c               |    2 
 hw/kdrive/Makefile.am             |    9 
 hw/kdrive/fbdev/fbdev.c           |   59 +
 hw/kdrive/fbdev/fbinit.c          |    7 
 hw/kdrive/linux/evdev.c           |  385 +++++++
 hw/kdrive/linux/linux.c           |    4 
 hw/kdrive/linux/mouse.c           |    2 
 hw/kdrive/nomadik/Makefile.am     |   29 
 hw/kdrive/nomadik/nomadik-exa.c   |  957 ++++++++++++++++++
 hw/kdrive/nomadik/nomadik-exa.h   |  147 ++
 hw/kdrive/nomadik/nomadik-init.c  |  194 +++
 hw/kdrive/nomadik/nomadik-log.h   |   70 +
 hw/kdrive/nomadik/nomadik-sva.c   |  626 ++++++++++++
 hw/kdrive/nomadik/nomadik-sva.h   |  193 +++
 hw/kdrive/nomadik/nomadik-video.c | 1956 ++++++++++++++++++++++++++++++++++++++
 hw/kdrive/nomadik/nomadik-video.h |   26 
 hw/kdrive/src/kdrive.c            |   41 
 hw/kdrive/src/kdrive.h            |    7 
 hw/kdrive/src/kinput.c            |   14 
 hw/kdrive/src/kmode.c             |   49 
 include/kdrive-config.h.in        |    3 
 mi/miinitext.c                    |    6 
 xfixes/cursor.c                   |   25 
 30 files changed, 5034 insertions(+), 37 deletions(-)

--- xorg-server-1.3.0.0.orig/Makefile.am
+++ xorg-server-1.3.0.0/Makefile.am
@@ -28,10 +28,14 @@ endif
 
 if XINPUT
 XINPUT_DIR=Xi
 endif
 
+if XKB
+XKB_DIR=xkb
+endif
+
 if DBE
 DBE_DIR=dbe
 endif
 
 SUBDIRS = \
@@ -44,11 +48,11 @@ SUBDIRS = \
 	miext \
 	os \
 	randr \
 	render  \
 	$(XINPUT_DIR) \
-	xkb \
+	$(XKB_DIR) \
 	$(DBE_DIR) \
 	$(MFB_DIR) \
 	$(AFB_DIR) \
 	$(CFB_DIR) \
 	$(CFB32_DIR) \
--- xorg-server-1.3.0.0.orig/Xext/Makefile.am
+++ xorg-server-1.3.0.0/Xext/Makefile.am
@@ -89,10 +89,15 @@ XCALIBRATE_SRCS = xcalibrate.c
 if XCALIBRATE
 BUILTIN_SRCS += $(XCALIBRATE_SRCS)
 # XCalibrare needs tslib
 endif
 
+XCALIBRATE_SRCS = xcalibrate.c
+if XCALIBRATE
+BUILTIN_SRCS += $(XCALIBRATE_SRCS)
+endif
+
 # X EVent Interception Extension: allows accessibility helpers & composite
 # managers to intercept events from input devices and transform as needed
 # before the clients see them.
 XEVIE_SRCS = xevie.c
 if XEVIE
@@ -167,10 +172,11 @@ EXTRA_DIST = \
 	$(SCREENSAVER_SRCS) \
 	$(XACE_SRCS) \
 	$(XCSECURITY_SRCS) \
 	$(XCALIBRATE_SRCS) \
 	$(XINERAMA_SRCS) \
+	$(XCALIBRATE_SRCS) \
 	$(XEVIE_SRCS) \
 	$(XPRINT_SRCS) \
 	$(APPGROUP_SRCS) \
 	$(CUP_SRCS) \
 	$(EVI_SRCS) \
--- xorg-server-1.3.0.0.orig/Xext/xcalibrate.c
+++ xorg-server-1.3.0.0/Xext/xcalibrate.c
@@ -164,11 +164,10 @@ ProcXCalibrateSetRawMode (ClientPtr clie
     }
   WriteToClient(client, sizeof (rep), (char *) &rep);
   return (client->noClientException);
 }
 
-
 static int
 SProcXCalibrateSetRawMode (ClientPtr client)
 {
   REQUEST(xXCalibrateRawModeReq);
   int n;
@@ -178,10 +177,51 @@ SProcXCalibrateSetRawMode (ClientPtr cli
   swaps(&stuff->on, n);
 
   return ProcXCalibrateSetRawMode(client);
 }
 
+static int
+ProcXCalibrateScreenToCoord (ClientPtr client)
+{
+  REQUEST(xXCalibrateScreenToCoordReq);
+  xXCalibrateScreenToCoordReply rep;
+
+  REQUEST_SIZE_MATCH (xXCalibrateScreenToCoordReq);
+
+  memset (&rep, 0, sizeof (rep));
+  rep.type = X_Reply;
+  rep.sequenceNumber = client->sequence;
+  rep.x = stuff->x;
+  rep.y = stuff->y;
+
+  KdScreenToMouseCoords(&rep.x, &rep.y);
+
+  if (client->swapped)
+    {
+      int n;
+
+      swaps (&rep.x, n);
+      swaps (&rep.y, n);
+    }
+  WriteToClient(client, sizeof (rep), (char *) &rep);
+  return (client->noClientException);
+}
+
+static int
+SProcXCalibrateScreenToCoord (ClientPtr client)
+{
+  REQUEST(xXCalibrateScreenToCoordReq);
+  int n;
+
+  REQUEST_SIZE_MATCH (xXCalibrateScreenToCoordReq);
+
+  swaps(&stuff->x, n);
+  swaps(&stuff->y, n);
+
+  return ProcXCalibrateScreenToCoord(client);
+}
+
 static void
 XCalibrateResetProc (ExtensionEntry *extEntry) 
 { 
 }
 
@@ -192,10 +232,13 @@ ProcXCalibrateDispatch (ClientPtr client
     switch (stuff->data) {
     case X_XCalibrateQueryVersion:
         return ProcXCalibrateQueryVersion(client);
     case X_XCalibrateRawMode:
         return ProcXCalibrateSetRawMode(client);
+    case X_XCalibrateScreenToCoord:
+        return ProcXCalibrateScreenToCoord(client);
+
     default: break;
     }
 
     return BadRequest;
 }
@@ -211,10 +254,12 @@ SProcXCalibrateDispatch (ClientPtr clien
     switch (stuff->data) {
     case X_XCalibrateQueryVersion:
         return SProcXCalibrateQueryVersion(client);
     case X_XCalibrateRawMode:
         return SProcXCalibrateSetRawMode(client);
+    case X_XCalibrateScreenToCoord:
+        return SProcXCalibrateScreenToCoord(client);
 
     default: break;
     }
 
     return BadRequest;
--- xorg-server-1.3.0.0.orig/configure.ac
+++ xorg-server-1.3.0.0/configure.ac
@@ -389,10 +389,16 @@ AC_ARG_WITH(rgb-path,         AS_HELP_ST
 				[ RGBPATH="$withval" ],
 				[ RGBPATH="${datadir}/X11/rgb" ])
 AC_ARG_WITH(dri-driver-path,  AS_HELP_STRING([--with-dri-driver-path=PATH], [Path to DRI drivers (default: ${libdir}/dri)]),
 				[ DRI_DRIVER_PATH="$withval" ],
 				[ DRI_DRIVER_PATH="${libdir}/dri" ])
+KERNEL_HEADERS_PATH="${libdir}/linux"
+AC_ARG_WITH(kernel-headers-path,
+            AS_HELP_STRING([--with-kernel-headers=PATH],
+                    [Path to kernel headers (default: ${includedir}/linux)]),
+            [KERNEL_HEADERS_PATH="$withval"],
+            [KERNEL_HEADERS_PATH="${libdir}/linux"])
 AC_ARG_ENABLE(builddocs,      AS_HELP_STRING([--enable-builddocs], [Build docs (default: disabled)]),
                                 [BUILDDOCS=$enableval],
                                 [BUILDDOCS=no])
 AC_ARG_ENABLE(install-libxf86config,
 				AS_HELP_STRING([--enable-install-libxf86config],
@@ -419,10 +425,11 @@ AC_ARG_ENABLE(dri,            AS_HELP_ST
 AC_ARG_ENABLE(xinerama,	      AS_HELP_STRING([--disable-xinerama], [Build Xinerama extension (default: enabled)]), [XINERAMA=$enableval], [XINERAMA=yes])
 AC_ARG_ENABLE(xf86vidmode,    AS_HELP_STRING([--disable-xf86vidmode], [Build XF86VidMode extension (default: enabled)]), [XF86VIDMODE=$enableval], [XF86VIDMODE=yes])
 AC_ARG_ENABLE(xf86misc,       AS_HELP_STRING([--disable-xf86misc], [Build XF86Misc extension (default: enabled)]), [XF86MISC=$enableval], [XF86MISC=yes])
 AC_ARG_ENABLE(xace,     AS_HELP_STRING([--disable-xace], [Build X-ACE extension (default: enabled)]), [XACE=$enableval], [XACE=yes])
 AC_ARG_ENABLE(xcsecurity,     AS_HELP_STRING([--disable-xcsecurity], [Build Security extension (default: enabled)]), [XCSECURITY=$enableval], [XCSECURITY=$XACE])
+AC_ARG_ENABLE(xcalibrate,     AS_HELP_STRING([--enable-xcalibrate], [Build XCalibrate extension (default: disabled)]), [XCALIBRATE=$enableval], [XCALIBRATE=no])
 AC_ARG_ENABLE(appgroup,       AS_HELP_STRING([--disable-appgroup], [Build XC-APPGROUP extension (default: enabled)]), [APPGROUP=$enableval], [APPGROUP=$XCSECURITY])
 AC_ARG_ENABLE(xcalibrate,     AS_HELP_STRING([--enable-xcalibrate], [Build XCalibrate extension (default: disabled)]), [XCALIBRATE=$enableval], [XCALIBRATE=no])
 AC_ARG_ENABLE(tslib,          AS_HELP_STRING([--enable-tslib], [Build kdrive tslib touchscreen support (default: disabled)]), [TSLIB=$enableval], [TSLIB=no])
 AC_ARG_ENABLE(xevie,          AS_HELP_STRING([--disable-xevie], [Build XEvIE extension (default: enabled)]), [XEVIE=$enableval], [XEVIE=yes])
 AC_ARG_ENABLE(cup,            AS_HELP_STRING([--disable-cup], [Build TOG-CUP extension (default: enabled)]), [CUP=$enableval], [CUP=yes])
@@ -432,10 +439,11 @@ AC_ARG_ENABLE(fontcache,      AS_HELP_ST
 AC_ARG_ENABLE(dbe,            AS_HELP_STRING([--disable-dbe], [Build DBE extension (default: enabled)]), [DBE=$enableval], [DBE=yes])
 AC_ARG_ENABLE(xf86bigfont,    AS_HELP_STRING([--disable-xf86bigfont], [Build XF86 Big Font extension (default: enabled)]), [XF86BIGFONT=$enableval], [XF86BIGFONT=yes])
 AC_ARG_ENABLE(dpms,           AS_HELP_STRING([--disable-dpms], [Build DPMS extension (default: enabled)]), [DPMSExtension=$enableval], [DPMSExtension=yes])
 AC_ARG_ENABLE(xinput,         AS_HELP_STRING([--disable-xinput], [Build XInput Extension (default: enabled)]), [XINPUT=$enableval], [XINPUT=yes])
 AC_ARG_ENABLE(xfree86-utils,     AS_HELP_STRING([--enable-xfree86-utils], [Build xfree86 DDX utilities (default: enabled)]), [XF86UTILS=$enableval], [XF86UTILS=yes])
+AC_ARG_ENABLE(xkb,            AS_HELP_STRING([--disable-xkb], [Build XKB (default: enabled)]), [XKB=$enableval], [XKB=yes])
 
 dnl DDXes.
 AC_ARG_ENABLE(xorg,    	      AS_HELP_STRING([--enable-xorg], [Build Xorg server (default: auto)]), [XORG=$enableval], [XORG=auto])
 AC_ARG_ENABLE(dmx,    	      AS_HELP_STRING([--enable-dmx], [Build DMX server (default: auto)]), [DMX=$enableval], [DMX=auto])
 AC_ARG_ENABLE(xvfb,    	      AS_HELP_STRING([--enable-xvfb], [Build Xvfb server (default: yes)]), [XVFB=$enableval], [XVFB=yes])
@@ -446,10 +454,11 @@ AC_ARG_ENABLE(xgl,            AS_HELP_ST
 AC_ARG_ENABLE(xglx,           AS_HELP_STRING([--enable-xglx], [Build Xglx xgl module (default: no)]), [XGLX=$enableval], [XGLX=no])
 AC_ARG_ENABLE(xegl,           AS_HELP_STRING([--enable-xegl], [Build Xegl xgl module (default: no)]), [XEGL=$enableval], [XEGL=no])
 dnl kdrive and its subsystems
 AC_ARG_ENABLE(kdrive,         AS_HELP_STRING([--enable-kdrive], [Build kdrive servers (default: no)]), [KDRIVE=$enableval], [KDRIVE=no])
 AC_ARG_ENABLE(xephyr,         AS_HELP_STRING([--enable-xephyr], [Build the kdrive Xephyr server (default: auto)]), [XEPHYR=$enableval], [XEPHYR=auto])
+AC_ARG_ENABLE(nomadik,        AS_HELP_STRING([--enable-nomadik],[Build the kdrive Xnomadik server (default: auto)]), [NOMADIK=$enableval], [NOMADIK=auto])
 AC_ARG_ENABLE(xsdl,           AS_HELP_STRING([--enable-xsdl], [Build the kdrive Xsdl server (default: auto)]), [XSDL=$enableval], [XSDL=auto])
 dnl xprint
 AC_ARG_ENABLE(freetype,       AS_HELP_STRING([ --enable-freetype], [Build Xprint FreeType backend (default: yes)]), [XP_USE_FREETYPE=$enableval],[XP_USE_FREETYPE=no])
 AC_ARG_WITH(freetype-config,  AS_HELP_STRING([ --with-freetype-config=PROG], [Use FreeType configuration program PROG (default: auto)]), freetype_config=$withval, freetype_config=auto)
 
@@ -518,11 +527,15 @@ dnl ------------------------------------
 XEXT_INC='-I$(top_srcdir)/Xext'
 XEXT_LIB='$(top_builddir)/Xext/libXext.la'
 XEXTXORG_LIB='$(top_builddir)/Xext/libXextbuiltin.la'
 
 dnl Core modules for most extensions, et al.
+if test "$KDRIVE" = yes; then
+REQUIRED_MODULES="[randrproto >= 1.2] renderproto [fixesproto >= 4.0] [damageproto >= 1.1] xcmiscproto xextproto xproto xtrans xf86bigfontproto [scrnsaverproto >= 1.1] bigreqsproto resourceproto fontsproto inputproto [kbproto >= 1.0.3]"
+else
 REQUIRED_MODULES="[randrproto >= 1.2] renderproto [fixesproto >= 4.0] [damageproto >= 1.1] xcmiscproto xextproto xproto xtrans xf86miscproto xf86vidmodeproto xf86bigfontproto [scrnsaverproto >= 1.1] bigreqsproto resourceproto fontsproto inputproto xf86dgaproto [kbproto >= 1.0.3]"
+fi
 REQUIRED_LIBS="xfont xau fontenc"
 
 AM_CONDITIONAL(XV, [test "x$XV" = xyes])
 if test "x$XV" = xyes; then
 	AC_DEFINE(XV, 1, [Support Xv extension])
@@ -646,10 +659,16 @@ if test "x$XCSECURITY" = xyes; then
 		AC_MSG_ERROR([cannot build Security extension without X-ACE])
 	fi
 	AC_DEFINE(XCSECURITY, 1, [Build Security extension])
 fi
 
+AM_CONDITIONAL(XCALIBRATE, [test "x$XCALIBRATE" = xyes])
+if test "x$XCALIBRATE" = xyes; then
+	AC_DEFINE(XCALIBRATE, 1, [Build XCalibrate extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES xcalibrateproto"
+fi
+
 AM_CONDITIONAL(XEVIE, [test "x$XEVIE" = xyes])
 if test "x$XEVIE" = xyes; then
 	AC_DEFINE(XEVIE, 1, [Build XEvIE extension])
 	REQUIRED_MODULES="$REQUIRED_MODULES evieproto"
 fi
@@ -758,16 +777,19 @@ fi
 
 AM_CONDITIONAL(XF86UTILS, test "x$XF86UTILS" = xyes)
 
 AC_DEFINE(SHAPE, 1, [Support SHAPE extension])
 
-AC_DEFINE(XKB, 1, [Build XKB])
-AC_DEFINE(XKB_IN_SERVER, 1, [Build XKB server])
-AC_DEFINE(XKB_DFLT_DISABLED, 0, [Disable XKB per default])
-REQUIRED_MODULES="$REQUIRED_MODULES xkbfile"
-XKB_LIB='$(top_builddir)/xkb/libxkb.la'
-XKB_STUB_LIB='$(top_builddir)/xkb/libxkbstubs.la'
+AM_CONDITIONAL(XKB, [test "x$XKB" = xyes])
+if test "x$XKB" = xyes; then
+	AC_DEFINE(XKB, 1, [Build XKB])
+	AC_DEFINE(XKB_IN_SERVER, 1, [Build XKB server])
+	AC_DEFINE(XKB_DFLT_DISABLED, 0, [Disable XKB per default])
+	REQUIRED_MODULES="$REQUIRED_MODULES xkbfile"
+	XKB_LIB='$(top_builddir)/xkb/libxkb.la'
+	XKB_STUB_LIB='$(top_builddir)/xkb/libxkbstubs.la'
+fi
 
 AC_CHECK_FUNC(strcasecmp, [], AC_DEFINE([NEED_STRCASECMP], 1,
                                         [Do not have `strcasecmp'.]))
 
 PKG_CHECK_MODULES([XDMCP], [xdmcp], [have_libxdmcp="yes"], [have_libxdmcp="no"])
@@ -1509,15 +1531,16 @@ if test "$KDRIVE" = yes; then
         AC_DEFINE(KDRIVEFBDEV, 1, [Build fbdev-based kdrive server])
     fi
     
     # tslib...
     if test "x$TSLIB" = xyes; then
-        PKG_CHECK_MODULES([TSLIB], [tslib-0.0], [HAVE_TSLIB="yes"], [HAVE_TSLIB="no"])
+        PKG_CHECK_MODULES([TSLIB], [tslib-1.0], [HAVE_TSLIB="yes"], [HAVE_TSLIB="no"])
         if test "x$HAVE_TSLIB" = xno; then
             AC_MSG_ERROR([tslib must be installed to build the tslib driver. See http://tslib.berlios.de/])
         fi
         AC_DEFINE(TSLIB, 1, [Have tslib support])
+        AC_DEFINE(TOUCHSCREEN, 1, [Have touchscreen support])
     fi
 
     # damage shadow extension glx (NOTYET) fb mi
     KDRIVE_INC='-I$(top_srcdir)/hw/kdrive/src'
     KDRIVE_PURE_INCS="$KDRIVE_INC $MIEXT_DAMAGE_INC $MIEXT_SHADOW_INC $XEXT_INC $FB_INC $MI_INC"
@@ -1536,14 +1559,18 @@ if test "$KDRIVE" = yes; then
 	    KDRIVE_OS_LIB='$(top_builddir)/hw/kdrive/linux/liblinux.a'
             KDRIVELINUX=yes
 	    ;;
     esac
     KDRIVE_STUB_LIB='$(top_builddir)/hw/kdrive/src/libkdrivestubs.a'
-    KDRIVE_LIBS="$DIX_LIB $KDRIVE_LIB $KDRIVE_OS_LIB $KDRIVE_PURE_LIBS $KDRIVE_STUB_LIB $TSLIB_LIBS"
+    KDRIVE_LIBS="$DIX_LIB $KDRIVE_LIB $KDRIVE_PURE_LIBS $KDRIVE_OS_LIB $KDRIVE_STUB_LIB $TSLIB_LIBS"
 
     # check if we can build Xephyr
     PKG_CHECK_MODULES(XEPHYR, x11 xext xfont xau xdmcp, [xephyr="yes"], [xephyr="no"])
+
+    #check if we can build Xnomadik
+    AC_CHECK_HEADER([nomadik/sga_lib.h], nomadik="yes")
+
     
     # check for SDL SDK
     AC_CHECK_HEADERS([SDL/SDL.h])
     if test "x$XSDL" = xauto; then
         XSDL="$ac_cv_header_SDL_SDL_h"
@@ -1567,10 +1594,13 @@ AC_CHECK_FUNC([nanosleep], [],
 AM_CONDITIONAL(XEPHYR, [test x"$xephyr" = xyes])
 XEPHYR_LIBS="$XEPHYR_LIBS $XSERVER_LIBS"
 AC_SUBST([XEPHYR_LIBS])
 AC_SUBST([XEPHYR_INCS])
 
+AM_CONDITIONAL(NOMADIK,[test x"$nomadik" = xyes])
+AC_SUBST([KERNEL_HEADERS_PATH])
+
 if test x"$XSDL" = xyes; then
     AC_DEFINE(XSDLSERVER,,[Build Xsdl server])
     XSDL_LIBS="`sdl-config --libs` $XSERVER_LIBS"
     XSDL_INCS="`sdl-config --cflags` $XSERVER_CFLAGS"
 fi
@@ -1601,11 +1631,13 @@ XKB_COMPILED_DIR=`echo $XKBOUTPUT | sed 
 AC_DEFINE_DIR(XKM_OUTPUT_DIR, XKBOUTPUT, [Path to XKB output dir])
 
 AC_SUBST(XKB_COMPILED_DIR)
 
 dnl and the rest of these are generic, so they're in config.h
+if test ! x"$KDRIVE" = xyes; then
 AC_DEFINE(XFreeXDGA, 1, [Build XDGA support])
+fi
 AC_DEFINE(XResExtension, 1, [Build XRes extension])
 
 AC_TRY_COMPILE([
 #include <features.h>
 #ifndef __GLIBC__
@@ -1614,14 +1646,16 @@ AC_TRY_COMPILE([
 ], [], [AC_DEFINE(_GNU_SOURCE, 1,
 	[ Enable GNU and other extensions to the C environment for glibc])])
 
 AC_DEFINE_DIR(PROJECTROOT, prefix, [Overall prefix])
 
+if test ! "x$KDRIVE" = xyes ; then
 dnl xorgconfig CLI configuration utility
 PKG_CHECK_MODULES([XORGCONFIG_DEP], [xkbfile x11])
 AC_SUBST(XORGCONFIG_DEP_CFLAGS)
 AC_SUBST(XORGCONFIG_DEP_LIBS)
+fi
 
 dnl xorgcfg GUI configuration utility
 AC_ARG_ENABLE(xorgcfg, AS_HELP_STRING([--enable-xorgcfg], 
 	[Build xorgcfg GUI configuration utility (default: yes)]),
 	[XORGCFG=$enableval],[XORGCFG=yes])
@@ -1813,10 +1847,11 @@ hw/kdrive/sdl/Makefile
 hw/kdrive/sis300/Makefile
 hw/kdrive/smi/Makefile
 hw/kdrive/src/Makefile
 hw/kdrive/vesa/Makefile
 hw/kdrive/via/Makefile
+hw/kdrive/nomadik/Makefile
 hw/xprint/Makefile
 hw/xprint/doc/Makefile
 hw/xprint/pcl/Makefile
 hw/xprint/pcl-mono/Makefile
 hw/xprint/raster/Makefile
--- xorg-server-1.3.0.0.orig/dix/dixfonts.c
+++ xorg-server-1.3.0.0/dix/dixfonts.c
@@ -48,11 +48,11 @@ Equipment Corporation.
 
 ******************************************************************/
 
 #define NEED_REPLIES
 #ifdef HAVE_DIX_CONFIG_H
-#include <dix-config.h>
+#include <kdrive-config.h>
 #endif
 
 #include <X11/X.h>
 #include <X11/Xmd.h>
 #include <X11/Xproto.h>
--- xorg-server-1.3.0.0.orig/dix/window.c
+++ xorg-server-1.3.0.0/dix/window.c
@@ -179,10 +179,12 @@ static Bool TileScreenSaver(int i, int k
 
 
 _X_EXPORT int numSaveUndersViewable = 0;
 _X_EXPORT int deltaSaveUndersViewable = 0;
 
+char* RootPPM = NULL;
+
 #ifdef DEBUG
 /******
  * PrintWindowTree
  *    For debugging only
  ******/
@@ -305,20 +307,159 @@ SetWindowToDefaults(register WindowPtr p
 #ifdef COMPOSITE
     pWin->redirectDraw = 0;
 #endif
 }
 
+static int
+get_int(FILE *fp)
+{
+  int c = 0;
+
+  while ((c = getc(fp)) != EOF)
+    {
+      if (isspace(c))
+	continue;
+
+      if (c == '#')
+	while (c = getc(fp))
+	  if (c == EOF)
+	    return 0;
+	  else if (c == '\n')
+	    break;
+
+      if (isdigit(c))
+	{
+	  int val = c - '0';
+	  while ((c = getc(fp)) && isdigit(c))
+	    val = (val * 10) + (c - '0');
+	  return val;
+	}
+    }
+
+  return 0;
+}
+
+static unsigned char*
+ppm_load (const char* path, int depth, int *width, int *height)
+{
+  FILE *fp;
+  int   max, n = 0, w, h, i, j, bytes_per_line;
+  unsigned char *data, *res, h1, h2;
+
+  if (depth < 16 || depth > 32)
+    return NULL;
+
+  if (depth > 16)
+    depth = 32;
+
+  fp = fopen (path, "r");
+  if (fp == NULL)
+    return FALSE;
+
+  h1 = getc(fp);
+  h2 = getc(fp);
+
+  /* magic is 'P6' for raw ppm */
+  if (h1 != 'P' && h2 != '6')
+      goto fail;
+
+  w = get_int(fp);
+  h = get_int(fp);
+
+  if (w == 0 || h == 0)
+    goto fail;
+
+  max = get_int(fp);
+
+  if (max != 255)
+      goto fail;
+
+  bytes_per_line = ((w * depth + 31) >> 5) << 2;
+
+  res = data = malloc(bytes_per_line * h);
+
+  for (i=0; i<h; i++)
+    {
+      for (j=0; j<w; j++)
+	{
+	  unsigned char buf[3];
+	  fread(buf, 1, 3, fp);
+
+	  switch (depth)
+	    {
+	    case 24:
+	    case 32:
+	      *data     = buf[2];
+	      *(data+1) = buf[1];
+	      *(data+2) = buf[0];
+	      data += 4;
+	      break;
+	    case 16:
+	    default:
+	      *(unsigned short*)data
+		= ((buf[0] >> 3) << 11) | ((buf[1] >> 2) << 5) | (buf[2] >> 3);
+	      data += 2;
+	      break;
+	    }
+	}
+      data += (bytes_per_line - (w*(depth>>3)));
+    }
+
+  data = res;
+
+  *width  = w;
+  *height = h;
+
+  fclose(fp);
+
+  return res;
+
+ fail:
+  fclose(fp);
+  return NULL;
+}
+
 static void
 MakeRootTile(WindowPtr pWin)
 {
     ScreenPtr pScreen = pWin->drawable.pScreen;
     GCPtr pGC;
     unsigned char back[128];
     int len = BitmapBytePad(sizeof(long));
     register unsigned char *from, *to;
     register int i, j;
 
+    if (RootPPM != NULL)
+      {
+	int            w, h;
+	unsigned char *data;
+
+	if ((data = ppm_load (RootPPM, pScreen->rootDepth, &w, &h)) != NULL)
+	  {
+	    pWin->background.pixmap
+	      = (*pScreen->CreatePixmap)(pScreen, w, h, pScreen->rootDepth);
+
+	    pWin->backgroundState = BackgroundPixmap;
+	    pGC = GetScratchGC(pScreen->rootDepth, pScreen);
+	    if (!pWin->background.pixmap || !pGC)
+	      FatalError("could not create root tile");
+
+	    ValidateGC((DrawablePtr)pWin->background.pixmap, pGC);
+
+	    (*pGC->ops->PutImage)((DrawablePtr)pWin->background.pixmap,
+				  pGC,
+				  pScreen->rootDepth,
+				  0, 0, w, h, 0, ZPixmap, (char *)data);
+	    FreeScratchGC(pGC);
+
+	    free(data);
+	    return;
+	  }
+	else
+	  ErrorF("Unable to load root window image.");
+      }
+
     pWin->background.pixmap = (*pScreen->CreatePixmap)(pScreen, 4, 4,
 						    pScreen->rootDepth);
 
     pWin->backgroundState = BackgroundPixmap;
     pGC = GetScratchGC(pScreen->rootDepth, pScreen);
@@ -348,10 +489,11 @@ MakeRootTile(WindowPtr pWin)
 
    FreeScratchGC(pGC);
 
 }
 
+
 WindowPtr
 AllocateWindow(ScreenPtr pScreen)
 {
     WindowPtr pWin;
     register char *ptr;
--- xorg-server-1.3.0.0.orig/exa/exa.c
+++ xorg-server-1.3.0.0/exa/exa.c
@@ -781,10 +781,12 @@ void exaMarkSync(ScreenPtr pScreen)
  */
 void exaWaitSync(ScreenPtr pScreen)
 {
     ExaScreenPriv(pScreen);
 
-    if (pExaScr->info->needsSync && !pExaScr->swappedOut) {
-        (*pExaScr->info->WaitMarker)(pScreen, pExaScr->info->lastMarker);
+    if (pExaScr->info->needsSync
+        && !pExaScr->swappedOut) {
+        if (pExaScr->info->WaitMarker)
+            (*pExaScr->info->WaitMarker)(pScreen, pExaScr->info->lastMarker);
         pExaScr->info->needsSync = FALSE;
     }
 }
--- xorg-server-1.3.0.0.orig/exa/exa_offscreen.c
+++ xorg-server-1.3.0.0/exa/exa_offscreen.c
@@ -425,11 +425,11 @@ ExaOffscreenMarkUsed (PixmapPtr pPixmap)
 {
     ExaPixmapPriv (pPixmap);
     ExaScreenPriv (pPixmap->drawable.pScreen);
     static int iter = 0;
 
-    if (!pExaPixmap->area)
+    if (!pExaPixmap || !pExaPixmap->area)
 	return;
 
     /* The numbers here are arbitrary.  We may want to tune these. */
     pExaPixmap->area->score += 100;
     if (++iter == 10) {
--- xorg-server-1.3.0.0.orig/hw/kdrive/Makefile.am
+++ xorg-server-1.3.0.0/hw/kdrive/Makefile.am
@@ -2,11 +2,11 @@ if KDRIVEVESA
 VESA_SUBDIRS = vesa ati chips epson i810 mach64 mga neomagic nvidia pm2 r128 \
                smi via
 endif
 
 if KDRIVEFBDEV
-FBDEV_SUBDIRS = fbdev
+FBDEV_SUBDIRS = fbdev epson
 endif
 
 if XSDLSERVER
 XSDL_SUBDIRS = sdl
 endif
@@ -17,16 +17,21 @@ endif
 
 if KDRIVELINUX
 LINUX_SUBDIRS = linux
 endif
 
+if NOMADIK
+NOMADIK_SUBDIRS = nomadik
+endif
+
 SUBDIRS =			\
 	src			\
 	$(LINUX_SUBDIRS)	\
 	$(XSDL_SUBDIRS)		\
 	$(FBDEV_SUBDIRS)	\
 	$(VESA_SUBDIRS)		\
 	$(XEPHYR_SUBDIRS)       \
+	$(NOMADIK_SUBDIRS)      \
 	fake
 
 DIST_SUBDIRS = vesa ati chips epson i810 mach64 mga neomagic nvidia pm2 r128 \
-               smi via fbdev sdl ephyr src linux fake sis300
+               smi via fbdev sdl ephyr src linux fake sis300 nomadik
--- xorg-server-1.3.0.0.orig/hw/kdrive/fbdev/fbdev.c
+++ xorg-server-1.3.0.0/hw/kdrive/fbdev/fbdev.c
@@ -30,10 +30,11 @@
 #include <sys/ioctl.h>
 
 #include <errno.h>
 
 extern int KdTsPhyScreen;
+Bool showMemInfo = FALSE ;
 
 char *fbdevDevicePath = NULL;
 
 Bool
 fbdevInitialize (KdCardInfo *card, FbdevPriv *priv)
@@ -186,15 +187,34 @@ fbdevScreenInitialize (KdScreenInfo *scr
 
     t = KdFindMode (screen, fbdevModeSupported);
     screen->rate = t->rate;
     screen->width = t->horizontal;
     screen->height = t->vertical;
+    fprintf(stderr, "%s, %d, %d, %d, %d, \
+    %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, \
+    %d, %d, %d, %d, %d, %d, %d, %d, %d", __FUNCTION__, __LINE__,
+	var.xres, var.yres, var.xres_virtual, var.yres_virtual,
+	var.xoffset, var.yoffset, var.bits_per_pixel, var.grayscale,
+	var.nonstd, var.activate, var.height, var.width,
+	var.accel_flags, var.pixclock, var.left_margin, var.right_margin,
+	var.upper_margin, var.lower_margin, var.hsync_len, var.vsync_len,
+	var.sync, var.vmode);
 
     /* Now try setting the mode */
     if (k < 0 || (t->horizontal != var.xres || t->vertical != var.yres))
         fbdevConvertMonitorTiming (t, &var);
 
+    fprintf(stderr, "%s, %d, %d, %d, %d, \
+    %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, \
+    %d, %d, %d, %d, %d, %d, %d, %d, %d", __FUNCTION__, __LINE__,
+	var.xres, var.yres, var.xres_virtual, var.yres_virtual,
+	var.xoffset, var.yoffset, var.bits_per_pixel, var.grayscale,
+	var.nonstd, var.activate, var.height, var.width,
+	var.accel_flags, var.pixclock, var.left_margin, var.right_margin,
+	var.upper_margin, var.lower_margin, var.hsync_len, var.vsync_len,
+	var.sync, var.vmode);
+
     var.activate = FB_ACTIVATE_NOW;
     var.bits_per_pixel = screen->fb[0].depth;
     var.nonstd = 0;
     var.grayscale = 0;
 
@@ -209,10 +229,15 @@ fbdevScreenInitialize (KdScreenInfo *scr
     /* Re-get the "fixed" parameters since they might have changed */
     k = ioctl (priv->fd, FBIOGET_FSCREENINFO, &priv->fix);
     if (k < 0)
         perror ("FBIOGET_FSCREENINFO");
 
+    /* Re-get the "fixed" parameters since they might have changed */
+    k = ioctl (priv->fd, FBIOGET_FSCREENINFO, &priv->fix);
+    if (k < 0)
+        perror ("FBIOGET_FSCREENINFO");
+
     /* Now get the new screeninfo */
     ioctl (priv->fd, FBIOGET_VSCREENINFO, &priv->var);
     depth = priv->var.bits_per_pixel;
     gray = priv->var.grayscale;
     
@@ -345,11 +370,11 @@ fbdevMapFramebuffer (KdScreenInfo *scree
     
     screen->width = priv->var.xres;
     screen->height = priv->var.yres;
     screen->memory_base = (CARD8 *) (priv->fb);
     screen->memory_size = priv->fix.smem_len;
-    
+
     if (scrpriv->shadow)
     {
 	if (!KdShadowFbAlloc (screen, 0, 
 			      scrpriv->randr & (RR_Rotate_90|RR_Rotate_270)))
 	    return FALSE;
@@ -361,10 +386,30 @@ fbdevMapFramebuffer (KdScreenInfo *scree
         screen->fb[0].pixelStride = (priv->fix.line_length * 8 / 
     				 priv->var.bits_per_pixel);
         screen->fb[0].frameBuffer = (CARD8 *) (priv->fb);
 	screen->off_screen_base = screen->fb[0].byteStride * screen->height;
     }
+
+    if (showMemInfo)
+    {
+        LogMessageVerb (X_INFO,
+                        0,
+                        "screen width:        %d\n"
+                        "screen height:       %d\n"
+                        "video mem base:      %#x\n"
+                        "offscreen mem offset %#x\n"
+                        "video mem size:      %#x\n"
+                        "depth (in bits)     %d\n",
+                        screen->width,
+                        screen->height,
+                        screen->memory_base,
+                        screen->off_screen_base,
+                        screen->memory_size,
+                        priv->var.bits_per_pixel) ;
+        exit(0) ;
+    }
+
     
     return TRUE;
 }
 
 void
@@ -664,18 +709,27 @@ fbdevEnable (ScreenPtr pScreen)
     FbdevPriv		*priv = pScreenPriv->card->driver;
     int			k;
 
     priv->var.activate = FB_ACTIVATE_NOW|FB_CHANGE_CMAP_VBL;
     
+    fprintf(stderr, "%s, %d, %d, %d, %d, \
+    %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, \
+    %d, %d, %d, %d, %d, %d, %d, %d, %d", __FUNCTION__, __LINE__,
+	 priv->var.xres,  priv->var.yres,  priv->var.xres_virtual,  priv->var.yres_virtual,
+	 priv->var.xoffset,  priv->var.yoffset,  priv->var.bits_per_pixel,  priv->var.grayscale,
+	 priv->var.nonstd,  priv->var.activate,  priv->var.height,  priv->var.width,
+	 priv->var.accel_flags,  priv->var.pixclock,  priv->var.left_margin,  priv->var.right_margin,
+	 priv->var.upper_margin,  priv->var.lower_margin,  priv->var.hsync_len,  priv->var.vsync_len,
+	 priv->var.sync,  priv->var.vmode);
     /* display it on the LCD */
+#if 0
     k = ioctl (priv->fd, FBIOPUT_VSCREENINFO, &priv->var);
     if (k < 0)
     {
 	perror ("FBIOPUT_VSCREENINFO");
 	return FALSE;
     }
-    
     if (priv->fix.visual == FB_VISUAL_DIRECTCOLOR)
     {
 	struct fb_cmap	cmap;
 	int		i;
 
@@ -694,10 +748,11 @@ fbdevEnable (ScreenPtr pScreen)
 	cmap.green = &priv->green[0];
 	cmap.blue = &priv->blue[0];
 	cmap.transp = 0;
 	ioctl (priv->fd, FBIOPUTCMAP, &cmap);
     }
+   #endif
     return TRUE;
 }
 
 Bool
 fbdevDPMS (ScreenPtr pScreen, int mode)
--- xorg-server-1.3.0.0.orig/hw/kdrive/fbdev/fbinit.c
+++ xorg-server-1.3.0.0/hw/kdrive/fbdev/fbinit.c
@@ -26,10 +26,12 @@
 #ifdef HAVE_CONFIG_H
 #include <kdrive-config.h>
 #endif
 #include <fbdev.h>
 
+extern int use_evdev;
+
 void
 InitCard (char *name)
 {
     KdCardAttr	attr;
 
@@ -43,11 +45,14 @@ InitOutput (ScreenInfo *pScreenInfo, int
 }
 
 void
 InitInput (int argc, char **argv)
 {
-    KdInitInput (&LinuxMouseFuncs, &LinuxKeyboardFuncs);
+    if (use_evdev)
+        KdInitInput (&LinuxEvdevMouseFuncs, &LinuxEvdevKeyboardFuncs);
+    else
+        KdInitInput (&LinuxMouseFuncs, &LinuxKeyboardFuncs);
 #ifdef TOUCHSCREEN
     KdAddMouseDriver (&TsFuncs);
 #endif
 }
 
--- xorg-server-1.3.0.0.orig/hw/kdrive/linux/evdev.c
+++ xorg-server-1.3.0.0/hw/kdrive/linux/evdev.c
@@ -29,13 +29,15 @@
 #include <errno.h>
 #include <linux/input.h>
 #include <X11/X.h>
 #include <X11/Xproto.h>
 #include <X11/Xpoll.h>
+#include <X11/keysym.h>
 #include "inputstr.h"
 #include "scrnintstr.h"
 #include "kdrive.h"
+#include "kkeymap.h"
 
 #define NUM_EVENTS  128
 #define ABS_UNSET   -65535
 
 #define BITS_PER_LONG (sizeof(long) * 8)
@@ -103,36 +105,79 @@ EvdevMotion (KdMouseInfo    *mi)
 static void
 EvdevRead (int evdevPort, void *closure)
 {
     KdMouseInfo		*mi = closure;
     Kevdev		*ke = mi->driver;
-    int			i;
+    int			i, j;
     struct input_event	events[NUM_EVENTS];
     int			n;
+    int                 flags;
 
     n = read (evdevPort, &events, NUM_EVENTS * sizeof (struct input_event));
     if (n <= 0)
 	return;
     n /= sizeof (struct input_event);
     for (i = 0; i < n; i++)
     {
+	flags = KD_MOUSE_DELTA | kdMouseInfo->buttonState;
 	switch (events[i].type) {
 	case EV_SYN:
 	    break;
 	case EV_KEY:
-	    EvdevMotion (mi);
-	    ASSIGNBIT(ke->key,events[i].code, events[i].value);
-	    if (events[i].code < 0x100)
-		ErrorF ("key %d %d\n", events[i].code, events[i].value);
-	    else
-		ErrorF ("key 0x%x %d\n", events[i].code, events[i].value);
+	  if (events[i].code >= BTN_MOUSE && events[i].code < BTN_JOYSTICK) {
+	        switch (events[i].code) {
+		case BTN_LEFT:
+		  if (events[i].value == 1)
+		    flags |= KD_BUTTON_1;
+		  else
+		    flags &= ~KD_BUTTON_1;
+		  break;
+		case BTN_MIDDLE:
+		  if (events[i].value == 1)
+		    flags |= KD_BUTTON_2;
+		  else
+		    flags &= ~KD_BUTTON_2;
+		  break;
+		case BTN_RIGHT:
+		  if (events[i].value == 1)
+		    flags |= KD_BUTTON_3;
+		  else
+		    flags &= ~KD_BUTTON_3;
+		  break;
+		default:
+		  /* Unknow button */
+		  break;
+       	        }
+		KdEnqueueMouseEvent (kdMouseInfo, flags, 0, 0);
+	    }
 	    break;
 	case EV_REL:
-	    ke->rel[events[i].code] += events[i].value;
+	    if (events[i].code == REL_X) {
+	      KdEnqueueMouseEvent (kdMouseInfo, flags, events[i].value, 0);
+	    }
+	    else if (events[i].code == REL_Y) {
+	      KdEnqueueMouseEvent (kdMouseInfo, flags, 0, events[i].value);
+	    }
+	    else if (events[i].code == REL_WHEEL) {
+	      for (j = 0; j < abs (events[i].value); j++) {
+		if (events[i].value > 0)
+		  flags |= KD_BUTTON_4;
+		else
+		  flags |= KD_BUTTON_5;
+
+		KdEnqueueMouseEvent (kdMouseInfo, flags, 0, 0);
+
+		if (events[i].value > 0)
+		  flags &= ~KD_BUTTON_4;
+		else
+		  flags &= ~KD_BUTTON_5;
+
+		KdEnqueueMouseEvent (kdMouseInfo, flags, 0, 0);
+	      } /* events[i].code == REL_WHEEL */
+	    }
 	    break;
 	case EV_ABS:
-	    ke->abs[events[i].code] = events[i].value;
 	    break;
 	}
     }
     EvdevMotion (mi);
 }
@@ -171,10 +216,16 @@ EvdevInit (void)
 	    for (i = 0; i < NUM_DEFAULT_EVDEV; i++)
 	    {
 		fd = open (kdefaultEvdev[i], 2);
 		if (fd >= 0)
 		{
+                    if (ioctl (fd, EVIOCGRAB, 1) < 0)
+                    {
+                        close (fd);
+                        continue;
+                    }
+
 		    mi->name = KdSaveString (kdefaultEvdev[i]);
 		    break;
 		}
 	    }
 	}
@@ -285,15 +336,327 @@ EvdevFini (void)
 KdMouseFuncs LinuxEvdevMouseFuncs = {
     EvdevInit,
     EvdevFini,
 };
 
-#if 0
+/* Keyboard */
+
+int kbd_fd = -1;
+int EvdevInputType = 0;
+
+KeySym evdevKeymap[(194 - 1 + 1) * 2] = {
+/* These are directly mapped from DOS scanset 0 */
+/*      1     8 */       XK_Escape, NoSymbol,
+/*      2     9 */       XK_1,  XK_exclam,
+/*      3    10 */       XK_2,  XK_at,
+/*      4    11 */       XK_3,  XK_numbersign,
+/*      5    12 */       XK_4,  XK_dollar,
+/*      6    13 */       XK_5,  XK_percent,
+/*      7    14 */       XK_6,  XK_asciicircum,
+/*      8    15 */       XK_7,  XK_ampersand,
+/*      9    16 */       XK_8,  XK_asterisk,
+/*     10    17 */       XK_9,  XK_parenleft,
+/*     11    18 */       XK_0,  XK_parenright,
+/*     12    19 */       XK_minus,      XK_underscore,
+/*     13    20 */       XK_equal,      XK_plus,
+/*     14    21 */       XK_BackSpace,  NoSymbol,
+/*     15    22 */       XK_Tab,        NoSymbol,
+/*     16    23 */       XK_Q,  NoSymbol,
+/*     17    24 */       XK_W,  NoSymbol,
+/*     18    25 */       XK_E,  NoSymbol,
+/*     19    26 */       XK_R,  NoSymbol,
+/*     20    27 */       XK_T,  NoSymbol,
+/*     21    28 */       XK_Y,  NoSymbol,
+/*     22    29 */       XK_U,  NoSymbol,
+/*     23    30 */       XK_I,  NoSymbol,
+/*     24    31 */       XK_O,  NoSymbol,
+/*     25    32 */       XK_P,  NoSymbol,
+/*     26    33 */       XK_bracketleft,        XK_braceleft,
+/*     27    34 */       XK_bracketright,       XK_braceright,
+/*     28    35 */       XK_Return,     NoSymbol,
+/*     29    36 */       XK_Control_L,  NoSymbol,
+/*     30    37 */       XK_A,  NoSymbol,
+/*     31    38 */       XK_S,  NoSymbol,
+/*     32    39 */       XK_D,  NoSymbol,
+/*     33    40 */       XK_F,  NoSymbol,
+/*     34    41 */       XK_G,  NoSymbol,
+/*     35    42 */       XK_H,  NoSymbol,
+/*     36    43 */       XK_J,  NoSymbol,
+/*     37    44 */       XK_K,  NoSymbol,
+/*     38    45 */       XK_L,  NoSymbol,
+/*     39    46 */       XK_semicolon,  XK_colon,
+/*     40    47 */       XK_apostrophe, XK_quotedbl,
+/*     41    48 */       XK_grave,      XK_asciitilde,
+/*     42    49 */       XK_Shift_L,    NoSymbol,
+/*     43    50 */       XK_backslash,  XK_bar,
+/*     44    51 */       XK_Z,  NoSymbol,
+/*     45    52 */       XK_X,  NoSymbol,
+/*     46    53 */       XK_C,  NoSymbol,
+/*     47    54 */       XK_V,  NoSymbol,
+/*     48    55 */       XK_B,  NoSymbol,
+/*     49    56 */       XK_N,  NoSymbol,
+/*     50    57 */       XK_M,  NoSymbol,
+/*     51    58 */       XK_comma,      XK_less,
+/*     52    59 */       XK_period,     XK_greater,
+/*     53    60 */       XK_slash,      XK_question,
+/*     54    61 */       XK_Shift_R,    NoSymbol,
+/*     55    62 */       XK_KP_Multiply,        NoSymbol,
+/*     56    63 */       XK_Alt_L,      XK_Meta_L,
+/*     57    64 */       XK_space,      NoSymbol,
+/*     58    65 */       XK_Caps_Lock,  NoSymbol,
+/*     59    66 */       XK_F1, NoSymbol,
+/*     60    67 */       XK_F2, NoSymbol,
+/*     61    68 */       XK_F3, NoSymbol,
+/*     62    69 */       XK_F4, NoSymbol,
+/*     63    70 */       XK_F5, NoSymbol,
+/*     64    71 */       XK_F6, NoSymbol,
+/*     65    72 */       XK_F7, NoSymbol,
+/*     66    73 */       XK_F8, NoSymbol,
+/*     67    74 */       XK_F9, NoSymbol,
+/*     68    75 */       XK_F10,        NoSymbol,
+/*     69    76 */       XK_Break,      XK_Pause,
+/*     70    77 */       XK_Scroll_Lock,        NoSymbol,
+/*     71    78 */       XK_KP_Home,    XK_KP_7,
+/*     72    79 */       XK_KP_Up,      XK_KP_8,
+/*     73    80 */       XK_KP_Page_Up, XK_KP_9,
+/*     74    81 */       XK_KP_Subtract,        NoSymbol,
+/*     75    82 */       XK_KP_Left,    XK_KP_4,
+/*     76    83 */       XK_KP_5,       NoSymbol,
+/*     77    84 */       XK_KP_Right,   XK_KP_6,
+/*     78    85 */       XK_KP_Add,     NoSymbol,
+/*     79    86 */       XK_KP_End,     XK_KP_1,
+/*     80    87 */       XK_KP_Down,    XK_KP_2,
+/*     81    88 */       XK_KP_Page_Down,       XK_KP_3,
+/*     82    89 */       XK_KP_Insert,  XK_KP_0,
+/*     83    90 */       XK_KP_Delete,  XK_KP_Decimal,
+/*     84    91 */     NoSymbol,        NoSymbol,
+/*     85    92 */     NoSymbol,        NoSymbol,
+/*     86    93 */     NoSymbol,        NoSymbol,
+/*     87    94 */       XK_F11,        NoSymbol,
+/*     88    95 */       XK_F12,        NoSymbol,
+
+/* These are remapped from the extended set (using ExtendMap) */
+
+/*     89    96 */       XK_Control_R,  NoSymbol,
+/*     90    97 */       XK_KP_Enter,   NoSymbol,
+/*     91    98 */       XK_KP_Divide,  NoSymbol,
+/*     92    99 */       XK_Sys_Req,    XK_Print,
+/*     93   100 */       XK_Alt_R,      XK_Meta_R,
+/*     94   101 */       XK_Num_Lock,   NoSymbol,
+/*     95   102 */       XK_Home,       NoSymbol,
+/*     96   103 */       XK_Up,         NoSymbol,
+/*     97   104 */       XK_Page_Up,    NoSymbol,
+/*     98   105 */       XK_Left,       NoSymbol,
+/*     99   106 */       XK_Right,      NoSymbol,
+/*    100   107 */       XK_End,        NoSymbol,
+/*    101   108 */       XK_Down,       NoSymbol,
+/*    102   109 */       XK_Page_Down,  NoSymbol,
+/*    103   110 */       XK_Insert,     NoSymbol,
+/*    104   111 */       XK_Delete,     NoSymbol,
+/*    105   112 */       XK_Super_L,    NoSymbol,
+/*    106   113 */       XK_Super_R,    NoSymbol,
+/*    107   114 */       XK_Menu,       NoSymbol,
+/*    108   115 */       NoSymbol,      NoSymbol,
+/*    109   116 */       NoSymbol,      NoSymbol,
+/*    110   117 */       NoSymbol,      NoSymbol,
+/*    111   118 */       NoSymbol,      NoSymbol,
+/*    112   119 */       NoSymbol,      NoSymbol,
+
+/*    113   120 */      NoSymbol,     NoSymbol,
+/*    114   121 */      NoSymbol,     NoSymbol,
+/*    115   122 */      NoSymbol,     NoSymbol,
+/*    116   123 */      NoSymbol,     NoSymbol,
+/*    117   124 */      NoSymbol,     NoSymbol,
+/*    118   125 */      NoSymbol,     NoSymbol,
+/*    119   126 */      NoSymbol,     NoSymbol,
+/*    120   127 */      NoSymbol,     NoSymbol,
+/*    121   128 */      NoSymbol,     NoSymbol,
+/*    122   129 */      NoSymbol,     NoSymbol,
+/*    123   130 */      NoSymbol,     NoSymbol,
+/*    124   131 */      NoSymbol,     NoSymbol,
+/*    125   132 */      NoSymbol,     NoSymbol,
+/*    126   133 */      NoSymbol,     NoSymbol,
+/*    127   134 */      NoSymbol,     NoSymbol,
+/*    128   135 */      NoSymbol,     NoSymbol,
+/*    129   136 */      NoSymbol,     NoSymbol,
+/*    130   137 */      NoSymbol,     NoSymbol,
+/*    131   138 */      NoSymbol,     NoSymbol,
+/*    132   139 */      NoSymbol,     NoSymbol,
+/*    133   140 */      NoSymbol,     NoSymbol,
+/*    134   141 */      NoSymbol,     NoSymbol,
+/*    135   142 */      NoSymbol,     NoSymbol,
+/*    136   143 */      NoSymbol,     NoSymbol,
+/*    137   144 */      NoSymbol,     NoSymbol,
+/*    138   145 */      NoSymbol,     NoSymbol,
+/*    139   146 */      NoSymbol,     NoSymbol,
+/*    140   147 */      NoSymbol,     NoSymbol,
+/*    141   148 */      NoSymbol,     NoSymbol,
+/*    142   149 */      NoSymbol,     NoSymbol,
+/*    143   150 */      NoSymbol,     NoSymbol,
+/*    144   151 */      NoSymbol,     NoSymbol,
+/*    145   152 */      NoSymbol,     NoSymbol,
+/*    146   153 */      NoSymbol,     NoSymbol,
+/*    147   154 */      NoSymbol,     NoSymbol,
+/*    148   155 */      NoSymbol,     NoSymbol,
+/*    149   156 */      NoSymbol,     NoSymbol,
+/*    150   157 */      NoSymbol,     NoSymbol,
+/*    151   158 */      NoSymbol,     NoSymbol,
+/*    152   159 */      NoSymbol,     NoSymbol,
+/*    153   160 */      NoSymbol,     NoSymbol,
+/*    154   161 */      NoSymbol,     NoSymbol,
+/*    155   162 */      NoSymbol,     NoSymbol,
+/*    156   163 */      NoSymbol,     NoSymbol,
+/*    157   164 */      NoSymbol,     NoSymbol,
+/*    158   165 */      NoSymbol,     NoSymbol,
+/*    159   166 */      NoSymbol,     NoSymbol,
+/*    160   167 */      NoSymbol,     NoSymbol,
+/*    161   168 */      NoSymbol,     NoSymbol,
+/*    162   169 */      NoSymbol,     NoSymbol,
+/*    163   170 */      NoSymbol,     NoSymbol,
+/*    164   171 */      NoSymbol,     NoSymbol,
+/*    165   172 */      NoSymbol,     NoSymbol,
+/*    166   173 */      NoSymbol,     NoSymbol,
+/*    167   174 */      NoSymbol,     NoSymbol,
+/*    168   175 */      NoSymbol,     NoSymbol,
+/*    169   176 */      NoSymbol,     NoSymbol,
+/*    170   177 */      NoSymbol,     NoSymbol,
+/*    171   178 */      NoSymbol,     NoSymbol,
+/*    172   179 */      NoSymbol,     NoSymbol,
+/*    173   180 */      NoSymbol,     NoSymbol,
+/*    174   181 */      NoSymbol,     NoSymbol,
+/*    175   182 */      NoSymbol,     NoSymbol,
+/*    176   183 */      NoSymbol,     NoSymbol,
+/*    177   184 */      NoSymbol,     NoSymbol,
+/*    178   185 */      NoSymbol,     NoSymbol,
+/*    179   186 */      NoSymbol,     NoSymbol,
+/*    180   187 */      NoSymbol,     NoSymbol,
+/*    181   188 */      NoSymbol,     NoSymbol,
+/*    182   189 */      NoSymbol,     NoSymbol,
+/*    183   190 */      NoSymbol,     NoSymbol,
+/*    184   191 */      NoSymbol,     NoSymbol,
+/*    185   192 */      NoSymbol,     NoSymbol,
+/*    186   193 */      NoSymbol,     NoSymbol,
+/*    187   194 */      NoSymbol,     NoSymbol,
+/*    188   195 */      NoSymbol,     NoSymbol,
+/*    189   196 */      NoSymbol,     NoSymbol,
+/*    190   197 */      NoSymbol,     NoSymbol,
+/*    191   198 */      NoSymbol,     NoSymbol,
+/*    192   199 */      NoSymbol,     NoSymbol,
+/*    193   200 */      NoSymbol,     NoSymbol,
+/*    194   201 */      NoSymbol,     NoSymbol,
+};
+
+static void
+EvdevKbdRead (int fd, void *closure)
+{
+    int i, n;
+    struct input_event events[NUM_EVENTS];
+
+    n = read (fd, &events, NUM_EVENTS * sizeof (struct input_event));
+    if (n <= 0)
+      return;
+
+    n /= sizeof (struct input_event);
+
+    for (i = 0; i < n; i++)
+    {
+        if (events[i].type == EV_KEY)
+      	    KdEnqueueKeyboardEvent (events[i].code, !events[i].value);
+    }
+}
+
+static void
+EvdevKbdLoad (void)
+{
+    kdMinScanCode = 0;
+    kdMaxScanCode = 193;
+    kdKeymapWidth = 2;
+    memcpy (kdKeymap, evdevKeymap, sizeof (evdevKeymap));
+}
+
+static int
+EvdevKbdInit (void)
+{
+    int fd, i;
+
+    if (!EvdevInputType)
+        EvdevInputType = KdAllocInputType ();
+
+    if (!kdKeyboard)
+    {
+        for (i = 0; i < NUM_DEFAULT_EVDEV; i++)
+        {
+            fd = open (kdefaultEvdev[i], 2);
+            if (fd >= 0)
+            {
+                kdKeyboard = KdSaveString (kdefaultEvdev[i]);
+                break;
+            }
+	}
+    }
+    else
+    {
+        fd = open (kdKeyboard, O_RDWR);
+        if (fd < 0)
+            return FALSE;
+    }
+
+    if (ioctl (fd, EVIOCGRAB, 1) < 0)
+    {
+        close (fd);
+	return FALSE;
+    }
+
+    if (!KdRegisterFd (EvdevInputType, fd, EvdevKbdRead, NULL))
+        return FALSE;
+
+    kbd_fd = fd;
+    return TRUE;
+}
+
+static void
+EvdevKbdFini (void)
+{
+}
+
+static void
+EvdevKbdLeds (int leds)
+{
+    struct input_event event;
+
+    memset(&event, 0, sizeof(event));
+
+    event.type = EV_LED;
+    event.code = LED_CAPSL;
+    event.value = leds & (1 << 0) ? 1 : 0;
+    write(kbd_fd, (char *) &event, sizeof(event));
+
+    event.type = EV_LED;
+    event.code = LED_NUML;
+    event.value = leds & (1 << 1) ? 1 : 0;
+    write(kbd_fd, (char *) &event, sizeof(event));
+
+    event.type = EV_LED;
+    event.code = LED_SCROLLL;
+    event.value = leds & (1 << 2) ? 1 : 0;
+    write(kbd_fd, (char *) &event, sizeof(event));
+
+    event.type = EV_LED;
+    event.code = LED_COMPOSE;
+    event.value = leds & (1 << 3) ? 1 : 0;
+    write(kbd_fd, (char *) &event, sizeof(event));
+}
+
+static void
+EvdevKbdBell (int volume, int frequency, int duration)
+{
+}
+
 KdKeyboardFuncs LinuxEvdevKeyboardFuncs = {
     EvdevKbdLoad,
     EvdevKbdInit,
     EvdevKbdLeds,
     EvdevKbdBell,
     EvdevKbdFini,
     0,
 };
-#endif
+
--- xorg-server-1.3.0.0.orig/hw/kdrive/linux/linux.c
+++ xorg-server-1.3.0.0/hw/kdrive/linux/linux.c
@@ -340,21 +340,21 @@ LinuxEnable (void)
 	ioctl (LinuxConsoleFd, VT_RELDISP, VT_ACKACQ);
     }
     /*
      * Open the APM driver
      */
-    LinuxApmFd = open ("/dev/apm_bios", 2);
+    /*LinuxApmFd = open ("/dev/apm_bios", 2);
     if (LinuxApmFd < 0 && errno == ENOENT)
 	LinuxApmFd = open ("/dev/misc/apm_bios", 2); 
     if (LinuxApmFd >= 0)
     {
 	LinuxApmRunning = TRUE;
 	fcntl (LinuxApmFd, F_SETFL, fcntl (LinuxApmFd, F_GETFL) | NOBLOCK);
 	RegisterBlockAndWakeupHandlers (LinuxApmBlock, LinuxApmWakeup, 0);
 	AddEnabledDevice (LinuxApmFd);
     }
-	
+    */
     /*
      * now get the VT
      */
     LinuxSetSwitchMode (VT_AUTO);
     if (ioctl(LinuxConsoleFd, VT_ACTIVATE, vtno) != 0)
--- xorg-server-1.3.0.0.orig/hw/kdrive/linux/mouse.c
+++ xorg-server-1.3.0.0/hw/kdrive/linux/mouse.c
@@ -925,12 +925,14 @@ int MouseInputType;
 char *kdefaultMouse[] =  {
     "/dev/mouse",
     "/dev/psaux",
     "/dev/input/mice",
     "/dev/adbmouse",
+#ifdef BREAK_MY_SERIAL_CONSOLE
     "/dev/ttyS0",
     "/dev/ttyS1",
+#endif
 };
 
 #define NUM_DEFAULT_MOUSE    (sizeof (kdefaultMouse) / sizeof (kdefaultMouse[0]))
 
 static Bool
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/Makefile.am
@@ -0,0 +1,29 @@
+if  NOMADIK
+
+INCLUDES = 					\
+	@KDRIVE_INCS@				\
+	@KDRIVE_CFLAGS@ \
+	-I$(top_srcdir)/hw/kdrive/fbdev		\
+	-I$(top_srcdir)/exa	\
+	-I@KERNEL_HEADERS_PATH@/drivers/video/nomadik
+
+bin_PROGRAMS = Xnomadik
+
+Xnomadik_SOURCES = \
+nomadik-init.c \
+nomadik-exa.c \
+nomadik-exa.h \
+nomadik-video.c \
+nomadik-sva.c \
+nomadik-sva.h \
+nomadik-log.h
+
+Xnomadik_LDADD = 					\
+	../fbdev/libfbdev.a				\
+	../../../exa/libexa.la				\
+	-lSGALib					\
+	-lpthread					\
+	@KDRIVE_LIBS@					\
+	@XSERVER_LIBS@
+
+endif
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-exa.c
@@ -0,0 +1,957 @@
+/*
+ * Copyright 2007 ST Microelectronics
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *   Dodji Seketeli <dodji@openedhand.com>
+ */
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+#include <nomadik/sga_lib.h>
+#include "kdrive.h"
+#include "fbdev.h"
+#include "nomadik-exa.h"
+#include "nomadik-log.h"
+
+#include <X11/extensions/render.h> //added for composite
+
+#define PIX_THRESHOLD 0
+Bool noCopyAccel = FALSE;
+Bool noSolidAccel = FALSE;
+Bool noUploadToScreenAccel = FALSE ;
+Bool noDownloadFromScreenAccel = FALSE ;
+Bool noCompositeAccel = FALSE ;
+int accelCopyType = 0 ; /*0->sgalibCopy, 1->memcpyCopy*/
+int accelDownloadFromScreenType = 1 ; /*0->sgalibBlitting, 1->memcpy*/
+int nomadikPrivScreenPrivateIndex=0 ;
+
+struct _NomadikPriv
+{
+    ExaDriverPtr                exa ;
+    PixmapPtr                   srcPix /*used in copy accel call*/;
+    PixmapPtr                   maskPix /* added for composite */;
+    PixmapPtr                   dstPix /*used in copy accel call*/;
+    int                         dx;
+    int                         dy;
+    int				fill_handle;
+    int				copy_handle;
+    int				blit_handle;
+    int				comp_handle;
+    Sga_bitmap                  sgaBitmap ;
+    Sga_bitmap                  maskBmap ; /* added for composite */
+    Sga_bitmap                  dstBmap ;
+    int                         solidROP ;
+    Pixel                       solidFg ;
+    Pixel                       solidPlaneMask ;
+    char			CopyPrimitiveAdded;
+    char			SolidPrimitiveAdded;
+    char			CompositePrimitiveAdded; /* added for composite */
+};
+
+typedef struct _NomadikPriv NomadikPriv ;
+
+#ifndef GetNomadikPriv
+#  define GetNomadikPriv(pScreen) \
+     ((NomadikPriv*)(pScreen)->devPrivates[nomadikPrivScreenPrivateIndex].ptr)
+#endif
+
+#ifndef SetNomadikPriv
+# define SetNomadikPriv(pScreen,value) \
+    (pScreen)->devPrivates[nomadikPrivScreenPrivateIndex].ptr = (value)
+#endif
+
+
+static void
+memcpyCopy (PixmapPtr       pDstPixmap,
+            int             srcX,
+            int             srcY,
+            int             dstX,
+            int             dstY,
+            int             width,
+            int             height) ;
+
+static void
+sgalibCopy (PixmapPtr       pDstPixmap,
+           int             srcX,
+           int             srcY,
+           int             dstX,
+           int             dstY,
+           int             width,
+           int             height) ;
+static Bool
+CheckCompositeParams (int          op,
+                          PicturePtr   pSrcPicture,
+                          PicturePtr   pMaskPicture,
+                          PicturePtr   pDstPicture);
+
+static Bool
+isPixmapOffscreen (PixmapPtr pPix)
+{
+    NomadikPriv *priv = NULL ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (pPix || pPix->drawable.pScreen, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (KdGetScreenPriv(pPix->drawable.pScreen),
+                                FALSE) ;
+
+    priv = GetNomadikPriv (pPix->drawable.pScreen);
+    NOMADIK_RETURN_VAL_IF_FAIL(priv, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL(priv->exa, FALSE) ;
+
+    return (exaGetPixmapOffset(pPix) >= priv->exa->offScreenBase) ;
+}
+
+/**
+ * exaDDXDriverInit is required by the top-level EXA module, and is used by
+ * the xorg DDX to hook in its EnableDisableNOMADIK wrapper.  More generaly,
+ * it is where you can enable/disable some exa functions, based on options
+ * people have set in the X config files.
+ * We obviously don't need it.
+ */
+void
+exaDDXDriverInit(ScreenPtr pScreen)
+{
+    NOMADIK_LOG ("mark\n") ;
+}
+
+Bool
+nomadikExaInit(ScreenPtr pScreen)
+{
+    NomadikPriv *priv = NULL;
+    KdScreenPriv(pScreen) ;
+    KdScreenInfo *kdScreenInfo = NULL ;
+    FbdevPriv		*drvpriv = pScreenPriv->screen->card->driver;
+    Bool success = FALSE ;
+    NOMADIK_LOG ("mark\n") ;
+    int sgalib_ret =0 ;
+
+    NOMADIK_LOG("going to initialize sgalib with: w:%d,h:%d,bitspp:%d\n",
+                pScreenPriv->screen->width,
+                pScreenPriv->screen->height,
+                pScreenPriv->screen->fb[0].bitsPerPixel) ;
+
+    /*
+    sgalib_ret =
+        SGALIB_InitFromParams(pScreenPriv->screen->width,
+                              pScreenPriv->screen->height,
+                              pScreenPriv->screen->fb[0].bitsPerPixel) ;
+    */
+    NOMADIK_LOG("Going to init sgalib with \n"
+                "memaddr:%#x,width:#%d,height:%#x,bpp:%#x,memsize:%#d,phymemstart:%#x\n",
+                pScreenPriv->screen->memory_base,
+                pScreenPriv->screen->width,
+                pScreenPriv->screen->height,
+                pScreenPriv->screen->fb[0].bitsPerPixel,
+                pScreenPriv->screen->memory_size,
+                drvpriv->fix.smem_start) ;
+    sgalib_ret = SGALIB_Init(pScreenPriv->screen->memory_base,
+                             pScreenPriv->screen->width,
+                             pScreenPriv->screen->height,
+                             pScreenPriv->screen->fb[0].bitsPerPixel,
+                             pScreenPriv->screen->memory_size,
+                             drvpriv->fix.smem_start);
+    if (sgalib_ret != SGALIB_SUCCESS) {
+        NOMADIK_LOG_ERROR ("Failed to initialise sgalib: %d\n", sgalib_ret) ;
+        return FALSE ;
+    }
+    NOMADIK_LOG ("sgalib initialized okay") ;
+
+    priv = xalloc(sizeof(NomadikPriv)) ;
+    if (!priv) {
+        NOMADIK_LOG_ERROR ("Failed to allocate nomadik data\n") ;
+        goto error ;
+    }
+    memset(priv, 0, sizeof(NomadikPriv)) ;
+    nomadikPrivScreenPrivateIndex = AllocateScreenPrivateIndex() ;
+    pScreen->devPrivates[nomadikPrivScreenPrivateIndex].ptr = priv ;
+
+    priv->exa = exaDriverAlloc() ;
+    if (!priv->exa) {
+        NOMADIK_LOG_ERROR ("Failed to allocate exa driver\n") ;
+        SetNomadikPriv(pScreen, NULL) ;
+        goto error ;
+    }
+    /*
+     * Since we statically link against EXA,
+     * we shouldn't have to be smart about
+     * versioning.
+     */
+    priv->exa->exa_major = 2;
+    priv->exa->exa_minor = 0 ;
+
+    priv->exa->memoryBase = pScreenPriv->screen->memory_base ;
+    priv->exa->memorySize = pScreenPriv->screen->memory_size ;
+    priv->exa->offScreenBase = pScreenPriv->screen->off_screen_base ;
+    priv->exa->pixmapOffsetAlign = 4 ;
+    priv->exa->pixmapPitchAlign =  4 ;
+    priv->exa->maxX = 1023 ;
+    priv->exa->maxY = 1023 ;
+    priv->exa->flags = EXA_OFFSCREEN_PIXMAPS ;
+    priv->exa->PrepareSolid = nomadikExaPrepareSolid;
+    priv->exa->Solid = nomadikExaSolid ;
+    priv->exa->DoneSolid = nomadikExaDoneSolid ;
+    priv->exa->PrepareCopy = nomadikExaPrepareCopy ;
+    priv->exa->Copy = nomadikExaCopy ;
+    priv->exa->DoneCopy = nomadikExaDoneCopy  ;
+    priv->exa->CheckComposite = nomadikExaCheckComposite ; //added for composite
+    priv->exa->PrepareComposite = nomadikExaPrepareComposite ; //added for composite
+    priv->exa->Composite = nomadikExaComposite ; //added for composite
+    priv->exa->DoneComposite =nomadikExaDoneComposite ;  //added for composite
+    priv->exa->UploadToScreen = NULL;//nomadikExaUploadToScreen ;
+    priv->exa->DownloadFromScreen = NULL;//nomadikExaDownloadFromScreen ;
+    priv->exa->PrepareAccess = NULL;//nomadikExaPrepareAccess ;
+    priv->exa->FinishAccess  = NULL;//nomadikExaFinishAccess ;
+    priv->exa->WaitMarker = nomadikExaWaitMarker;
+
+    success = exaDriverInit (pScreen, priv->exa) ;
+    if (success) {
+        NOMADIK_LOG ("Initialized EXA acceleration\n") ;
+    } else {
+        NOMADIK_LOG_ERROR ("Failed to initialize EXA acceleration\n") ;
+        SetNomadikPriv(pScreen, NULL) ;
+        goto error ;
+    }
+
+    NOMADIK_LOG("membase: %#x\n"
+                "memsize: %#x\n"
+                "offscreen membase: %#x\n",
+                priv->exa->memoryBase,
+                priv->exa->memorySize,
+                priv->exa->offScreenBase) ;
+    return TRUE ;
+
+error:
+    if (priv->exa) {
+        xfree(priv->exa) ;
+        priv->exa = NULL ;
+    }
+    if (priv) {
+        xfree(priv) ;
+        priv=NULL ;
+    }
+    return FALSE ;
+}
+
+void
+nomadikExaEnable(ScreenPtr pScreen)
+{
+    NOMADIK_LOG ("mark\n") ;
+}
+
+void
+nomadikExaDisable(ScreenPtr pScreen)
+{
+    NOMADIK_LOG ("mark\n") ;
+}
+
+void
+nomadikExaFini(ScreenPtr pScreen)
+{
+    NOMADIK_LOG ("mark\n") ;
+}
+
+void	nomadikExaWaitMarker(ScreenPtr pScreen, int marker)
+{
+	SGALIB_WaitMarker();
+}
+
+Bool
+nomadikExaPrepareSolid (PixmapPtr      pPixmap,
+                   int            alu,
+                   Pixel          planemask,
+                   Pixel          fg)
+{
+	NomadikPriv *priv = NULL ;
+	unsigned int colour;
+
+	NOMADIK_LOG ("mark\n") ;
+	NOMADIK_LOG("//PSolid(off:%d, wid:%d, ht:%d, st:%d);\ncolour(0x%x)\n",   exaGetPixmapOffset(pPixmap), pPixmap->drawable.width, pPixmap->drawable.height,exaGetPixmapPitch(pPixmap), fg);
+	if (noSolidAccel) {
+		NOMADIK_LOG("-nosolidaccel turned on. Unacelerated\n") ;
+		return FALSE ;
+	}
+	if (alu != GXcopy) {
+		NOMADIK_LOG("rop '%#x' was requested. Unaccelerated\n") ;
+//		NOMADIK_MLOG("PSolid(rop:%d, pmask:0x%x);\n",alu, planemask) ;
+		return FALSE ;
+	}
+	//if(24 == pPixmap->drawable.bitsPerPixel || 8 == pPixmap->drawable.bitsPerPixel || 32 == pPixmap->drawable.bitsPerPixel) {
+	if(32 == pPixmap->drawable.bitsPerPixel) {
+	NOMADIK_LOG_ERROR("//PSolid(off:%d, wid:%d, ht:%d, st:%d);\ncolour(0x%x)\n",   exaGetPixmapOffset(pPixmap), pPixmap->drawable.width, pPixmap->drawable.height,exaGetPixmapPitch(pPixmap), fg);
+	return FALSE;
+}
+
+	if(PIX_THRESHOLD > (pPixmap->drawable.width * pPixmap->drawable.height)) {
+		return FALSE;
+	}
+
+	priv = GetNomadikPriv(pPixmap->drawable.pScreen) ;
+	priv->solidROP = alu ;
+	priv->solidPlaneMask = planemask ;
+	priv->solidFg = fg ;
+	NOMADIK_LOG("priv->solidFg=0x%x\n",fg) ;
+
+
+	/*
+	 * start filling the sgalib bitmap params
+	 */
+	priv->sgaBitmap.addr = priv->exa->memoryBase + exaGetPixmapOffset(pPixmap);
+	priv->sgaBitmap.width = pPixmap->drawable.width;
+	priv->sgaBitmap.height = pPixmap->drawable.height;
+	priv->sgaBitmap.line_jump = exaGetPixmapPitch(pPixmap);
+	priv->sgaBitmap.bitspp = pPixmap->drawable.bitsPerPixel;
+    	switch(pPixmap->drawable.bitsPerPixel)
+    	{
+	    case 8:
+	    	priv->sgaBitmap.format = SGALIB_MONO_8BPP;
+	    	break;
+	    case 16:
+	    	priv->sgaBitmap.format = SGALIB_RGB16;
+	    	break;
+	    case 24:
+	    	priv->sgaBitmap.format = SGALIB_ARGB24;
+		break;
+	    case 32:
+	    	priv->sgaBitmap.format = SGALIB_ARGB24;
+		break;
+	    default:
+	    	return FALSE;
+	}
+	NOMADIK_LOG("pBmap(a:0x%x, w:%d, h:%d, lj:%d, fmt:%d, bpp:%d), col:0x%x;\n",
+			priv->sgaBitmap.addr, priv->sgaBitmap.width,
+			priv->sgaBitmap.height,  priv->sgaBitmap.line_jump,
+			priv->sgaBitmap.format, priv->sgaBitmap.bitspp, priv->solidFg);
+
+	priv->fill_handle = SGALIB_PrepareSolid(&priv->sgaBitmap, priv->solidFg) ;
+	if (priv->fill_handle < 0) {
+            NOMADIK_LOG("SGALIB_PrepareSolid() failed: %d\n", priv->fill_handle) ;
+            return ;
+        }
+	priv->SolidPrimitiveAdded = 0;
+
+	NOMADIK_LOG("okay\n") ;
+	return TRUE ;
+}
+
+void memfill(PixmapPtr      pPixmap,
+                int            x1,
+                int            y1,
+                int            x2,
+                int            y2)
+{
+	NomadikPriv *priv = NULL ;
+	int i, bpp, stride;
+	unsigned char *rect_addr, *fill_addr;
+
+	priv = GetNomadikPriv (pPixmap->drawable.pScreen) ;
+	stride = exaGetPixmapPitch(pPixmap);
+	bpp = pPixmap->drawable.bitsPerPixel>>3;
+	rect_addr = priv->exa->memoryBase + exaGetPixmapOffset(pPixmap);
+	rect_addr += y1 * stride + x1 * bpp;
+
+	fill_addr = rect_addr;
+	for(i= 0; i < (x2 - x1); i++) {
+		memcpy(fill_addr, &priv->solidFg, bpp); // filled one line
+		fill_addr += bpp;
+	}
+	fill_addr = rect_addr + stride;
+
+	for(i = y1+1; i < y2; i++) {
+		memcpy(fill_addr, rect_addr, bpp * (x2 - x1));
+		fill_addr += stride;
+	}
+}
+
+void
+nomadikExaSolid(PixmapPtr      pPixmap,
+                int            x1,
+                int            y1,
+                int            x2,
+                int            y2)
+{
+	NomadikPriv *priv = NULL ;
+	int res = 0 , i, j;
+
+	NOMADIK_LOG("mark\n") ;
+
+	priv = GetNomadikPriv (pPixmap->drawable.pScreen) ;
+
+	NOMADIK_LOG("Solid(x1:%d, y1:%d, x2:%d, y2:%d);\n", x1, y1, x2, y2);
+//	NOMADIK_MLOG("Solid(w:%d, h:%d, pix:%d);\n", x2 - x1, y2 - y1, (x2 - x1) * (y2 - y1));
+	if((x2 - x1) * (y2 - y1) < PIX_THRESHOLD) {
+		memfill(pPixmap, x1, y1, x2, y2);
+	} else {
+		priv->SolidPrimitiveAdded = 1;
+		res = SGALIB_Solid(priv->fill_handle, x1, y1, x2, y2) ;
+		if (res != SGALIB_SUCCESS) {
+		    NOMADIK_LOG("SGALIB_Solid() failed: %d\n", res) ;
+		    return ;
+		}
+	}
+	NOMADIK_LOG("okay\n") ;
+}
+
+void
+nomadikExaDoneSolid (PixmapPtr      pPixmap)
+{
+	NomadikPriv *priv = NULL ;
+	int res = 0 ;
+
+	NOMADIK_LOG ("mark\n") ;
+
+	priv = GetNomadikPriv (pPixmap->drawable.pScreen) ;
+	if(priv->SolidPrimitiveAdded) {
+		res = SGALIB_DoneSolid(priv->fill_handle) ;
+		if (res != SGALIB_SUCCESS) {
+		    NOMADIK_LOG("SGALIB_DoneSolid() failed: %d\n", res) ;
+		    return ;
+		}
+	}
+	exaMarkSync(pPixmap->drawable.pScreen);
+}
+
+
+Bool
+nomadikExaPrepareCopy (PixmapPtr       pSrcPixmap,
+                       PixmapPtr       pDstPixmap,
+                       int             dx,
+                       int             dy,
+                       int             alu,
+                       Pixel           planemask)
+{
+	NomadikPriv *priv = NULL ;
+	int res = 0 ;
+
+	if (alu != GXcopy) {
+		NOMADIK_LOG("Got rop:%d. Unaccelerated\n", alu) ;
+//		NOMADIK_MLOG("PCopy(rop:%d, pmask:0x%x);\n",alu, planemask) ;
+	}
+	if (noCopyAccel) {
+		NOMADIK_LOG("-nocopyaccel turned on. Unaccelerated\n") ;
+		return FALSE ;
+	}
+
+	NOMADIK_RETURN_VAL_IF_FAIL (pSrcPixmap && pDstPixmap, FALSE) ;
+
+	//if(24 == pSrcPixmap->drawable.bitsPerPixel || 8 == pSrcPixmap->drawable.bitsPerPixel || 32 == pSrcPixmap->drawable.bitsPerPixel || 24 == pDstPixmap->drawable.bitsPerPixel || 8 == pDstPixmap->drawable.bitsPerPixel || 32 == pDstPixmap->drawable.bitsPerPixel) {
+	if(32 == pSrcPixmap->drawable.bitsPerPixel || 32 == pDstPixmap->drawable.bitsPerPixel) {
+	return FALSE;
+}
+
+	if(PIX_THRESHOLD > (pSrcPixmap->drawable.width * pSrcPixmap->drawable.height) || PIX_THRESHOLD > (pDstPixmap->drawable.width * pDstPixmap->drawable.height)) {
+		return FALSE;
+	}
+	/*
+	* dump some logs for debugging
+	*/
+	NOMADIK_LOG ("Preparing to copy: \n"
+	    "src(%d,%d,%d,%d), dst(%d,%d,%d,%d)\n"
+	    "xydir(%d,%d)\n"
+	    "rop: %x\n",
+	    pSrcPixmap->drawable.x, pSrcPixmap->drawable.y,
+	    pSrcPixmap->drawable.width, pSrcPixmap->drawable.height,
+	    pDstPixmap->drawable.x, pDstPixmap->drawable.y,
+	    pDstPixmap->drawable.width, pDstPixmap->drawable.height,
+	    dx,dy,alu) ;
+
+	priv = GetNomadikPriv(pSrcPixmap->drawable.pScreen) ;
+	NOMADIK_RETURN_VAL_IF_FAIL (priv, FALSE) ;
+
+	priv->srcPix = pSrcPixmap ;
+	priv->dstPix = pDstPixmap ;
+	priv->dx = dx ;
+	priv->dy = dy ;
+
+	if (accelCopyType == 0) {
+
+		priv->sgaBitmap.addr = priv->exa->memoryBase + exaGetPixmapOffset(pSrcPixmap);
+		priv->sgaBitmap.width = pSrcPixmap->drawable.width;
+		priv->sgaBitmap.height = pSrcPixmap->drawable.height;
+		priv->sgaBitmap.line_jump = exaGetPixmapPitch(pSrcPixmap);
+		priv->sgaBitmap.bitspp = pSrcPixmap->drawable.bitsPerPixel;
+		switch(pSrcPixmap->drawable.bitsPerPixel)
+		{
+		    case 8:
+			priv->sgaBitmap.format = SGALIB_MONO_8BPP;
+			break;
+		    case 16:
+			priv->sgaBitmap.format = SGALIB_RGB16;
+			break;
+		    case 24:
+			priv->sgaBitmap.format = SGALIB_ARGB24;
+			break;
+		    case 32:
+			priv->sgaBitmap.format = SGALIB_ARGB24;
+			break;
+		    default:
+			return FALSE;
+		}
+
+		priv->dstBmap.addr = priv->exa->memoryBase + exaGetPixmapOffset(pDstPixmap);
+		priv->dstBmap.width = pDstPixmap->drawable.width;
+		priv->dstBmap.height = pDstPixmap->drawable.height;
+		priv->dstBmap.line_jump = exaGetPixmapPitch(pDstPixmap);
+		priv->dstBmap.bitspp = pDstPixmap->drawable.bitsPerPixel;
+		switch(pDstPixmap->drawable.bitsPerPixel)
+		{
+		    case 8:
+			priv->dstBmap.format = SGALIB_MONO_8BPP;
+			break;
+		    case 16:
+			priv->dstBmap.format = SGALIB_RGB16;
+			break;
+		    case 24:
+			priv->dstBmap.format = SGALIB_ARGB24;
+			break;
+		    case 32:
+			priv->dstBmap.format = SGALIB_ARGB24;
+			break;
+		    default:
+			return FALSE;
+		}
+
+		priv->copy_handle = SGALIB_PrepareCopy(&priv->sgaBitmap, &priv->dstBmap);
+		if(priv->copy_handle  < 0) {
+		    NOMADIK_LOG("SGALIB_PrepareCopy() failed: %d\n", priv->copy_handle) ;
+		    return FALSE;
+		}
+	}
+	priv->CopyPrimitiveAdded = 0;
+
+	NOMADIK_LOG ("OK\n") ;
+	return TRUE ;
+}
+
+void
+nomadikExaCopy (PixmapPtr       pDstPixmap,
+                int             srcX,
+                int             srcY,
+                int             dstX,
+                int             dstY,
+                int             width,
+                int             height)
+{
+    NomadikPriv *priv = NULL ;
+    NOMADIK_LOG ("enter\n") ;
+
+    priv = GetNomadikPriv(pDstPixmap->drawable.pScreen) ;
+    NOMADIK_RETURN_IF_FAIL (priv) ;
+
+//    NOMADIK_MLOG("Copy(w:%d, h:%d, pixels:%d);\n", width, height, width*height);
+    if (accelCopyType == 0 || (PIX_THRESHOLD > (width * height))) {
+	priv->CopyPrimitiveAdded = 1;
+        SGALIB_Copy(priv->copy_handle, srcX, srcY, dstX, dstY, width, height) ;
+    } else {
+        memcpyCopy (pDstPixmap, srcX, srcY, dstX, dstY, width, height) ;
+    }
+}
+
+static void
+memcpyCopy (PixmapPtr       pDstPixmap,
+            int             srcX,
+            int             srcY,
+            int             dstX,
+            int             dstY,
+            int             width,
+            int             height)
+{
+    NomadikPriv *priv = NULL ;
+    int bytespp=0 ;
+    char *from=NULL, *to=NULL ;
+    int srcStride=0, dstStride=0, i=0, j=0, k=0, copyStride=0;
+
+    NOMADIK_LOG("src{x:%d,y:%d}, "
+           "dst{x:%d,y:%d}, "
+            "size(w:%d,h:%d)\n",
+            srcX,srcY,
+            dstX,dstY,
+            width, height) ;
+
+    priv = GetNomadikPriv(pDstPixmap->drawable.pScreen) ;
+    bytespp = priv->srcPix->drawable.bitsPerPixel >> 3 ;
+
+    srcStride = exaGetPixmapPitch(priv->srcPix);
+    from = priv->srcPix->devPrivate.ptr + srcX*bytespp + srcY*srcStride;
+    dstStride =  exaGetPixmapPitch(pDstPixmap);
+    to = pDstPixmap->devPrivate.ptr + dstX*bytespp + dstY*dstStride;
+    copyStride = width*bytespp ;
+    NOMADIK_LOG("dstStride:%d, srcStride:%d, copyStride:%d\n",
+           dstStride, srcStride, copyStride) ;
+    if (priv->srcPix != priv->dstPix) {
+        NOMADIK_LOG("Non overlapping pixmaps\n") ;
+        for (i=0; i<height; i++) {
+            memcpy(to + i*dstStride, from + i*srcStride, copyStride) ;
+        }
+        return ;
+    } else {
+        NOMADIK_LOG("overlapping pixmaps\n") ;
+        if (priv->dy >= 0) {
+            for (i=0; i<height; i++) {
+                memcpy(to + i*dstStride, from + i*srcStride, copyStride) ;
+            }
+        } else {
+            for (i=height-1; i>=0; i--) {
+                memcpy(to + i*dstStride, from + i*srcStride, copyStride) ;
+            }
+        }
+    }
+
+    NOMADIK_LOG("out\n") ;
+}
+
+void
+nomadikExaDoneCopy (PixmapPtr       pDstPixmap)
+{
+    NomadikPriv *priv = NULL ;
+    NOMADIK_LOG("mark\n") ;
+    priv = GetNomadikPriv(pDstPixmap->drawable.pScreen) ;
+    if (accelCopyType == 0 && priv->CopyPrimitiveAdded) {
+	    SGALIB_DoneCopy(priv->copy_handle);
+	}
+	exaMarkSync(pDstPixmap->drawable.pScreen);
+
+    NOMADIK_LOG("okay\n") ;
+}
+
+static Bool
+CheckCompositeParams (int          op,
+                          PicturePtr   pSrcPicture,
+                          PicturePtr   pMaskPicture,
+                          PicturePtr   pDstPicture)
+{
+    int srcRepeat = 0;
+
+	if ( (PictOpOver != op) && (PictOpAdd != op) ) //3, 12
+			return FALSE ;
+
+	if (PictOpAdd == op) {
+		if ( (PICT_a8r8g8b8 == pSrcPicture->format) && (PICT_a8r8g8b8 == pDstPicture->format) ) {
+			return TRUE ;
+		}
+		else {
+			return FALSE ;
+		}
+	}
+	if (PictOpOver == op) {
+                /* check for src repeat is supported and  src picture height/width is 1x1 */
+		if ( (pSrcPicture->repeatType == RepeatNormal) && !pMaskPicture->repeatType && !pDstPicture->repeatType)
+			if ( (pSrcPicture->pDrawable->width == 1 ) && ( pSrcPicture->pDrawable->height == 1) )
+				srcRepeat = 1;
+		if ((PICT_a8r8g8b8 == pSrcPicture->format) && (PICT_a8r8g8b8 == pMaskPicture->format) && srcRepeat )
+		{
+			if ( (PICT_r8g8b8 == pDstPicture->format) || (PICT_r5g6b5 == pDstPicture->format)) {
+				return TRUE;
+			}
+			else {
+				return FALSE ;
+			}
+		} else {
+			return FALSE ;
+		}
+	}
+	/* Acceleration of PictOp add and Over only supported, so return false for other operations */
+	return FALSE ;
+}
+
+Bool
+nomadikExaCheckComposite (int          op,
+                          PicturePtr   pSrcPicture,
+                          PicturePtr   pMaskPicture,
+                          PicturePtr   pDstPicture)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (pSrcPicture && pDstPicture, FALSE) ;
+
+   /* NOMADIK_MLOG("CComp(op: %d, "
+                "src(%d,%d,%d,%d) format(%d), "
+                "dst(%d,%d,%d,%d) format(%d)\n",
+                op,
+                pSrcPicture->pDrawable->x, pSrcPicture->pDrawable->y,
+                pSrcPicture->pDrawable->width, pSrcPicture->pDrawable->height,pSrcPicture->format,
+                pDstPicture->pDrawable->x, pDstPicture->pDrawable->y,
+                pDstPicture->pDrawable->width, pDstPicture->pDrawable->height, pDstPicture->format) ;
+    if(pMaskPicture) {
+		NOMADIK_MLOG("mask(%d,%d,%d,%d) format(%d) \n",
+		pMaskPicture->pDrawable->x, pMaskPicture->pDrawable->y,
+		pMaskPicture->pDrawable->width, pMaskPicture->pDrawable->height, pMaskPicture->format) ;
+    }
+*/
+    if (noCompositeAccel) {
+        return FALSE ;
+    }
+
+	if ( CheckCompositeParams (op, pSrcPicture, pMaskPicture, pDstPicture) == TRUE) {
+		return TRUE ;
+	} else {
+		/* Composite operation is other than Add and Over*/
+		return FALSE ;
+	}
+}
+
+Bool
+nomadikExaPrepareComposite (int                op,
+                            PicturePtr         pSrcPicture,
+                            PicturePtr         pMaskPicture,
+                            PicturePtr         pDstPicture,
+                            PixmapPtr          pSrc,
+                            PixmapPtr          pMask,
+                            PixmapPtr          pDst)
+{
+     NomadikPriv *priv = NULL ;
+     int srcRepeat ;
+
+  /*   NOMADIK_MLOG(" PrepareComp(op: %d, "
+	                "src(%d,%d,%d,%d) format(%d), "
+	                "dst(%d,%d,%d,%d) format(%d)\n",
+	                op,
+	                pSrcPicture->pDrawable->x, pSrcPicture->pDrawable->y,
+	                pSrcPicture->pDrawable->width, pSrcPicture->pDrawable->height,pSrcPicture->format,
+	                pDstPicture->pDrawable->x, pDstPicture->pDrawable->y,
+                pDstPicture->pDrawable->width, pDstPicture->pDrawable->height, pDstPicture->format) ;
+*/
+	if (noCompositeAccel) {
+              return FALSE ;
+        }
+
+	if ( CheckCompositeParams (op, pSrcPicture, pMaskPicture, pDstPicture) == FALSE) {
+               return FALSE ;
+	}
+
+	priv = GetNomadikPriv(pSrc->drawable.pScreen) ;
+	NOMADIK_RETURN_VAL_IF_FAIL (priv, FALSE) ;
+
+	priv->srcPix  = pSrc ;
+	priv->maskPix = pMask ;
+	priv->dstPix  = pDst ;
+
+	/* save source bitmap parameters into devprivate */
+	priv->sgaBitmap.addr = priv->exa->memoryBase + exaGetPixmapOffset(pSrc);
+	priv->sgaBitmap.width = pSrc->drawable.width;
+	priv->sgaBitmap.height = pSrc->drawable.height;
+	priv->sgaBitmap.line_jump = exaGetPixmapPitch(pSrc);
+	priv->sgaBitmap.bitspp = pSrc->drawable.bitsPerPixel;
+
+
+	switch(pSrc->drawable.bitsPerPixel)
+	{
+		case 8:
+		priv->sgaBitmap.format = SGALIB_MONO_8BPP;
+		break;
+		case 16:
+		priv->sgaBitmap.format = SGALIB_RGB16;
+		break;
+		case 24:
+		priv->sgaBitmap.format = SGALIB_ARGB24;
+		break;
+		case 32:
+		priv->sgaBitmap.format = SGALIB_ARGB24;
+		break;
+		default:
+		return FALSE;
+	}
+
+	if (pMask) {
+		/* save mask bitmap parameters into devprivate */
+		priv->maskBmap.addr = priv->exa->memoryBase + exaGetPixmapOffset(pMask);
+		priv->maskBmap.width = pMask->drawable.width;
+		priv->maskBmap.height = pMask->drawable.height;
+		priv->maskBmap.line_jump = exaGetPixmapPitch(pMask);
+		priv->maskBmap.bitspp = pMask->drawable.bitsPerPixel;
+		switch(pMask->drawable.bitsPerPixel)
+		{
+			case 8:
+			priv->maskBmap.format = SGALIB_MONO_8BPP;
+			break;
+			case 16:
+			priv->maskBmap.format = SGALIB_RGB16;
+			break;
+			case 24:
+			priv->maskBmap.format = SGALIB_ARGB24;
+			break;
+			case 32:
+			priv->maskBmap.format = SGALIB_ARGB24;
+			break;
+			default:
+			return FALSE;
+		}
+	}
+
+	/* save destination bitmap parameters into devprivate */
+	priv->dstBmap.addr = priv->exa->memoryBase + exaGetPixmapOffset(pDst);
+	priv->dstBmap.width = pDst->drawable.width;
+	priv->dstBmap.height = pDst->drawable.height;
+	priv->dstBmap.line_jump = exaGetPixmapPitch(pDst);
+	priv->dstBmap.bitspp = pDst->drawable.bitsPerPixel;
+	switch(pDst->drawable.bitsPerPixel)
+	{
+		case 8:
+		priv->dstBmap.format = SGALIB_MONO_8BPP;
+		break;
+		case 16:
+		priv->dstBmap.format = SGALIB_RGB16;
+		break;
+		case 24:
+		priv->dstBmap.format = SGALIB_ARGB24;
+		break;
+		case 32:
+		priv->dstBmap.format = SGALIB_ARGB24;
+		break;
+		default:
+		return FALSE;
+	}
+
+	if (pMask) {
+		priv->comp_handle = SGALIB_PrepareComposite(op, &priv->sgaBitmap, &priv->maskBmap, &priv->dstBmap);
+		if(priv->comp_handle  < 0) {
+			return FALSE;
+		}
+	} else {
+                /* For PictOpAdd operation if Mask is NULL */
+		priv->comp_handle = SGALIB_PrepareComposite(op, &priv->sgaBitmap, NULL, &priv->dstBmap);
+		if(priv->comp_handle  < 0) {
+			return FALSE;
+		}
+	}
+	priv->CompositePrimitiveAdded = 0 ;
+	return TRUE ;
+}
+
+void
+nomadikExaComposite (PixmapPtr         pDst,
+                     int       srcX,
+                     int        srcY,
+                     int        maskX,
+                     int        maskY,
+                     int        dstX,
+                     int        dstY,
+                     int        width,
+                     int        height)
+{
+    NomadikPriv *priv = NULL ;
+    int ret ;
+
+    priv = GetNomadikPriv(pDst->drawable.pScreen) ;
+    NOMADIK_RETURN_IF_FAIL (priv) ;
+
+    priv->CompositePrimitiveAdded = 1 ;
+    ret = SGALIB_Composite (priv->comp_handle, srcX, srcY, maskX, maskY, dstX, dstY, width, height) ;
+}
+
+void
+nomadikExaDoneComposite (PixmapPtr         pDst)
+{
+    NomadikPriv *priv = NULL ;
+
+    priv = GetNomadikPriv(pDst->drawable.pScreen) ;
+    if (priv->CompositePrimitiveAdded) {
+	SGALIB_DoneComposite(priv->comp_handle);
+    }
+    exaMarkSync(pDst->drawable.pScreen);
+}
+
+Bool
+nomadikExaUploadToScreen (PixmapPtr            pDst,
+                          int                  x,
+                          int                  y,
+                          int                  w,
+                          int                  h,
+                          char                 *src,
+                          int                  src_pitch)
+{
+	NomadikPriv *priv=NULL ;
+    int ret=0, bytesPerPixel=0, i ;
+    char *dest=NULL ;
+
+	if (noUploadToScreenAccel) {
+        	NOMADIK_LOG("-nouploadtoscreenaccel turned on. Unaccelerated\n") ;
+//        	NOMADIK_MLOG("-nouploadtoscreenaccel turned on. Unaccelerated\n") ;
+        	return FALSE ;
+    	}
+    priv = GetNomadikPriv(pDst->drawable.pScreen) ;
+    bytesPerPixel = pDst->drawable.bitsPerPixel >> 3;
+        dest = pDst->devPrivate.ptr + x * bytesPerPixel +
+               y * exaGetPixmapPitch(pDst);
+
+        NOMADIK_LOG("going to memcpy %d bytes from "
+                    "%#x, to %#x, bs:%d, bpp:%d\n",
+                    h*src_pitch, src, dest,
+                    exaGetPixmapPitch(pDst), bytesPerPixel) ;
+
+//        NOMADIK_MLOG("UtScr %d bytes\n", h*src_pitch) ;
+
+        for (i=0; i < h; i++) {
+            memcpy (dest + i*exaGetPixmapPitch(pDst),
+                    src + i*src_pitch,
+                    w*bytesPerPixel) ;
+        }
+
+	NOMADIK_LOG("mark\n") ;
+        return TRUE ;
+}
+
+Bool
+nomadikExaDownloadFromScreen (PixmapPtr pSrc,
+                              int x,  int y,
+                              int w,  int h,
+                              char *dst,
+                              int dst_pitch)
+{
+    NomadikPriv *priv=NULL ;
+    int ret=0, bytesPerPixel=0, i ;
+    char *src=NULL ;
+
+
+	NOMADIK_LOG("mark\n") ;
+    if (noDownloadFromScreenAccel) {
+        NOMADIK_LOG("-nodownloadfromscreenaccel turned on. Unaccelerated\n") ;
+//        NOMADIK_MLOG("-nodownloadfromscreenaccel turned on. Unaccelerated\n") ;
+        return FALSE ;
+    }
+
+    priv = GetNomadikPriv(pSrc->drawable.pScreen) ;
+    bytesPerPixel = pSrc->drawable.bitsPerPixel >> 3 ;
+
+        src = pSrc->devPrivate.ptr + x*bytesPerPixel +
+              y*exaGetPixmapPitch(pSrc) ;
+        NOMADIK_LOG("going to memcpy %d bytes from %#x, to %#x\n",
+               y*exaGetPixmapPitch(pSrc), src, dst) ;
+//	NOMADIK_MLOG("DfScr %d bytes\n",h*exaGetPixmapPitch(pSrc));
+
+        for (i=0; i<h; i++) {
+            memcpy (dst+i*dst_pitch,
+                    src+i*exaGetPixmapPitch(pSrc),
+                    w*bytesPerPixel) ;
+        }
+        return TRUE ;
+}
+
+Bool
+nomadikExaPrepareAccess (PixmapPtr pPix, int index)
+{
+    NOMADIK_LOG ("mark\n") ;
+    SGALIB_WaitMarker();
+    return TRUE;
+}
+
+void
+nomadikExaFinishAccess (PixmapPtr pPix, int index)
+{
+    NOMADIK_LOG ("mark\n") ;
+}
+
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-exa.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2007 ST Microelectronics
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *   Dodji Seketeli <dodji@openedhand.com>
+ */
+#ifndef _NOMADIKEXA_H_
+#define _NOMADIKEXA_H_
+
+#include "exa.h"
+
+/*************************************
+ * <acceleration init/fini routines>
+ **************************************/
+
+Bool
+nomadikExaInit(ScreenPtr pScreen) ;
+
+void
+nomadikExaEnable(ScreenPtr pScreen);
+
+void
+nomadikExaDisable(ScreenPtr pScreen);
+
+void
+nomadikExaFini(ScreenPtr pScreen);
+
+/*************************************
+ * </acceleration init/fini routines>
+ **************************************/
+
+/***********************************
+ * <exa acceleration calls>
+ ************************************/
+
+Bool
+nomadikExaPrepareSolid (PixmapPtr      pPixmap,
+                        int            alu,
+                        Pixel          planemask,
+                        Pixel          fg) ;
+
+void
+nomadikExaSolid (PixmapPtr      pPixmap,
+                 int            x1,
+                 int            y1,
+                 int            x2,
+                 int            y2);
+
+void
+nomadikExaDoneSolid (PixmapPtr      pPixmap);
+
+Bool
+nomadikExaPrepareCopy (PixmapPtr       pSrcPixmap,
+                       PixmapPtr       pDstPixmap,
+                       int             dx,
+                       int             dy,
+                       int             alu,
+                       Pixel           planemask);
+
+void
+nomadikExaCopy (PixmapPtr       pDstPixmap,
+                int             srcX,
+                int             srcY,
+                int             dstX,
+                int             dstY,
+                int             width,
+                int             height);
+
+void
+nomadikExaDoneCopy (PixmapPtr       pDstPixmap);
+
+Bool
+nomadikExaCheckComposite (int          op,
+                     PicturePtr   pSrcPicture,
+                     PicturePtr   pMaskPicture,
+                     PicturePtr   pDstPicture);
+
+Bool
+nomadikExaPrepareComposite (int                op,
+                       PicturePtr         pSrcPicture,
+                       PicturePtr         pMaskPicture,
+                       PicturePtr         pDstPicture,
+                       PixmapPtr          pSrc,
+                       PixmapPtr          pMask,
+                       PixmapPtr          pDst);
+
+void
+nomadikExaComposite (PixmapPtr         pDst,
+                     int       srcX,
+                     int        srcY,
+                     int        maskX,
+                     int        maskY,
+                     int        dstX,
+                     int        dstY,
+                     int        width,
+                     int        height);
+
+void
+nomadikExaDoneComposite (PixmapPtr         pDst);
+
+Bool
+nomadikExaUploadToScreen (PixmapPtr            pDst,
+                          int                  x,
+                          int                  y,
+                          int                  w,
+                          int                  h,
+                          char                 *src,
+                          int                  src_pitch);
+
+Bool
+nomadikExaDownloadFromScreen (PixmapPtr pSrc,
+                              int x,  int y,
+                              int w,  int h,
+                              char *dst,
+                              int dst_pitch);
+
+Bool
+nomadikExaPrepareAccess (PixmapPtr pPix, int index);
+
+void
+nomadikExaFinishAccess (PixmapPtr pPix, int index);
+
+void	nomadikExaWaitMarker(ScreenPtr pScreen, int marker);
+/***********************************
+ * </exa acceleration calls>
+ ************************************/
+
+#endif /*_NOMADIKEXA_H_*/
+
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-init.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2007 ST Microelectronics
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *   Dodji Seketeli <dodji@openedhand.com>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+#include <fbdev.h>
+#include "nomadik-exa.h"
+#include "nomadik-video.h"
+#include "nomadik-log.h"
+
+extern int use_evdev;
+extern Bool noCopyAccel ;
+extern Bool noCompositeAccel;
+extern Bool noSolidAccel;
+extern Bool noUploadToScreenAccel;
+extern Bool noDownloadFromScreenAccel;
+extern int accelCopyType ;
+extern int accelDownloadFromScreenType ;
+extern Bool showMemInfo ;
+Bool is2DAccel;
+
+void
+InitCard (char *name)
+{
+    KdCardAttr	attr;
+
+    KdCardInfoAdd (&fbdevFuncs, &attr, 0);
+}
+
+void
+InitOutput (ScreenInfo *pScreenInfo, int argc, char **argv)
+{
+    KdInitOutput (pScreenInfo, argc, argv);
+}
+
+void
+InitInput (int argc, char **argv)
+{
+    if (use_evdev)
+        KdInitInput (&LinuxEvdevMouseFuncs, &LinuxEvdevKeyboardFuncs);
+    else
+        KdInitInput (&LinuxMouseFuncs, &LinuxKeyboardFuncs);
+#ifdef TOUCHSCREEN
+    KdAddMouseDriver (&TsFuncs);
+#endif
+}
+
+void
+ddxUseMsg (void)
+{
+    KdUseMsg();
+    ErrorF("\nXnomadik device Usage:\n");
+    ErrorF("-fb path          Framebuffer device to use. Defaults to /dev/fb0\n");
+    ErrorF("-verbosity <num>  The messages verbosity level. 3 dumps a lot\n");
+    ErrorF("-noaccel          Disables 2D acceleration\n");
+    ErrorF("-xvideo           Disables xvideo acceleration\n");
+    ErrorF("-nocopyaccel      Disable the copy accel call\n");
+    ErrorF("-nosolidaccel     Disable the solid accel call\n");
+    ErrorF("-nocompositeaccel Disable the composite accel call\n");
+    ErrorF("-nouploadaccel    Disable the uploadtoscreen accel call\n");
+    ErrorF("-memcpycopy       use memcpy for the copy accel call\n");
+    ErrorF("-showmeminfo      show memory setup and exit\n");
+    ErrorF("\n");
+}
+
+int
+ddxProcessArgument (int argc, char **argv, int i)
+{
+    is2DAccel = TRUE;
+
+    if (!strcmp (argv[i], "-fb")) {
+        if (i+1 < argc) {
+            fbdevDevicePath = argv[i+1];
+            return 2;
+        }
+        UseMsg();
+        exit(1);
+    } else if (!strcmp(argv[i], "-verbosity")) {
+        if (i+1 < argc && isdigit(argv[i+1][0])) {
+            int verbosity = atoi (argv[i+1]) ;
+            LogSetParameter(XLOG_VERBOSITY, verbosity) ;
+            LogMessage (X_INFO, "verbosity set to %d\n", verbosity) ;
+            return 2 ;
+        }
+        UseMsg();
+        exit(1) ;
+    } else if (!strcmp (argv[i], "-noaccel")) {
+        is2DAccel = FALSE;
+        fbdevFuncs.initAccel = NULL ;
+        fbdevFuncs.enableAccel = NULL ;
+        fbdevFuncs.disableAccel = NULL ;
+        fbdevFuncs.finiAccel = NULL ;
+        return 1 ;
+    } else if (!strcmp (argv[i], "-noxvideo")) {
+        fbdevFuncs.initScreen = fbdevInitScreen ;
+        return 1 ;
+    } else if (!strcmp (argv[i], "-nocopyaccel")) {
+        noCopyAccel = TRUE ;
+        return 1 ;
+    } else if (!strcmp (argv[i], "-memcpycopy")) {
+        accelCopyType = 1 ;
+        return 1 ;
+    }  else if (!strcmp (argv[i], "-memcpydownload")) {
+        accelDownloadFromScreenType = 1 ;
+        return 1 ;
+    } else if (!strcmp (argv[i], "-nocompositeaccel")) {
+        noCompositeAccel = TRUE ;
+        return 1 ;
+    }else if (!strcmp (argv[i], "-nosolidaccel")) {
+        noSolidAccel = TRUE ;
+        return 1 ;
+    }else if (!strcmp (argv[i], "-nouploadaccel")) {
+        noUploadToScreenAccel = TRUE ;
+        return 1 ;
+    }else if (!strcmp (argv[i], "-nodownloadaccel")) {
+        noDownloadFromScreenAccel = TRUE ;
+        return 1 ;
+    } else if (!strcmp (argv[i], "-showmeminfo")) {
+        showMemInfo = TRUE ;
+        return 1 ;
+    }
+
+    return KdProcessArgument (argc, argv, i);
+}
+
+static Bool
+nomadikInitScreen (ScreenPtr pScreen)
+{
+    NOMADIK_LOG ("enter\n") ;
+    fbdevInitScreen (pScreen) ;
+#ifdef XV
+    NOMADIK_LOG ("going to initialized xvideo\n") ;
+    if (!nomadikInitVideo (pScreen, is2DAccel)) {
+        NOMADIK_LOG_ERROR ("failed to initialise xvideo\n") ;
+    } else {
+        NOMADIK_LOG ("Initialized xvideo okay\n") ;
+    }
+#endif
+    NOMADIK_LOG ("leave\n") ;
+    return TRUE ;
+}
+
+KdCardFuncs	fbdevFuncs = {
+    fbdevCardInit,	    /* cardinit */
+    fbdevScreenInit,	    /* scrinit */
+    nomadikInitScreen,	    /* initScreen */
+    fbdevFinishInitScreen,  /* finishInitScreen */
+    fbdevCreateResources,   /* createRes */
+    fbdevPreserve,	    /* preserve */
+    fbdevEnable,	    /* enable */
+    fbdevDPMS,		    /* dpms */
+    fbdevDisable,	    /* disable */
+    fbdevRestore,	    /* restore */
+    fbdevScreenFini,	    /* scrfini */
+    fbdevCardFini,	    /* cardfini */
+
+    0,			    /* initCursor */
+    0,			    /* enableCursor */
+    0,			    /* disableCursor */
+    0,			    /* finiCursor */
+    0,			    /* recolorCursor */
+
+    nomadikExaInit,         /* initAccel */
+    nomadikExaEnable,	    /* enableAccel */
+    nomadikExaDisable,	    /* disableAccel */
+    nomadikExaFini,	    /* finiAccel */
+
+    fbdevGetColors,    	    /* getColors */
+    fbdevPutColors,	    /* putColors */
+};
+
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-log.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2007 ST Microelectronics
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *   Dodji Seketeli <dodji@openedhand.com>
+ */
+#ifndef _NOMADIK_LOG_H_
+#define _NOMADIK_LOG_H_
+#include <assert.h>
+#include "os.h"
+
+#ifdef NDEBUG
+/*we are not in debug mode*/
+#define NOMADIK_LOG
+#define NOMADIK_LOG_ERROR
+#endif /*NDEBUG*/
+
+#define ERROR_LOG_LEVEL 3
+#define INFO_LOG_LEVEL 4
+#define M_LOG_LEVEL 3
+
+#ifndef NOMADIK_MLOG
+#define NOMADIK_MLOG(...) \
+LogMessageVerb(X_NOTICE, M_LOG_LEVEL, __VA_ARGS__)
+#endif /*nomadik_mlog*/
+
+#ifndef NOMADIK_LOG
+#define NOMADIK_LOG(...) \
+LogMessageVerb(X_NOTICE, INFO_LOG_LEVEL, "in %s:%d:%s: ",\
+               __FILE__, __LINE__, __func__) ; \
+LogMessageVerb(X_NOTICE, INFO_LOG_LEVEL, __VA_ARGS__)
+#endif /*nomadik_log*/
+
+#ifndef NOMADIK_LOG_ERROR
+#define NOMADIK_LOG_ERROR(...) \
+LogMessageVerb(X_NOTICE, ERROR_LOG_LEVEL, "Error:in %s:%d:%s: ",\
+               __FILE__, __LINE__, __func__) ; \
+LogMessageVerb(X_NOTICE, ERROR_LOG_LEVEL, __VA_ARGS__)
+#endif /*NOMADIK_LOG_ERROR*/
+
+#ifndef NOMADIK_RETURN_IF_FAIL
+#define NOMADIK_RETURN_IF_FAIL(cond) \
+if (!(cond)) {NOMADIK_LOG_ERROR("condition %s failed\n", #cond);return;}
+#endif /*nomadik_return_if_fail*/
+
+#ifndef NOMADIK_RETURN_VAL_IF_FAIL
+#define NOMADIK_RETURN_VAL_IF_FAIL(cond,val) \
+if (!(cond)) {NOMADIK_LOG_ERROR("condition %s failed\n", #cond);return val;}
+#endif /*nomadik_return_val_if_fail*/
+#endif /* _NOMADIK_LOG_H_*/
+
+
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-sva.c
@@ -0,0 +1,626 @@
+/*
+ * Copyright ST Microelectronics.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Dodji Seketeli <dodji@openedhand.com>
+ */
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include "nomadik-sva.h"
+#include "nomadik-log.h"
+
+struct sva_t*
+svaNew ()
+{
+    struct sva_t *result = NULL ;
+    result = calloc (1, sizeof (struct sva_t)) ;
+/* if sva is opened here the sva driver cannot be rmmod
+    if (!svaOpenDevice (result)) {
+        NOMADIK_LOG_ERROR ("failed to open sva device\n") ;
+        goto error ;
+    }
+*/
+    if (!svaPostProcConfigInit (&result->post_proc_config, NULL)) {
+        NOMADIK_LOG_ERROR ("failed to init post_proc_config\n") ;
+        goto error ;
+    }
+    return result ;
+
+error:
+
+    if (result) {
+        svaDelete (result) ;
+        result = NULL ;
+    }
+    return NULL ;
+}
+
+Bool
+svaOpenDevice (struct sva_t *a_sva)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_sva, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (!a_sva->fd,  FALSE) ;
+
+    NOMADIK_LOG ("enter: sva:%#x\n", a_sva) ;
+    a_sva->fd = open ("/dev/sva", O_RDWR) ;
+    if (a_sva->fd <0) {
+        NOMADIK_LOG_ERROR ("failed to open /dev/sva\n") ;
+        return FALSE ;
+    }
+    NOMADIK_LOG ("/dev/sva opened okay: %d\n", a_sva->fd) ;
+    return TRUE ;
+}
+
+Bool
+svaCloseDevice (struct sva_t *a_sva)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_sva, FALSE) ;
+
+    NOMADIK_LOG ("enter: sva:%#x\n", a_sva) ;
+
+    if (a_sva->fd) {
+        close (a_sva->fd) ;
+        a_sva->fd = 0 ;
+    }
+    NOMADIK_LOG ("leave: sva:%#x\n", a_sva) ;
+    return TRUE ;
+}
+
+void
+svaDelete (struct sva_t *a_sva)
+{
+    NOMADIK_LOG("enter: sva:%#x\n", a_sva) ;
+
+    if (!a_sva)
+        return ;
+/*  see open ::open is not done so no close
+    svaCloseDevice (a_sva) ;
+*/
+    NOMADIK_LOG("leave: sva:%#x\n", a_sva) ;
+}
+
+struct sva_buffer_t*
+svaBufferNew (struct sva_t *a_sva,
+              enum sva_buffer_type a_type,
+              unsigned a_size)
+{
+    struct sva_buffer_t *result=NULL ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_sva && a_sva->fd, NULL) ;
+
+    NOMADIK_LOG ("enter: sva:%#x\n", a_sva) ;
+
+    NOMADIK_LOG ("going to allocate buffer.size: %d, type: %d\n",
+                 a_size, a_type) ;
+
+    result = calloc (1, sizeof (struct sva_buffer_t)) ;
+    result->kernel_buf.type = a_type ;
+    result->kernel_buf.size = a_size ;
+
+    NOMADIK_LOG ("sva->fd: %d\n", a_sva->fd) ;
+    if (ioctl (a_sva->fd, SVA_ALLOCATE_BUFFER, &result->kernel_buf)) {
+        NOMADIK_LOG_ERROR ("failed to ioctl(SVA_ALLOCATE_BUFFER\n)") ;
+        goto error;
+    }
+    NOMADIK_LOG ("buffer got allocated: id:%d\n",
+                 result->kernel_buf.buffer_id) ;
+    result->data = mmap (NULL,
+                         result->kernel_buf.length,
+                         PROT_READ|PROT_WRITE,
+                         MAP_SHARED,
+                         a_sva->fd,
+                         result->kernel_buf.offset) ;
+    if (result->data == (int*) MAP_FAILED) {
+        NOMADIK_LOG_ERROR ("mmap failed\n") ;
+        goto error ;
+    }
+    result->len = result->kernel_buf.length ;
+    memset (result->data, 0, result->len) ;
+    NOMADIK_LOG ("buffer got mmaped: data:%#x\n", result->data) ;
+    return result ;
+
+error:
+    if (result) {
+        svaBufferDelete (a_sva, result) ;
+        result = NULL ;
+    }
+    return NULL ;
+}
+
+void
+svaBufferDelete (struct sva_t *a_sva,
+                 struct sva_buffer_t *a_buffer)
+{
+    if (!a_buffer)
+        return ;
+
+    NOMADIK_RETURN_IF_FAIL (a_sva) ;
+
+    NOMADIK_LOG ("enter: sva:%#x, buffer: %#x\n"
+                 "buffer.data:%#x, buffer.len: %#x, id:%d\n",
+                 a_sva, a_buffer, a_buffer->data,
+                 a_buffer->len, a_buffer->kernel_buf.buffer_id) ;
+
+    if (a_buffer->data) {
+        if (munmap (a_buffer->data, a_buffer->len)) {
+            NOMADIK_LOG_ERROR ("failed to unmap: %d, ", errno) ;
+            perror (NULL) ;
+        }
+        a_buffer->data = NULL ;
+    }
+    NOMADIK_LOG ("sva->fd: %d\n", a_sva->fd) ;
+    if (ioctl (a_sva->fd, SVA_DEALLOCATE_BUFFER,
+               &a_buffer->kernel_buf.buffer_id)) {
+        NOMADIK_LOG_ERROR ("ioctl(SVA_DEALLOCATE_BUFFER) failed: %d\n", errno) ;
+        perror (NULL) ;
+        return ;
+    }
+    NOMADIK_LOG("buffer got deleted\n") ;
+}
+
+
+struct sva_service_struct*
+svaPostProcServiceNew (struct sva_t *a_sva,
+                       struct sva_non_size_params_t a_params,
+                       enum fourcc_yuv_format_t a_color_format,
+                       int a_src_width,
+                       int a_src_height,
+                       int a_src_x,
+                       int a_src_y,
+                       int a_src_crop_width,
+                       int a_src_crop_height,
+                       int a_dest_x,
+                       int a_dest_y,
+                       int a_dest_width,
+                       int a_dest_height,
+                       BoxRec a_dst_clip,
+                       int a_dest_screen_width,
+                       int a_dest_screen_height,
+                       Bool a_yuvpl_buff_id_enable)
+{
+    struct sva_service_struct *service=NULL ;
+    struct sva_control_service service_control ;
+    int dst_clip_w, dst_clip_h ;
+
+    /*round everything to 2 otherwise SVA won't work*/
+    a_src_width = (a_src_width + 1) & ~1 ;
+    a_src_height =  (a_src_height + 1) & ~1 ;
+    a_src_x = (a_src_x + 1) & ~1 ;
+    a_src_y = (a_src_y + 1) & ~1 ;
+    a_src_crop_width = (a_src_crop_width + 1) & ~1 ;
+    a_src_crop_height= (a_src_crop_height + 1) & ~1 ;
+    a_dest_x = (a_dest_x + 1) & ~1 ;
+    a_dest_y = (a_dest_y + 1) & ~1 ;
+    a_dest_width = (a_dest_width + 1) & ~1 ;
+    a_dest_height = (a_dest_height + 1) & ~1 ;
+    a_dst_clip.x1 = (a_dst_clip.x1 + 1) & ~1 ;
+    a_dst_clip.x2 = (a_dst_clip.x2 + 1) & ~1 ;
+    a_dst_clip.y1 = (a_dst_clip.y1 + 1) & ~1 ;
+    a_dst_clip.y2 = (a_dst_clip.y2 + 1) & ~1 ;
+
+    NOMADIK_LOG ("enter: src_w: %d, src_h:%d, src_x:%d, src_y:%d\n"
+                 "src_crop_width:%d, src_crop_height:%d\n"
+                 "dest_x:%d, dest_y:%d, dest_width:%d, dest_height:%d\n"
+                 "screen_width:%d, screen_height:%d\n",
+                 a_src_width, a_src_height, a_src_x, a_src_y,
+                 a_src_crop_width, a_src_crop_height,
+                 a_dest_x, a_dest_y, a_dest_width, a_dest_height,
+                 a_dest_screen_width, a_dest_screen_height) ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_sva && a_sva->fd, FALSE) ;
+
+    a_sva->post_proc_config.brightness = a_params.brightness ;
+    a_sva->post_proc_config.contrast = a_params.contrast ;
+    a_sva->post_proc_config.dithering = a_params.dithering;
+    a_sva->post_proc_config.depth = a_params.color_depth ;
+    a_sva->post_proc_config.chroma_sampling = a_params.chroma_sampling_format ;
+    a_sva->post_proc_config.red_blue_swap = a_params.red_blue_swap ;
+    a_sva->post_proc_config.alpha_key = a_params.alpha_key ;
+
+    switch (a_color_format) {
+        case YUV_FOURCC_YV12: /*YUV 4:2:0 planar*/
+        case YUV_FOURCC_I420: /*YUV 4:2:0 planar*/
+            a_sva->post_proc_config.capability =
+                                POSTPROCESSOR_YUV420PL_TO_RGB;
+            break ;
+        case YUV_ST_420_MACRO_BLOCK_OPTIMIZED: /*YUV 4:2:0 macro block*/
+        case YUV_ST_420_MACRO_BLOCK_NON_OPTIMIZED: /*YUV 4:2:0 macro block*/
+            if(a_yuvpl_buff_id_enable==TRUE) {
+                a_sva->post_proc_config.capability =
+                                POSTPROCESSOR_YUV420PL_TO_RGB;
+            } else {
+            a_sva->post_proc_config.capability =
+                                POSTPROCESSOR_YUV420MB_TO_RGB;
+            }
+            break ;
+        case YUV_FOURCC_YV16: /*YUV 4:2:2 planar*/
+            a_sva->post_proc_config.capability =
+                                POSTPROCESSOR_YUV422PL_TO_RGB;
+            break ;
+        default:
+            NOMADIK_LOG_ERROR ("unsupported color format:%d\n",a_color_format) ;
+            goto error ;
+    }
+
+    a_sva->post_proc_config.source_frame.width = a_src_width ;
+    a_sva->post_proc_config.source_frame.height = a_src_height ;
+
+    a_sva->post_proc_config.cropped_window.offset.x_offset = a_src_x ;
+    a_sva->post_proc_config.cropped_window.offset.y_offset = a_src_y ;
+    a_sva->post_proc_config.cropped_window.frame.width = a_src_crop_width ;
+    a_sva->post_proc_config.cropped_window.frame.height = a_src_crop_height ;
+
+    a_sva->post_proc_config.resized_frame.width = a_dest_width ;
+    a_sva->post_proc_config.resized_frame.height = a_dest_height ;
+
+    a_sva->post_proc_config.clipped_window.offset.x_offset = 0 ;
+    a_sva->post_proc_config.clipped_window.offset.y_offset = 0 ;
+    dst_clip_w = abs (a_dst_clip.x2 - a_dst_clip.x1) ;
+    dst_clip_h = abs (a_dst_clip.y2 - a_dst_clip.y1) ;
+
+    /* multiple clip region will take care of the clipping less than src size */
+    if((a_src_width==a_dest_width) && (a_src_height == a_dest_height)) {
+        if(dst_clip_w < a_src_width) dst_clip_w = a_src_width;
+        if(dst_clip_h < a_src_height) dst_clip_h = a_src_height;
+    }
+
+    a_sva->post_proc_config.clipped_window.frame.width = dst_clip_w ;
+    a_sva->post_proc_config.clipped_window.frame.height = dst_clip_h ;
+
+    a_sva->post_proc_config.display_window.offset.x_offset = a_dst_clip.x1 ;
+    a_sva->post_proc_config.display_window.offset.y_offset = a_dst_clip.y1 ;
+    a_sva->post_proc_config.display_window.frame.width =  a_dest_screen_width;
+    a_sva->post_proc_config.display_window.frame.height = a_dest_screen_height;
+
+    service = calloc (1, sizeof (struct sva_service_struct)) ;
+    if (!service) {
+        NOMADIK_LOG_ERROR ("failed to allocated sva service\n") ;
+        goto error ;
+    }
+    service->service_type = POSTPROCESSOR ;
+    service->mode = REALTIME ;
+    service->config.postprocessor_configuration = a_sva->post_proc_config;
+
+    NOMADIK_LOG ("sva->fd: %d\n", a_sva->fd) ;
+    if (ioctl (a_sva->fd, SVA_CREATE_SERVICE, service)) {
+        NOMADIK_LOG_ERROR ("failed to ioctl (SVA_CREATE_SERVICE): %d\n",
+                           errno) ;
+        perror (NULL) ;
+
+    NOMADIK_LOG_ERROR ("enter: src_w: %d, src_h:%d, src_x:%d, src_y:%d\n"
+                 "src_crop_width:%d, src_crop_height:%d\n"
+                 "dest_x:%d, dest_y:%d, dest_width:%d, dest_height:%d\n"
+                 "screen_width:%d, screen_height:%d  "
+                 "x1:%d,  x2:%d, y1:%d, y2:%d\n",
+                 a_src_width, a_src_height, a_src_x, a_src_y,
+                 a_src_crop_width, a_src_crop_height,
+                 a_dest_x, a_dest_y, a_dest_width, a_dest_height,
+                 a_dest_screen_width, a_dest_screen_height,
+                 a_dst_clip.x1, a_dst_clip.x2, a_dst_clip.y1, a_dst_clip.y2);
+
+
+        goto error;
+    }
+    NOMADIK_LOG ("created service id: %d\n", service->service_id) ;
+
+    /*start the display service*/
+    service_control.service_id = service->service_id ;
+    service_control.command = SERVICE_START;
+    if(ioctl (a_sva->fd, SVA_CONTROL_SERVICE, &service_control)) {
+        NOMADIK_LOG_ERROR ("failed to start post proc service\n") ;
+        goto error ;
+    }
+
+    return service ;
+
+error:
+    if (service) {
+        free (service) ;
+    }
+    NOMADIK_LOG ("leave\n") ;
+    return NULL ;
+}
+
+void
+svaPostProcServiceDelete (struct sva_t *a_sva,
+                          struct sva_service_struct *a_service)
+{
+    if (!a_service)
+        return ;
+
+    NOMADIK_RETURN_IF_FAIL (a_sva && a_sva->fd) ;
+
+    if (a_service->service_id) {
+        if (ioctl (a_sva->fd, SVA_DELETE_SERVICE, a_service)) {
+            NOMADIK_LOG_ERROR ("failed to delete post proc service\n") ;
+        } else {
+            NOMADIK_LOG ("deleted post proc service. id was %d",
+                 a_service->service_id);
+        }
+    }
+    free (a_service) ;
+    NOMADIK_LOG("service deleted\n") ;
+}
+
+Bool
+svaPostProcConfigInit (struct sva_postprocessor_configuration *a_conf,
+                       struct sva_non_size_params_t *a_params)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_conf, FALSE) ;
+
+    memset (a_conf, 0, sizeof (struct sva_postprocessor_configuration)) ;
+    if (a_params) {
+        a_conf->depth = a_params->color_depth ;
+        a_conf->brightness = a_params->brightness ;
+        a_conf->contrast = a_params->contrast ;
+        a_conf->alpha_key = a_params->alpha_key;
+        a_conf->red_blue_swap = a_params->red_blue_swap;
+        a_conf->chroma_sampling = a_params->chroma_sampling_format ;
+    } else {
+        a_conf->depth = BITS_15 ;
+        a_conf->brightness = 50 ;
+        a_conf->contrast = 50 ;
+        a_conf->alpha_key = 0 ;
+        a_conf->red_blue_swap = 0 ;
+        a_conf->chroma_sampling = DEFAULT_SAMPLING_FORMAT ;
+    }
+    a_conf->capability = POSTPROCESSOR_YUV420PL_TO_RGB ;
+    a_conf->direct_display = TRUE ;
+    a_conf->matrix.matrix_coef1 = 204;
+    a_conf->matrix.matrix_coef2 = -50;
+    a_conf->matrix.matrix_coef3 = -104;
+    a_conf->matrix.matrix_coef4 = 258;
+    a_conf->output_range = FULL_RANGE ;
+    a_conf->ace_mode = ACE_DISABLE ;
+    a_conf->ace_strength = ACE_STRENGTH_4 ; /*useless because ace is disabled*/
+    a_conf->ace_range = FULL_RANGE ;
+    a_conf->mirroring = NO_MIRRORING ;
+    a_conf->rotation = NO_ROTATION ;
+    a_conf->dithering = TRUE ;
+    a_conf->deblocking_filter = NONE_DEBLOCKING_FILTER ;
+    a_conf->deringing_filter = NONE_DERINGING_FILTER ;
+
+    NOMADIK_LOG("initialized post proc config\n") ;
+
+    return TRUE ;
+}
+
+Bool
+svaPushBufferToService (struct sva_t *a_sva,
+                        struct sva_service_struct *a_service,
+                        struct sva_buffer_t *a_buffer)
+{
+
+    return svaPushBufferFromIDToService (a_sva, a_service,
+                                         a_buffer->kernel_buf.buffer_id,
+                                         0, /*timestamp*/
+                                         FALSE, /*buffer shared*/
+                                         0, /*sharing index. useless because not shared*/
+                                         a_buffer->kernel_buf.type) ;
+}
+
+Bool
+svaPushBufferFromIDToService (struct sva_t *a_sva,
+                              struct sva_service_struct *a_service,
+                              unsigned int a_buffer_id,
+                              unsigned int a_timestamp,
+                              Bool a_shared,
+                              unsigned int a_sharing_index,
+                              enum sva_buffer_type a_type)
+{
+    int res=0, count=0 ;
+    struct sva_queue_buffer queue_buffer ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_sva && a_sva->fd, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_service, FALSE) ;
+
+    queue_buffer.service_id = a_service->service_id ;
+    queue_buffer.buffer.buffer_id = a_buffer_id ;
+    queue_buffer.buffer.shared = a_shared ;
+    if (queue_buffer.buffer.shared) {
+        queue_buffer.buffer.index = a_sharing_index ;
+    }
+    queue_buffer.buffer.type = a_type ;
+    queue_buffer.block = BLOCK ;
+    queue_buffer.buffer.timestamp = a_timestamp;
+    queue_buffer.push = PUSH_IN ;
+    NOMADIK_LOG("going to queue idx:%d, buffer id:%d, tst:%d serv_id:%d\n",
+                 queue_buffer.buffer.index,
+                 queue_buffer.buffer.buffer_id,
+                 queue_buffer.buffer.timestamp,
+                 queue_buffer.service_id) ;
+
+    res = ioctl (a_sva->fd, SVA_QUEUE_BUFFER, &queue_buffer) ;
+    if (res) {
+        NOMADIK_LOG_ERROR ("failed to queue buffer\n") ;
+        /* in case of buffer-id sharing let us not return error
+	 * since there are chances where same buffer-id is pushed twice
+	 * but this will not affect the playback
+	 * Anyhow in serious case we need to enable the print and debug */
+	if(a_shared) {
+            return TRUE ;
+        } else {
+            perror (NULL) ;
+            return FALSE ;
+        }
+    }
+
+    queue_buffer.service_id = a_service->service_id ;
+    queue_buffer.buffer.type = a_type ;
+    queue_buffer.block = BLOCK ;
+    queue_buffer.push = PUSH_IN ;
+
+    NOMADIK_LOG ("queued buffer to service\n") ;
+    res = ioctl (a_sva->fd, SVA_DEQUEUE_BUFFER, &queue_buffer) ;
+    while (res && errno == EINTR) {
+        res = ioctl (a_sva->fd, SVA_DEQUEUE_BUFFER, &queue_buffer) ;
+        /* trying for 5 times and then returing otherwise playback freezes */
+        if(count++ > 5) break;
+    }
+    if (res) {
+        NOMADIK_LOG_ERROR ("failed to dequeue buffer:%d\n", errno) ;
+        perror (NULL) ;
+        return FALSE ;
+    }
+    NOMADIK_LOG ("dequeued buffer from service\n") ;
+
+    return TRUE ;
+}
+
+
+Bool
+svaRemovePPPTile (struct sva_t *a_sva,
+                                        struct sva_service_struct *a_service)
+{
+    struct sva_update_service update_service;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_sva && a_sva->fd, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_service, FALSE) ;
+
+    update_service.service_id = a_service->service_id;
+    update_service.param = POSTPROCESSOR_TILE;
+    update_service.type = UPDATE_LAST;
+    update_service.value = NULL;
+
+    if(ioctl(a_sva->fd,SVA_UPDATE_SERVICE,&update_service)) {
+        NOMADIK_LOG_ERROR ("failed to enable PPP tile:%d\n", errno) ;
+        perror(NULL);
+        return FALSE;
+    }
+
+    NOMADIK_LOG ("updated the PPP tile\n") ;
+    return TRUE ;
+}
+
+
+Bool
+svaUpdatePPPTile (struct sva_t *a_sva,
+                                      struct sva_service_struct *a_service,
+                                      struct sva_ppp_tile_info *a_ppp_tile_ptr)
+{
+    struct sva_update_service update_service;
+    struct sva_ppp_tile_info *next = a_ppp_tile_ptr;
+    int i=0;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_sva && a_sva->fd, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_service, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_ppp_tile_ptr, FALSE) ;
+
+    update_service.service_id = a_service->service_id;
+    update_service.param = POSTPROCESSOR_TILE;
+    update_service.type = UPDATE_LAST;
+    update_service.value = a_ppp_tile_ptr;
+
+    NOMADIK_MLOG("In svaUpdatePPPTile: %x\n", a_ppp_tile_ptr);
+    for(i=0; ;i++) {
+
+            NOMADIK_MLOG("ppp tile: %d:\n"
+               "x_off:%d, y_off:%d, "
+                "h:%d, w:%d\n", i,
+                next->offset.x_offset ,
+                next->offset.y_offset,
+                next->image.height,
+                next->image.width) ;
+
+        if(next->next_tile)
+            next=next->next_tile;
+        else
+            break;
+    }
+
+    if(ioctl(a_sva->fd,SVA_UPDATE_SERVICE,&update_service)) {
+        NOMADIK_LOG_ERROR ("failed to enable PPP tile:%d\n", errno) ;
+        perror(NULL);
+       return FALSE;
+    }
+
+    NOMADIK_LOG ("updated the PPP tile\n") ;
+    return TRUE ;
+}
+
+Bool
+computeYUVImageSize (enum fourcc_yuv_format_t a_yuv_format,
+                     unsigned a_width,
+                     unsigned a_height,
+                     unsigned *a_len)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_len, FALSE) ;
+
+    switch (a_yuv_format) {
+        case YUV_FOURCC_YV12: /*YUV 4:2:0 planar*/
+        case YUV_FOURCC_I420: /*YUV 4:2:0 planar*/
+        case YUV_ST_420_MACRO_BLOCK_OPTIMIZED: /*YUV 4:2:0 macro block*/
+        case YUV_ST_420_MACRO_BLOCK_NON_OPTIMIZED: /*YUV 4:2:0 macro block*/
+            *a_len = 3*a_width*a_height/2 ;
+            break ;
+        case YUV_FOURCC_YV16: /*YUV 4:2:2 planar*/
+            *a_len = 3*a_width*a_height;
+            break ;
+        default:
+            NOMADIK_LOG_ERROR ("unsupported format: %#x\n", a_yuv_format) ;
+            return FALSE ;
+    }
+    return TRUE ;
+}
+
+Bool
+readYUVMBFrameDescFromBuf (const char *a_buf,
+                           struct st_yuvmb_frame_desc_t *a_desc)
+{
+    char *cur = (char*)a_buf ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_buf, FALSE) ;
+
+    /*
+     * content of a_buf is in big endian
+     * so memcpying it should be fine.
+     */
+    memcpy (&a_desc->buffer_index, cur, sizeof (a_desc->buffer_index)) ;
+    cur+= sizeof (a_desc->buffer_index);
+    memcpy (&a_desc->buffer_id, cur, sizeof (a_desc->buffer_id)) ;
+    cur+= sizeof (a_desc->buffer_id) ;
+    memcpy (&a_desc->timestamp, cur, sizeof (a_desc->timestamp)) ;
+
+    return TRUE ;
+}
+
+Bool
+colorFormatMatchesPPCapability (enum fourcc_yuv_format_t a_color_format,
+                                enum postprocessor_capability a_cap)
+{
+    if ((a_color_format == YUV_FOURCC_YV12 && a_cap  == POSTPROCESSOR_YUV420PL_TO_RGB) ||
+         (a_color_format == YUV_FOURCC_I420 && a_cap  == POSTPROCESSOR_YUV420PL_TO_RGB) ||
+        (a_color_format == YUV_FOURCC_YV16 && a_cap == POSTPROCESSOR_YUV422PL_TO_RGB)  ||
+        (a_color_format == YUV_ST_420_MACRO_BLOCK_NON_OPTIMIZED
+           && a_cap == POSTPROCESSOR_YUV420MB_TO_RGB) ||
+        (a_color_format == YUV_ST_420_MACRO_BLOCK_OPTIMIZED
+           && a_cap == POSTPROCESSOR_YUV420MB_TO_RGB) ||
+        (a_color_format == YUV_ST_420_MACRO_BLOCK_OPTIMIZED
+           && a_cap == POSTPROCESSOR_YUV420PL_TO_RGB) ) {
+        return TRUE ;
+    }
+    return FALSE ;
+}
+
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-sva.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright ST Microelectronics.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Dodji Seketeli <dodji@openedhand.com>
+ */
+#ifndef __NOMADIK_SVA_H__
+#define __NOMADIK_SVA_H__
+#include <stdint.h>
+#include "region.h"
+#include "nomadik_sva_services.h"
+
+#define GUID_I420_PLANAR 0x30323449
+#define GUID_YV12_PLANAR 0x32315659 /*YUV 4:2:0 planar*/
+#define GUID_YV16_PLANAR 0x36315659 /*YUV 4:2:2 planar*/
+
+ /*
+  * proprietary code for ST MB, optimized.
+  * when XVideo receives a frame buffer with
+  * this code, it considers the frame buffer
+  * to contain the id of an in-kernel buffer
+  * that actually contains the yuv frame.
+  * XVideo then pushes the buffer ID to SVA,
+  * saving a couple of memcpy like that ...
+  */
+#define GUID_ST_YUV420_MACRO_BLOCK 0x424D5559
+ /*
+  * proprietary code for ST MB, non optimized.
+  * when XVideo receives a frame buffer with
+  * this code, it really considers that the frame
+  * contains an image in a YUVMB format.
+  * So it is the same as above, but non optimised.
+  */
+#define GUID_ST_YUV420_MACRO_BLOCK2 0x424D5453
+
+enum fourcc_yuv_format_t {
+    YUV_FOURCC_UNDEF=0,
+    YUV_FOURCC_YV12=GUID_YV12_PLANAR, /*YUV 4:2:0 planar*/
+    YUV_FOURCC_I420=GUID_I420_PLANAR, /*YUV 4:2:0 planar*/
+    YUV_FOURCC_YV16=GUID_YV16_PLANAR, /*YUV 4:2:2 planar*/
+    YUV_ST_420_MACRO_BLOCK_OPTIMIZED=GUID_ST_YUV420_MACRO_BLOCK,     /*yuv 4:2:0 MB*/
+    YUV_ST_420_MACRO_BLOCK_NON_OPTIMIZED=GUID_ST_YUV420_MACRO_BLOCK2 /*yuv 4:2:0 MB*/
+};
+
+#define XVIMAGE_YUMB \
+   { \
+        YUV_ST_420_MACRO_BLOCK_OPTIMIZED, \
+        XvYUV, \
+        LSBFirst, \
+        {'Y','U','M','B', \
+          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+        12, \
+        XvPacked, \
+        3, \
+        0, 0, 0, 0, \
+        8, 8, 8, \
+        1, 2, 2, \
+        1, 2, 2, \
+        {'Y','V','U', \
+          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+        XvTopToBottom \
+   }
+
+#define XVIMAGE_STMB \
+   { \
+        YUV_ST_420_MACRO_BLOCK_NON_OPTIMIZED, \
+        XvYUV, \
+        LSBFirst, \
+        {'S','T','M','B', \
+          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+        12, \
+        XvPacked, \
+        3, \
+        0, 0, 0, 0, \
+        8, 8, 8, \
+        1, 2, 2, \
+        1, 2, 2, \
+        {'Y','V','U', \
+          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+        XvTopToBottom \
+   }
+
+struct sva_t {
+    int fd ;
+    struct sva_postprocessor_configuration post_proc_config ;
+};
+
+struct sva_buffer_t {
+    struct sva_buffer kernel_buf ; /*buffer in kernel space*/
+    void *data ; /*mmap'ed buffer in user space*/
+    unsigned len ; /*lenght of mmap'ed buffer*/
+};
+
+struct sva_non_size_params_t {
+    unsigned char brightness ;
+    unsigned char contrast;
+    Bool dithering;
+    enum sva_color_depth color_depth ;
+    enum sva_chroma_sampling_format chroma_sampling_format ;
+    unsigned char red_blue_swap ;
+    unsigned char alpha_key ;
+};
+
+struct st_yuvmb_frame_desc_t {
+    uint32_t buffer_index ;
+    uint32_t buffer_id ;
+    uint32_t timestamp ;
+};
+
+Bool svaPostProcConfigInit
+                            (struct sva_postprocessor_configuration *a_conf,
+                             struct sva_non_size_params_t *a_params);
+struct sva_t* svaNew () ;
+Bool svaOpenDevice (struct sva_t *a_sva) ;
+Bool svaCloseDevice (struct sva_t *a_sva) ;
+void svaDelete (struct sva_t *a_sva) ;
+struct sva_buffer_t* svaBufferNew (struct sva_t *a_sva,
+                                   enum sva_buffer_type a_type,
+                                   unsigned a_size) ;
+void svaBufferDelete (struct sva_t *a_sva,
+                      struct sva_buffer_t *a_buffer) ;
+
+struct sva_service_struct* svaPostProcServiceNew
+                                     (struct sva_t *a_sva,
+                                      struct sva_non_size_params_t a_params,
+                                      enum fourcc_yuv_format_t a_color_fmt,
+                                      int a_src_width,
+                                      int a_src_height,
+                                      int a_src_x,
+                                      int a_src_y,
+                                      int a_src_crop_width,
+                                      int a_src_crop_height,
+                                      int a_dest_x,
+                                      int a_dest_y,
+                                      int a_dest_width,
+                                      int a_dest_height,
+                                      BoxRec a_dst_clip,
+                                      int a_dest_screen_width,
+                                      int a_dest_screen_height,
+                                      Bool a_yuvpl_buff_id_enable) ;
+
+void svaPostProcServiceDelete (struct sva_t *a_sva,
+                               struct sva_service_struct *a_service) ;
+
+Bool svaPushBufferToService (struct sva_t *sva,
+                             struct sva_service_struct *a_service,
+                             struct sva_buffer_t *a_buffer) ;
+
+Bool svaPushBufferFromIDToService (struct sva_t *sva,
+                                   struct sva_service_struct *a_service,
+                                   unsigned int a_buffer_id,
+                                   unsigned int a_timestamp,
+                                   Bool a_shared,
+                                   unsigned int a_sharing_index,
+                                   enum sva_buffer_type a_type) ;
+
+Bool svaRemovePPPTile (struct sva_t *a_sva,
+                                   struct sva_service_struct *a_service);
+
+Bool svaUpdatePPPTile (struct sva_t *a_sva,
+                                   struct sva_service_struct *a_service,
+                                   struct sva_ppp_tile_info *a_ppp_tile_ptr);
+
+Bool computeYUVImageSize (enum fourcc_yuv_format_t a_yuv_format,
+                          unsigned a_width,
+                          unsigned a_height,
+                          unsigned *a_len) ;
+
+Bool readYUVMBFrameDescFromBuf (const char *a_buf,
+                                struct st_yuvmb_frame_desc_t *a_desc) ;
+
+Bool colorFormatMatchesPPCapability (enum fourcc_yuv_format_t a_color_format,
+                                     enum postprocessor_capability a_cap) ;
+
+#endif
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-video.c
@@ -0,0 +1,1956 @@
+/*
+ * Copyright ST Microelectronics.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Dodji Seketeli <dodji@openedhand.com>
+ */
+#include "kdrive.h"
+#include "nomadik-log.h"
+#include "kxv.h"
+#include "fourcc.h"
+#include "X11/extensions/Xv.h"
+#include "nomadik-sva.h"
+
+#define IMAGE_RESIZE_MAX_WIDTH   640
+#define IMAGE_RESIZE_MAX_HEIGHT	 480
+#define IMAGE_MAX_WIDTH		 800
+#define IMAGE_MAX_HEIGHT	 480
+#define Y_BUF_SIZE		(IMAGE_MAX_WIDTH * IMAGE_MAX_HEIGHT)
+
+#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
+
+/* SVA PPP tile supports X offset, Y offset, width and Height with multiple of 16 */
+#define ALIGN_TO_16MULTI(X) (((X%16) < 8)?(X-(X%16)):(X+(16-(X%16))))
+
+#define MAX_NUM_OF_PPP_PIECES     16
+#define PIXEL_16_VALUE                     16
+/* Maximum image buffers supported by SVA driver */
+#define MAX_NUM_OF_IMAGE_BUFFER    50
+
+
+static nomadikXVPrivScreenPrivateIndex ;
+static Atom xvBrightness, xvContrast, xvDithering ;
+
+/* client libraries expect an encoding */
+static KdVideoEncodingRec DummyEncoding[1] =
+{
+    {
+        0,
+        "XV_IMAGE",
+        IMAGE_MAX_WIDTH,
+        IMAGE_MAX_HEIGHT,
+        {1, 1}
+    }
+};
+
+#define NUM_FORMATS 3
+static KdVideoFormatRec formats[NUM_FORMATS] =
+{
+  {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
+};
+
+static KdAttributeRec attributes[] =
+{
+   {XvSettable | XvGettable, 0, 100, "XV_BRIGHTNESS"},
+   {XvSettable | XvGettable, 0, 100, "XV_CONTRAST"},
+   {XvSettable | XvGettable, 0, 1, "XV_DITHERING"},
+};
+#define NUM_ATTRIBUTES sizeof(attributes)/sizeof(KdAttributeRec)
+
+
+static KdImageRec images[] =
+{
+    XVIMAGE_YV12,
+    XVIMAGE_I420,
+    XVIMAGE_YUMB,
+    XVIMAGE_STMB,
+};
+#define NUM_IMAGES sizeof(images)/sizeof(KdImageRec)
+
+struct _NomadikXVPriv
+{
+    struct sva_t *sva ;
+    struct sva_non_size_params_t sva_params ;
+    struct sva_service_struct **pp_services_tab ;
+    int pp_services_tab_size ;
+    int nb_pp_services ;
+    struct sva_buffer_t *cur_buf ;
+    RegionRec clipping_region ;
+    BoxRec simple_clipping_rect ;
+    int src_x, src_y,
+        src_w, src_h,
+        drw_x, drw_y,
+        drw_w, drw_h,
+        img_width, img_height;
+    int screen_width ;
+    int screen_height ;
+    enum fourcc_yuv_format_t color_format ;
+    struct sva_ppp_tile_info ppp_tile_list;
+    int update_ppp_tile_count;
+    Bool ppp_tile_enable;
+    Bool update_ppp_tile_flag;
+    Bool resize_enable;
+    Bool prev_buffid;
+    Bool is2DAccel;
+    PixmapPtr dst_pixmap;
+    void *mem_base;
+    Bool yuvpl_buff_id_enable;
+};
+typedef struct _NomadikXVPriv NomadikXVPriv ;
+
+/**************************
+ * <NomadikXVPriv methods>
+ **************************/
+
+Bool nomadikXVPrivCreateSVA (NomadikXVPriv *a_this) ;
+
+Bool nomadikXVPrivAppendSVAService (NomadikXVPriv *a_this,
+                                    struct sva_service_struct *a_service,
+                                    Bool a_can_grow);
+
+Bool nomadikXVPrivLookupSVAService (NomadikXVPriv *a_this,
+                                    struct sva_service_struct **a_service) ;
+
+Bool nomadikXVPrivCreateService (NomadikXVPriv *a_this,
+                                 struct sva_service_struct **a_service) ;
+
+Bool nomadikXVPrivSaveFrameInfo (NomadikXVPriv *a_this,
+                                 ScreenPtr a_screen,
+                                 int a_color_format,
+                                 int a_src_x,
+                                 int a_src_y,
+                                 int a_src_w,
+                                 int a_src_h,
+                                 int a_drw_x,
+                                 int a_drw_y,
+                                 int a_drw_w,
+                                 int a_drw_h,
+                                 int a_img_width,
+                                 int a_img_height,
+                                 RegionPtr a_clipping_region) ;
+
+Bool nomadikXVPrivDisplayFrame (NomadikXVPriv *a_this,
+                                const char *a_buf) ;
+
+void nomadikXVPrivClearSVAServices (NomadikXVPriv *a_this) ;
+
+void nomadikXVPrivDeleteSVAServices (NomadikXVPriv *a_this) ;
+
+struct sva_buffer_t* nomadikXVPrivGetSVABuffer (NomadikXVPriv *a_this,
+                                                int a_size) ;
+
+void nomadikXVPrivFreeSVABuffer (NomadikXVPriv *a_this) ;
+
+Bool nomadikXVPrivSaveClippingRegion (NomadikXVPriv *a_this,
+                                      ScreenPtr  a_screen,
+                                      RegionPtr a_region) ;
+
+Bool nomadikXVPrivHasClippingRegionChanged (NomadikXVPriv *a_this,
+                                            ScreenPtr a_screen,
+                                            RegionPtr a_region,
+                                            Bool *a_answer) ;
+
+Bool nomadikXVPrivUpdateSavedClippingRegionIfNeeded (NomadikXVPriv *a_this,
+                                                     ScreenPtr a_screen,
+                                                     RegionPtr a_region) ;
+
+Bool nomadikXVPrivDoSimpleClip (ScreenPtr a_screen,
+                                int x, int y, int w,  int h,
+                                RegionPtr a_clip_box,
+                                BoxPtr a_simple_clipped_rect) ;
+
+Bool nomadikXVPrivClipRegionToSimpleClipBox (NomadikXVPriv *a_this,
+                                             ScreenPtr a_screen,
+                                             RegionPtr a_region) ;
+
+Bool nomadikXVPrivUpdateSVAClippingRegion (NomadikXVPriv *a_this) ;
+
+void nomadikXVPrivFreeMembers (NomadikXVPriv *a_this) ;
+
+/**************************
+ * </NomadikXVPriv methods>
+ **************************/
+
+/******************
+ * <XVideo hooks>
+ *******************/
+static void               nomadikClipVideo       (BoxPtr dst,
+                                                  INT32 *x1,
+                                                  INT32 *x2,
+                                                  INT32 *y1,
+                                                  INT32 *y2,
+                                                  BoxPtr extents,
+                                                  INT32 width,
+                                                  INT32 height) ;
+
+static KdVideoAdaptorPtr nomadikSetupImageVideo  (ScreenPtr pScreen,
+                                                  Bool is2DAccel) ;
+
+static void              nomadikStopVideo        (KdScreenInfo *screen,
+                                                  pointer data,
+                                                  Bool exit) ;
+
+static int               nomadikSetPortAttribute (KdScreenInfo *screen,
+                                                  Atom attribute,
+                                                  int value,
+                                                  pointer data) ;
+
+static int               nomadikGetPortAttribute (KdScreenInfo *screen,
+                                                  Atom attribute,
+                                                  int *value,
+                                                  pointer data) ;
+
+static void              nomadikQueryBestSize    (KdScreenInfo *screen,
+                                                  Bool motion,
+                                                  short vid_w,
+                                                  short vid_h,
+                                                  short drw_w,
+                                                  short drw_h,
+                                                  unsigned int *p_w,
+                                                  unsigned int *p_h,
+                                                  pointer data) ;
+
+static int               nomadikPutImage         (KdScreenInfo *screen,
+                                                  DrawablePtr pDraw,
+                                                  short src_x,
+                                                  short src_y,
+                                                  short drw_x,
+                                                  short drw_y,
+                                                  short src_w,
+                                                  short src_h,
+                                                  short drw_w,
+                                                  short drw_h,
+                                                  int id,
+                                                  unsigned char *buf,
+                                                  short width,
+                                                  short height,
+                                                  Bool sync,
+                                                  RegionPtr clipBoxes,
+                                                  pointer data) ;
+
+static int               nomadikQueryImageAttributes (KdScreenInfo *screen,
+                                                      int id,
+                                                      unsigned short *w,
+                                                      unsigned short *h,
+                                                      int *pitches,
+                                                      int *offsets);
+
+/******************
+ * </XVideo hooks>
+ *******************/
+
+Bool
+nomadikXVPrivCreateSVA (NomadikXVPriv *a_this)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this, FALSE) ;
+
+    if (a_this->sva)
+        return TRUE ;
+
+    a_this->sva = svaNew () ;
+    if (!a_this->sva) {
+        NOMADIK_LOG_ERROR ("Failed to create sva object\n") ;
+        return FALSE ;
+    }
+    return TRUE ;
+}
+
+/**
+ * @param a_this the current instance of NomadikXVPriv
+ * @param a_service the service to to append to the list of post processing
+ *        services cached by NomadikXVPriv
+ * @param a_can_grow whether if the storage of the pp services cache can grow.
+ *        it is currently set to a maximum of 32 services at the moment.
+ *        if set to FALSE, this function clears the cache, forcing
+ *        subsequent frame showing requests to create a new pp service.
+ */
+Bool
+nomadikXVPrivAppendSVAService (NomadikXVPriv *a_this,
+                               struct sva_service_struct *a_service,
+                               Bool a_can_grow)
+{
+#define SVA_SERVICES_TAB_CHUNK_SIZE 32
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_service, FALSE) ;
+
+    /*if services tab is NULL. Allocate it*/
+    if (!a_this->pp_services_tab) {
+        a_this->pp_services_tab =
+            xcalloc (SVA_SERVICES_TAB_CHUNK_SIZE,
+                     sizeof (struct sva_service_struct *)) ;
+        if (!a_this->pp_services_tab) {
+            NOMADIK_LOG_ERROR ("failed to allocate sva services tab\n") ;
+            return FALSE ;
+        }
+        a_this->pp_services_tab_size = SVA_SERVICES_TAB_CHUNK_SIZE ;
+        a_this->nb_pp_services = 0 ;
+    }
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this->pp_services_tab
+                                && a_this->pp_services_tab_size,
+                                FALSE) ;
+
+    /*
+     * if services tab is too small, grow it or clear it to make some room
+     */
+    if (a_this->nb_pp_services == a_this->pp_services_tab_size) {
+        if (a_can_grow) {
+            struct sva_service_struct **new_services=NULL ;
+            new_services =
+                xrealloc (a_this->pp_services_tab,
+                          a_this->nb_pp_services+SVA_SERVICES_TAB_CHUNK_SIZE);
+            if (!new_services) {
+                NOMADIK_LOG_ERROR ("Could not grow sva services tab\n") ;
+                return FALSE ;
+            }
+            a_this->pp_services_tab = new_services ;
+            a_this->pp_services_tab_size += SVA_SERVICES_TAB_CHUNK_SIZE ;
+        } else {
+            nomadikXVPrivClearSVAServices (a_this) ;
+        }
+    }
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this->nb_pp_services
+                                < a_this->pp_services_tab_size,
+                                FALSE) ;
+
+    /*really append the service now*/
+    a_this->pp_services_tab[a_this->nb_pp_services] = a_service ;
+    a_this->nb_pp_services++ ;
+    return TRUE ;
+}
+
+Bool
+nomadikXVPrivLookupSVAService (NomadikXVPriv *a_this,
+                               struct sva_service_struct **a_service)
+{
+    int i=0 ;
+    struct sva_service_struct *service=NULL ;
+    struct sva_postprocessor_configuration config ;
+    int dst_clip_w, dst_clip_h ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_service, FALSE) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (!a_this->pp_services_tab || !a_this->nb_pp_services) {
+        NOMADIK_LOG ("leave\n") ;
+        return FALSE ;
+    }
+
+    dst_clip_w = abs (a_this->simple_clipping_rect.x2 -
+                        a_this->simple_clipping_rect.x1) ;
+    dst_clip_h = abs (a_this->simple_clipping_rect.y2 -
+                        a_this->simple_clipping_rect.y1) ;
+
+    /* multiple clip region will take care of the clipping less than src size */
+    if((a_this->src_w==a_this->drw_w) && (a_this->src_h == a_this->drw_h)) {
+        if(dst_clip_w < a_this->src_w) dst_clip_w = a_this->src_w;
+        if(dst_clip_h < a_this->src_h) dst_clip_h = a_this->src_h;
+    }
+
+
+    for (i=0 ; i < a_this->nb_pp_services ; ++i) {
+        service = a_this->pp_services_tab[i] ;
+        if (!service || service->service_type != POSTPROCESSOR)
+            continue ;
+        config = service->config.postprocessor_configuration ;
+        if (colorFormatMatchesPPCapability (a_this->color_format,
+                                            config.capability)         &&
+            config.source_frame.width == a_this->src_w                 &&
+            config.source_frame.height == a_this->src_h                &&
+            config.cropped_window.offset.x_offset == a_this->src_x     &&
+            config.cropped_window.offset.y_offset == a_this->src_y     &&
+            config.cropped_window.frame.width == a_this->src_w         &&
+            config.cropped_window.frame.height == a_this->src_h        &&
+            config.resized_frame.width == a_this->drw_w                &&
+            config.resized_frame.height == a_this->drw_h               &&
+            config.clipped_window.offset.x_offset == 0                 &&
+            config.clipped_window.offset.y_offset == 0                 &&
+            config.clipped_window.frame.width     == dst_clip_w        &&
+            config.clipped_window.frame.height    == dst_clip_h        &&
+            config.display_window.offset.x_offset == a_this->drw_x     &&
+            config.display_window.offset.y_offset == a_this->drw_y     &&
+            config.display_window.frame.width == a_this->screen_width  &&
+            config.display_window.frame.height == a_this->screen_height) {
+            *a_service = service ;
+            NOMADIK_LOG ("leave\n") ;
+            return TRUE ;
+        }
+    }
+    NOMADIK_LOG ("leave\n") ;
+    return FALSE ;
+}
+
+Bool
+nomadikXVPrivCreateService (NomadikXVPriv *a_this,
+                            struct sva_service_struct **a_service)
+{
+    struct sva_service_struct *service=NULL ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this && a_service, FALSE) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (!svaOpenDevice (a_this->sva)) {
+        NOMADIK_LOG_ERROR ("failed to open sva device\n") ;
+        return FALSE ;
+    }
+
+    service = svaPostProcServiceNew (a_this->sva, a_this->sva_params,
+                                     a_this->color_format,
+                                     a_this->img_width, a_this->img_height,
+                                     a_this->src_x, a_this->src_y,
+                                     a_this->src_w, a_this->src_h,
+                                     a_this->drw_x, a_this->drw_y,
+                                     a_this->drw_w, a_this->drw_h,
+                                     a_this->simple_clipping_rect,
+                                     a_this->screen_width,
+                                     a_this->screen_height,
+                                     a_this->yuvpl_buff_id_enable) ;
+    if (!service) {
+        NOMADIK_LOG_ERROR ("failed to create post proc service\n") ;
+        return FALSE ;
+    }
+    *a_service = service ;
+    NOMADIK_LOG ("leave\n") ;
+    return TRUE ;
+}
+
+Bool
+nomadikXVPrivSaveFrameInfo (NomadikXVPriv *a_this,
+                            ScreenPtr a_screen,
+                            int a_color_format,
+                            int a_src_x,
+                            int a_src_y,
+                            int a_src_w,
+                            int a_src_h,
+                            int a_drw_x,
+                            int a_drw_y,
+                            int a_drw_w,
+                            int a_drw_h,
+                            int a_img_width,
+                            int a_img_height,
+                            RegionPtr a_clipping_region)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this, FALSE) ;
+
+    NOMADIK_LOG ("enter\n") ;
+    a_this->src_x = a_src_x ;
+    a_this->src_y = a_src_y ;
+    a_this->src_w = a_src_w ;
+    a_this->src_h = a_src_h ;
+    a_this->drw_x = a_drw_x ;
+    a_this->drw_y = a_drw_y ;
+    a_this->drw_w = a_drw_w ;
+    a_this->drw_h = a_drw_h ;
+    a_this->img_width = a_img_width ;
+    a_this->img_height = a_img_height ;
+    a_this->color_format = a_color_format ;
+    a_this->screen_width  = a_screen->width ;
+    a_this->screen_height  = a_screen->height ;
+
+    NOMADIK_LOG("geometry:\n"
+                "src_x:%d, src_y:%d,"
+                "src_w:%d, src_h:%d, "
+                "drw_x:%d, drw_y:%d\n"
+                "drw_w:%d, drw_h:%d\n"
+                "img_width:%d, img_height:%d\n",
+                a_this->src_x, a_this->src_y,
+                a_this->src_w, a_this->src_h,
+                a_this->drw_x, a_this->drw_y,
+                a_this->drw_w, a_this->drw_h,
+                a_this->img_width, a_this->img_height) ;
+
+    /*round everything to 2 otherwise SVA won't work*/
+    a_this->src_w = (a_this->src_w + 1) & ~1 ;
+    a_this->src_h = (a_this->src_h + 1) & ~1 ;
+    a_this->src_x = (a_this->src_x + 1) & ~1 ;
+    a_this->src_y = (a_this->src_y + 1) & ~1 ;
+    a_this->src_w = (a_this->src_w + 1) & ~1 ;
+    a_this->src_h = (a_this->src_h + 1) & ~1 ;
+    a_this->drw_x = (a_this->drw_x + 1) & ~1 ;
+    a_this->drw_y = (a_this->drw_y + 1) & ~1 ;
+    a_this->drw_w = (a_this->drw_w + 1) & ~1 ;
+    a_this->drw_h = (a_this->drw_h + 1) & ~1 ;
+
+    NOMADIK_LOG("rounded geometry:\n"
+                "src_x:%d, src_y:%d,"
+                "src_w:%d, src_h:%d, "
+                "drw_x:%d, drw_y:%d\n"
+                "drw_w:%d, drw_h:%d\n"
+                "img_width:%d, img_height:%d\n",
+                a_this->src_x, a_this->src_y,
+                a_this->src_w, a_this->src_h,
+                a_this->drw_x, a_this->drw_y,
+                a_this->drw_w, a_this->drw_h,
+                a_this->img_width, a_this->img_height) ;
+
+    if (!nomadikXVPrivUpdateSavedClippingRegionIfNeeded (a_this,
+                                                         a_screen,
+                                                         a_clipping_region)) {
+        NOMADIK_LOG_ERROR ("failed to update nomadik saved CP regions\n") ;
+        return FALSE ;
+    }
+    NOMADIK_LOG ("leave\n") ;
+    return TRUE ;
+}
+
+Bool
+nomadikXVPrivDisplayFrame (NomadikXVPriv *a_this,
+                           const char *a_buf)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this, FALSE) ;
+    int imageSize=0;
+    Bool result=FALSE ;
+    struct sva_buffer_t *svaBuffer=NULL ;
+    struct sva_service_struct *svaService=NULL ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    /*
+     * do we have a cached  sva service capable of
+     * handling the current frame ?
+     */
+    if (nomadikXVPrivLookupSVAService (a_this, &svaService)) {
+        NOMADIK_LOG ("found an existing sva service for this image size\n") ;
+    } else {
+        NOMADIK_LOG ("did not find any sva service for this image size."
+                     "creating one\n") ;
+        a_this->ppp_tile_enable=0;
+        NOMADIK_LOG ("Create service: %d\n", a_this->ppp_tile_enable) ;
+        /* deleting previous service else dequeue returns EINTR */
+        nomadikXVPrivClearSVAServices (a_this) ;
+
+        a_this->yuvpl_buff_id_enable=FALSE;
+
+        if (a_this->color_format == YUV_ST_420_MACRO_BLOCK_OPTIMIZED) {
+            struct st_yuvmb_frame_desc_t frame_desc ;
+            memset (&frame_desc, 0, sizeof (frame_desc)) ;
+            NOMADIK_LOG ("got yuv id:%#x. YUVMB, OPTIMIZED.\n", a_this->color_format) ;
+
+            if (!readYUVMBFrameDescFromBuf (a_buf, &frame_desc)) {
+                NOMADIK_LOG_ERROR ("failed to read YUV MB frame desc from buf\n") ;
+                goto out ;
+            }
+            if(frame_desc.timestamp == 0xBFBFBFBF) {
+                a_this->yuvpl_buff_id_enable=TRUE;
+            } else {
+                a_this->yuvpl_buff_id_enable=FALSE;
+            }
+            NOMADIK_MLOG ("Create service buffer-id sharing with Planar: %d\n", a_this->yuvpl_buff_id_enable) ;
+        }
+
+        if (!nomadikXVPrivCreateService (a_this, &svaService) || !svaService) {
+            NOMADIK_LOG_ERROR ("failed to create sva post proc service\n") ;
+            goto out ;
+        }
+        if (!nomadikXVPrivAppendSVAService (a_this, svaService, FALSE)) {
+            NOMADIK_LOG_ERROR ("failed to append service\n") ;
+            goto out ;
+        }
+    }
+
+    if (!svaService) {
+        NOMADIK_LOG_ERROR ("svaService should not be NULL\n") ;
+        goto out ;
+    }
+
+    /*
+     * by now, we should have an sva post processing service capable
+     * of handling the current frame.
+     */
+
+    /*compute the image size*/
+    if (!computeYUVImageSize (a_this->color_format,
+                              a_this->img_width,
+                              a_this->img_height,
+                              &imageSize)) {
+        NOMADIK_LOG_ERROR ("failed to compute yuv image size\n") ;
+        goto out ;
+    }
+    NOMADIK_LOG ("computed image size: %d bytes\n", imageSize) ;
+
+    /* if display is WIDE MODE of QCIF and CIF don't perform PPP tiling */
+    if( (a_this->drw_w == 584) && (a_this->drw_h == 480) ) {
+        a_this->update_ppp_tile_flag=FALSE;
+    }
+
+
+    /*
+      * if clip region is changed just update new PPP tile in the SVA service
+      */
+    if(a_this->update_ppp_tile_flag) {
+        if(a_this->ppp_tile_list.image.width && a_this->ppp_tile_list.image.height) {
+                //NOMADIK_LOG("calling svaUpdatePPPTile: %x\n", &(a_this->ppp_tile_list));
+
+                if(!svaUpdatePPPTile (a_this->sva, svaService, &(a_this->ppp_tile_list))) {
+                    NOMADIK_LOG_ERROR ("failed to update the PPP tile\n") ;
+                    goto out ;
+                }
+                a_this->ppp_tile_enable=TRUE;
+
+        } else {
+
+              /* Remove the previous PPP tile service */
+             //NOMADIK_LOG("calling svaRemovePPPTile\n");
+             if( a_this->ppp_tile_enable==TRUE) {
+                 svaRemovePPPTile (a_this->sva, svaService);
+                 a_this->ppp_tile_enable=FALSE;
+             }
+         }
+    }
+
+    /*
+     * push the YUV frame buffer to the sva service so that it displays it
+     */
+    if (a_this->color_format != YUV_ST_420_MACRO_BLOCK_OPTIMIZED) {
+        NOMADIK_LOG ("got yuv image id:%#x\n", a_this->color_format) ;
+        svaBuffer = nomadikXVPrivGetSVABuffer (a_this, imageSize) ;
+        if (!svaBuffer) {
+            NOMADIK_LOG_ERROR ("failed to get an sva buffer\n") ;
+            goto out ;
+        }
+        memcpy (svaBuffer->data, a_buf, imageSize) ;
+
+        if (!svaPushBufferToService (a_this->sva, svaService, svaBuffer)) {
+            NOMADIK_LOG_ERROR ("failed to push buffer to service\n") ;
+            goto out ;
+        }
+    } else {
+        /*
+         * We received an ST Macro block format YUV frame,
+         * in the optimized format.
+         * Actually what we received is an id that points to an in-kernel
+         * buffer. That in-kernel buffer contains the YUV frame.
+         * It has been put there by an "optimized and proprietary" application.
+         * This saves us from a couple of memcpies.
+         *
+         * So let's extract the id of the buffer from the the image buffer
+         * and pass that to SGA.
+         */
+        struct st_yuvmb_frame_desc_t frame_desc ;
+        memset (&frame_desc, 0, sizeof (frame_desc)) ;
+        NOMADIK_LOG ("got yuv id:%#x. YUVMB, OPTIMIZED.\n", a_this->color_format) ;
+
+        if (!readYUVMBFrameDescFromBuf (a_buf, &frame_desc)) {
+            NOMADIK_LOG_ERROR ("failed to read YUV MB frame desc from buf\n") ;
+            goto out ;
+        }
+        NOMADIK_LOG ("in kernel buffer id: %d prev buff-id: %d\n", \
+                       frame_desc.buffer_id, a_this->prev_buffid) ;
+
+        /* validate the buffer-id */
+        if (frame_desc.buffer_id > MAX_NUM_OF_IMAGE_BUFFER) {
+            goto out ;
+        }
+
+        /* similar buffer-id will come in case of GUI change,
+           This should be discarded to avoid the
+           shared buffer already queued error */
+        if(a_this->prev_buffid == frame_desc.buffer_id) {
+            result = TRUE ;
+            goto out ;
+        }
+
+        a_this->prev_buffid = frame_desc.buffer_id;
+
+        if (!svaPushBufferFromIDToService (a_this->sva, svaService,
+                                           frame_desc.buffer_id,
+                                           frame_desc.timestamp,
+                                           TRUE, /*buffer is shared*/
+                                           frame_desc.buffer_index, /*sharing index*/
+                                           BUF_TYPE_IMAGE)) {
+            NOMADIK_LOG_ERROR ("failed to push buffer (from ID) to service\n");
+            goto out ;
+        }
+        NOMADIK_LOG ("pushed buffer id: %d\n to sva okay",
+                      frame_desc.buffer_id) ;
+    }
+
+    result = TRUE ;
+
+out:
+    /*we don't have to free the SVA Buffer. It will done later*/
+    NOMADIK_LOG("leave\n") ;
+    return result ;
+}
+
+void
+nomadikXVPrivClearSVAServices (NomadikXVPriv *a_this)
+{
+    int i=0 ;
+
+    NOMADIK_RETURN_IF_FAIL (a_this) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    for (i=0; i<a_this->nb_pp_services; ++i) {
+        svaPostProcServiceDelete (a_this->sva, a_this->pp_services_tab[i]) ;
+        a_this->pp_services_tab[i] = NULL ;
+    }
+
+    a_this->nb_pp_services = 0 ;
+
+    svaCloseDevice (a_this->sva) ;
+
+    NOMADIK_LOG ("leave\n") ;
+}
+
+void
+nomadikXVPrivDeleteSVAServices (NomadikXVPriv *a_this)
+{
+    NOMADIK_RETURN_IF_FAIL (a_this) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (!a_this->pp_services_tab) {
+        NOMADIK_LOG ("leave\n") ;
+        return ;
+    }
+
+    nomadikXVPrivClearSVAServices (a_this) ;
+    xfree (a_this->pp_services_tab) ;
+    a_this->pp_services_tab = NULL ;
+    a_this->pp_services_tab_size = 0 ;
+    NOMADIK_LOG ("leave\n") ;
+}
+
+struct sva_buffer_t*
+nomadikXVPrivGetSVABuffer (NomadikXVPriv *a_this,
+                           int a_size)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this, NULL) ;
+
+    NOMADIK_LOG ("enter: this:%#x, a_this->cur_buf: %#x, a_size:%d\n",
+                 a_this, a_this->cur_buf, a_size) ;
+
+    if (!a_this->cur_buf) {
+        NOMADIK_LOG ("creating an sva buffer for the first time\n") ;
+        a_this->cur_buf = svaBufferNew (a_this->sva, BUF_TYPE_IMAGE, a_size) ;
+        NOMADIK_RETURN_VAL_IF_FAIL (a_this->cur_buf, NULL) ;
+    } else if (a_this->cur_buf->len < a_size) {
+        NOMADIK_LOG ("freeing current sva buffer to allocate a bigger\n") ;
+        svaBufferDelete (a_this->sva, a_this->cur_buf) ;
+        a_this->cur_buf = svaBufferNew (a_this->sva, BUF_TYPE_IMAGE, a_size) ;
+        NOMADIK_RETURN_VAL_IF_FAIL (a_this->cur_buf, NULL) ;
+    }
+    NOMADIK_LOG ("leave: this->cur_buf:%#x\n", a_this->cur_buf) ;
+    return a_this->cur_buf ;
+}
+
+void
+nomadikXVPrivFreeSVABuffer (NomadikXVPriv *a_this)
+{
+    NOMADIK_RETURN_IF_FAIL (a_this) ;
+
+    if (a_this->cur_buf) {
+        svaBufferDelete (a_this->sva, a_this->cur_buf) ;
+        a_this->cur_buf = NULL;
+    }
+}
+
+Bool
+nomadikXVPrivSaveClippingRegion (NomadikXVPriv *a_this,
+                                 ScreenPtr a_screen,
+                                 RegionPtr a_region)
+{
+    Bool result=FALSE ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this && a_screen, FALSE) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (!a_region) {
+        REGION_INIT (a_screen, &a_this->clipping_region, NullBox, 0) ;
+        result = TRUE ;
+        goto out ;
+    }
+    REGION_COPY (a_screen, &a_this->clipping_region, a_region) ;
+    result = TRUE ;
+
+out:
+    NOMADIK_LOG ("leave\n") ;
+    return result ;
+}
+
+Bool
+nomadikXVPrivHasClippingRegionChanged (NomadikXVPriv *a_this,
+                                       ScreenPtr a_screen,
+                                       RegionPtr a_region,
+                                       Bool *a_answer)
+{
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this && a_screen && a_answer, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_region, FALSE) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (REGION_EQUAL (a_screen, &a_this->clipping_region, a_region)) {
+        *a_answer = FALSE ;
+    } else {
+        *a_answer = TRUE ;
+    }
+    NOMADIK_LOG ("leave\n") ;
+    return TRUE ;
+}
+
+Bool
+nomadikXVPrivUpdateSavedClippingRegionIfNeeded (NomadikXVPriv *a_this,
+                                                ScreenPtr a_screen,
+                                                RegionPtr a_region)
+{
+    Bool has_cr_changed=FALSE, result=FALSE ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this && a_screen, FALSE) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_region, FALSE) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    /* Reset the update ppp tile flag,
+    if the clip region is changed this flag has to be set */
+    a_this->update_ppp_tile_flag = FALSE;
+
+    if (!nomadikXVPrivHasClippingRegionChanged (a_this, a_screen,
+                                                a_region, &has_cr_changed)) {
+        NOMADIK_LOG_ERROR ("failed to test if clipping region has changed\n") ;
+        result = FALSE ;
+        goto out ;
+    }
+    if (!has_cr_changed) {
+        if( a_this->nb_pp_services == 0) {
+            /* Set the update ppp tile flag */
+            a_this->update_ppp_tile_flag = TRUE;
+        }
+        result = TRUE ;
+        goto out ;
+    }
+
+
+    /* Set the update ppp tile flag */
+    a_this->update_ppp_tile_flag = TRUE;
+
+
+    /*
+     * if we reached this point, it means the clipping region has changed.
+     * so save the new clipping region and do the necessary voodoo
+     * to let SVA know about about the new clipping region.
+     */
+
+    if (!nomadikXVPrivSaveClippingRegion (a_this, a_screen, a_region)) {
+        NOMADIK_LOG_ERROR ("failed to save new clipping region\n") ;
+        result = FALSE;
+        goto out ;
+    }
+
+    NOMADIK_LOG("before clipping:\n"
+                "src_x:%d, src_y:%d,"
+                "src_w:%d, src_h:%d, "
+                 "drw_x:%d, drw_y:%d,"
+                "drw_w:%d, drw_h:%d\n"
+                "cp_x1:%d, cp_y1:%d, "
+                "cp_x2:%d, cp_y2:%d\n"
+                "width:%d, height:%d\n",
+                a_this->src_x, a_this->src_y,
+                a_this->src_w, a_this->src_h,
+                 a_this->drw_x, a_this->drw_y,
+                a_this->drw_w, a_this->drw_h,
+                a_this->simple_clipping_rect.x1,
+                a_this->simple_clipping_rect.y1,
+                a_this->simple_clipping_rect.x2,
+                a_this->simple_clipping_rect.y2,
+                a_this->img_width, a_this->img_height) ;
+
+
+    if (!nomadikXVPrivDoSimpleClip (a_screen,
+                                    a_this->drw_x, a_this->drw_y,
+                                    a_this->drw_w, a_this->drw_h,
+                                    &a_this->clipping_region,
+                                    &a_this->simple_clipping_rect)) {
+        NOMADIK_LOG_ERROR ("failed to do simple clipping\n") ;
+        result = BadImplementation ;
+        goto out ;
+    }
+
+    /*round result of clipping to 2 other sva won't be happy*/
+    a_this->simple_clipping_rect.x1 =
+                            (a_this->simple_clipping_rect.x1 + 1) & ~1 ;
+    a_this->simple_clipping_rect.x2 =
+                            (a_this->simple_clipping_rect.x2 + 1) & ~1 ;
+    a_this->simple_clipping_rect.y1 =
+                            (a_this->simple_clipping_rect.y1 + 1) & ~1 ;
+    a_this->simple_clipping_rect.y2 =
+                            (a_this->simple_clipping_rect.y2 + 1) & ~1 ;
+
+    NOMADIK_LOG("after clipping:\n"
+                "src_x:%d, src_y:%d, "
+                 "src_w:%d, src_h:%d, "
+                 "drw_x:%d, drw_y:%d,"
+                 "drw_w:%d, drw_h:%d\n"
+                 "cp_x1:%d, cp_y1:%d, "
+                 "cp_x2:%d, cp_y2:%d\n"
+                "width:%d, height:%d\n",
+                a_this->src_x, a_this->src_y,
+                a_this->src_w, a_this->src_h,
+                 a_this->drw_x, a_this->drw_y,
+                a_this->drw_w, a_this->drw_h,
+                a_this->simple_clipping_rect.x1,
+                a_this->simple_clipping_rect.y1,
+                a_this->simple_clipping_rect.x2,
+                a_this->simple_clipping_rect.y2,
+                a_this->img_width,  a_this->img_height) ;
+
+    /*
+     * Tell SVA about the new clipping region.
+     * the new clipping region is inside a_this->clipping_region.
+     */
+    if (!nomadikXVPrivUpdateSVAClippingRegion (a_this)) {
+        NOMADIK_LOG_ERROR ("failed") ;
+        result = FALSE ;
+        goto out ;
+    }
+
+    result = TRUE ;
+
+out:
+    NOMADIK_LOG ("leave\n") ;
+    return result ;
+}
+
+Bool
+nomadikXVPrivDoSimpleClip (ScreenPtr a_screen,
+                           int x, int y, int w,  int h,
+                           RegionPtr a_clip_reg,
+                           BoxPtr a_result /*out parameter*/)
+{
+    BoxRec dstClippedBox, *clipper=NULL ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_screen && a_clip_reg && a_result,
+                                FALSE) ;
+
+    /*
+     * setup the clipbox inside the destination.
+     */
+    dstClippedBox.x1 = x ;
+    dstClippedBox.x2 = x + w;
+    dstClippedBox.y1 = y ;
+    dstClippedBox.y2 = y + h ;
+
+    clipper = REGION_EXTENTS (pScreen, a_clip_reg) ;
+    if (clipper) {
+        /*
+         * if the cliper leftmost edge is inside
+         * the destination area then the leftmost edge of the resulting
+         * clipped box is the leftmost edge of the cliper.
+         */
+        if (clipper->x1 > dstClippedBox.x1)
+            dstClippedBox.x1 = clipper->x1 ;
+
+        /*
+         * if the cliper top edge is inside the destination area
+         * then the bottom horizontal edge of the resulting clipped box
+         * is the bottom edge of the cliper
+         */
+        if (clipper->y1 > dstClippedBox.y1)
+            dstClippedBox.y1 = clipper->y1 ;
+
+        /*ditto for right edge*/
+        if (clipper->x2 < dstClippedBox.x2)
+            dstClippedBox.x2 = clipper->x2 ;
+
+        /*ditto for bottom edge*/
+        if (clipper->y2 < dstClippedBox.y2)
+            dstClippedBox.y2 = clipper->y2 ;
+
+        /* in case of full screen mode x1 and y1 should be 0 */
+        if( ((dstClippedBox.x2 - dstClippedBox.x1) == IMAGE_MAX_WIDTH) &&  \
+            ((dstClippedBox.y2-dstClippedBox.y1)== IMAGE_MAX_HEIGHT)) {
+            if(dstClippedBox.x1 || dstClippedBox.y1) {
+                dstClippedBox.x1 = 0;
+                dstClippedBox.y1 = 0;
+            }
+        }
+
+        /* this is a hack to switch from full screen to normal mode */
+        if(dstClippedBox.y1 == 130) dstClippedBox.y1 = 0;
+        if(dstClippedBox.x2 == 656) dstClippedBox.x2 = 720;
+
+ NOMADIK_LOG("clipper: \n"
+                "cp_x1:%d, cp_y1:%d, "
+                "cp_x2:%d, cp_y2:%d\n",
+                dstClippedBox.x1,
+                dstClippedBox.y1,
+                dstClippedBox.x2,
+                dstClippedBox.y2) ;
+
+    }
+
+    memcpy (a_result, &dstClippedBox, sizeof (dstClippedBox)) ;
+
+    return TRUE ;
+}
+
+Bool
+nomadikXVPrivClipRegionToSimpleClipBox (NomadikXVPriv *a_this,
+                                        ScreenPtr a_screen,
+                                        RegionPtr a_region)
+{
+    BoxRec dstClippedBox, *clipper=NULL ;
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this && a_screen, FALSE) ;
+
+    NOMADIK_LOG ("enter\n") ;
+    NOMADIK_LOG ("leave\n") ;
+}
+
+
+void
+nomadikXVPrivMemFill( NomadikXVPriv *a_this,
+					int x, int y, int w, int h)
+{
+	int i, bpp, stride;
+	unsigned char *rect_addr, *fill_addr;
+	unsigned int black_fill = 0x00;
+
+	/* If 2D is not accelerated we cannot take the pointer from
+	 * EXA. */
+	if(a_this->is2DAccel == FALSE) {
+	   NOMADIK_MLOG("memfill(x:%d, y:%d, w:%d h:%d)\n", x, y, w, h);
+	   if(a_this->dst_pixmap)
+	   {
+		   bpp = a_this->dst_pixmap->drawable.bitsPerPixel>>3;
+	   }
+	   else
+	   {
+		   NOMADIK_MLOG("a_this->dst_pixmap is NULL\n");
+		   return;
+	   }
+
+
+	   NOMADIK_MLOG("bpp:%d a_this->screen_width:%d\n", bpp, a_this->screen_width);
+
+	   stride = a_this->screen_width*bpp;
+	   NOMADIK_MLOG("stride:%d\n", stride);
+
+	   rect_addr = a_this->mem_base;
+	   NOMADIK_MLOG("rect_addr:%x\n", rect_addr);
+
+	} else {
+	    NOMADIK_MLOG("memfill(x:%d, y:%d, w:%d h:%d)\n", x, y, w, h);
+	    stride = exaGetPixmapPitch(a_this->dst_pixmap);
+	    NOMADIK_MLOG("stride:%d\n", stride);
+	    bpp = a_this->dst_pixmap->drawable.bitsPerPixel>>3;
+	    NOMADIK_MLOG("bpp:%d\n", bpp);
+	    rect_addr = a_this->mem_base + exaGetPixmapOffset(a_this->dst_pixmap);
+	    NOMADIK_MLOG("rect_addr:%x\n", rect_addr);
+	}
+
+	rect_addr += y * stride + x * bpp;
+	fill_addr = rect_addr;
+NOMADIK_MLOG("fill_addr:%x\n", fill_addr);
+	for(i= 0; i < w; i++) {
+		memcpy(fill_addr, (char *)&black_fill, bpp); // filled one line
+		fill_addr += bpp;
+	}
+	fill_addr = rect_addr + stride;
+
+	for(i = 0; i < h; i++) {
+		memcpy(fill_addr, rect_addr, bpp*w);
+		fill_addr += stride;
+	}
+}
+
+
+#define MIN_DELTA_PIXEL_FILL 4
+
+Bool
+nomadikXVPrivAlignResizeRect(NomadikXVPriv *a_this,
+                                       struct sva_ppp_tile_info *a_tile_info)
+{
+    Bool fill_delta=TRUE;
+    int real_w=0, real_h=0, real_x=0, real_y=0;
+    int delta_w=0, delta_h=0, delta_x=0, delta_y=0;
+
+
+   /* check whether the actual x, y, w and h of the PPP tile are
+     * 16 pixel aligned or not
+     */
+    real_x = a_tile_info->offset.x_offset*a_this->src_w/a_this->drw_w;
+    real_y = a_tile_info->offset.y_offset*a_this->src_h/a_this->drw_h;
+    real_w = a_tile_info->image.width*a_this->src_w/a_this->drw_w;
+    real_h = a_tile_info->image.height*a_this->src_h/a_this->drw_h;
+
+    real_x = (ALIGN_TO_16MULTI(real_x))*a_this->drw_w/a_this->src_w;
+    real_y = (ALIGN_TO_16MULTI(real_y))*a_this->drw_h/a_this->src_h;
+    real_w = (ALIGN_TO_16MULTI(real_w))*a_this->drw_w/a_this->src_w;
+    real_h = (ALIGN_TO_16MULTI(real_h))* a_this->drw_h/a_this->src_h;
+
+
+    /* find out the delta and trigger the solid fill for the rect */
+    delta_w = a_tile_info->image.width-real_w;
+    if(delta_w > MIN_DELTA_PIXEL_FILL) {
+        delta_x = a_tile_info->offset.x_offset+real_w;
+        delta_y = real_y;
+        delta_h = real_h;
+        NOMADIK_MLOG("Case 1: x:%d y:%d w:%d h%d\n", \
+			delta_x, delta_y, delta_w, delta_h);
+        nomadikXVPrivMemFill( a_this, delta_x, delta_y, delta_w, delta_h);
+    }
+
+    delta_h = a_tile_info->image.height-real_h;
+    if(delta_h > MIN_DELTA_PIXEL_FILL) {
+        delta_x = a_tile_info->offset.x_offset;
+        delta_y = a_tile_info->offset.y_offset+real_h;
+        delta_w = real_w;
+        NOMADIK_MLOG("Case 2: x:%d y:%d w:%d h%d\n", \
+			delta_x, delta_y, delta_w, delta_h);
+        nomadikXVPrivMemFill( a_this, delta_x, delta_y, delta_w, delta_h);
+    }
+
+    delta_x = real_x-a_tile_info->offset.x_offset;
+    if(delta_x > MIN_DELTA_PIXEL_FILL) {
+        delta_x = a_tile_info->offset.x_offset;
+        delta_y = a_tile_info->offset.y_offset;
+        delta_w = real_x-a_tile_info->offset.x_offset;
+        delta_h = real_h;
+        NOMADIK_MLOG("Case 3: x:%d y:%d w:%d h%d\n", \
+			delta_x, delta_y, delta_w, delta_h);
+        nomadikXVPrivMemFill( a_this, delta_x, delta_y, delta_w, delta_h);
+    }
+
+    delta_y = real_y-a_tile_info->offset.y_offset;
+    if(delta_y > MIN_DELTA_PIXEL_FILL) {
+        delta_x = a_tile_info->offset.x_offset;
+        delta_y = real_y+a_tile_info->image.height;
+        delta_w = real_w;
+        delta_h = real_h-a_tile_info->image.height;
+        NOMADIK_MLOG("Case 4: x:%d y:%d w:%d h%d\n", \
+			delta_x, delta_y, delta_w, delta_h);
+        nomadikXVPrivMemFill( a_this, delta_x, delta_y, delta_w, delta_h);
+    }
+/*
+	else {
+        NOMADIK_MLOG("No delta present: x:%d y:%d w:%d h%d\n", \
+			delta_x, delta_y, delta_w, delta_h);
+        fill_delta=FALSE;
+    }
+*/
+    /* call the memory fill function to fill the delta rect */
+/*
+    if( fill_delta == TRUE) {
+        nomadikXVPrivMemFill( a_this, delta_x, delta_y, delta_w, delta_h);
+    }
+*/
+
+    a_tile_info->offset.x_offset = real_x;
+    a_tile_info->offset.y_offset = real_y;
+    a_tile_info->image.width = real_w;
+    a_tile_info->image.height = real_h;
+
+    if((a_tile_info->offset.x_offset+a_tile_info->image.width)>a_this->drw_w) {
+        a_tile_info->image.width = a_this->drw_w-a_tile_info->offset.x_offset;
+    }
+
+    if((a_tile_info->offset.y_offset+a_tile_info->image.height)>a_this->drw_h) {
+        a_tile_info->image.height = a_this->drw_h-a_tile_info->offset.y_offset;
+    }
+
+    NOMADIK_MLOG("Aligned rect:\n"
+               "X:%d, Y:%d, "
+                "W:%d, H:%d\n",
+                a_tile_info->offset.x_offset,
+                a_tile_info->offset.y_offset,
+                a_tile_info->image.width,
+                a_tile_info->image.height) ;
+
+
+}
+
+Bool
+nomadikXVPrivUpdateSVAClippingRegion (NomadikXVPriv *a_this)
+{
+    Bool result=TRUE ;
+    int i=0, num=0, width=0, height=0, skip_height=0, num_ppp_tile=0;
+    BoxPtr rects;
+    struct sva_ppp_tile_info *next;
+    struct sva_ppp_tile_info *temp;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (a_this, FALSE) ;
+
+    next = &(a_this->ppp_tile_list);
+    temp =  next;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (next->next_tile) {
+        //NOMADIK_LOG("clean the previous ppp list first\n");
+        next=next->next_tile;
+
+        for(i=0; ;i++){
+            if(next){
+                temp=next;
+                next=next->next_tile;
+                free(temp);
+            } else
+                break;
+        }
+
+    /*
+          *  reset the pointers
+          */
+        next = &(a_this->ppp_tile_list);
+        temp = next;
+
+    }
+
+    /* make the end of list NULL */
+    next->next_tile=NULL;
+
+    /*
+     * Get the number of clipping region and convert it to ppp tiles to be used by SVA for display
+     */
+    NOMADIK_LOG("number of clipping region: %d\n", REGION_NUM_RECTS(&a_this->clipping_region));
+
+    num = REGION_NUM_RECTS(&a_this->clipping_region);
+    rects = REGION_RECTS(&a_this->clipping_region);
+
+    /*
+      * check if there is no overlay, disable the PPP tile
+      * service by making h & w as zero
+      * if there is only one clipping region this means there
+      * is no overlay. So calculate the h and w of the clipping
+      * region and check with the actual display h & w.
+      */
+    if(num == 1) {
+
+        /* this is a hack to switch from full screen to normal mode */
+        if(rects[0].y1 == 130) rects[0].y1 = 0;
+
+       NOMADIK_MLOG("one clip: \n"
+               "cp_x1:%d, cp_y1:%d, "
+                "cp_x2:%d, cp_y2:%d\n",
+                rects[0].x1,
+                rects[0].y1,
+                rects[0].x2,
+                rects[0].y2) ;
+
+        next->offset.x_offset = ALIGN_TO_16MULTI(rects[0].x1);
+        next->offset.y_offset = ALIGN_TO_16MULTI(rects[0].y1);
+        next->offset.x_offset -= a_this->simple_clipping_rect.x1;
+        next->offset.y_offset -= a_this->simple_clipping_rect.y1;
+
+        /* h & w of the clipping region */
+        height = (rects[0].y2 - rects[0].y1);
+        next->image.height = ALIGN_TO_16MULTI(height);
+        width = (rects[0].x2 - rects[0].x1);
+        next->image.width = ALIGN_TO_16MULTI(width);
+
+        /* h & w of display image */
+//        height = (a_this->simple_clipping_rect.y2-a_this->simple_clipping_rect.y1);
+//        width = (a_this->simple_clipping_rect.x2-a_this->simple_clipping_rect.x1);
+
+        if((next->image.height >= a_this->drw_h) && (next->image.width >= a_this->drw_w)){
+            next->image.height = 0;
+            next->image.width = 0;
+        }
+
+        if(a_this->resize_enable) {
+            /* if resize is happening then check the actual cordinates
+              * 16 pixel alignment
+              */
+            nomadikXVPrivAlignResizeRect(a_this, next);
+        }
+
+        /* since there is no more clipping region we can return */
+        goto out;
+
+    }
+
+    for (i = 0; i != num; i++) {
+       NOMADIK_MLOG("clipping: %d:\n"
+               "cp_x1:%d, cp_y1:%d, "
+                "cp_x2:%d, cp_y2:%d\n", i,
+                rects[i].x1,
+                rects[i].y1,
+                rects[i].x2,
+                rects[i].y2) ;
+
+        if( ( (rects[i].x2 - rects[i].x1) > PIXEL_16_VALUE) && \
+             ( (rects[i].y2 - rects[i].y1) > PIXEL_16_VALUE) ) {
+
+            /* increase the number of PPP tiles in the list */
+            if(num_ppp_tile < MAX_NUM_OF_PPP_PIECES) {
+                num_ppp_tile++;
+            } else {
+                NOMADIK_LOG_ERROR ("number of PPP tile exceeded maximum value\n") ;
+                result=FALSE;
+                goto out;
+            }
+
+            if(!temp) {
+                temp = (struct sva_ppp_tile_info *) \
+					malloc(sizeof(struct sva_ppp_tile_info));
+                if(!temp) {
+                    NOMADIK_LOG_ERROR ("failed to allocate new tile\n") ;
+                    result=FALSE;
+                    goto out;
+                }
+                temp->next_tile = NULL;
+                next->next_tile = temp;
+                next=next->next_tile;
+            }
+
+            /* if any less than 16 rectangle is skipped the skip height will
+              * have the value otherwise it will be zero
+              * To avoid gap in between the rects include the skipped rect height.
+              */
+            next->offset.y_offset -= skip_height;
+            skip_height=0;
+
+            /* convert the rect (x1, y1, x1, y2) to tile (x ,y , w, h).
+              * Here y1 in rect is wrt screen origin (0,0). The tile origin(0,0)
+              * is at the x,y of the display image.
+              * So align the y cordinat accordingly.
+              */
+            next->offset.x_offset = ALIGN_TO_16MULTI(rects[i].x1);
+            next->offset.y_offset = ALIGN_TO_16MULTI(rects[i].y1);
+            next->offset.x_offset -= a_this->simple_clipping_rect.x1;
+            next->offset.y_offset -= a_this->simple_clipping_rect.y1;
+            height = (rects[i].y2 - rects[i].y1);
+            next->image.height = ALIGN_TO_16MULTI(height);
+            width = (rects[i].x2 - rects[i].x1);
+            next->image.width = ALIGN_TO_16MULTI(width);
+
+            if(a_this->resize_enable) {
+                next->offset.x_offset = rects[i].x1 - a_this->simple_clipping_rect.x1;
+                next->offset.y_offset = rects[i].y1 - a_this->simple_clipping_rect.y1;
+                next->image.height = rects[i].y2 - rects[i].y1;
+                next->image.width = rects[i].x2 - rects[i].x1;
+            } else {
+                next->offset.x_offset = ALIGN_TO_16MULTI(rects[i].x1);
+                next->offset.y_offset = ALIGN_TO_16MULTI(rects[i].y1);
+                next->offset.x_offset -= a_this->simple_clipping_rect.x1;
+                next->offset.y_offset -= a_this->simple_clipping_rect.y1;
+                height = (rects[i].y2 - rects[i].y1);
+                next->image.height = ALIGN_TO_16MULTI(height);
+                width = (rects[i].x2 - rects[i].x1);
+                next->image.width = ALIGN_TO_16MULTI(width);
+	    }
+
+            NOMADIK_MLOG("ppp tile: %d:\n"
+               "x_off:%d, y_off:%d, "
+                "h:%d, w:%d\n", i,
+                next->offset.x_offset ,
+                next->offset.y_offset,
+                next->image.height,
+                next->image.width) ;
+
+            if(a_this->resize_enable) {
+               /* if resize is happening then check the actual cordinates
+                 * 16 pixel alignment
+                 */
+                nomadikXVPrivAlignResizeRect(a_this, next);
+            }
+
+            temp = next->next_tile;
+
+        } else {
+            /*
+              *  we cannot display anything with height/width
+              *  less than 16 so presently skip this.
+     */
+
+            /* Let us not neglect the height it may give gap between 2 tiles */
+            skip_height+=(rects[i].y2 - rects[i].y1);
+
+            NOMADIK_LOG("Region %d with height %d (less than 16) skipping!!!\n", i, skip_height);
+        }
+    }
+
+
+out:
+    NOMADIK_LOG ("leave\n") ;
+    return result ;
+}
+
+void
+nomadikXVPrivFreeMembers (NomadikXVPriv *a_this)
+{
+    if (!a_this)
+        return ;
+    if (a_this->sva) {
+        svaDelete (a_this->sva) ;
+        a_this->sva = NULL ;
+    }
+    if (a_this->pp_services_tab) {
+        xfree (a_this->pp_services_tab) ;
+        a_this->pp_services_tab = NULL ;
+        a_this->pp_services_tab_size = 0 ;
+        a_this->nb_pp_services = 0 ;
+    }
+}
+
+Bool
+nomadikInitVideo(ScreenPtr pScreen, Bool is2DAccel)
+{
+    KdScreenPriv(pScreen);
+    KdScreenInfo *screen = pScreenPriv->screen;
+    KdVideoAdaptorPtr *adaptors=NULL,
+                       *newAdaptors = NULL;
+    KdVideoAdaptorPtr newAdaptor = NULL;
+    int num_adaptors;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (screen->fb[0].bitsPerPixel != 8) {
+        newAdaptor = nomadikSetupImageVideo(pScreen, is2DAccel);
+    }
+
+    num_adaptors = KdXVListGenericAdaptors(screen, &adaptors);
+
+    if (newAdaptor) {
+        if (!num_adaptors) {
+            num_adaptors = 1;
+            adaptors = &newAdaptor;
+        } else {
+            newAdaptors =
+                xrealloc(adaptors,
+                         (num_adaptors + 1) * sizeof(KdVideoAdaptorPtr*));
+            if (newAdaptors) {
+                adaptors = newAdaptors ;
+                adaptors[num_adaptors] = newAdaptor;
+                num_adaptors++;
+            }
+        }
+    }
+
+    if (num_adaptors) {
+        KdXVScreenInit(pScreen, adaptors, num_adaptors);
+        NOMADIK_LOG ("initialized video adaptor okay\n") ;
+    } else {
+        NOMADIK_LOG_ERROR ("no video adaptor was initialized\n") ;
+    }
+
+    NOMADIK_LOG ("leave\n") ;
+    return TRUE;
+}
+
+static KdVideoAdaptorPtr
+nomadikSetupImageVideo(ScreenPtr pScreen, Bool is2DAccel)
+{
+    KdScreenPriv(pScreen);
+    KdScreenInfo *screen = pScreenPriv->screen;
+    NomadikXVPriv *xvPriv=NULL;
+    KdVideoAdaptorPtr adaptor=NULL ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    /*
+     * allocate enough room so that:
+     * 1/ memory ranging from &adaptor[0] to &adaptor[1]
+     *    can be used to store the video
+     *    adaptor information,
+     * 2/ memory ranging from &adaptor[1] onward can be used for other stuff,
+     *    like adaptor->pPortPrivates etc ...
+     */
+    adaptor = xcalloc(1, sizeof (KdVideoAdaptorRec) +
+                         sizeof (DevUnion) +
+                         sizeof (NomadikXVPriv)) ;
+    if (!adaptor) {
+        NOMADIK_LOG_ERROR("failed to allocate video adaptor\n") ;
+        goto error ;
+    }
+
+    /*
+     * set adaptor members
+     */
+    adaptor->type = XvWindowMask | XvInputMask | XvImageMask;
+    adaptor->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
+    adaptor->name = "Nomadik Video Accelerator";
+    adaptor->nEncodings = 1 ;
+    adaptor->pEncodings = DummyEncoding ;
+    adaptor->nFormats = NUM_FORMATS ;
+    adaptor->pFormats = formats ;
+    adaptor->nPorts = 1 ;
+    adaptor->pPortPrivates = (DevUnion*)(&adaptor[1]) ;
+    /*
+     * allocate xvPriv to a memory region that will
+     * be de-allocated when the adaptor get freed.
+     */
+    xvPriv = (NomadikXVPriv*)&adaptor->pPortPrivates[1];
+    /*
+     * adaptor->pPortPrivate[n].ptr must hold
+     * port priv data of the nth port of that adaptor.
+     */
+    adaptor->pPortPrivates[0].ptr = xvPriv ;
+    adaptor->nAttributes = NUM_ATTRIBUTES;
+    adaptor->pAttributes = attributes;
+    adaptor->nImages = NUM_IMAGES ;
+    adaptor->pImages = images ;
+    adaptor->PutVideo = NULL ;
+    adaptor->PutStill = NULL ;
+    adaptor->GetVideo = NULL ;
+    adaptor->GetStill = NULL ;
+    adaptor->StopVideo = nomadikStopVideo ;
+    adaptor->SetPortAttribute = nomadikSetPortAttribute ;
+    adaptor->GetPortAttribute = nomadikGetPortAttribute ;
+    adaptor->QueryBestSize = nomadikQueryBestSize ;
+    adaptor->PutImage = nomadikPutImage ;
+    adaptor->ReputImage = NULL;
+    adaptor->QueryImageAttributes = nomadikQueryImageAttributes ;
+
+    /***************************
+     * <init xvPriv attributes>
+     ***************************/
+    xvPriv->sva_params.brightness = 50 ;//80
+    xvPriv->sva_params.contrast = 50 ; //60
+    xvPriv->sva_params.dithering = TRUE ;
+    xvPriv->sva_params.color_depth = BITS_24 ;
+    xvPriv->sva_params.chroma_sampling_format = DEFAULT_SAMPLING_FORMAT ;
+    xvPriv->sva_params.red_blue_swap = 0;
+    xvPriv->sva_params.alpha_key = 0;
+    /*
+     * create the sva object
+     */
+    if (!nomadikXVPrivCreateSVA (xvPriv)) {
+        NOMADIK_LOG_ERROR ("failed to create nomadik SVA\n") ;
+        goto error;
+    }
+    if (!xvPriv->sva) {
+        NOMADIK_LOG_ERROR ("failed to create nomadik SVA\n") ;
+        goto error ;
+    }
+    REGION_INIT (pScreen, &xvPriv->clipping_region, NullBox, 0) ;
+
+    /***************************
+     * </init xvPriv attributes>
+     ***************************/
+
+    xvBrightness = MAKE_ATOM ("XV_BRIGHTNESS") ;
+    xvContrast = MAKE_ATOM ("XV_CONTRAST") ;
+    xvDithering = MAKE_ATOM ("XV_DITHERING") ;
+    NOMADIK_LOG ("leave: xvPriv:%#x, xvPriv->sva:%#x, xvPriv->sva->fd:%d\n",
+                 xvPriv, xvPriv->sva, xvPriv->sva->fd) ;
+
+    /***************************
+     * </init xvPriv global variables>
+     ***************************/
+    xvPriv->prev_buffid=-1;
+    xvPriv->dst_pixmap=NULL;
+    xvPriv->mem_base=NULL;
+    xvPriv->is2DAccel=is2DAccel;
+
+    return adaptor ;
+
+error:
+    if (adaptor) {
+        xfree(adaptor) ;
+    }
+    NOMADIK_LOG ("leave\n") ;
+    return NULL ;
+}
+
+static void
+nomadikStopVideo (KdScreenInfo *screen,
+                  pointer data,
+                  Bool exit)
+{
+    NomadikXVPriv *xvPriv = data ;
+
+    NOMADIK_LOG("enter\n") ;
+    if (exit) {
+        NOMADIK_LOG ("freeing sva cur buffer...\n") ;
+        nomadikXVPrivFreeSVABuffer (xvPriv) ;
+        NOMADIK_LOG ("sva cur buffer freed\n") ;
+        REGION_EMPTY (screen->pScreen,
+                      &xvPriv->clipping_region) ;
+    } else {
+        NOMADIK_LOG ("nothing to be done\n") ;
+    }
+    NOMADIK_LOG("leave\n") ;
+}
+
+static int
+nomadikSetPortAttribute (KdScreenInfo *screen,
+                         Atom attribute,
+                         int value,
+                         pointer data)
+{
+    NomadikXVPriv *xvPriv = data ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (xvPriv, BadValue) ;
+
+    NOMADIK_LOG ("enter\n") ;
+
+    if (attribute == xvBrightness) {
+        if (value < 0 || value > 100) {
+            NOMADIK_LOG_ERROR ("BadValue\n") ;
+            return BadValue ;
+        }
+        //xvPriv->sva_params.brightness = value ;
+        NOMADIK_LOG ("Brightness set to 50\n") ;
+        xvPriv->sva_params.brightness = 50 ;
+    } else if (attribute == xvContrast) {
+        if (value < 0 || value > 100) {
+            NOMADIK_LOG_ERROR ("BadValue\n") ;
+            return BadValue ;
+        }
+        //xvPriv->sva_params.contrast = value ;
+        NOMADIK_LOG ("COntrast set to 50\n") ;
+        xvPriv->sva_params.contrast = 50 ;
+    } else if (attribute == xvDithering) {
+        if (!value)
+            xvPriv->sva_params.dithering = FALSE;
+        else
+            xvPriv->sva_params.dithering = TRUE;
+    } else {
+        return BadMatch ;
+    }
+
+    /*
+     * now that attribute has been set,
+     * delete all the services that has been
+     * created before with other attributes.
+     * subsequent calls to XvPutImage() will re-create
+     * the necessary services with the proper parameters
+     */
+    nomadikXVPrivClearSVAServices (xvPriv) ;
+    NOMADIK_LOG ("leave\n") ;
+    return Success ;
+}
+
+static int
+nomadikGetPortAttribute (KdScreenInfo *screen,
+                         Atom attribute,
+                         int *value,
+                         pointer data)
+{
+    NomadikXVPriv *xvPriv = data ;
+
+    NOMADIK_RETURN_VAL_IF_FAIL (xvPriv, BadMatch) ;
+
+    NOMADIK_LOG("enter\n") ;
+
+    if (!value)
+        return BadMatch ;
+
+    if (attribute == xvBrightness) {
+        *value = xvPriv->sva_params.brightness ;
+    } else if (attribute == xvContrast) {
+        *value = xvPriv->sva_params.contrast ;
+    } else if (attribute == xvDithering) {
+        *value = xvPriv->sva_params.dithering ;
+    } else {
+        return BadMatch ;
+    }
+    NOMADIK_LOG("leave\n") ;
+    return Success ;
+}
+
+static void
+nomadikQueryBestSize (KdScreenInfo *screen,
+                      Bool motion,
+                      short vid_w,
+                      short vid_h,
+                      short drw_w,
+                      short drw_h,
+                      unsigned int *p_w,
+                      unsigned int *p_h,
+                      pointer data)
+{
+    NOMADIK_LOG ("enter\n") ;
+    *p_w = drw_w;
+    *p_h = drw_h;
+    NOMADIK_LOG ("leave\n") ;
+}
+
+static int
+nomadikPutImage (KdScreenInfo *pScreen,
+                 DrawablePtr pDraw,
+                 short src_x,
+                 short src_y,
+                 short drw_x,
+                 short drw_y,
+                 short src_w,
+                 short src_h,
+                 short drw_w,
+                 short drw_h,
+                 int id,
+                 unsigned char *buf,
+                 short width,
+                 short height,
+                 Bool sync,
+                 RegionPtr clipBoxes,
+                 pointer data)
+{
+    NomadikXVPriv *xvPriv=NULL;
+    int result=BadValue ;
+    BoxPtr rects;
+
+    xvPriv = (NomadikXVPriv*) data ;
+    NOMADIK_RETURN_VAL_IF_FAIL(xvPriv, BadValue) ;
+
+    /* get the pixmap pointer and memory base */
+    if(xvPriv->is2DAccel == FALSE) {
+	    xvPriv->dst_pixmap= (PixmapPtr)(pDraw);
+    } else {
+	    xvPriv->dst_pixmap= exaGetDrawablePixmap (pDraw);
+    }
+    xvPriv->mem_base= pScreen->memory_base;
+
+
+    if(drw_w > IMAGE_MAX_WIDTH) drw_w = IMAGE_MAX_WIDTH;
+    if(drw_h > IMAGE_MAX_HEIGHT) drw_h = IMAGE_MAX_HEIGHT;
+
+    /* check whether resize if done or not */
+    if( (src_w ==  drw_w) && (src_h == drw_h) ) {
+        xvPriv->resize_enable=FALSE;
+    } else {
+        xvPriv->resize_enable=TRUE;
+    }
+    if(drw_y == 130) goto out;
+    /* this is a hack to switch from full screen to normal mode */
+    rects = REGION_RECTS(clipBoxes);
+    if(rects[0].y1 == 130) rects[0].y1 = 0;
+    if(rects[0].x2 == 656) rects[0].x2 = 720;
+    if(drw_w == 656) drw_w = 640;
+
+    /* in case of full screen mode x and y should be 0 */
+    if( (drw_w == IMAGE_MAX_WIDTH) &&  (drw_h == IMAGE_MAX_HEIGHT)) {
+        if(drw_x || drw_y) {
+            drw_x = 0;
+            drw_y = 0;
+        }
+    }
+
+    /*
+     * populate xvPriv with information
+     * about the current yuv frame.
+     * methods of xvPriv will then be able
+     * to work properly.
+     */
+    if (!nomadikXVPrivSaveFrameInfo (xvPriv, pScreen->pScreen, id,
+                                     src_x, src_y, src_w, src_h,
+                                     drw_x, drw_y, drw_w, drw_h,
+                                     width, height, clipBoxes)) {
+        NOMADIK_LOG_ERROR ("failed to save frame info\n") ;
+        result = BadImplementation ;
+        goto out ;
+    }
+
+    NOMADIK_LOG ("xvPriv:%#x, xvPriv->sva:%#x, xvPriv->sva->fd:%d\n",
+                 xvPriv,
+                 xvPriv->sva,
+                 xvPriv->sva->fd) ;
+    NOMADIK_RETURN_VAL_IF_FAIL (xvPriv->sva, BadValue) ;
+
+    /*
+     * call the machinery to actually display the frame which info
+     * has been saved earlier in xvPriv.
+     */
+    if (!nomadikXVPrivDisplayFrame (xvPriv, buf)) {
+        NOMADIK_LOG_ERROR ("failed to display yuv buffer\n") ;
+        result = BadImplementation ;
+        goto out ;
+    }
+
+    result= Success ;
+out:
+    NOMADIK_LOG("leave\n") ;
+    return result ;
+}
+
+static int
+nomadikQueryImageAttributes (KdScreenInfo *screen,
+                             int id,
+                             unsigned short *w,
+                             unsigned short *h,
+                             int *pitches,
+                             int *offsets)
+{
+    int size=0, tmp=0;
+
+    NOMADIK_LOG("enter\n") ;
+
+    NOMADIK_LOG ("id:%d, w:%#x, h:%#x, pitches:%#x, offsets:%#x\n",
+                 id, w, h, pitches, offsets) ;
+
+    if (w && (*w > IMAGE_MAX_WIDTH))
+        *w = IMAGE_MAX_WIDTH;
+    if (h && (*h > IMAGE_MAX_HEIGHT))
+        *h = IMAGE_MAX_HEIGHT;
+
+    if (w)
+        *w = (*w + 1) & ~1;
+    if (offsets) offsets[0] = 0;
+
+    NOMADIK_LOG ("id:%x, w:%d, h:%d\n", id, *w, *h) ;
+
+    switch (id) {
+        case GUID_ST_YUV420_MACRO_BLOCK:
+	    if (pitches) pitches[0] = 0;
+            size = sizeof(struct st_yuvmb_frame_desc_t);
+            break;
+        case GUID_ST_YUV420_MACRO_BLOCK2:
+	    if (pitches) pitches[0] = 0;
+            size = (*w)*(*h)*3/2;
+            break;
+        case FOURCC_YV12:
+        case FOURCC_I420:
+            if (h) {
+                *h = (*h + 1) & ~1;
+            }
+            size = (*w + 3) & ~3;
+            if (pitches) pitches[0] = size;
+            size *= *h;
+            if (offsets) offsets[1] = size;
+            tmp = ((*w >> 1) + 3) & ~3;
+            if (pitches) pitches[1] = pitches[2] = tmp;
+            tmp *= (*h >> 1);
+            size += tmp;
+            if (offsets) offsets[2] = size;
+            size += tmp;
+            break;
+        case FOURCC_UYVY:
+        case FOURCC_YUY2:
+        default:
+            size = *w << 1;
+            if (pitches) pitches[0] = size;
+            size *= *h;
+            break;
+    }
+    NOMADIK_LOG("leave:%d\n",size) ;
+    return size ;
+}
+
+/**
+ * Given a source image (in a source buffer), a source rectangle in that image,
+ * a destination rectangle (in a drawable), and a cliping region in that
+ * destination, scale the source rectangle and clip the destination rectangle.
+ *
+ * The clipped destination rectangle is to contain the part of the source image
+ * that is contained in the source rectangle that has been scaled to fit into
+ * that clipped destination rectangle.
+ *
+ * @param dst in/out parameter. Destination rectangle in the drawable
+ *        The resulting rectangle - resulting from cliping - is returned here.
+ * @param x1 in/out parameter. absissa of the top-left point of the
+ *       rectangle in source img buffer. The resulting x1 - after scaling of
+ *       the source rectangle - is returned here.
+ * @param x2 in/out parameter. Absissa of the bottom-right point of
+ *        the rectangle in source img buffer. The resulting x2 - after scaling
+ *        of the source rectangle - is returned here.
+ * @param y1 in/out parameter. Ordinate of the top-left point of the
+ *        rectangle in source img buffer. The resulting y1 - after scaling of
+ *        the source rectangle - is returned here.
+ * @param y2 in/out parameter ordinate of the bottom-right point of
+ *        the rectangle in source img buffer. The resulting y2 - after scaling
+ *        of the of the source rectangle - is returned here.
+ * @param extents extends of the clip region in the drawable (destination)
+ * @param width width of the source image in the source buffer
+ * @param height height of the source image in source buffer
+ *
+ */
+static void
+nomadikClipVideo (BoxPtr dst,/*destination box, in the drawable*/
+                  INT32 *x1, /*src x1, in the source buffer*/
+                  INT32 *x2, /*src x2, in the source buffer*/
+                  INT32 *y1, /*src y1, in the source buffer*/
+                  INT32 *y2, /*src y2, in the source buffer*/
+                  BoxPtr extents,/*extents of the clip region, in the drawable*/
+                  INT32 width, /*initial width of source image.*/
+                  INT32 height /*initial height of source image.*/
+                  /*
+                   * {x1,y1,x2,y2} can have width/height different
+                   * from width/height. In that case, {x1,y1,x2,y2}
+                   * represents a rectangle to which the source image
+                   * has been scaled and cliped. Note that there is also some
+                   * cliping that happens in the destination drawable.
+                   */
+                  )
+{
+    INT32 vscale, hscale, delta;
+    int diff;
+
+    NOMADIK_LOG ("enter:\n"
+                 "x1:%d, x2:%d, y1:%d, y2:%d\n"
+                 "dst.x1:%d, dst.x2:%d, dst.y1:%d, dst.y2:%d\n"
+                 "ext.x1:%d, ext.x2:%d, ext.y1:%d, ext.y2:%d\n"
+                 "w:%d, h:%d\n",
+                 *x1, *x2, *y1, *y2,
+                 dst->x1, dst->x2, dst->y1, dst->y2,
+                 extents->x1, extents->x2, extents->y1, extents->y2,
+                 width, height) ;
+
+    hscale = (*x2 - *x1) / (dst->x2 - dst->x1);
+    vscale = (*y2 - *y1) / (dst->y2 - dst->y1);
+
+    diff = extents->x1 - dst->x1;
+    if(diff > 0) {
+        dst->x1 = extents->x1;
+        *x1 += diff * hscale;
+    }
+    diff = dst->x2 - extents->x2;
+    if(diff > 0) {
+        dst->x2 = extents->x2;
+        *x2 -= diff * hscale;
+    }
+    diff = extents->y1 - dst->y1;
+    if(diff > 0) {
+        dst->y1 = extents->y1;
+        *y1 += diff * vscale;
+    }
+    diff = dst->y2 - extents->y2;
+    if(diff > 0) {
+        dst->y2 = extents->y2;
+        *y2 -= diff * vscale;
+    }
+
+    if(*x1 < 0) {
+        diff =  (- *x1 + hscale - 1)/ hscale;
+        dst->x1 += diff;
+        *x1 += diff * hscale;
+    }
+    delta = *x2 - width ;
+    if(delta > 0) {
+        diff = (delta + hscale - 1)/ hscale;
+        dst->x2 -= diff;
+        *x2 -= diff * hscale;
+    }
+    if(*y1 < 0) {
+        diff =  (- *y1 + vscale - 1)/ vscale;
+        dst->y1 += diff;
+        *y1 += diff * vscale;
+    }
+
+    delta = *y2 - height;
+    if(delta > 0) {
+        diff = (delta + vscale - 1)/ vscale;
+        dst->y2 -= diff;
+        *y2 -= diff * vscale;
+    }
+    NOMADIK_LOG ("enter:\n"
+                 "x1:%d, x2:%d, y1:%d, y2:%d\n"
+                 "dst.x1:%d, dst.x2:%d, dst.y1:%d, dst.y2:%d\n"
+                 "ext.x1:%d, ext.x2:%d, ext.y1:%d, ext.y2:%d\n"
+                 "w:%d, h:%d\n",
+                 *x1, *x2, *y1, *y2,
+                 dst->x1, dst->x2, dst->y1, dst->y2,
+                 extents->x1, extents->x2, extents->y1, extents->y2,
+                 width, height) ;
+}
+
--- /dev/null
+++ xorg-server-1.3.0.0/hw/kdrive/nomadik/nomadik-video.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright ST Microelectronics.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of ST Microelectronics not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  ST Microelectronics makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ST Microelectronics DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ST Microelectronics BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Dodji Seketeli <dodji@openedhand.com>
+ */
+
+Bool nomadikInitVideo(ScreenPtr pScreen, Bool is2DAccel) ;
--- xorg-server-1.3.0.0.orig/hw/kdrive/src/kdrive.c
+++ xorg-server-1.3.0.0/hw/kdrive/src/kdrive.c
@@ -41,10 +41,12 @@
 
 #ifdef DPMSExtension
 #include "dpmsproc.h"
 #endif
 
+int use_evdev = 0;
+
 typedef struct _kdDepths {
     CARD8   depth;
     CARD8   bpp;
 } KdDepths;
 
@@ -56,10 +58,13 @@ KdDepths    kdDepths[] = {
     { 16, 16 },
     { 24, 32 },
     { 32, 32 }
 };
 
+int
+ProcXFixesHideCursor (ClientPtr client) ;
+
 #define NUM_KD_DEPTHS (sizeof (kdDepths) / sizeof (kdDepths[0]))
 
 int                 kdScreenPrivateIndex;
 unsigned long       kdGeneration;
 
@@ -70,10 +75,11 @@ Bool		    kdRawPointerCoordinates;
 Bool		    kdDisableZaphod;
 Bool                kdDontZap;
 Bool		    kdEnabled;
 int		    kdSubpixelOrder;
 int		    kdVirtualTerminal = -1;
+char		    *kdKeyboard = 0;
 Bool		    kdSwitchPending;
 char		    *kdSwitchCmd;
 DDXPointRec	    kdOrigin;
 
 /*
@@ -82,10 +88,13 @@ DDXPointRec	    kdOrigin;
  */
 
 KdOsFuncs	*kdOsFuncs;
 extern WindowPtr *WindowTable;
 
+extern Bool CursorInitiallyHidden; /* See Xfixes cursor.c */
+extern char* RootPPM;		   /* dix/window.c */
+
 void
 KdSetRootClip (ScreenPtr pScreen, BOOL enable)
 {
 #ifndef FB_OLD_SCREEN
     WindowPtr	pWin = WindowTable[pScreen->myNum];
@@ -310,10 +319,11 @@ KdEnableScreen (ScreenPtr pScreen)
 	(*pScreenPriv->card->cfuncs->enableAccel) (pScreen);
     KdEnableColormap (pScreen);
     KdSetRootClip (pScreen, TRUE);
     if (pScreenPriv->card->cfuncs->dpms)
 	(*pScreenPriv->card->cfuncs->dpms) (pScreen, pScreenPriv->dpmsState);
+
     return TRUE;
 }
 
 void
 KdResume (void)
@@ -682,16 +692,21 @@ KdUseMsg (void)
     ErrorF("-dumb            Disable hardware acceleration\n");
     ErrorF("-softCursor      Force software cursor\n");
     ErrorF("-videoTest       Start the server, pause momentarily and exit\n");
     ErrorF("-origin X,Y      Locates the next screen in the the virtual screen (Xinerama)\n");
     ErrorF("-mouse path[,n]  Filename of mouse device, n is number of buttons\n");
+    ErrorF("-use-evdev       Use Linux evdev input\n");
     ErrorF("-switchCmd       Command to execute on vt switch\n");
     ErrorF("-nozap           Don't terminate server on Ctrl+Alt+Backspace\n");
+    ErrorF("-hide-cursor     Start with cursor hidden\n");
+    ErrorF("-root-ppm [path] Specify ppm file to use as root window background.\n");
     ErrorF("vtxx             Use virtual terminal xx instead of the next available\n");
 #ifdef PSEUDO8
     p8UseMsg ();
 #endif
+
+
 }
 
 int
 KdProcessArgument (int argc, char **argv, int i)
 {
@@ -759,10 +774,23 @@ KdProcessArgument (int argc, char **argv
     if (!strcmp (argv[i], "-softCursor"))
     {
 	kdSoftCursor = TRUE;
 	return 1;
     }
+    if (!strcmp (argv[i], "-hide-cursor"))
+    {
+      CursorInitiallyHidden = TRUE;
+      return 1;
+    }
+    if (!strcmp (argv[i], "-root-ppm"))
+    {
+      if ((i+1) < argc)
+	RootPPM =  argv[i+1];
+      else
+	UseMsg ();
+      return 2;
+    }
     if (!strcmp (argv[i], "-videoTest"))
     {
 	kdVideoTest = TRUE;
 	return 1;
     }
@@ -791,10 +819,23 @@ KdProcessArgument (int argc, char **argv
 	    KdParseMouse (argv[i+1]);
 	else
 	    UseMsg ();
 	return 2;
     }
+    if (!strcmp (argv[i], "-use-evdev"))
+    {
+	use_evdev = 1;
+	return 1;
+    }
+    if (!strcmp (argv[i], "-keyboard"))
+    {
+	if ((i+1) < argc)
+	    kdKeyboard = argv[i+1];
+	else
+	    UseMsg ();
+	return 2;
+    }
     if (!strcmp (argv[i], "-rgba"))
     {
 	if ((i+1) < argc)
 	    KdParseRgba (argv[i+1]);
 	else
--- xorg-server-1.3.0.0.orig/hw/kdrive/src/kdrive.h
+++ xorg-server-1.3.0.0/hw/kdrive/src/kdrive.h
@@ -414,10 +414,11 @@ extern Bool		kdEnabled;
 extern Bool		kdSwitchPending;
 extern Bool		kdEmulateMiddleButton;
 extern Bool		kdDisableZaphod;
 extern Bool		kdDontZap;
 extern int		kdVirtualTerminal;
+extern char		*kdKeyboard;
 extern char		*kdSwitchCmd;
 extern KdOsFuncs	*kdOsFuncs;
 
 #define KdGetScreenPriv(pScreen) ((KdPrivScreenPtr) \
 				  (pScreen)->devPrivates[kdScreenPrivateIndex].ptr)
@@ -743,10 +744,13 @@ KdSetLed (int led, Bool on);
 
 void
 KdSetMouseMatrix (KdMouseMatrix *matrix);
 
 void
+KdScreenToMouseCoords (int *x, int *y);
+
+void
 KdComputeMouseMatrix (KdMouseMatrix *matrix, Rotation randr, int width, int height);
     
 void
 KdBlockHandler (int		screen,
 		pointer		blockData,
@@ -767,18 +771,19 @@ KdEnableInput (void);
 
 void
 ProcessInputEvents (void);
 
 extern KdMouseFuncs	LinuxMouseFuncs;
-extern KdMouseFuncs	LinuxEvdevFuncs;
+extern KdMouseFuncs	LinuxEvdevMouseFuncs;
 extern KdMouseFuncs	Ps2MouseFuncs;
 extern KdMouseFuncs	BusMouseFuncs;
 extern KdMouseFuncs	MsMouseFuncs;
 #ifdef TOUCHSCREEN
 extern KdMouseFuncs	TsFuncs;
 #endif
 extern KdKeyboardFuncs	LinuxKeyboardFuncs;
+extern KdKeyboardFuncs	LinuxEvdevKeyboardFuncs;
 extern KdOsFuncs	LinuxFuncs;
 
 extern KdMouseFuncs	VxWorksMouseFuncs;
 extern KdKeyboardFuncs	VxWorksKeyboardFuncs;
 extern KdOsFuncs	VxWorksFuncs;
--- xorg-server-1.3.0.0.orig/hw/kdrive/src/kinput.c
+++ xorg-server-1.3.0.0/hw/kdrive/src/kinput.c
@@ -379,10 +379,22 @@ KdSetMouseMatrix (KdMouseMatrix *matrix)
 {
     kdMouseMatrix = *matrix;
 }
 
 void
+KdScreenToMouseCoords (int *x, int *y)
+{
+    int	(*m)[3] = kdMouseMatrix.matrix;
+    int div = m[0][1] * m[1][0] - m[1][1] * m[0][0];
+    int sx = *x;
+    int sy = *y;
+
+    *x = (m[0][1] * sy - m[0][1] * m[1][2] + m[1][1] * m[0][2] - m[1][1] * sx) / div;
+    *y = (m[1][0] * sx + m[0][0] * m[1][2] - m[1][0] * m[0][2] - m[0][0] * sy) / div;
+}
+
+void
 KdComputeMouseMatrix (KdMouseMatrix *m, Rotation randr, int width, int height)
 {
     int		    x_dir = 1, y_dir = 1;
     int		    i, j;
     int		    size[2];
@@ -1301,10 +1313,11 @@ KdEnqueueKeyboardEvent(unsigned char	sca
 	    xE.u.u.type = KeyRelease;
 	else
 	    xE.u.u.type = KeyPress;
 	xE.u.u.detail = key_code;
 	
+#ifndef XKB
 	switch (KEYCOL1(key_code)) 
 	{
 	case XK_Num_Lock:
 	case XK_Scroll_Lock:
 	case XK_Shift_Lock:
@@ -1314,10 +1327,11 @@ KdEnqueueKeyboardEvent(unsigned char	sca
 	    if (IsKeyDown (key_code))
 		xE.u.u.type = KeyRelease;
 	    else
 		xE.u.u.type = KeyPress;
 	}
+#endif
 	
 	/*
 	 * Check pressed keys which are already down
 	 */
 	if (IsKeyDown (key_code) && xE.u.u.type == KeyPress)
--- xorg-server-1.3.0.0.orig/hw/kdrive/src/kmode.c
+++ xorg-server-1.3.0.0/hw/kdrive/src/kmode.c
@@ -30,19 +30,49 @@
 
 const KdMonitorTiming  kdMonitorTimings[] = {
     /*	H	V	Hz	KHz */
 		/*  FP	    BP	    BLANK   POLARITY */
 
+	/* Treo 650 */
+
+    {   320,	320,	64,	16256,
+	            17,	    12,	    32,     KdSyncNegative,
+	            1,      11,     14,     KdSyncNegative,
+    },
+
+    {   320,	320,	64,	    0,
+	            0,	    0,	    0,     KdSyncNegative,
+	            0,      0,      0,     KdSyncNegative,
+    },
+
+	/* LifeDrive/T3/TX modes */
+
+    {   320,	480,	64,	16256,
+	            17,	    12,	    32,     KdSyncNegative,
+	            1,      11,     14,     KdSyncNegative,
+    },
+
+    {   480,	320,	64,	    0,
+	            0,	    0,	    0,     KdSyncNegative,
+	            0,      0,      0,     KdSyncNegative,
+    },
+
+
     /* IPAQ modeline:
      *
      * Modeline "320x240"      5.7222 320 337 340 352   240 241 244 254"
      */
     {   320,	240,	64,	16256,
 	            17,	    12,	    32,     KdSyncNegative,
 	            1,      11,     14,     KdSyncNegative,
     },
     
+    {   240,	320,	64,	    0,
+	            0,	    0,	    0,     KdSyncNegative,
+	            0,      0,      0,     KdSyncNegative,
+    },
+
     /* Other VESA modes */
     {	640,	350,	85,	31500,			    /* VESA */
 		    32,	    96,	    192,    KdSyncPositive, /* 26.413 */
 		    32,	    60,	    95,	    KdSyncNegative, /* 59.354 */
     },
@@ -74,26 +104,38 @@ const KdMonitorTiming  kdMonitorTimings[
     },
     {	640,	480,	72,	31500,			    /* VESA */
 		    16,	    120,    176,    KdSyncNegative, /* 37.861 */
 		    1,	    20,	    24,	    KdSyncNegative, /* 72.809 */
     },
+
+
     {	640,	480,	60,	25175,			    /* VESA */
 		   16,	    48,	    160,    KdSyncNegative, /* 31.469 */
 		   10,	    33,	    45,	    KdSyncNegative, /* 59.940 */
     },
+
+
+  {   480,    640,    60,     0,                      /* VESA */
+               0,      0,     0,    KdSyncNegative, /* 31.469 */
+               0,      0,     0,     KdSyncNegative, /* 59.940 */
+   },
+    /* DEFAULT */
+#define MONITOR_TIMING_DEFAULT	15
+     {	800,	480,	60,	25000,			    /* VESA */
+     214,    39,    254,    KdSyncPositive, /* 90.000 */
+     34,	    10,	    45,	    KdSyncPositive, /* 60.000 */
+     },
     
     /* 800x600 modes */
     {	800,	600,	85,	56250,			    /* VESA */
 		    32,	    152,    248,    KdSyncPositive, /* 53.674 */
 		    1,	    27,	    31,	    KdSyncPositive, /* 85.061 */
     },
     {	800,	600,	75,	49500,			    /* VESA */
 		    16,	    160,    256,    KdSyncPositive, /* 46.875 */
 		    1,	    21,	    25,	    KdSyncPositive, /* 75.000 */
     },
-    /* DEFAULT */
-#define MONITOR_TIMING_DEFAULT	9
     {	800,	600,	72,	50000,			    /* VESA */
 		    56,	    64,	    240,    KdSyncPositive, /* 48.077 */
 		    37,	    23,	    66,	    KdSyncPositive, /* 72.188 */
     },
     {	800,	600,	60,	40000,			    /* VESA */
@@ -243,10 +285,11 @@ const KdMonitorTiming  kdMonitorTimings[
     },
     {	1920,	1440,	60,	234000,			    /* VESA */
 		    128,    244,    680,    KdSyncNegative, /* 90.000 */
 		    1,	    56,	    60,	    KdSyncPositive, /* 60.000 */
     },
+
 };
 
 #define NUM_MONITOR_TIMINGS (sizeof kdMonitorTimings/sizeof kdMonitorTimings[0])
 
 const int kdNumMonitorTimings = NUM_MONITOR_TIMINGS;
@@ -257,10 +300,12 @@ KdFindMode (KdScreenInfo    *screen,
 					  const KdMonitorTiming *))
 {
     int			    i;
     const KdMonitorTiming   *t;
 
+	fprintf (stderr, "%s, %d, %d, %d, %d\n", __FUNCTION__, __LINE__,
+				screen->width, screen->height, screen->rate);
     for (i = 0, t = kdMonitorTimings; i < NUM_MONITOR_TIMINGS; i++, t++)
     {
 	if ((*supported) (screen, t) &&
 	    t->horizontal == screen->width &&
 	    t->vertical == screen->height &&
--- xorg-server-1.3.0.0.orig/include/kdrive-config.h.in
+++ xorg-server-1.3.0.0/include/kdrive-config.h.in
@@ -23,6 +23,9 @@
 #undef TSLIB
 
 /* Verbose debugging output hilarity */
 #undef DEBUG
 
+/* Enable XCalibrate extension */
+#undef XCALIBRATE
+
 #endif /* _KDRIVE_CONFIG_H_ */
--- xorg-server-1.3.0.0.orig/mi/miinitext.c
+++ xorg-server-1.3.0.0/mi/miinitext.c
@@ -370,10 +370,13 @@ extern void RRExtensionInit(INITARGS);
 extern void ResExtensionInit(INITARGS);
 #endif
 #ifdef DMXEXT
 extern void DMXExtensionInit(INITARGS);
 #endif
+#ifdef XCALIBRATE
+extern void XCalibrateExtensionInit(INITARGS);
+#endif
 #ifdef XEVIE
 extern void XevieExtensionInit(INITARGS);
 #endif
 #ifdef XFIXES
 extern void XFixesExtensionInit(INITARGS);
@@ -661,10 +664,13 @@ InitExtensions(argc, argv)
     if (!noCompositeExtension) CompositeExtensionInit();
 #endif
 #ifdef DAMAGE
     if (!noDamageExtension) DamageExtensionInit();
 #endif
+#ifdef  XCALIBRATE
+    XCalibrateExtensionInit ();
+#endif
 }
 
 void
 InitVisualWrap()
 {
--- xorg-server-1.3.0.0.orig/xfixes/cursor.c
+++ xorg-server-1.3.0.0/xfixes/cursor.c
@@ -57,13 +57,16 @@
 static RESTYPE		CursorClientType;
 static RESTYPE		CursorHideCountType;
 static RESTYPE		CursorWindowType;
 static int		CursorScreenPrivateIndex = -1;
 static int		CursorGeneration;
+static Bool             CursorGloballyHidden;
 static CursorPtr	CursorCurrent;
 static CursorPtr        pInvisibleCursor = NULL;
 
+Bool CursorInitiallyHidden = FALSE;
+
 static void deleteCursorHideCountsForScreen (ScreenPtr pScreen);
 
 #define VERIFY_CURSOR(pCursor, cursor, client, access) { \
     pCursor = (CursorPtr)SecurityLookupIDByType((client), (cursor), \
 					RT_CURSOR, (access)); \
@@ -128,11 +131,11 @@ CursorDisplayCursor (ScreenPtr pScreen,
     CursorScreenPtr	cs = GetCursorScreen(pScreen);
     Bool		ret;
 
     Unwrap (cs, pScreen, DisplayCursor);
 
-    if (cs->pCursorHideCounts != NULL) {
+    if (cs->pCursorHideCounts != NULL || CursorGloballyHidden) {
 	ret = (*pScreen->DisplayCursor) (pScreen, pInvisibleCursor);
     } else {
 	ret = (*pScreen->DisplayCursor) (pScreen, pCursor);
     }
 
@@ -847,10 +850,16 @@ ProcXFixesHideCursor (ClientPtr client) 
     if (!pWin) {
 	client->errorValue = stuff->window;
 	return BadWindow;
     }
 
+    /* Is cursor set to be initially hidden ?, if so reset this
+     * flag as now visibility assumed under control of client.
+    */
+    if (CursorGloballyHidden)
+      CursorGloballyHidden = FALSE;
+
     /* 
      * Has client hidden the cursor before on this screen? 
      * If so, just increment the count. 
      */
 
@@ -898,13 +907,23 @@ ProcXFixesShowCursor (ClientPtr client) 
     if (!pWin) {
 	client->errorValue = stuff->window;
 	return BadWindow;
     }
 
+    /* X was started with cursor hidden, therefore just reset our flag
+     * (returning to normal client control) and cause cursor to now be
+     * shown.
+    */
+    if (CursorGloballyHidden == TRUE)
+      {
+	CursorGloballyHidden = FALSE;
+	return (client->noClientException);
+      }
+
     /* 
      * Has client hidden the cursor on this screen?
-     * If not, generate an error.
+     * If so, generate an error.
      */
     pChc = findCursorHideCount(client, pWin->drawable.pScreen);
     if (pChc == NULL) {
 	return BadMatch;
     }
@@ -1008,10 +1027,12 @@ createInvisibleCursor (void)
 
 Bool
 XFixesCursorInit (void)
 {
     int	i;
+
+    CursorGloballyHidden = CursorInitiallyHidden;
     
     if (CursorGeneration != serverGeneration)
     {
 	CursorScreenPrivateIndex = AllocateScreenPrivateIndex ();
 	if (CursorScreenPrivateIndex < 0)
