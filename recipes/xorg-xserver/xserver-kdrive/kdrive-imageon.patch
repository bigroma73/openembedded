# Author: Manuel Teira <manuel.teira@telefonica.net> (sirfred in #oe)
# Description: New driver for the Imageon ATI Card. Implementing:
# -Hardware solid fills
# -Hardware bitblt
# -Hardware cursors
# -XV Extension
# -Internal and External Imageon offscreen memory support
# -Hardware RandR rotation (without using a shadow framebuffer)
# -Support for RandR mode changing

#
# Patch managed by http://www.holgerschurig.de/patcher.html
#

--- xorg-server-X11R7.1-1.1.0.work/configure.ac~kdrive-imageon
+++ xorg-server-X11R7.1-1.1.0.work/configure.ac
@@ -435,6 +435,7 @@
 AC_ARG_ENABLE(kdrive,         AS_HELP_STRING([--enable-kdrive], [Build kdrive servers (default: no)]), [KDRIVE=$enableval], [KDRIVE=no])
 AC_ARG_ENABLE(xephyr,         AS_HELP_STRING([--enable-xephyr], [Build the kdrive Xephyr server (default: auto)]), [XEPHYR=$enableval], [XEPHYR=auto])
 AC_ARG_ENABLE(xsdl,           AS_HELP_STRING([--enable-xsdl], [Build the kdrive Xsdl server (default: auto)]), [XSDL=$enableval], [XSDL=auto])
+AC_ARG_ENABLE(imageon,        AS_HELP_STRING([--enable-imageon], [Build the kdrive Ximageon server (default: no)]), [KDRIVEIMAGEON=$enableval], [KDRIVEIMAGEON=no])
 dnl xprint
 AC_ARG_ENABLE(freetype,       AS_HELP_STRING([ --enable-freetype], [Build Xprint FreeType backend (default: yes)]), [XP_USE_FREETYPE=$enableval],[XP_USE_FREETYPE=no])
 AC_ARG_WITH(freetype-config,  AS_HELP_STRING([ --with-freetype-config=PROG], [Use FreeType configuration program PROG (default: auto)]), freetype_config=$withval, freetype_config=auto)
@@ -1509,6 +1510,11 @@
 AC_SUBST([XSDL_INCS])
 
 
+AM_CONDITIONAL(KDRIVEIMAGEON, [test "x$KDRIVEIMAGEON" = xyes])
+if test "x$KDRIVEIMAGEON" = xyes; then
+        AC_DEFINE(KDRIVEIMAGEON, 1, [Build Ximageon server])
+fi
+
 dnl these only go in xkb-config.h (which is shared by the Xorg and Xnest servers)
 AC_DEFINE(__XKBDEFRULES__, "xorg", [Default XKB rules])
 AC_DEFINE_DIR(XKB_BASE_DIRECTORY, XKBPATH, [Path to XKB data])
@@ -1750,6 +1756,7 @@
 hw/kdrive/epson/Makefile
 hw/kdrive/fake/Makefile
 hw/kdrive/fbdev/Makefile
+hw/kdrive/imageon/Makefile
 hw/kdrive/i810/Makefile
 hw/kdrive/linux/Makefile
 hw/kdrive/mach64/Makefile
--- xorg-server-X11R7.1-1.1.0.work/hw/kdrive/Makefile.am~kdrive-imageon
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/Makefile.am
@@ -1,18 +1,9 @@
-if KDRIVEVESA
-VESA_SUBDIRS = vesa ati chips epson i810 mach64 mga neomagic nvidia pm2 r128 \
-               smi via
-endif
-
 if KDRIVEFBDEV
 FBDEV_SUBDIRS = fbdev
 endif
 
-if XSDLSERVER
-XSDL_SUBDIRS = sdl
-endif
-
-if XEPHYR
-XEPHYR_SUBDIRS = ephyr
+if KDRIVEIMAGEON
+IMAGEON_SUBDIRS = imageon
 endif
 
 SUBDIRS =			\
@@ -20,9 +11,9 @@
 	linux			\
 	$(XSDL_SUBDIRS)		\
 	$(FBDEV_SUBDIRS)	\
+	$(IMAGEON_SUBDIRS)	\
 	$(VESA_SUBDIRS)		\
-	$(XEPHYR_SUBDIRS)       \
-	fake
+	$(XEPHYR_SUBDIRS) 
 
 DIST_SUBDIRS = vesa ati chips epson i810 mach64 mga neomagic nvidia pm2 r128 \
                smi via fbdev sdl ephyr src linux fake sis300
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/Makefile.am
@@ -0,0 +1,47 @@
+if KDRIVEFBDEV
+FBDEV_INCLUDES =-I$(top_srcdir)/hw/kdrive/fbdev
+FBDEV_LIBS = $(top_builddir)/hw/kdrive/fbdev/libfbdev.a
+endif
+
+INCLUDES = 					\
+	@KDRIVE_INCS@				\
+	$(FBDEV_INCLUDES)			\
+	@KDRIVE_CFLAGS@
+
+bin_PROGRAMS = Ximageon
+
+if TSLIB
+TSLIB_FLAG = -lts
+endif
+
+noinst_LIBRARIES = libimageon.a
+
+libimageon_a_SOURCES = 	  \
+	imageon.h	  \
+	imageon_regs.h    \
+	imageon_const.h   \
+	imageon.c	  \
+	imageon_cursor.c  \
+	imageon_draw.c	  \
+	imageon_support.c \
+	imageon_video.c
+
+
+
+Ximageon_SOURCES = \
+	imageon_stub.c
+
+W100_LIBS =				\
+	libimageon.a 			\
+	$(FBDEV_LIBS)			\
+	@KDRIVE_LIBS@
+
+Ximageon_LDADD = \
+	$(W100_LIBS)			\
+	@XSERVER_LIBS@			\
+	$(TSLIB_FLAG)
+
+
+Ximageon_DEPENDENCIES =			\
+        libimageon.a                    \
+        $(FBDEV_LIBS) 
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon.c
@@ -0,0 +1,606 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+#include "imageon.h"
+#include "imageon_regs.h"
+#include "imageon_support.h"
+
+W100CardEntry w100_cards[] = {
+    {0x1002, 0x5644, 0,             "ATI Imageon 3200"},
+    {0x1002, 0x5741, W100XVSupport, "ATI Imageon 100"},
+    {0x1002, 0x5744, 0,             "ATI Imageon 3220"},
+    {0,      0,      0,             NULL}
+};
+
+W100ModeSpec w100_modes[] = {
+    {800, 600, 16, W100_EXTMEM, FALSE},
+    {640, 480, 16, W100_EXTMEM, FALSE},
+    {320, 240, 16, W100_INTMEM, FALSE},
+    {  0,   0,  0,           0, FALSE}    
+};
+
+W100StartupInfo w100StartupInfo;
+
+extern void (*tslib_transform_coords)(long *x, long *y, void *closure);
+extern void *tslib_transform_closure;
+
+static void
+W100Startup(W100CardInfo *w100c)
+{
+    int i;
+    DBG_IMAGEON(("--W100Startup\n"));
+    W100ModeSpec *modes;
+    /* Take the current graphics mode */
+    if (!W100GetFbMode(w100c, &w100StartupInfo.mode)) {
+        ErrorF("(E) Unable to get current mode\n");
+    }
+    w100StartupInfo.randr = W100GetRotation(w100c);
+    w100StartupInfo.portrait = w100StartupInfo.mode.width < w100StartupInfo.mode.height;
+
+    /* Test the valid modes  */
+    for (modes = w100_modes; modes->width; modes++) {
+        modes->supported = W100CheckFbMode(w100c, modes);
+    }
+
+    DBG_IMAGEON(("Startup Mode: %dx%d@%d, rot: %d, portrait: %s\n", 
+                 w100StartupInfo.mode.width,
+                 w100StartupInfo.mode.height,
+                 w100StartupInfo.mode.bpp,
+                 w100StartupInfo.randr,
+                 w100StartupInfo.portrait ? "Yes" : "No"));
+
+    /* Tell the kernel to never switch off external memory  */
+    W100SysFsSet(w100c, W100_SYSFS_BASE "extmem", "1");
+
+    /* Disable framebuffer accel */
+    W100SysFsSet(w100c, W100_SYSFS_BASE "accel", "0");
+
+    /* Enable fastsysclk */
+    W100SysFsSet(w100c, W100_SYSFS_BASE "fastpllclk", "1");
+
+}
+
+
+static Bool
+W100Map(KdCardInfo * card, W100CardInfo *w100c)
+{
+    DBG_IMAGEON(("--W100Map\n"));
+    w100c->mem_base = (CARD8 *) KdMapDevice(W100_MEM_BASE, W100_MEM_SIZE);
+
+    if (w100c->mem_base == NULL) {
+        return FALSE;
+    }
+
+    w100c->reg_base = w100c->mem_base + W100_REG_OFFSET;
+
+    /* 
+     * It doesn't matter mapping all the area as registers.
+     * There's only difference when HAVE_ASM_MTRR_H is defined.
+     * So, this call is doing nothing.
+     */
+    KdSetMappedMode(W100_MEM_BASE, W100_MEM_SIZE, KD_MAPPED_MODE_REGISTERS);
+
+    return TRUE;
+}
+
+static void
+W100Unmap(KdCardInfo * card, W100CardInfo *w100c)
+{
+    DBG_IMAGEON(("--W100Unmap\n"));
+    if (w100c->mem_base) {
+        KdResetMappedMode(W100_MEM_BASE, W100_MEM_SIZE, 
+                          KD_MAPPED_MODE_REGISTERS);
+        KdUnmapDevice((void *) w100c->mem_base, W100_MEM_SIZE);
+        w100c->mem_base = w100c->reg_base = 0;
+    }
+}
+
+static void W100MemSetup(W100CardInfo *w100c)
+{
+    int reg_value;
+    int int_start, int_size;
+    int ext_start, ext_size;
+    int i;
+    DBG_IMAGEON(("--W100MemSetup\n"));
+
+    for (i = 0; i < w100c->num_memareas; i++) {
+        xfree(w100c->memareas[i]);
+    }
+    xfree(w100c->memareas);
+
+    reg_value = MMIO_IN32(mmMC_FB_LOCATION);
+    int_start = (reg_value & 0xffff) << 8;
+    int_size =  (((reg_value >> 16) & 0xffff) - (reg_value & 0xffff)) << 8;
+    DBG_IMAGEON(("(I) MC_FB_LOCATION: 0x%08x. Start: 0x%08x, size: %d\n",
+                 reg_value, int_start, int_size));
+
+    reg_value = MMIO_IN32(mmMC_EXT_MEM_LOCATION);
+    ext_start = (reg_value & 0xffff) << 8;
+    ext_size =  (((reg_value >> 16) & 0xffff) - (reg_value & 0xffff)) << 8;
+    DBG_IMAGEON(("(I) MC_EXT_MEM_LOCATION: 0x%08x. Start: 0x%08x, size: %d\n",
+                 reg_value, ext_start, ext_size));
+
+    w100c->num_memareas = (ext_size > 0) ? 2 : 1;
+    w100c->memareas = xcalloc(sizeof(W100MemArea *), w100c->num_memareas);
+
+    w100c->memareas[W100_INTMEM] = xcalloc(sizeof(W100MemArea), 1);
+    w100c->memareas[W100_INTMEM]->priority = KD_VIDMEM_MAXPRIO;
+    w100c->memareas[W100_INTMEM]->start = (CARD8 *) int_start;
+    w100c->memareas[W100_INTMEM]->size = int_size;
+
+    if (w100c->num_memareas == 2) {
+        w100c->memareas[W100_EXTMEM] = xcalloc(sizeof(W100MemArea), 1);
+        w100c->memareas[W100_EXTMEM]->priority = KD_VIDMEM_MINPRIO;
+        w100c->memareas[W100_EXTMEM]->start = (CARD8 *) ext_start;
+        w100c->memareas[W100_EXTMEM]->size = ext_size;
+    }
+
+    for (i = 0; i < w100c->num_memareas; i++) {
+        DBG_IMAGEON(("(I) Memory mapped at 0x%08x(0x%08x), size %d bytes\n",
+                     W100_CARD2HOST(w100c->memareas[i]->start),
+                     w100c->memareas[i]->start,
+                     w100c->memareas[i]->size));
+    }
+
+}
+
+static Bool
+W100CardInit(KdCardInfo * card)
+{
+    W100CardInfo *w100c;
+
+    W100CardEntry *model = &w100_cards[0];
+    static Bool initialized = FALSE;
+
+    DBG_IMAGEON(("--W100CardInit\n"));
+
+    w100c = xcalloc(sizeof(W100CardInfo), 1);
+    if (w100c == NULL)
+        return FALSE;
+
+    if (!fbdevInitialize(card, &w100c->fbdev)) {
+        return FALSE;
+    }
+
+    if (!W100Map(card, w100c)) {
+        xfree(w100c);
+        return FALSE;
+    }
+    card->driver = w100c;
+
+    while (model->name) {
+        if (model->device == card->attr.deviceID) {
+            w100c->card_id = model;
+            break;
+        }
+        model++;
+    }
+
+    ErrorF("(I) Using ATI card: %s\n", w100c->card_id->name);
+
+    if (!initialized) {
+        initialized = TRUE;
+        W100Startup(w100c);
+    }
+
+    w100c->hw_window.mode  = W100GetModeSpec(w100c, &w100StartupInfo.mode);
+    w100c->hw_window.randr = w100StartupInfo.randr;
+
+    tslib_transform_closure = w100c;
+    tslib_transform_coords = W100TransformTsLibCoordinates;
+    return TRUE;
+}
+
+
+static void
+W100CardFini(KdCardInfo * card)
+{
+    W100CardInfo *w100c = (W100CardInfo *) card->driver;
+
+    DBG_IMAGEON(("--W100CardFini\n"));
+    W100Unmap(card, w100c);
+    fbdevCardFini(card);
+}
+
+static void
+W100Setup(KdScreenInfo *screen)
+{
+    W100CardInfo(screen);
+    W100MemArea *mem;
+    KdMouseMatrix m;
+    int fb_size, i;
+
+    DBG_IMAGEON(("--W100Setup\n"));
+
+    /* Adjust mode */
+    w100c->hw_window.width = screen->width;
+    w100c->hw_window.height = screen->height;
+    w100c->hw_window.bpp =  screen->fb[0].bitsPerPixel;
+    W100SetupGraphicWindow(w100c);
+
+    /* Get some register values */
+    w100c->regs.ENG_CNTL =       MMIO_IN32(mmENG_CNTL);
+    w100c->regs.VIDEO_CTRL =     MMIO_IN32(mmVIDEO_CTRL);
+    w100c->regs.GRAPHIC_H_DISP = MMIO_IN32(mmGRAPHIC_H_DISP);
+    w100c->regs.GRAPHIC_V_DISP = MMIO_IN32(mmGRAPHIC_V_DISP);
+    w100c->regs.DISP_DEBUG2    = MMIO_IN32(mmDISP_DEBUG2);
+
+    W100MemSetup(w100c);
+
+    /* Clear the VideoMemAreas set up by the framebuffer initialization */
+    for (i = 0; i < screen->num_videomem_areas; i++) {
+        xfree(screen->videomem_areas[i]);
+    }
+    xfree(screen->videomem_areas);
+    
+    screen->videomem_areas = xcalloc(sizeof(KdVideoMemArea *), 
+                                     w100c->num_memareas);
+    screen->num_videomem_areas = w100c->num_memareas;
+
+    screen->fb[0].byteStride = screen->width * screen->fb[0].bitsPerPixel / 8;
+    fb_size = screen->fb[0].byteStride * screen->height;
+
+    DBG_IMAGEON(("(I) Framebuffer required size: %d bytes\n", fb_size));
+    
+    for (i = 0; i < w100c->num_memareas; i++) {
+        mem = w100c->memareas[i];
+        screen->videomem_areas[i] = xcalloc(sizeof(KdVideoMemArea), 1);
+        screen->videomem_areas[i]->priority = mem->priority;
+        screen->videomem_areas[i]->base = W100_CARD2HOST(mem->start);
+        screen->videomem_areas[i]->size = mem->size;
+        if (w100c->hw_window.mode->fbpool == i) {
+            DBG_IMAGEON(("(I) FrameBuffer in w100 memzone 0x%08x(0x%08x)\n", 
+                         W100_CARD2HOST(mem->start), mem->start));
+            screen->videomem_areas[i]->available_offset = fb_size;
+            screen->fb[0].frameBuffer = W100_CARD2HOST(mem->start);
+        } else {
+            screen->videomem_areas[i]->available_offset = 0;
+        }
+        DBG_IMAGEON(("New videomem_area(priority:%d, start:0x%08x, size:%d, available_offset:%d\n",
+                     screen->videomem_areas[i]->priority,
+                     screen->videomem_areas[i]->base,
+                     screen->videomem_areas[i]->size,
+                     screen->videomem_areas[i]->available_offset));
+    }
+
+
+    w100c->hw_window.offset = W100_HOST2CARD(screen->fb[0].frameBuffer);
+
+    KdComputeMouseMatrix(&m, screen->randr, 
+                         w100StartupInfo.portrait ? 
+                         W100_MIN(screen->width, screen->height) :
+                         W100_MAX(screen->width, screen->height),
+                         w100StartupInfo.portrait ? 
+                         W100_MAX(screen->width, screen->height) :
+                         W100_MIN(screen->width, screen->height));
+
+    KdSetMouseMatrix(&m);
+
+    DBG_IMAGEON(("Window(width:%d,height:%d,bpp:%d,offset:0x%08x"
+                 "(0x%08x), randr:%d)\n",
+                 w100c->hw_window.width,
+                 w100c->hw_window.height,
+                 w100c->hw_window.bpp,
+                 w100c->hw_window.offset,
+                 screen->fb[0].frameBuffer,
+                 w100c->hw_window.randr));
+
+}
+
+static Bool
+W100ScreenInit(KdScreenInfo * screen)
+{
+    W100ScreenInfo *w100s;
+    W100CardInfo(screen);
+    Bool success = FALSE;
+
+    DBG_IMAGEON(("--W100ScreenInit\n"));
+    w100s = xcalloc(sizeof(W100ScreenInfo), 1);
+    if (w100s == NULL)
+        return FALSE;
+
+    w100s->w100c = w100c;
+    w100s->screen = screen;
+    screen->driver = w100s;
+
+    success = fbdevScreenInitialize(screen, &w100s->fbdev);
+
+    if (!success) {
+        screen->driver = NULL;
+        xfree(w100s);
+        return FALSE;
+    }
+
+    W100Setup(screen);
+
+    return TRUE;
+}
+
+static void
+W100ScreenFini(KdScreenInfo * screen)
+{
+    W100ScreenInfo *w100s = (W100ScreenInfo *) screen->driver;
+    DBG_IMAGEON(("--W100ScreenFini\n"));
+    fbdevScreenFini(screen);
+    xfree(w100s);
+    screen->driver = 0;
+}
+
+static Bool
+W100InitScreen(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+
+    DBG_IMAGEON(("--W100InitScreen\n"));
+    if (w100c->card_id->caps & W100XVSupport) {
+        W100InitVideo(pScreen);
+    }
+    return fbdevInitScreen(pScreen);
+}
+
+#ifdef RANDR
+
+static Bool W100RandRSetConfig(ScreenPtr pScreen,
+                               Rotation randr,
+                               int rate,
+                               RRScreenSizePtr pSize)
+{
+    KdScreenPriv(pScreen);
+    KdScreenInfo *screen = pScreenPriv->screen;
+    W100CardInfo(pScreenPriv);
+    Bool screenEnabled = pScreenPriv->enabled;
+
+    DBG_IMAGEON(("--W100RandRSetConfig(randr:%d,pSize:%dx%d)\n",
+                 randr, pSize->width, pSize->height));
+
+    if (screenEnabled) {
+        KdDisableScreen(pScreen);
+    }
+
+    if (randr & (RR_Rotate_0|RR_Rotate_180)) {
+        pScreen->mmWidth  = screen->width_mm;
+        pScreen->mmHeight = screen->height_mm;
+        pScreen->width = pSize->width;
+        pScreen->height = pSize->height;
+    } else {
+	pScreen->mmWidth  = screen->height_mm;
+	pScreen->mmHeight = screen->width_mm;
+        pScreen->width = pSize->height;
+        pScreen->height = pSize->width;
+    }
+
+    screen->randr = randr;
+    screen->width = pScreen->width;
+    screen->height = pScreen->height;
+    w100c->hw_window.randr = KdSubRotation(w100StartupInfo.randr, randr);
+    w100c->hw_window.mode = W100GetBestMode(w100c, pScreen->width, pScreen->height);
+
+    KdOffscreenSwapOut(screen->pScreen);
+
+    W100Setup(screen);
+
+    DBG_IMAGEON(("ModifyPixMapHeader(width:%d,height:%d,depth:%d,bpp:%d,bs:%d,fb:0x%08x)\n", pScreen->width, pScreen->height, 
+                 screen->fb[0].depth,
+                 screen->fb[0].bitsPerPixel,
+                 screen->fb[0].byteStride,
+                 screen->fb[0].frameBuffer));
+
+
+    (*pScreen->ModifyPixmapHeader) (fbGetScreenPixmap(pScreen),
+                                    pScreen->width,
+                                    pScreen->height,
+                                    screen->fb[0].depth,
+                                    screen->fb[0].bitsPerPixel,
+                                    screen->fb[0].byteStride,
+                                    screen->fb[0].frameBuffer);
+
+
+    if (screenEnabled) {
+        KdEnableScreen(pScreen);
+    }
+    return TRUE;
+}
+
+static Bool W100RandRGetInfo(ScreenPtr pScreen, Rotation *rotations)
+{
+    KdScreenPriv(pScreen);
+    KdScreenInfo *screen = pScreenPriv->screen;
+    W100CardInfo(pScreenPriv);
+    RRScreenSizePtr pSize;
+    Rotation randr;
+    W100ModeSpec *modes;
+    int i;
+
+    DBG_IMAGEON(("--W100RandRGetInfo\n"));
+
+    *rotations = RR_Rotate_All;
+
+    for (modes = w100_modes; modes->width; modes++) {
+        if (modes->supported) {
+            pSize = RRRegisterSize(pScreen, 
+                                   modes->width,
+                                   modes->height,
+                                   screen->width_mm,
+                                   screen->height_mm);
+            if (modes == w100c->hw_window.mode) {
+                RRSetCurrentConfig(pScreen, screen->randr, 0, pSize);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+static Bool W100RandRInit(ScreenPtr pScreen)
+{
+    rrScrPrivPtr pScrPriv = rrGetScrPriv(pScreen);
+    DBG_IMAGEON(("--W100RandRInit\n"));
+    pScrPriv->rrSetConfig = W100RandRSetConfig;
+    pScrPriv->rrGetInfo   = W100RandRGetInfo;
+    return TRUE;
+}
+
+#endif
+
+static Bool
+W100FinishInitScreen(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    DBG_IMAGEON(("--W100FinishInitScreen\n"));
+    if (!fbdevFinishInitScreen(pScreen))
+        return FALSE;
+
+#ifdef RANDR
+    if (!W100RandRInit(pScreen))
+        return FALSE;
+#endif
+    return TRUE;
+}
+
+static Bool
+W100CreateResources(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+
+    return fbdevCreateResources(pScreen);
+}
+
+static void
+W100Preserve(KdCardInfo * card)
+{
+    W100CardInfo *w100c = card->driver;
+    DBG_IMAGEON(("--W100Preserve\n"));
+
+    fbdevPreserve(card);
+}
+
+static void
+W100Restore(KdCardInfo * card)
+{
+    W100CardInfo *w100c = card->driver;
+    DBG_IMAGEON(("--W100Restore\n"));
+    fbdevRestore(card);
+}
+
+static Bool
+W100DPMS(ScreenPtr pScreen, int mode)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    DBG_IMAGEON(("--W100DPMS\n"));
+    return fbdevDPMS(pScreen, mode);
+}
+
+static Bool
+W100Enable(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+
+    DBG_IMAGEON(("--W100Enable\n"));
+
+    /*
+    if (!fbdevEnable(pScreen))
+        return FALSE;
+    */
+
+    if (w100c->mem_base == NULL) {
+        if (!W100Map(pScreenPriv->screen->card, w100c)) {
+            return FALSE;
+        }
+        W100Setup(pScreenPriv->screen);
+    }
+    W100SetupGraphicEngine(w100c);
+
+    graphic_offset_u go;
+    go.val = MMIO_IN32(mmGRAPHIC_OFFSET);
+    DBG_IMAGEON(("Graphic offset is 0x%08x(0x%08x)\n",
+                 go.f.graphic_offset,
+                 W100_CARD2HOST(go.f.graphic_offset)));
+
+
+    return TRUE;
+}
+
+static void
+W100Disable(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    DBG_IMAGEON(("--W100Disable\n"));
+    //W100Unmap(pScreenPriv->card, w100c);
+
+    fbdevDisable(pScreen);
+}
+
+static void
+W100GetColors(ScreenPtr pScreen, int fb, int n, xColorItem * pdefs)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+
+    fbdevGetColors(pScreen, fb, n, pdefs);
+}
+
+static void
+W100PutColors(ScreenPtr pScreen, int fb, int n, xColorItem * pdefs)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+
+    fbdevPutColors(pScreen, fb, n, pdefs);
+}
+
+KdCardFuncs W100Funcs = {
+    W100CardInit,                /* cardinit */
+    W100ScreenInit,              /* scrinit */
+    W100InitScreen,              /* initScreen */
+    W100FinishInitScreen,        /* finishInitScreen */
+    W100CreateResources,         /* createRes */
+    W100Preserve,                /* preserve */
+    W100Enable,                  /* enable */
+    W100DPMS,                    /* dpms */
+    W100Disable,                 /* disable */
+    W100Restore,                 /* restore */
+    W100ScreenFini,              /* scrfini */
+    W100CardFini,                /* cardfini */
+
+    W100CursorInit,              /* initCursor */
+    W100CursorEnable,            /* enableCursor */
+    W100CursorDisable,           /* disableCursor */
+    W100CursorFini,              /* finiCursor */
+    W100RecolorCursor,           /* recolorCursor */
+
+    W100InitAccel,               /* initAccel */
+    W100EnableAccel,             /* enableAccel */
+    W100DisableAccel,            /* disableAccel */
+    W100FiniAccel,               /* finiAccel */
+
+    W100GetColors,               /* getColors */
+    W100PutColors,               /* putColors */
+};
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_const.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __IMAGEON_CONST_H__
+#define __IMAGEON_CONST_H__
+
+// DP_GUI_MASTER_CNTL.GMC_Brush_DataType
+// DP_DATATYPE.Brush_DataType
+#define DP_BRUSH_8x8MONOOPA	0   //8x8 mono pattern (expanded to frgd, bkgd)
+#define DP_BRUSH_8x8MONOTRA	1   //8x8 mono pattern (expanded to frgd, leave_alone)
+#define DP_PEN_32x1MONOOPA	6   //32x1 mono pattern (expanded to frgd, bkgd)
+#define DP_PEN_32x1MONOTRA	7   //32x1 mono pattern (expanded to frgd, leave_alone)
+#define DP_BRUSH_8x8COLOR	10  //8x8 color pattern
+#define DP_BRUSH_SOLIDCOLOR	13  //solid color pattern (frgd)
+#define DP_BRUSH_NONE		15	//no brush used
+
+#define SIZE_BRUSH_8x8MONO	2
+#define SIZE_PEN_32x1MONO	1
+#define SIZE_BRUSH_8x8COLOR_8	16
+#define SIZE_BRUSH_8x8COLOR_16	32
+#define MAX_BRUSH_SIZE		SIZE_BRUSH_8x8COLOR_16
+
+// DP_GUI_MASTER_CNTL.GMC_Dst_DataType
+// DP_DATATYPE.Dp_Dst_DataType
+#define DP_DST_8BPP		2   // 8 bpp grey scale
+#define DP_DST_16BPP_1555	3   //16 bpp aRGB 1555
+#define DP_DST_16BPP_444	5   //16 bpp aRGB 4444
+
+// DP_GUI_MASTER_CNTL.GMC_Src_DataType
+// DP_DATATYPE.Dp_Src_DataType
+#define DP_SRC_1BPP_OPA		0   //mono (expanded to frgd, bkgd)
+#define DP_SRC_1BPP_TRA		1   //mono (expanded to frgd, leave_alone)
+#define DP_SRC_COLOR_SAME_AS_DST	3   //color (same as DST)
+#define	DP_SRC_SOLID_COLOR_BLT		4	//solid color for Blt (use frgd)
+#define	DP_SRC_4BPP			5	//4 bpp
+#define	DP_SRC_12BPP_PACKED		6	//12 bpp packed
+
+// DP_GUI_MASTER_CNTL.GMC_Byte_Pix_Order
+// DP_DATATYPE.Dp_Byte_Pix_Order
+#define DP_PIX_ORDER_MSB2LSB		0   //monochrome pixel order from MSBit to LSBit
+#define DP_PIX_ORDER_LSB2MSB		1   //monochrome pixel order from LSBit to MSBit
+
+// DP_GUI_MASTER_CNTL.GMC_Dp_Src_Source
+#define DP_SRC_MEM_LINEAR		1	//loaded from memory (linear trajectory)
+#define DP_SRC_MEM_RECTANGULAR		2   //loaded from memory (rectangular trajectory)
+#define DP_SRC_HOSTDATA_BIT		3   //loaded from hostdata (linear trajectory)
+#define DP_SRC_HOSTDATA_BYTE		4   //loaded from hostdata (linear trajectory & byte-aligned)
+
+// DP_GUI_MASTER_CNTL.GMC_Dp_Op
+#define	DP_OP_ROP			0
+#define	DP_OP_ARITHMETIC		1
+
+// E2_ARITHMETIC_CNTL.opcode
+#define	E2_OPC_GLBALP_ADD_SRC2		0
+#define	E2_OPC_GLBALP_SUB_SRC2		1
+#define	E2_OPC_SRC1_ADD_SRC2		2
+#define	E2_OPC_SRC1_SUB_SRC2		3
+#define	E2_OPC_DST_SADDBLEND_SRC2	4
+#define	E2_OPC_DST_CADDBLEND_SRC2	5
+#define	E2_OPC_DST_CSUBBLEND_SRC2	6
+#define	E2_OPC_LF_SRC2			7
+#define	E2_OPC_SCALE_SRC2		8
+#define	E2_OPC_STRETCH_SRC2		9
+#define	E2_OPC_SRC1_4BPPCPYWEXP		10
+#define	E2_OPC_MC1			11
+#define	E2_OPC_MC2			12
+#define E2_OPC_MC1_IDCT			13
+#define	E2_OPC_MC2_IDCT			14
+#define	E2_OPC_IDCT_ONLY_IFRAME		15
+
+// E2_ARITHMETIC_CNTL.clamp
+#define	E2_CLAMP_OFF			0
+#define	E2_CLAMP_ON			1
+
+// E2_ARITHMETIC_CNTL.rounding
+#define	E2_ROUNDING_TRUNCATE		0
+#define	E2_ROUNDING_TO_INFINITY		1
+
+// E2_ARITHMETIC_CNTL.srcblend
+#define	E2_SRCBLEND_GLOBALALPHA		0
+#define	E2_SRCBLEND_ZERO		1
+#define	E2_SRCBLEND_SRC2ALPHA		2
+#define	E2_SRCBLEND_DSTALPHA		3
+#define	E2_SRCBLEND_ALPHA1PLANE		4
+
+// E2_ARITHMETIC_CNTL.destblend
+#define	E2_DSTBLEND_GLOBALALPHA		0
+#define	E2_DSTBLEND_ZERO		1
+#define	E2_DSTBLEND_SRC2ALPHA		2
+#define	E2_DSTBLEND_DSTALPHA		3
+#define	E2_DSTBLEND_ALPHA1PLANE		4
+
+// LCD_FORMAT.lcd_type
+#define	LCDTYPE_TFT333			0
+#define	LCDTYPE_TFT444			1
+#define	LCDTYPE_TFT555			2
+#define	LCDTYPE_TFT666			3
+#define	LCDTYPE_COLSTNPACK4		4
+#define	LCDTYPE_COLSTNPACK8F1		5
+#define	LCDTYPE_COLSTNPACK8F2		6
+#define	LCDTYPE_COLSTNPACK16		7
+#define	LCDTYPE_MONSTNPACK4		8
+#define	LCDTYPE_MONSTNPACK8		9
+
+// CP_RB_CNTL.rb_bufsz
+#define	RB_SIZE_2K			8
+#define	RB_SIZE_4K			9
+#define	RB_SIZE_8K			10
+#define	RB_SIZE_16K			11
+#define	RB_SIZE_32K			12
+#define	RB_SIZE_64K			13
+
+// GRAPHIC_CTRL.color_depth
+#define	COLOR_DEPTH_1BPP		0
+#define	COLOR_DEPTH_2BPP		1
+#define	COLOR_DEPTH_4BPP		2
+#define	COLOR_DEPTH_8BPP		3
+#define	COLOR_DEPTH_332			4
+#define	COLOR_DEPTH_A444		5
+#define	COLOR_DEPTH_A555		6
+
+// VIDEO_CTRL.video_mode
+#define	VIDEO_MODE_422			0
+#define	VIDEO_MODE_420			1
+
+// CLR_CMP_CNTL.cmp_fcn_src
+#define CMP_FCN_SRC_NEQ                 4
+#define CMP_FCN_SRC_EQ                  5
+
+// CLR_CMP_CNTL.cmp_src
+#define CMP_SRC_SRC                     1
+
+// Overlay formats
+#define OVLFORMAT_YUV422           (6)       
+#define OVLFORMAT_YUV420           (7)
+#define OVLFORMAT_RGB565           (5)
+#define OVLFORMAT_EQU_DISPLAY      (8)
+
+#define W100_CLK_SRC_XTAL  0
+#define W100_CLK_SRC_PLL   1
+
+#endif
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_cursor.c
@@ -0,0 +1,569 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+
+#include "cursorstr.h"
+#include "imageon.h"
+#include "imageon_regs.h"
+
+#define W100_CURSOR_HEIGHT (16)
+#define W100_CURSOR_WIDTH  (16)
+#define W100_CURSOR_PITCH  (W100_CURSOR_WIDTH / 4)
+
+#define W100_CURSOR_SIZE   W100_CURSOR_PITCH * W100_CURSOR_WIDTH
+
+static CARD16 expand2bpp[256];
+
+static CARD16 spread_byte(CARD8 b) 
+{
+    CARD16 s = b;
+
+    s = ((s & 0x00f0) << 4) | (s & 0x000f);
+    s = ((s & 0x0c0c) << 2) | (s & 0x0303);
+    s = ((s & 0x2222) << 1) | (s & 0x1111);
+    return s;
+}
+
+static void W100InitExpansionTable()
+{
+    int i;
+    for (i = 0; i < 256; i++) {
+        expand2bpp[i] = spread_byte(i);
+    }
+}
+
+#define BigEndian(v) \
+    (((v & 0x000000ff) << 24) | \
+     ((v & 0x0000ff00) << 8)  | \
+     ((v & 0x00ff0000) >> 8)  | \
+     ((v & 0xff000000) >> 24))
+
+#define PixelOffset(x, y) \
+    (((y) * W100_CURSOR_PITCH + ((x) / 4)) >> 2)
+
+#define PixelShift(x, y) \
+    (2 * ((x) % 16))
+
+#define PixelMask(x, y) \
+    ((0xc0000000) >> PixelShift(x, y))
+
+#define PixelVal(src, x, y) \
+    ((*(src + PixelOffset(x, y)) & PixelMask(x, y)) >> (30 - PixelShift(x, y)))
+
+#define SetPixelVal(ptr, x, y, val)                                   \
+    *(((CARD32 *)(ptr)) + PixelOffset(x, y)) =                        \
+        *(((CARD32 *)(ptr)) + PixelOffset(x, y)) & ~PixelMask(x, y) | \
+        ((val) & 0x03) << (30 - PixelShift(x2, y2))
+
+#define DUMP_CURSOR(src) do {                         \
+    int x;                                            \
+    int y;                                            \
+    for (y = 0; y < W100_CURSOR_HEIGHT; y++) {        \
+        DBG_IMAGEON(("Line %02d: ", y));              \
+        for (x = 0; x < W100_CURSOR_WIDTH; x++) {     \
+            DBG_IMAGEON(("%d", PixelVal(src,x,y)));   \
+        }                                             \
+        DBG_IMAGEON(("\n"));                          \
+    }                                                 \
+    DBG_IMAGEON((".\n"));                             \
+} while (0)
+
+static void
+W100RotateCursor(int randr, CARD32 *src, CARD32 *dst)
+{
+    int x1, y1, x2, y2;
+
+    switch (randr & RR_Rotate_All) {
+    case RR_Rotate_0:
+        x1 = 0;
+        y1 = 0;
+        for (y2 = 0; y2 < W100_CURSOR_HEIGHT; y2++) {
+            for (x2 = W100_CURSOR_WIDTH - 1; x2 >= 0; --x2) {
+                SetPixelVal(dst, x2, y2, PixelVal(src, x1, y1));
+                ++x1;
+                if (x1 >= W100_CURSOR_WIDTH) {
+                    x1 = 0;
+                    ++y1;
+                }
+            }
+        }
+        break;
+    case RR_Rotate_90:
+        x1 = 0; 
+        y1 = 0;
+        for (x2 = W100_CURSOR_WIDTH - 1; x2 >= 0; --x2) {
+            for (y2 = W100_CURSOR_HEIGHT - 1; y2 >=0; --y2) {
+                SetPixelVal(dst, x2, y2, PixelVal(src, x1, y1));
+                ++x1;
+                if (x1 >= W100_CURSOR_WIDTH) {
+                    x1 = 0;
+                    ++y1;
+                }
+            }
+        }
+        break;
+    case RR_Rotate_180:
+        x1 = 0;
+        y1 = 0;
+        for (y2 = W100_CURSOR_HEIGHT - 1; y2 >= 0; --y2) {
+            for (x2 = 0; x2 < W100_CURSOR_WIDTH; x2++) {
+                SetPixelVal(dst, x2, y2, PixelVal(src, x1, y1));
+                ++x1;
+                if (x1 >= W100_CURSOR_WIDTH) {
+                    x1 = 0;
+                    ++y1;
+                }
+            }
+        }            
+        break;
+    case RR_Rotate_270:
+        x1 = 0; 
+        y1 = 0;
+        for (x2 = 0; x2 < W100_CURSOR_WIDTH; x2++) {
+            for (y2 = 0; y2 < W100_CURSOR_HEIGHT; y2++) {
+                SetPixelVal(dst, x2, y2, PixelVal(src, x1, y1));
+                ++x1;
+                if (x1 >= W100_CURSOR_WIDTH) {
+                    x1 = 0;
+                    ++y1;
+                }
+            }
+        }
+        break;
+    }
+}
+
+static void
+W100SetCursorColors(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+    CursorPtr pCursor = pCurPriv->pCursor;
+    CursorBitsPtr bits = pCursor->bits;
+    cursor_color_u fgcolor;
+    cursor_color_u bgcolor;
+
+    fgcolor.f.cur_color_r = pCursor->foreRed   >> 8;
+    fgcolor.f.cur_color_g = pCursor->foreGreen >> 8;
+    fgcolor.f.cur_color_b = pCursor->foreBlue  >> 8;
+
+    bgcolor.f.cur_color_r = pCursor->backRed   >> 8;
+    bgcolor.f.cur_color_g = pCursor->backGreen >> 8;
+    bgcolor.f.cur_color_b = pCursor->backBlue  >> 8;
+
+    DBG_IMAGEON(("W100SetCursorColors fg(%02x,%02x,%02x), bg(%02x,%02x,%02x)\n",
+                 fgcolor.f.cur_color_r, 
+                 fgcolor.f.cur_color_g, 
+                 fgcolor.f.cur_color_b,
+                 bgcolor.f.cur_color_r, 
+                 bgcolor.f.cur_color_g,
+                 bgcolor.f.cur_color_b));
+
+    W100DisableDisplayUpdate(w100c);
+    MMIO_OUT32(mmCURSOR1_COLOR0, bgcolor.val);
+    MMIO_OUT32(mmCURSOR1_COLOR1, fgcolor.val);
+    W100EnableDisplayUpdate(w100c);
+
+}
+    
+static void
+W100LoadCursor(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+    CursorPtr pCursor = pCurPriv->pCursor;
+    CursorBitsPtr bits = pCursor->bits;
+    CARD32 *dst;
+    CARD8 tmpCursor0[W100_CURSOR_SIZE];
+    CARD8 tmpCursor1[W100_CURSOR_SIZE];
+    CARD32 expValue, expMask;
+    CARD32 *src;
+    CARD32 *mask;
+    int lwsrc;
+    int line, i;
+    int h, w;
+
+    
+    pCurPriv->pCursor = pCursor;
+    pCurPriv->xhot = bits->xhot;
+    pCurPriv->yhot = bits->yhot;
+
+    memset(tmpCursor0, 0xaa, W100_CURSOR_SIZE);
+
+    h = bits->height;
+    w = bits->width;
+    if (h > W100_CURSOR_HEIGHT) {
+        h = W100_CURSOR_HEIGHT;
+    }
+
+    if (w > W100_CURSOR_WIDTH) {
+        w = W100_CURSOR_WIDTH;
+    }
+
+    src =  (CARD32*) bits->source;
+    dst =  (CARD32*) tmpCursor0;
+    mask = (CARD32*) bits->mask;
+
+    lwsrc = BitmapBytePad(bits->width) >> 2;
+
+    for (line = 0; line < h; line++) {
+        for (i = 0; i < lwsrc; i++) {
+            expValue = 
+                (expand2bpp[src[i] & 0xff]) |
+                (expand2bpp[(src[i] >> 8) & 0xff] << 16);
+            expMask = 
+                (expand2bpp[mask[i] & 0xff]) |
+                (expand2bpp[(mask[i] >> 8) & 0xff] << 16);
+            expMask |= (expMask << 1); /* Expand 01 -> 11, 00 -> 00 */
+            dst[i] = (0xaaaaaaaa & ~expMask) | (expValue & expMask);
+        }
+        src  += lwsrc;
+        mask += lwsrc;
+        dst  += lwsrc;
+    }
+
+    /* Rotate the pixmap to get the correct orientation */
+    W100RotateCursor(w100c->hw_window.randr,
+                     (CARD32*) tmpCursor0,
+                     (CARD32*) tmpCursor1);
+
+    DUMP_CURSOR((CARD32*)tmpCursor1);
+    /* Correct endianness */
+    src = (CARD32*) tmpCursor1;
+    dst = (CARD32*) (pCurPriv->area->vidmem->base + pCurPriv->area->offset);
+    DBG_IMAGEON(("W100LoadCursor(xhot:%d,yhot:%d,width:%d,height:%d) dst(0x%08x)\n",
+                 bits->xhot, bits->yhot, 
+                 bits->width, bits->height,
+                 dst));
+
+    for (line = 0; line < h; line++) {
+        for (i = 0; i < lwsrc; i++) {
+            dst[i] = BigEndian(src[i]);
+        }
+        src += lwsrc;
+        dst += lwsrc;
+    }
+
+    W100SetCursorColors(pScreen);
+}
+
+static void 
+W100UnloadCursor(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    cursor_h_pos_u hpos;
+    W100Cursor *pCurPriv = &w100s->cursor;
+
+    DBG_IMAGEON(("W100UnloadCursor pCurPriv:%p\n", pCurPriv));
+
+    hpos.val = pCurPriv->hpos;
+    hpos.f.cur_en = 0;
+
+    W100DisableDisplayUpdate(w100c);
+    MMIO_OUT32(mmCURSOR1_H_POS, hpos.val);
+    W100EnableDisplayUpdate(w100c);
+    pCurPriv->hpos = hpos.val;
+}
+
+static void
+W100MoveCursor(ScreenPtr pScreen, int x, int y)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+    int xoffs, yoffs;
+    cursor_offset_u cursor_offset;
+    cursor_h_pos_u hpos;
+    cursor_v_pos_u vpos;
+    graphic_h_disp_u graphic_hdisp;
+    graphic_v_disp_u graphic_vdisp;
+    BoxRec cursorBox, deviceBox;
+
+
+    if (!pCurPriv->has_cursor) {
+        return;
+    }
+    if (!pScreenPriv->enabled) {
+        return;
+    }
+
+    graphic_hdisp.val = w100c->regs.GRAPHIC_H_DISP;
+    graphic_vdisp.val = w100c->regs.GRAPHIC_V_DISP;
+    xoffs = 0;
+    yoffs = 0;
+    cursorBox.x1 = x - pCurPriv->xhot;
+    cursorBox.y1 = y - pCurPriv->yhot;
+    cursorBox.x2 = cursorBox.x1 + pCurPriv->width  - 1;
+    cursorBox.y2 = cursorBox.y1 + pCurPriv->height - 1;
+    W100MapToDevice(w100c, &cursorBox, &deviceBox);
+
+    if (deviceBox.x1 < 0) {
+        xoffs = -deviceBox.x1;
+        deviceBox.x1 = 0;
+    }
+
+    if (deviceBox.y1 < 0) {
+        yoffs = -deviceBox.y1;
+        deviceBox.y1 = 0;
+    }
+    
+    hpos.f.cur_h_start = graphic_hdisp.f.graphic_h_start + deviceBox.x1;
+    hpos.f.cur_h_end   = graphic_hdisp.f.graphic_h_start + deviceBox.x2 + 1;
+    hpos.f.cur_en = 1;
+    vpos.f.cur_v_start = graphic_vdisp.f.graphic_v_start + deviceBox.y1;
+    vpos.f.cur_v_end   = graphic_vdisp.f.graphic_v_start + deviceBox.y2 + 1;
+
+    cursor_offset.f.cur_x_offset = xoffs;
+    cursor_offset.f.cur_y_offset = yoffs;
+    cursor_offset.f.cur_offset = (CARD32) 
+        W100_HOST2CARD(pCurPriv->area->vidmem->base
+                       + pCurPriv->area->offset);
+    DBG_IMAGEON(("W100MoveCursor dst(x:%d,y:%d),"
+                 "hwpos(hpos.start:%d,hpos.end:%d,vpos.start:%d,vpos.end:%d),"
+                 "mapped(x:%d,y:%d,xoffs:%d,yoffs:%d)\n",
+                 x, y, 
+                 hpos.f.cur_h_start, hpos.f.cur_h_end,
+                 vpos.f.cur_v_start, vpos.f.cur_v_end,
+                 deviceBox.x1, deviceBox.y1, xoffs, yoffs));
+
+    W100DisableDisplayUpdate(w100c);
+    MMIO_OUT32(mmCURSOR1_OFFSET, cursor_offset.val);
+    MMIO_OUT32(mmCURSOR1_V_POS,  vpos.val);
+    MMIO_OUT32(mmCURSOR1_H_POS,  hpos.val);
+    W100EnableDisplayUpdate(w100c);
+
+    pCurPriv->hpos = hpos.val;
+    pCurPriv->vpos = vpos.val;
+    pCurPriv->coffset = cursor_offset.val;
+
+}
+
+static Bool
+W100RealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+    DBG_IMAGEON(("W100RealizeCursor\n"));
+
+    if (!pScreenPriv->enabled) {
+        return TRUE;
+    }
+
+    if (pCursor && pCurPriv->pCursor == pCursor) {
+        int x, y;
+        miPointerPosition(&x, &y);
+        W100LoadCursor(pScreen);
+        W100MoveCursor(pScreen, x, y);
+    }
+    return TRUE;
+}
+
+
+static Bool
+W100UnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
+{
+    DBG_IMAGEON(("W100UnrealizeCursor\n"));
+    return TRUE;
+}
+
+
+static void
+W100SetCursor(ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+
+    pCurPriv->pCursor = pCursor;
+
+    if (!pScreenPriv->enabled) {
+        return;
+    }
+
+    if (pCursor) {
+        W100LoadCursor(pScreen);
+        W100MoveCursor(pScreen, x, y);
+    } else {
+        W100UnloadCursor(pScreen);
+    }
+}
+
+
+miPointerSpriteFuncRec W100PointerSpriteFuncs = {
+    W100RealizeCursor,
+    W100UnrealizeCursor,
+    W100SetCursor,
+    W100MoveCursor,
+};
+
+static void
+W100QueryBestSize(int class, unsigned short *pwidth, unsigned short *pheight,
+                  ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+
+    switch (class) {
+    case CursorShape:
+        if (*pwidth > pCurPriv->width) {
+            *pwidth = pCurPriv->width;
+        }
+        if (*pheight > pCurPriv->height) {
+            *pheight = pCurPriv->height;
+        }
+        if (*pwidth > pScreen->width) {
+            *pwidth = pScreen->width;
+        }
+        if (*pheight > pScreen->height) {
+            *pheight = pScreen->height;
+        }
+        break;
+    default:
+        fbQueryBestSize(class, pwidth, pheight, pScreen);
+        break;
+    }
+}
+
+static void
+W100CursorSave(ScreenPtr pScreen, KdOffscreenArea *area)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+    DBG_IMAGEON(("W100CursorSave\n"));
+
+    pCurPriv->area = NULL;
+}
+
+void
+W100CursorEnable(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+
+    if (!pCurPriv->has_cursor) {
+        return;
+    }
+
+    DBG_IMAGEON(("W100CursorEnable\n"));
+
+    if (pCurPriv->area == NULL) {
+        pCurPriv->area = KdOffscreenAlloc(pScreen, 
+                                          W100_CURSOR_SIZE, 0, TRUE,
+                                          W100CursorSave, w100s);
+    }
+    if (pCurPriv->area == NULL) {
+        FatalError("Couldn't allocate offscreen memory for cursor.\n");
+    } else {
+        DBG_IMAGEON(("Cursor memory at 0x%08x(0x%08x)\n", 
+                     pCurPriv->area->vidmem->base + pCurPriv->area->offset,
+                     W100_HOST2CARD(pCurPriv->area->vidmem->base
+                                    + pCurPriv->area->offset)));
+    }
+    if (pCurPriv->pCursor) {
+        int x, y;
+        miPointerPosition(&x, &y);
+        W100LoadCursor(pScreen);
+        W100MoveCursor(pScreen, x, y);
+    } else {
+        W100UnloadCursor(pScreen);
+    }
+}
+
+
+void
+W100CursorDisable(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+    DBG_IMAGEON(("W100CursorDisable\n"));
+
+    if (!pScreenPriv->enabled || !pCurPriv->has_cursor) {
+        return;
+    }
+
+    if (pCurPriv->pCursor) {
+        W100UnloadCursor(pScreen);
+    }
+
+    pCurPriv->area = NULL;
+}
+
+Bool
+W100CursorInit(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+    
+    DBG_IMAGEON(("W100CursorInit\n"));
+
+    pCurPriv->width  = W100_CURSOR_WIDTH;
+    pCurPriv->height = W100_CURSOR_HEIGHT;
+    pScreen->QueryBestSize = W100QueryBestSize;
+    miPointerInitialize(pScreen,
+                        &W100PointerSpriteFuncs,
+                        &kdPointerScreenFuncs, 
+                        FALSE);
+    pCurPriv->has_cursor = TRUE;
+    pCurPriv->pCursor = NULL;
+    W100InitExpansionTable();
+    return TRUE;
+}
+
+
+void
+W100RecolorCursor(ScreenPtr pScreen, int ndef, xColorItem *pdef)
+{
+    return;
+}
+
+
+void
+W100CursorFini(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100Cursor *pCurPriv = &w100s->cursor;
+
+    pCurPriv->has_cursor = FALSE;
+    pCurPriv->pCursor = NULL;
+}
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_draw.c
@@ -0,0 +1,238 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+
+#include "imageon.h"
+#include "imageon_regs.h"
+#include "imageon_const.h"
+#include "imageon_support.h"
+#include "kaa.h"
+
+static W100CardInfo *currentCard;
+
+void
+W100WaitMarker(ScreenPtr pScreen, int marker)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100WaitIdle(w100c);
+}
+
+Bool
+W100PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
+{
+    KdScreenPriv(pPix->drawable.pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100CardInfo(pScreenPriv);
+    W100PortPrivPtr pPortPriv = w100s->pAdaptor->pPortPrivates[0].ptr;
+    int fifoEntries = 4;
+
+    DBG_IMAGEON(("W100PrepareSolid(alu:%d, pm:0x%08x, fg:%d)\n",
+                 alu, pm, fg));
+    
+    W100ResetContext(w100c);
+    W100SetPixelMask(w100c, pm);
+
+    if (W100SetDestinationPixmap(pPix)) {
+        if (w100c->ctx.mask.enable) {
+            ++fifoEntries;
+        }
+        if (W100WaitCmdFifoEntries(w100c, fifoEntries)) {
+            MMIO_OUT32(mmDP_GUI_MASTER_CNTL, W100ComputeSolidGmc(w100c, alu));
+            MMIO_OUT32(mmDST_PITCH, w100c->ctx.dst.pitch);
+            MMIO_OUT32(mmDST_OFFSET, w100c->ctx.dst.offset);
+            MMIO_OUT32(mmDP_BRUSH_FRGD_CLR, fg);
+
+            if (w100c->ctx.mask.enable) {
+                MMIO_OUT32(mmDP_WRITE_MSK, pm);
+            }
+            currentCard = w100c;
+            return TRUE;
+        }
+    }
+    ErrorF("Error in W100PrepareSolid\n");
+    return FALSE;
+}
+
+void
+W100Solid(int x1, int y1, int x2, int y2)
+{
+    W100CardInfo *w100c = currentCard;
+    DBG_IMAGEON(("W100Solid(x1:%d,y1:%d,x2:%d,y2:%d)\n", x1, y1, x2, y2));
+
+    if (W100WaitCmdFifoEntries(w100c, 2)) {
+        MMIO_OUT32(mmDST_Y_X, (y1 << 16) | x1);
+        MMIO_OUT32(mmDST_HEIGHT_WIDTH, ((y2 - y1) << 16) | (x2 - x1));
+    } else {
+        ErrorF("Error in W100Solid\n");
+    }
+}
+
+void
+W100DoneSolid(void)
+{
+}
+
+
+Bool
+W100PrepareCopy(PixmapPtr pSrc, PixmapPtr pDst, 
+                int dx, int dy, int alu, Pixel pm)
+{
+    KdScreenPriv(pDst->drawable.pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100CardInfo(pScreenPriv);
+    dp_datatype_u datatype;
+
+    int fifoEntries = 6;
+
+    W100ResetContext(w100c);
+    W100SetPixelMask(w100c, pm);
+    W100SetXForm(w100c, dx, dy);
+
+    if (W100SetSourcePixmap(pSrc) && W100SetDestinationPixmap(pDst)) {
+        DBG_IMAGEON(("W100PrepareCopy(src(pitch:%d,offset:0x%08x),"
+                     "dst(pitch:%d,offset:0x%08x))\n",
+                     w100c->ctx.src.pitch,
+                     w100c->ctx.src.offset,
+                     w100c->ctx.dst.pitch,
+                     w100c->ctx.dst.offset));
+        if (w100c->ctx.mask.enable) {
+            ++fifoEntries;
+        }
+
+        if (W100WaitCmdFifoEntries(w100c, fifoEntries)) {
+            MMIO_OUT32(mmSRC_PITCH,  w100c->ctx.src.pitch);
+            MMIO_OUT32(mmSRC_OFFSET, w100c->ctx.src.offset);
+            MMIO_OUT32(mmDST_PITCH,  w100c->ctx.dst.pitch);
+            MMIO_OUT32(mmDST_OFFSET, w100c->ctx.dst.offset);
+            MMIO_OUT32(mmDP_GUI_MASTER_CNTL, W100ComputeCopyGmc(w100c, alu));
+            if (w100c->ctx.mask.enable) {
+                MMIO_OUT32(mmDP_WRITE_MSK, pm);
+            }
+            MMIO_OUT32(mmDP_CNTL, w100c->ctx.xform.dataPath);
+            currentCard = w100c;
+            return TRUE;
+        }
+    }
+    ErrorF("Error in W100PrepareCopy\n");
+    return FALSE;
+}
+
+void
+W100Copy(int srcX, int srcY, int dstX, int dstY, int w, int h)
+{
+    W100CardInfo *w100c = currentCard;
+    DBG_IMAGEON(("W100Copy(src(x:%d,y:%d),dst(x:%d,y:%d),w:%d,h:%d)\n",
+                 srcX, srcY, 
+                 dstX, dstY,
+                 w, h));
+    if (w100c->ctx.xform.dx < 0) {
+        dstX += w - 1;
+        srcX += w - 1;
+    }
+
+    if (w100c->ctx.xform.dy < 0) {
+        dstY += h - 1;
+        srcY += h - 1;
+    }
+
+    if (W100WaitCmdFifoEntries(w100c, 3)) {
+        MMIO_OUT32(mmSRC_Y_X, (srcY << 16) | srcX);
+        MMIO_OUT32(mmDST_Y_X, (dstY << 16) | dstX);
+        MMIO_OUT32(mmDST_HEIGHT_WIDTH, (h << 16) | w);
+    } else {
+        ErrorF("Error in W100Copy\n");
+    }
+}
+
+void
+W100DoneCopy(void)
+{
+}
+
+Bool
+W100InitAccel(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+
+
+    DBG_IMAGEON(("--W100InitAccel: %d/%d depth/bpp\n", 
+                 pScreenPriv->screen->fb[0].depth,
+                 pScreenPriv->screen->fb[0].bitsPerPixel));
+
+    memset(&w100s->kaa, 0, sizeof(KaaScreenInfoRec));
+    w100s->kaa.waitMarker = W100WaitMarker;
+    w100s->kaa.PrepareSolid = W100PrepareSolid;
+    w100s->kaa.Solid = W100Solid;
+    w100s->kaa.DoneSolid = W100DoneSolid;
+    w100s->kaa.PrepareCopy = W100PrepareCopy;
+    w100s->kaa.Copy = W100Copy;
+    w100s->kaa.DoneCopy = W100DoneCopy;
+
+    w100s->kaa.flags |= KAA_OFFSCREEN_PIXMAPS;
+    /* Offset alignment, not sure if this is enought */
+    w100s->kaa.offsetAlign = 0;
+    w100s->kaa.pitchAlign  = 16;
+
+    if (!kaaDrawInit(pScreen, &w100s->kaa)) {
+        return FALSE;
+    }
+    DBG_IMAGEON(("KAA flags: 0x%08x\n", w100s->kaa.flags));
+    return TRUE;
+}
+
+void
+W100EnableAccel(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100CardInfo(pScreenPriv);
+
+    DBG_IMAGEON(("--W100EnableAccel\n"));
+
+    w100s->kaa.PrepareBlend = NULL;
+    w100s->kaa.Blend = NULL;
+    w100s->kaa.DoneBlend = NULL;
+    w100s->kaa.CheckComposite = NULL;
+    w100s->kaa.PrepareComposite = NULL;
+    w100s->kaa.Composite = NULL;
+    w100s->kaa.DoneComposite = NULL;
+    w100s->kaa.UploadToScreen = NULL;
+    w100s->kaa.UploadToScratch = NULL;
+    kaaMarkSync(pScreen);
+}
+
+void
+W100DisableAccel(ScreenPtr pScreen)
+{
+    DBG_IMAGEON(("--W100DisableAccel\n"));
+}
+
+void
+W100FiniAccel(ScreenPtr pScreen)
+{
+    DBG_IMAGEON(("--W100FiniAccel\n"));
+}
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon.h
@@ -0,0 +1,284 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _IMAGEON_H_
+#define _IMAGEON_H_
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+
+#include <fbdev.h>
+
+#include <kxv.h>
+
+#define DEBUG_IMAGEON 0
+#if DEBUG_IMAGEON
+#define DBG_IMAGEON(a)  ErrorF a
+#else
+#define DBG_IMAGEON(a)
+#endif
+
+
+#define W100_MEM_BASE   (0x08000000)
+#define W100_REG_OFFSET (0x00010000)
+#define W100_REG_BASE   (W100_MEM_BASE + W100_REG_OFFSET)
+#define W100_MEM_SIZE   (0x01000000)
+#define W100_REG_SIZE   (0x00002000)
+#define W100_CMDFIFO_SIZE (16)
+
+#define W100_CARD2HOST(x) (w100c->mem_base + (CARD32)(x))
+#define W100_HOST2CARD(x) ((x) - (CARD32)(w100c->mem_base))
+#define W100_MEMAREAS   (2)
+#define W100_INTMEM     (0)
+#define W100_EXTMEM     (1)
+
+#define W100_SYSFS_BASE "/sys/bus/platform/devices/w100fb/"
+
+#define MMIO_OUT32(a, v)   (*(VOL32 *)((w100c->reg_base) + (a)) = (v))
+#define MMIO_IN32(a)       (*(VOL32 *)((w100c->reg_base) + (a)))
+
+#define W100_MAX(x, y) ((x) > (y) ? x : y)
+#define W100_MIN(x, y) ((x) < (y) ? x : y)
+
+#define W100_ALIGN(q, a) ((q + a - 1) & ~(a - 1))
+
+#define TIMEOUT_LOCALS struct timeval _target, _curtime;
+
+static inline Bool
+tv_le(struct timeval *tv1, struct timeval *tv2)
+{
+    if (tv1->tv_sec < tv2->tv_sec ||
+        (tv1->tv_sec == tv2->tv_sec && 
+         tv1->tv_usec < tv2->tv_usec))
+        return TRUE;
+    else
+        return FALSE;
+}
+
+#define WHILE_NOT_TIMEOUT(_timeout)					\
+    gettimeofday(&_target, NULL);					\
+    _target.tv_usec += ((_timeout) * 1000000);                          \
+    _target.tv_sec += _target.tv_usec / 1000000;			\
+    _target.tv_usec = _target.tv_usec % 1000000;			\
+    while (gettimeofday(&_curtime, NULL), tv_le(&_curtime, &_target))
+
+#define TIMEDOUT()	(!tv_le(&_curtime, &_target))
+
+typedef volatile CARD8	VOL8;
+typedef volatile CARD16	VOL16;
+typedef volatile CARD32	VOL32;
+
+typedef struct _W100CardEntry {
+    CARD16 vendor;
+    CARD16 device;
+    CARD8 caps;
+    char *name;
+} W100CardEntry;
+
+
+typedef enum _W100Caps {
+    W100XVSupport = 1
+} W100Caps;
+
+typedef struct _W100ModeSpec {
+    CARD16 width;
+    CARD16 height;
+    CARD8  bpp;
+    CARD8  fbpool;
+    Bool   supported;
+} W100ModeSpec;
+
+typedef struct _W100BoxRec {
+    CARD16 x;
+    CARD16 y;
+    CARD16 w;
+    CARD16 h;
+} W100BoxRec, *W100BoxPtr;
+
+typedef struct _W100Mode {
+    CARD16 width;
+    CARD16 height;
+    CARD8  bpp;
+} W100Mode;
+
+typedef struct _W100MemArea {
+    CARD8 *start;
+    CARD32 size;
+    CARD8 priority;
+} W100MemArea;
+
+typedef struct _W100StartupInfo {
+    W100CardEntry *card_id;
+    W100Mode mode;
+    Bool portrait;
+    int randr;
+} W100StartupInfo;
+
+typedef struct _W100CardInfo {
+    FbdevPriv fbdev;
+    W100CardEntry    *card_id;
+    CARD8 *mem_base;
+    CARD8 *reg_base;
+    W100MemArea **memareas;
+    int num_memareas;
+    int cmdfifo_entries;
+    struct {
+        CARD32  ENG_CNTL;
+        CARD32  VIDEO_CTRL;
+        CARD32  GRAPHIC_H_DISP;
+        CARD32  GRAPHIC_V_DISP;
+        CARD32  DISP_DEBUG2;
+    } regs;
+    struct {
+        CARD8 *offset;
+        CARD16 width;
+        CARD16 height;
+        int randr;
+        W100ModeSpec *mode;
+        CARD8 bpp;
+    } hw_window;
+    CARD8 last_dst_videomem;
+    CARD8 last_src_videomem;
+    struct {
+        struct {
+            CARD8 datatype;
+            CARD32 pitch;
+            CARD32 offset;
+            CARD8 videomem;
+        } dst;
+        struct {
+            CARD8 datatype;
+            CARD32 pitch;
+            CARD32 offset;
+            CARD8 videomem;
+        } src;
+        struct {
+            int dx;
+            int dy;
+            int randr;
+            Bool mirror;
+            CARD32 dataPath;
+        } xform;
+        struct {
+            Pixel pm;
+            Bool enable;
+        } mask;
+    } ctx;
+} W100CardInfo;
+
+#define W100GetCardInfo(kd)	((W100CardInfo *) ((kd)->card->driver))
+#define W100CardInfo(kd)	W100CardInfo *w100c = W100GetCardInfo(kd)
+
+typedef struct _W100Cursor {
+    int width, height;
+    int xhot, yhot;
+    Bool has_cursor;
+    CursorPtr pCursor;
+    KdOffscreenArea *area;
+    CARD32 vpos;
+    CARD32 hpos;
+    CARD32 coffset;
+} W100Cursor;
+
+typedef struct _W100ScreenInfo {
+    FbdevScrPriv fbdev;
+    KaaScreenInfoRec kaa;
+    W100CardInfo *w100c;
+    KdScreenInfo *screen;
+    KdVideoAdaptorPtr pAdaptor;
+    W100Cursor cursor;
+} W100ScreenInfo;
+
+#define W100GetScreenInfo(kd)  ((W100ScreenInfo *) ((kd)->screen->driver))
+#define W100ScreenInfo(kd) W100ScreenInfo *w100s = W100GetScreenInfo(kd)
+
+typedef enum _W100VideoStatus {
+    W100_OVERLAY_ON         = 1,
+    W100_OVERLAY_CONFIGURED = 2
+} W100VideoStatus;
+
+
+typedef struct _W100PortPriv {
+    CARD32 videoStatus;
+    CARD32 videoCtrl;
+    RegionRec clip;
+    struct {
+        int width;                /* Source width  */
+        int height;               /* Source height */
+        unsigned char *buffer;    /* Source buffer */
+        int id;                   /* Source FOURCC */
+        int size;                 /* Size of source rect (bytes) */
+        KdOffscreenArea *surface; /* Source surface (on card memory) */
+        BoxRec box;               /* Source rect boundaries */
+    } src;
+    struct {
+        BoxRec box;               /* Screen rectangle */
+    } dst;
+    struct {
+        int size;                  /* Size of the overlay surface (bytes) */
+        KdOffscreenArea *surface;  /* Overlay surface (on card memory)    */
+        BoxRec box;                /* Overlay box (util size)             */
+        BoxRec frame;              /* Overlay box (plus corrections)      */
+        Bool changed;              /* To avoid recalculations             */
+        int horExp;                /* Horizontal expansion                */
+        int verExp;                /* Vertical expansion                  */
+        int maxSize;               /* Maximum allowed surface size (bytes) */
+        int colorKey;              /* Colour to replace with overlay */
+        int brightness;            /* Brigthness */
+    } ovl;
+    struct {
+        int size;                  /* Number of planes  */
+        int bpp;                   /* bpp of the planes */
+        int offset[3];             /* Planes offsets    */
+        CARD32 yplane;             /* Offset (card) of Y plane */
+        CARD32 uplane;             /* Offset (card) of U plane */
+        CARD32 vplane;             /* Offset (card) of V plane */
+    } planes;
+    Bool changed;              /* To track changes and avoid recalculations */
+} W100PortPrivRec, *W100PortPrivPtr;
+
+extern KdCardFuncs W100Funcs;
+
+/* imageon_draw.c */
+void W100WaitMarker(ScreenPtr pScreen, int marker);
+Bool W100PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg);
+void W100Solid(int x1, int y1, int x2, int y2);
+Bool W100PrepareCopy(PixmapPtr pSrc, PixmapPtr pDst, 
+                     int dx, int dy, int alu, Pixel pm);
+void W100Copy(int srcX, int srcY, int dstX, int dstY, int w, int h);
+void W100DoneCopy(void);
+Bool W100InitAccel(ScreenPtr pScreen);
+void W100EnableAccel(ScreenPtr pScreen);
+void W100DisableAccel(ScreenPtr pScreen);
+void W100FiniAccel(ScreenPtr pScreen);
+/* imageon_cursor.c */
+void W100CursorEnable(ScreenPtr pScreen);
+void W100CursorDisable(ScreenPtr pScreen);
+Bool W100CursorInit(ScreenPtr pScreen);
+void W100RecolorCursor(ScreenPtr pScreen, int ndef, xColorItem * pdef);
+void W100CursorFini(ScreenPtr pScreen);
+
+
+
+
+#endif /* _IMAGEON_H_ */
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_regs.h
@@ -0,0 +1,4155 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __IMAGEON_REGS_H__
+#define __IMAGEON_REGS_H__
+
+/* Block CIF Start: */
+#define mmCHIP_ID                                                    0x0000
+#define mmREVISION_ID                                                0x0004
+#define mmWRAP_BUF_A                                                 0x0008
+#define mmWRAP_BUF_B                                                 0x000C
+#define mmWRAP_TOP_DIR                                               0x0010
+#define mmWRAP_START_DIR                                             0x0014
+#define mmCIF_CNTL                                                   0x0018
+#define mmCFGREG_BASE                                                0x001C
+#define mmCIF_IO                                                     0x0020
+#define mmCIF_READ_DBG                                               0x0024
+#define mmCIF_WRITE_DBG                                              0x0028
+#define cfgIND_ADDR_A_0                                              0x0000
+#define cfgIND_ADDR_A_1                                              0x0001
+#define cfgIND_ADDR_A_2                                              0x0002
+#define cfgIND_DATA_A                                                0x0003
+#define cfgREG_BASE                                                  0x0004
+#define cfgINTF_CNTL                                                 0x0005
+#define cfgSTATUS                                                    0x0006
+#define cfgCPU_DEFAULTS                                              0x0007
+#define cfgIND_ADDR_B_0                                              0x0008
+#define cfgIND_ADDR_B_1                                              0x0009
+#define cfgIND_ADDR_B_2                                              0x000A
+#define cfgIND_DATA_B                                                0x000B
+#define cfgPM4_RPTR                                                  0x000C
+#define cfgSCRATCH                                                   0x000D
+#define cfgPM4_WRPTR_0                                               0x000E
+#define cfgPM4_WRPTR_1                                               0x000F
+/* Block CIF End: */
+
+/* Block CP Start: */
+#define mmCP_RB_CNTL                                                 0x0210
+#define mmCP_RB_BASE                                                 0x0214
+#define mmCP_RB_RPTR_ADDR                                            0x0218
+#define mmCP_RB_RPTR                                                 0x021C
+#define mmCP_RB_RPTR_WR                                              0x02F8
+#define mmCP_RB_WPTR                                                 0x0220
+#define mmCP_IB_BASE                                                 0x0228
+#define mmCP_IB_BUFSZ                                                0x022C
+#define mmCP_CSQ_CNTL                                                0x0230
+#define mmCP_CSQ_APER_PRIMARY                                        0x0300
+#define mmCP_CSQ_APER_INDIRECT                                       0x0340
+#define mmCP_ME_CNTL                                                 0x0240
+#define mmCP_ME_RAM_ADDR                                             0x0244
+#define mmCP_ME_RAM_RADDR                                            0x0248
+#define mmCP_ME_RAM_DATAH                                            0x024C
+#define mmCP_ME_RAM_DATAL                                            0x0250
+#define mmCP_DEBUG                                                   0x025C
+#define mmSCRATCH_REG0                                               0x0260
+#define mmSCRATCH_REG1                                               0x0264
+#define mmSCRATCH_REG2                                               0x0268
+#define mmSCRATCH_REG3                                               0x026C
+#define mmSCRATCH_REG4                                               0x0270
+#define mmSCRATCH_REG5                                               0x0274
+#define mmSCRATCH_UMSK                                               0x0280
+#define mmSCRATCH_ADDR                                               0x0284
+#define mmCP_CSQ_ADDR                                                0x02E4
+#define mmCP_CSQ_DATA                                                0x02E8
+#define mmCP_CSQ_STAT                                                0x02EC
+#define mmCP_STAT                                                    0x02F0
+#define mmGEN_INT_CNTL                                               0x0200
+#define mmGEN_INT_STATUS                                             0x0204
+/* Block CP End: */
+
+/* Block DISPLAY Start: */
+#define mmLCD_FORMAT                                                 0x0410
+#define mmGRAPHIC_CTRL                                               0x0414
+#define mmGRAPHIC_OFFSET                                             0x0418
+#define mmGRAPHIC_PITCH                                              0x041C
+#define mmCRTC_TOTAL                                                 0x0420
+#define mmACTIVE_H_DISP                                              0x0424
+#define mmACTIVE_V_DISP                                              0x0428
+#define mmGRAPHIC_H_DISP                                             0x042C
+#define mmGRAPHIC_V_DISP                                             0x0430
+#define mmVIDEO_CTRL                                                 0x0434
+#define mmGRAPHIC_KEY                                                0x0438
+#define mmVIDEO_Y_OFFSET                                             0x043C
+#define mmVIDEO_Y_PITCH                                              0x0440
+#define mmVIDEO_U_OFFSET                                             0x0444
+#define mmVIDEO_U_PITCH                                              0x0448
+#define mmVIDEO_V_OFFSET                                             0x044C
+#define mmVIDEO_V_PITCH                                              0x0450
+#define mmVIDEO_H_POS                                                0x0454
+#define mmVIDEO_V_POS                                                0x0458
+#define mmBRIGHTNESS_CNTL                                            0x045C
+#define mmCURSOR1_OFFSET                                             0x0460
+#define mmCURSOR1_H_POS                                              0x0464
+#define mmCURSOR1_V_POS                                              0x0468
+#define mmCURSOR1_COLOR0                                             0x046C
+#define mmCURSOR1_COLOR1                                             0x0470
+#define mmCURSOR2_OFFSET                                             0x0474
+#define mmCURSOR2_H_POS                                              0x0478
+#define mmCURSOR2_V_POS                                              0x047C
+#define mmCURSOR2_COLOR0                                             0x0480
+#define mmCURSOR2_COLOR1                                             0x0484
+#define mmDISP_INT_CNTL                                              0x0488
+#define mmCRTC_SS                                                    0x048C
+#define mmCRTC_LS                                                    0x0490
+#define mmCRTC_REV                                                   0x0494
+#define mmCRTC_DCLK                                                  0x049C
+#define mmCRTC_GS                                                    0x04A0
+#define mmCRTC_VPOS_GS                                               0x04A4
+#define mmCRTC_GCLK                                                  0x04A8
+#define mmCRTC_GOE                                                   0x04AC
+#define mmCRTC_FRAME                                                 0x04B0
+#define mmCRTC_FRAME_VPOS                                            0x04B4
+#define mmGPIO_DATA                                                  0x04B8
+#define mmGPIO_CNTL1                                                 0x04BC
+#define mmGPIO_CNTL2                                                 0x04C0
+#define mmLCDD_CNTL1                                                 0x04C4
+#define mmLCDD_CNTL2                                                 0x04C8
+#define mmGENLCD_CNTL1                                               0x04CC
+#define mmGENLCD_CNTL2                                               0x04D0
+#define mmDISP_DEBUG                                                 0x04D4
+#define mmDISP_DB_BUF_CNTL                                           0x04D8
+#define mmDISP_CRC_SIG                                               0x04DC
+#define mmCRTC_DEFAULT_COUNT                                         0x04E0
+#define mmLCD_BACKGROUND_COLOR                                       0x04E4
+#define mmCRTC_PS2                                                   0x04E8
+#define mmCRTC_PS2_VPOS                                              0x04EC
+#define mmCRTC_PS1_ACTIVE                                            0x04F0
+#define mmCRTC_PS1_NACTIVE                                           0x04F4
+#define mmCRTC_GCLK_EXT                                              0x04F8
+#define mmCRTC_ALW                                                   0x04FC
+#define mmCRTC_ALW_VPOS                                              0x0500
+#define mmCRTC_PSK                                                   0x0504
+#define mmCRTC_PSK_HPOS                                              0x0508
+#define mmCRTC_CV4_START                                             0x050C
+#define mmCRTC_CV4_END                                               0x0510
+#define mmCRTC_CV4_HPOS                                              0x0514
+#define mmCRTC_ECK                                                   0x051C
+#define mmREFRESH_CNTL                                               0x0520
+#define mmGENLCD_CNTL3                                               0x0524
+#define mmGPIO_DATA2                                                 0x0528
+#define mmGPIO_CNTL3                                                 0x052C
+#define mmGPIO_CNTL4                                                 0x0530
+#define mmCHIP_STRAP                                                 0x0534
+#define mmDISP_DEBUG2                                                0x0538
+#define mmDEBUG_BUS_CNTL                                             0x053C
+#define mmGAMMA_VALUE1                                               0x0540
+#define mmGAMMA_VALUE2                                               0x0544
+#define mmGAMMA_SLOPE                                                0x0548
+#define mmGEN_STATUS                                                 0x054C
+#define mmHW_INT                                                     0x0550
+/* Block DISPLAY End: */
+
+/* Block GFX Start: */
+#define mmDST_OFFSET                                                 0x1004
+#define mmDST_PITCH                                                  0x1008
+#define mmDST_PITCH_OFFSET                                           0x102C
+#define mmDST_X                                                      0x101C
+#define mmDST_Y                                                      0x1020
+#define mmDST_X_Y                                                    0x1194
+#define mmDST_Y_X                                                    0x1038
+#define mmDST_WIDTH                                                  0x100C
+#define mmDST_HEIGHT                                                 0x1010
+#define mmDST_WIDTH_HEIGHT                                           0x1198
+#define mmDST_HEIGHT_WIDTH                                           0x103C
+#define mmDST_HEIGHT_WIDTH_8                                         0x118C
+#define mmDST_HEIGHT_Y                                               0x11A0
+#define mmDST_WIDTH_X                                                0x1188
+#define mmDST_WIDTH_X_INCY                                           0x119C
+#define mmDST_LINE_START                                             0x1090
+#define mmDST_LINE_END                                               0x1094
+#define mmBRUSH_OFFSET                                               0x108C
+#define mmBRUSH_Y_X                                                  0x1074
+#define mmDP_BRUSH_FRGD_CLR                                          0x107C
+#define mmDP_BRUSH_BKGD_CLR                                          0x1078
+#define mmSRC2_OFFSET                                                0x1060
+#define mmSRC2_PITCH                                                 0x1064
+#define mmSRC2_PITCH_OFFSET                                          0x1068
+#define mmSRC2_X                                                     0x1050
+#define mmSRC2_Y                                                     0x1054
+#define mmSRC2_X_Y                                                   0x1058
+#define mmSRC2_WIDTH                                                 0x1080
+#define mmSRC2_HEIGHT                                                0x1084
+#define mmSRC2_INC                                                   0x1088
+#define mmSRC_OFFSET                                                 0x11AC
+#define mmSRC_PITCH                                                  0x11B0
+#define mmSRC_PITCH_OFFSET                                           0x1028
+#define mmSRC_X                                                      0x1014
+#define mmSRC_Y                                                      0x1018
+#define mmSRC_X_Y                                                    0x1190
+#define mmSRC_Y_X                                                    0x1034
+#define mmSRC_WIDTH                                                  0x1040
+#define mmSRC_HEIGHT                                                 0x1044
+#define mmSRC_INC                                                    0x1048
+#define mmHOST_DATA0                                                 0x13C0
+#define mmHOST_DATA1                                                 0x13C4
+#define mmHOST_DATA2                                                 0x13C8
+#define mmHOST_DATA3                                                 0x13CC
+#define mmHOST_DATA4                                                 0x13D0
+#define mmHOST_DATA5                                                 0x13D4
+#define mmHOST_DATA6                                                 0x13D8
+#define mmHOST_DATA7                                                 0x13DC
+#define mmHOST_DATA_LAST                                             0x13E0
+#define mmDP_SRC_FRGD_CLR                                            0x1240
+#define mmDP_SRC_BKGD_CLR                                            0x1244
+#define mmSC_LEFT                                                    0x1140
+#define mmSC_RIGHT                                                   0x1144
+#define mmSC_TOP                                                     0x1148
+#define mmSC_BOTTOM                                                  0x114C
+#define mmSRC_SC_RIGHT                                               0x1154
+#define mmSRC_SC_BOTTOM                                              0x115C
+#define mmDP_CNTL                                                    0x11C8
+#define mmDP_CNTL_DST_DIR                                            0x11CC
+#define mmDP_DATATYPE                                                0x12C4
+#define mmDP_MIX                                                     0x12C8
+#define mmDP_WRITE_MSK                                               0x12CC
+#define mmCLR_CMP_CLR_SRC                                            0x1234
+#define mmCLR_CMP_CLR_DST                                            0x1238
+#define mmCLR_CMP_CNTL                                               0x1230
+#define mmCLR_CMP_MSK                                                0x123C
+#define mmDEFAULT_PITCH_OFFSET                                       0x10A0
+#define mmDEFAULT_SC_BOTTOM_RIGHT                                    0x10A8
+#define mmDEFAULT2_SC_BOTTOM_RIGHT                                   0x10AC
+#define mmREF1_PITCH_OFFSET                                          0x10B8
+#define mmREF2_PITCH_OFFSET                                          0x10BC
+#define mmREF3_PITCH_OFFSET                                          0x10C0
+#define mmREF4_PITCH_OFFSET                                          0x10C4
+#define mmREF5_PITCH_OFFSET                                          0x10C8
+#define mmREF6_PITCH_OFFSET                                          0x10CC
+#define mmDP_GUI_MASTER_CNTL                                         0x106C
+#define mmSC_TOP_LEFT                                                0x11BC
+#define mmSC_BOTTOM_RIGHT                                            0x11C0
+#define mmSRC_SC_BOTTOM_RIGHT                                        0x11C4
+#define mmGLOBAL_ALPHA                                               0x1210
+#define mmFILTER_COEF                                                0x1214
+#define mmMVC_CNTL_START                                             0x11E0
+#define mmE2_ARITHMETIC_CNTL                                         0x1220
+#define mmDEBUG0                                                     0x1280
+#define mmDEBUG1                                                     0x1284
+#define mmDEBUG2                                                     0x1288
+#define mmDEBUG3                                                     0x128C
+#define mmDEBUG4                                                     0x1290
+#define mmDEBUG5                                                     0x1294
+#define mmDEBUG6                                                     0x1298
+#define mmDEBUG7                                                     0x129C
+#define mmDEBUG8                                                     0x12A0
+#define mmDEBUG9                                                     0x12A4
+#define mmDEBUG10                                                    0x12A8
+#define mmDEBUG11                                                    0x12AC
+#define mmDEBUG12                                                    0x12B0
+#define mmDEBUG13                                                    0x12B4
+#define mmDEBUG14                                                    0x12B8
+#define mmDEBUG15                                                    0x12BC
+#define mmENG_CNTL                                                   0x13E8
+#define mmENG_PERF_CNT                                               0x13F0
+/* Block GFX End: */
+
+/* Block IDCT Start: */
+#define mmIDCT_RUNS                                                  0x0C00
+#define mmIDCT_LEVELS                                                0x0C04
+#define mmIDCT_CONTROL                                               0x0C3C
+#define mmIDCT_AUTH_CONTROL                                          0x0C08
+#define mmIDCT_AUTH                                                  0x0C0C
+/* Block IDCT End: */
+
+/* Block MC Start: */
+#define mmMEM_CNTL                                                   0x0180
+#define mmMEM_ARB                                                    0x0184
+#define mmMC_FB_LOCATION                                             0x0188
+#define mmMEM_EXT_CNTL                                               0x018C
+#define mmMC_EXT_MEM_LOCATION                                        0x0190
+#define mmMEM_EXT_TIMING_CNTL                                        0x0194
+#define mmMEM_SDRAM_MODE_REG                                         0x0198
+#define mmMEM_IO_CNTL                                                0x019C
+#define mmMC_DEBUG                                                   0x01A0
+#define mmMC_BIST_CTRL                                               0x01A4
+#define mmMC_BIST_COLLAR_READ                                        0x01A8
+#define mmTC_MISMATCH                                                0x01AC
+#define mmMC_PERF_MON_CNTL                                           0x01B0
+#define mmMC_PERF_COUNTERS                                           0x01B4
+/* Block MC End: */
+
+/* Block RBBM Start: */
+#define mmWAIT_UNTIL                                                 0x1400
+#define mmISYNC_CNTL                                                 0x1404
+#define mmRBBM_GUICNTL                                               0x1408
+#define mmRBBM_STATUS                                                0x0140
+#define mmRBBM_STATUS_alt_1                                          0x140C
+#define mmRBBM_CNTL                                                  0x0144
+#define mmRBBM_SOFT_RESET                                            0x0148
+#define mmNQWAIT_UNTIL                                               0x0150
+#define mmRBBM_DEBUG                                                 0x016C
+#define mmRBBM_CMDFIFO_ADDR                                          0x0170
+#define mmRBBM_CMDFIFO_DATAL                                         0x0174
+#define mmRBBM_CMDFIFO_DATAH                                         0x0178
+#define mmRBBM_CMDFIFO_STAT                                          0x017C
+/* Block RBBM End: */
+
+/* Block CG Start: */
+#define mmCLK_PIN_CNTL                                               0x0080
+#define mmPLL_REF_FB_DIV                                             0x0084
+#define mmPLL_CNTL                                                   0x0088
+#define mmSCLK_CNTL                                                  0x008C
+#define mmPCLK_CNTL                                                  0x0090
+#define mmCLK_TEST_CNTL                                              0x0094
+#define mmPWRMGT_CNTL                                                0x0098
+#define mmPWRMGT_STATUS                                              0x009C
+/* Block CG End: */
+
+/* default value definitions */
+#define defCHIP_ID                        0x00001002
+#define defREVISION_ID                    0x00000000
+#define defWRAP_BUF_A                     0x01000000
+#define defWRAP_BUF_B                     0x01000000
+#define defWRAP_TOP_DIR                   0x00000000
+#define defWRAP_START_DIR                 0x00000000
+//#define defCIF_CNTL                       0x00082900
+#define defCIF_CNTL                       0x00182d00		//??updated by Tobey Z.for Sharp,Oct11,2002
+#define defCFGREG_BASE                    0x00000000
+//#define defCIF_IO                         0x000c0800
+#define defCIF_IO                         0x000C0902		//??updated by Tobey Z.for Sharp,Oct11,2002
+#define defCIF_READ_DBG                   0x00018223
+#define defCIF_WRITE_DBG                  0x00002100
+#define defIND_ADDR_A_0                   0x00000000
+#define defIND_ADDR_A_1                   0x00000000
+#define defIND_ADDR_A_2                   0x00000000
+#define defIND_DATA_A                     0x00000000
+#define defREG_BASE                       0x00000001
+#define defINTF_CNTL                      0x00000011
+#define defSTATUS                         0x00000000
+#define defCPU_DEFAULTS                   0x00000006
+#define defIND_ADDR_B_0                   0x00000000
+#define defIND_ADDR_B_1                   0x00000000
+#define defIND_ADDR_B_2                   0x00000000
+#define defIND_DATA_B                     0x00000000
+#define defPM4_RPTR                       0x00000000
+#define defSCRATCH                        0x00000000
+#define defPM4_WRPTR_0                    0x00000000
+#define defPM4_WRPTR_1                    0x00000000
+#define defCP_RB_CNTL                     0x00000000
+#define defCP_RB_BASE                     0x00000000
+#define defCP_RB_RPTR_ADDR                0x00000000
+#define defCP_RB_RPTR                     0x00000000
+#define defCP_RB_RPTR_WR                  0x00000000
+#define defCP_RB_WPTR                     0x00000000
+#define defCP_IB_BASE                     0x00000000
+#define defCP_IB_BUFSZ                    0x00000000
+#define defCP_CSQ_CNTL                    0x00000000
+#define defCP_CSQ_APER_PRIMARY            0x00000000
+#define defCP_CSQ_APER_INDIRECT           0x00000000
+#define defCP_ME_CNTL                     0x40000000
+#define defCP_ME_RAM_ADDR                 0x00000000
+#define defCP_ME_RAM_RADDR                0x00000000
+#define defCP_ME_RAM_DATAH                0x00000000
+#define defCP_ME_RAM_DATAL                0x00000000
+#define defCP_DEBUG                       0x00000000
+#define defSCRATCH_REG0                   0x00000000
+#define defSCRATCH_REG1                   0x00000000
+#define defSCRATCH_REG2                   0x00000000
+#define defSCRATCH_REG3                   0x00000000
+#define defSCRATCH_REG4                   0x00000000
+#define defSCRATCH_REG5                   0x00000000
+#define defSCRATCH_UMSK                   0x00000000
+#define defSCRATCH_ADDR                   0x00000000
+#define defCP_CSQ_ADDR                    0x00000000
+#define defCP_CSQ_DATA                    0x00000000
+#define defCP_CSQ_STAT                    0x00000000
+#define defCP_STAT                        0x00000000
+#define defGEN_INT_CNTL                   0x00000000
+#define defGEN_INT_STATUS_rd              0x00080000
+#define defGEN_INT_STATUS_wr              0x00000000
+#define defLCD_FORMAT                     0x00000000
+#define defGRAPHIC_CTRL                   0x00000000
+#define defGRAPHIC_OFFSET                 0x00000000
+#define defGRAPHIC_PITCH                  0x00000000
+#define defCRTC_TOTAL                     0x00000000
+#define defACTIVE_H_DISP                  0x00000000
+#define defACTIVE_V_DISP                  0x00000000
+#define defGRAPHIC_H_DISP                 0x00000000
+#define defGRAPHIC_V_DISP                 0x00000000
+#define defVIDEO_CTRL                     0x00000000
+#define defGRAPHIC_KEY                    0x00000000
+#define defVIDEO_Y_OFFSET                 0x00000000
+#define defVIDEO_Y_PITCH                  0x00000000
+#define defVIDEO_U_OFFSET                 0x00000000
+#define defVIDEO_U_PITCH                  0x00000000
+#define defVIDEO_V_OFFSET                 0x00000000
+#define defVIDEO_V_PITCH                  0x00000000
+#define defVIDEO_H_POS                    0x00000000
+#define defVIDEO_V_POS                    0x00000000
+#define defBRIGHTNESS_CNTL                0x00000000
+#define defCURSOR1_OFFSET                 0x00000000
+#define defCURSOR1_H_POS                  0x00000000
+#define defCURSOR1_V_POS                  0x00000000
+#define defCURSOR1_COLOR0                 0x00000000
+#define defCURSOR1_COLOR1                 0x00000000
+#define defCURSOR2_OFFSET                 0x00000000
+#define defCURSOR2_H_POS                  0x00000000
+#define defCURSOR2_V_POS                  0x00000000
+#define defCURSOR2_COLOR0                 0x00000000
+#define defCURSOR2_COLOR1                 0x00000000
+#define defDISP_INT_CNTL                  0x00000000
+#define defCRTC_SS                        0x00000000
+#define defCRTC_LS                        0x00000000
+#define defCRTC_REV                       0x00000000
+#define defCRTC_DCLK                      0x00000000
+#define defCRTC_GS                        0x00000000
+#define defCRTC_VPOS_GS                   0x00000000
+#define defCRTC_GCLK                      0x00000000
+#define defCRTC_GOE                       0x00000000
+#define defCRTC_FRAME                     0x00000000
+#define defCRTC_FRAME_VPOS                0x00000000
+#define defGPIO_DATA                      0x00000000
+#define defGPIO_CNTL1                     0xff00ff00
+#define defGPIO_CNTL2                     0x00000000
+#define defLCDD_CNTL1                     0x0000ffff
+#define defLCDD_CNTL2                     0x00000000
+#define defGENLCD_CNTL1                   0x00aaa002
+#define defGENLCD_CNTL2                   0x00000002
+#define defDISP_DEBUG                     0x00000000
+#define defDISP_DB_BUF_CNTL_rd            0x00000000
+#define defDISP_DB_BUF_CNTL_wr            0x00000000
+#define defDISP_CRC_SIG                   0x00000000
+#define defCRTC_DEFAULT_COUNT             0x00000000
+#define defLCD_BACKGROUND_COLOR           0x00000000
+#define defCRTC_PS2                       0x00000000
+#define defCRTC_PS2_VPOS                  0x00000000
+#define defCRTC_PS1_ACTIVE                0x00000000
+#define defCRTC_PS1_NACTIVE               0x00000000
+#define defCRTC_GCLK_EXT                  0x00000000
+#define defCRTC_ALW                       0x00000000
+#define defCRTC_ALW_VPOS                  0x00000000
+#define defCRTC_PSK                       0x00000000
+#define defCRTC_PSK_HPOS                  0x00000000
+#define defCRTC_CV4_START                 0x00000000
+#define defCRTC_CV4_END                   0x00000000
+#define defCRTC_CV4_HPOS                  0x00000000
+#define defCRTC_ECK                       0x00000000
+#define defREFRESH_CNTL                   0x00000000
+#define defGENLCD_CNTL3                   0x000002aa
+#define defGPIO_DATA2                     0x00000000
+#define defGPIO_CNTL3                     0x00000000
+#define defGPIO_CNTL4                     0x00000000
+#define defCHIP_STRAP                     0x00000000
+#define defDISP_DEBUG2                    0x00000000
+#define defDEBUG_BUS_CNTL                 0x00000000
+#define defGAMMA_VALUE1                   0x00000000
+#define defGAMMA_VALUE2                   0x00000000
+#define defGAMMA_SLOPE                    0x00000000
+#define defGEN_STATUS                     0x00000000
+#define defHW_INT                         0x00000000
+#define defDST_OFFSET                     0x00000000
+#define defDST_PITCH                      0x00000000
+#define defDST_PITCH_OFFSET               0x00000000
+#define defDST_X                          0x00000000
+#define defDST_Y                          0x00000000
+#define defDST_X_Y                        0x00000000
+#define defDST_Y_X                        0x00000000
+#define defDST_WIDTH                      0x00000000
+#define defDST_HEIGHT                     0x00000000
+#define defDST_WIDTH_HEIGHT               0x00000000
+#define defDST_HEIGHT_WIDTH               0x00000000
+#define defDST_HEIGHT_WIDTH_8             0x00000000
+#define defDST_HEIGHT_Y                   0x00000000
+#define defDST_WIDTH_X                    0x00000000
+#define defDST_WIDTH_X_INCY               0x00000000
+#define defDST_LINE_START                 0x00000000
+#define defDST_LINE_END                   0x00000000
+#define defBRUSH_OFFSET                   0x00000000
+#define defBRUSH_Y_X                      0x00000000
+#define defDP_BRUSH_FRGD_CLR              0x00000000
+#define defDP_BRUSH_BKGD_CLR              0x00000000
+#define defSRC2_OFFSET                    0x00000000
+#define defSRC2_PITCH                     0x00000000
+#define defSRC2_PITCH_OFFSET              0x00000000
+#define defSRC2_X                         0x00000000
+#define defSRC2_Y                         0x00000000
+#define defSRC2_X_Y                       0x00000000
+#define defSRC2_WIDTH                     0x00000000
+#define defSRC2_HEIGHT                    0x00000000
+#define defSRC2_INC                       0x00000000
+#define defSRC_OFFSET                     0x00000000
+#define defSRC_PITCH                      0x00000000
+#define defSRC_PITCH_OFFSET               0x00000000
+#define defSRC_X                          0x00000000
+#define defSRC_Y                          0x00000000
+#define defSRC_X_Y                        0x00000000
+#define defSRC_Y_X                        0x00000000
+#define defSRC_WIDTH                      0x00000000
+#define defSRC_HEIGHT                     0x00000000
+#define defSRC_INC                        0x00000000
+#define defHOST_DATA0                     0x00000000
+#define defHOST_DATA1                     0x00000000
+#define defHOST_DATA2                     0x00000000
+#define defHOST_DATA3                     0x00000000
+#define defHOST_DATA4                     0x00000000
+#define defHOST_DATA5                     0x00000000
+#define defHOST_DATA6                     0x00000000
+#define defHOST_DATA7                     0x00000000
+#define defHOST_DATA_LAST                 0x00000000
+#define defDP_SRC_FRGD_CLR                0x00000000
+#define defDP_SRC_BKGD_CLR                0x00000000
+#define defSC_LEFT                        0x00000000
+#define defSC_RIGHT                       0x00000000
+#define defSC_TOP                         0x00000000
+#define defSC_BOTTOM                      0x00000000
+#define defSRC_SC_RIGHT                   0x00000000
+#define defSRC_SC_BOTTOM                  0x00000000
+#define defDP_CNTL                        0x00000000
+#define defDP_CNTL_DST_DIR                0x00000000
+#define defDP_DATATYPE                    0x00000000
+#define defDP_MIX                         0x00000000
+#define defDP_WRITE_MSK                   0x00000000
+#define defCLR_CMP_CLR_SRC                0x00000000
+#define defCLR_CMP_CLR_DST                0x00000000
+#define defCLR_CMP_CNTL                   0x00000000
+#define defCLR_CMP_MSK                    0x00000000
+#define defDEFAULT_PITCH_OFFSET           0x00000000
+#define defDEFAULT_SC_BOTTOM_RIGHT        0x00000000
+#define defDEFAULT2_SC_BOTTOM_RIGHT       0x00000000
+#define defREF1_PITCH_OFFSET              0x00000000
+#define defREF2_PITCH_OFFSET              0x00000000
+#define defREF3_PITCH_OFFSET              0x00000000
+#define defREF4_PITCH_OFFSET              0x00000000
+#define defREF5_PITCH_OFFSET              0x00000000
+#define defREF6_PITCH_OFFSET              0x00000000
+#define defDP_GUI_MASTER_CNTL             0x00000000
+#define defSC_TOP_LEFT                    0x00000000
+#define defSC_BOTTOM_RIGHT                0x00000000
+#define defSRC_SC_BOTTOM_RIGHT            0x00000000
+#define defGLOBAL_ALPHA                   0x00000000
+#define defFILTER_COEF                    0x00000000
+#define defMVC_CNTL_START                 0x00000000
+#define defE2_ARITHMETIC_CNTL             0x00000000
+#define defDEBUG0                         0x00000000
+#define defDEBUG1                         0x00000000
+#define defDEBUG2                         0x00000000
+#define defDEBUG3                         0x00000000
+#define defDEBUG4                         0x00000000
+#define defDEBUG5                         0x00000000
+#define defDEBUG6                         0x00000000
+#define defDEBUG7                         0x00000000
+#define defDEBUG8                         0x00000000
+#define defDEBUG9                         0x00000000
+#define defDEBUG10                        0x00000000
+#define defDEBUG11                        0x00000000
+#define defDEBUG12                        0x00000000
+#define defDEBUG13                        0x00000000
+#define defDEBUG14                        0x00000000
+#define defDEBUG15                        0x00000000
+#define defENG_CNTL                       0x00000003
+#define defENG_PERF_CNT                   0x00000000
+#define defIDCT_RUNS                      0x00000000
+#define defIDCT_LEVELS                    0x00000000
+#define defIDCT_CONTROL                   0x00000000
+#define defIDCT_AUTH_CONTROL              0x00000000
+#define defIDCT_AUTH                      0x00000000
+#define defMEM_CNTL                       0x00000006
+#define defMEM_ARB                        0x00000000
+#define defMC_FB_LOCATION                 0x00ff0000
+#define defMEM_EXT_CNTL                   0x00040010
+#define defMC_EXT_MEM_LOCATION            0x07ff0000
+#define defMEM_EXT_TIMING_CNTL            0x00140c73
+#define defMEM_SDRAM_MODE_REG             0x00050000
+#define defMEM_IO_CNTL                    0x00ff00ff
+#define defMC_DEBUG                       0x00000000
+#define defMC_BIST_CTRL                   0x00000000
+#define defMC_BIST_COLLAR_READ            0x00000000
+#define defTC_MISMATCH                    0x00000000
+#define defMC_PERF_MON_CNTL               0x00000000
+#define defMC_PERF_COUNTERS               0x00000000
+#define defWAIT_UNTIL                     0xc5cdcdcd
+#define defISYNC_CNTL                     0x00000000
+#define defRBBM_GUICNTL                   0x00000000
+#define defRBBM_STATUS                    0x81cdcd40
+#define defRBBM_CNTL                      0x0000000f
+#define defRBBM_SOFT_RESET                0x00000000
+#define defNQWAIT_UNTIL                   0x00000001
+#define defRBBM_DEBUG                     0x00000000
+#define defRBBM_CMDFIFO_ADDR              0x0000000d
+#define defRBBM_CMDFIFO_DATAL             0xcdcdcdcd
+#define defRBBM_CMDFIFO_DATAH             0x00000dcd
+#define defRBBM_CMDFIFO_STAT              0x00000d0d
+#define defCLK_PIN_CNTL                   0x0000003f
+#define defPLL_REF_FB_DIV                 0x5a500000
+#define defPLL_CNTL                       0x4b000203
+#define defSCLK_CNTL                      0x00ff0300
+#define defPCLK_CNTL                      0x00010000
+#define defCLK_TEST_CNTL                  0x00000000
+#define defPWRMGT_CNTL                    0x00000004
+#define defPWRMGT_STATUS                  0x00000001
+
+#define CFG_BASE_BOOT_DEFAULT  0x0
+#define CFG_BASE_VALUE         0x0
+#define REG_BASE_BOOT_DEFAULT  0x01
+#define REG_BASE_VALUE         0x10000
+#define MEM_INT_BASE_VALUE     0x100000
+#define MEM_INT_TOP_VALUE_W100 0x15ffff
+#define MEM_EXT_BASE_VALUE     0x800000
+#define MEM_EXT_TOP_VALUE      0x9fffff
+#define WRAP_BUF_BASE_VALUE    0x80000
+#define WRAP_BUF_TOP_VALUE     0xbffff
+
+
+/* data structure definitions */
+
+typedef struct _chip_id_t {
+     unsigned long vendor_id                      : 16;
+     unsigned long device_id                      : 16;
+     } chip_id_t;
+
+typedef union {
+     unsigned long val : 32;
+     chip_id_t f;
+} chip_id_u;
+
+typedef struct _revision_id_t {
+     unsigned long minor_rev_id                   : 4;
+     unsigned long major_rev_id                   : 4;
+     unsigned long                                : 24;
+     } revision_id_t;
+
+typedef union {
+     unsigned long val : 32;
+     revision_id_t f;
+} revision_id_u;
+
+typedef struct _wrap_buf_a_t {
+     unsigned long offset_addr_a                  : 24;
+     unsigned long block_size_a                   : 3;
+     unsigned long                                : 5;
+     } wrap_buf_a_t;
+
+typedef union {
+     unsigned long val : 32;
+     wrap_buf_a_t f;
+} wrap_buf_a_u;
+
+typedef struct _wrap_buf_b_t {
+     unsigned long offset_addr_b                  : 24;
+     unsigned long block_size_b                   : 3;
+     unsigned long                                : 5;
+     } wrap_buf_b_t;
+
+typedef union {
+     unsigned long val : 32;
+     wrap_buf_b_t f;
+} wrap_buf_b_u;
+
+typedef struct _wrap_top_dir_t {
+     unsigned long top_addr                       : 23;
+     unsigned long                                : 9;
+     } wrap_top_dir_t;
+
+typedef union {
+     unsigned long val : 32;
+     wrap_top_dir_t f;
+} wrap_top_dir_u;
+
+typedef struct _wrap_start_dir_t {
+     unsigned long start_addr                     : 23;
+     unsigned long                                : 9;
+     } wrap_start_dir_t;
+
+typedef union {
+     unsigned long val : 32;
+     wrap_start_dir_t f;
+} wrap_start_dir_u;
+
+typedef struct _cif_cntl_t {
+     unsigned long swap_reg                       : 2;
+     unsigned long swap_fbuf_1                    : 2;
+     unsigned long swap_fbuf_2                    : 2;
+     unsigned long swap_fbuf_3                    : 2;
+     unsigned long pmi_int_disable                : 1;
+     unsigned long pmi_schmen_disable             : 1;
+     unsigned long intb_oe                        : 1;
+     unsigned long en_wait_to_compensate_dq_prop_dly : 1;
+     unsigned long compensate_wait_rd_size        : 2;
+     unsigned long wait_asserted_timeout_val      : 2;
+     unsigned long wait_masked_val                : 2;
+     unsigned long en_wait_timeout                : 1;
+     unsigned long en_one_clk_setup_before_wait   : 1;
+     unsigned long interrupt_active_high          : 1;
+     unsigned long en_overwrite_straps            : 1;
+     unsigned long strap_wait_active_hi           : 1;
+     unsigned long lat_busy_count                 : 2;
+     unsigned long lat_rd_pm4_sclk_busy           : 1;
+     unsigned long dis_system_bits                : 1;
+     unsigned long dis_mr                         : 1;
+     unsigned long cif_spare_1                    : 4;
+     } cif_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     cif_cntl_t f;
+} cif_cntl_u;
+
+typedef struct _cfgreg_base_t {
+     unsigned long cfgreg_base                    : 24;
+     unsigned long                                : 8;
+     } cfgreg_base_t;
+
+typedef union {
+     unsigned long val : 32;
+     cfgreg_base_t f;
+} cfgreg_base_u;
+
+typedef struct _cif_io_t {
+     unsigned long dq_srp                         : 1;
+     unsigned long dq_srn                         : 1;
+     unsigned long dq_sp                          : 4;
+     unsigned long dq_sn                          : 4;
+     unsigned long waitb_srp                      : 1;
+     unsigned long waitb_srn                      : 1;
+     unsigned long waitb_sp                       : 4;
+     unsigned long waitb_sn                       : 4;
+     unsigned long intb_srp                       : 1;
+     unsigned long intb_srn                       : 1;
+     unsigned long intb_sp                        : 4;
+     unsigned long intb_sn                        : 4;
+     unsigned long                                : 2;
+     } cif_io_t;
+
+typedef union {
+     unsigned long val : 32;
+     cif_io_t f;
+} cif_io_u;
+
+typedef struct _cif_read_dbg_t {
+     unsigned long unpacker_pre_fetch_trig_gen    : 2;
+     unsigned long dly_second_rd_fetch_trig       : 1;
+     unsigned long rst_rd_burst_id                : 1;
+     unsigned long dis_rd_burst_id                : 1;
+     unsigned long en_block_rd_when_packer_is_not_emp : 1;
+     unsigned long dis_pre_fetch_cntl_sm          : 1;
+     unsigned long rbbm_chrncy_dis                : 1;
+     unsigned long rbbm_rd_after_wr_lat           : 2;
+     unsigned long dis_be_during_rd               : 1;
+     unsigned long one_clk_invalidate_pulse       : 1;
+     unsigned long dis_chnl_priority              : 1;
+     unsigned long rst_read_path_a_pls            : 1;
+     unsigned long rst_read_path_b_pls            : 1;
+     unsigned long dis_reg_rd_fetch_trig          : 1;
+     unsigned long dis_rd_fetch_trig_from_ind_addr : 1;
+     unsigned long dis_rd_same_byte_to_trig_fetch : 1;
+     unsigned long dis_dir_wrap                   : 1;
+     unsigned long dis_ring_buf_to_force_dec      : 1;
+     unsigned long dis_addr_comp_in_16bit         : 1;
+     unsigned long clr_w                          : 1;
+     unsigned long err_rd_tag_is_3                : 1;
+     unsigned long err_load_when_ful_a            : 1;
+     unsigned long err_load_when_ful_b            : 1;
+     unsigned long                                : 7;
+     } cif_read_dbg_t;
+
+typedef union {
+     unsigned long val : 32;
+     cif_read_dbg_t f;
+} cif_read_dbg_u;
+
+typedef struct _cif_write_dbg_t {
+     unsigned long packer_timeout_count           : 2;
+     unsigned long en_upper_load_cond             : 1;
+     unsigned long en_chnl_change_cond            : 1;
+     unsigned long dis_addr_comp_cond             : 1;
+     unsigned long dis_load_same_byte_addr_cond   : 1;
+     unsigned long dis_timeout_cond               : 1;
+     unsigned long dis_timeout_during_rbbm        : 1;
+     unsigned long dis_packer_ful_during_rbbm_timeout : 1;
+     unsigned long en_dword_split_to_rbbm         : 1;
+     unsigned long en_dummy_val                   : 1;
+     unsigned long dummy_val_sel                  : 1;
+     unsigned long mask_pm4_wrptr_dec             : 1;
+     unsigned long dis_mc_clean_cond              : 1;
+     unsigned long err_two_reqi_during_ful        : 1;
+     unsigned long err_reqi_during_idle_clk       : 1;
+     unsigned long err_global                     : 1;
+     unsigned long en_wr_buf_dbg_load             : 1;
+     unsigned long en_wr_buf_dbg_path             : 1;
+     unsigned long sel_wr_buf_byte                : 3;
+     unsigned long dis_rd_flush_wr                : 1;
+     unsigned long dis_packer_ful_cond            : 1;
+     unsigned long dis_invalidate_by_ops_chnl     : 1;
+     unsigned long en_halt_when_reqi_err          : 1;
+     unsigned long cif_spare_2                    : 5;
+     unsigned long                                : 1;
+     } cif_write_dbg_t;
+
+typedef union {
+     unsigned long val : 32;
+     cif_write_dbg_t f;
+} cif_write_dbg_u;
+
+typedef struct _ind_addr_a_0_t {
+     unsigned char ind_addr_a_0                   : 8;
+     } ind_addr_a_0_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_addr_a_0_t f;
+} ind_addr_a_0_u;
+
+typedef struct _ind_addr_a_1_t {
+     unsigned char ind_addr_a_1                   : 8;
+     } ind_addr_a_1_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_addr_a_1_t f;
+} ind_addr_a_1_u;
+
+typedef struct _ind_addr_a_2_t {
+     unsigned char ind_addr_a_2                   : 8;
+     } ind_addr_a_2_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_addr_a_2_t f;
+} ind_addr_a_2_u;
+
+typedef struct _ind_data_a_t {
+     unsigned char ind_data_a                     : 8;
+     } ind_data_a_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_data_a_t f;
+} ind_data_a_u;
+
+typedef struct _reg_base_t {
+     unsigned char reg_base                       : 8;
+     } reg_base_t;
+
+typedef union {
+     unsigned char val : 8;
+     reg_base_t f;
+} reg_base_u;
+
+typedef struct _intf_cntl_t {
+     unsigned char ad_inc_a                       : 1;
+     unsigned char ring_buf_a                     : 1;
+     unsigned char rd_fetch_trigger_a             : 1;
+     unsigned char rd_data_rdy_a                  : 1;
+     unsigned char ad_inc_b                       : 1;
+     unsigned char ring_buf_b                     : 1;
+     unsigned char rd_fetch_trigger_b             : 1;
+     unsigned char rd_data_rdy_b                  : 1;
+     } intf_cntl_t;
+
+typedef union {
+     unsigned char val : 8;
+     intf_cntl_t f;
+} intf_cntl_u;
+
+typedef struct _status_t {
+     unsigned char wr_fifo_available_space        : 2;
+     unsigned char fbuf_wr_pipe_emp               : 1;
+     unsigned char soft_reset                     : 1;
+     unsigned char system_pwm_mode                : 2;
+     unsigned char mem_access_dis                 : 1;
+     unsigned char en_pre_fetch                   : 1;
+     } status_t;
+
+typedef union {
+     unsigned char val : 8;
+     status_t f;
+} status_u;
+
+typedef struct _cpu_defaults_t {
+     unsigned char unpack_rd_data                 : 1;
+     unsigned char access_ind_addr_a              : 1;
+     unsigned char access_ind_addr_b              : 1;
+     unsigned char access_scratch_reg             : 1;
+     unsigned char pack_wr_data                   : 1;
+     unsigned char transition_size                : 1;
+     unsigned char en_read_buf_mode               : 1;
+     unsigned char rd_fetch_scratch               : 1;
+     } cpu_defaults_t;
+
+typedef union {
+     unsigned char val : 8;
+     cpu_defaults_t f;
+} cpu_defaults_u;
+
+typedef struct _ind_addr_b_0_t {
+     unsigned char ind_addr_b_0                   : 8;
+     } ind_addr_b_0_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_addr_b_0_t f;
+} ind_addr_b_0_u;
+
+typedef struct _ind_addr_b_1_t {
+     unsigned char ind_addr_b_1                   : 8;
+     } ind_addr_b_1_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_addr_b_1_t f;
+} ind_addr_b_1_u;
+
+typedef struct _ind_addr_b_2_t {
+     unsigned char ind_addr_b_2                   : 8;
+     } ind_addr_b_2_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_addr_b_2_t f;
+} ind_addr_b_2_u;
+
+typedef struct _ind_data_b_t {
+     unsigned char ind_data_b                     : 8;
+     } ind_data_b_t;
+
+typedef union {
+     unsigned char val : 8;
+     ind_data_b_t f;
+} ind_data_b_u;
+
+typedef struct _pm4_rptr_t {
+     unsigned char pm4_rptr                       : 8;
+     } pm4_rptr_t;
+
+typedef union {
+     unsigned char val : 8;
+     pm4_rptr_t f;
+} pm4_rptr_u;
+
+typedef struct _scratch_t {
+     unsigned char scratch                        : 8;
+     } scratch_t;
+
+typedef union {
+     unsigned char val : 8;
+     scratch_t f;
+} scratch_u;
+
+typedef struct _pm4_wrptr_0_t {
+     unsigned char pm4_wrptr_0                    : 8;
+     } pm4_wrptr_0_t;
+
+typedef union {
+     unsigned char val : 8;
+     pm4_wrptr_0_t f;
+} pm4_wrptr_0_u;
+
+typedef struct _pm4_wrptr_1_t {
+     unsigned char pm4_wrptr_1                    : 6;
+     unsigned char rd_fetch_pm4_rptr              : 1;
+     unsigned char wrptr_atomic_update_w          : 1;
+     } pm4_wrptr_1_t;
+
+typedef union {
+     unsigned char val : 8;
+     pm4_wrptr_1_t f;
+} pm4_wrptr_1_u;
+
+typedef struct _cp_rb_cntl_t {
+     unsigned long rb_bufsz                       : 6;
+     unsigned long                                : 2;
+     unsigned long rb_blksz                       : 6;
+     unsigned long                                : 2;
+     unsigned long buf_swap                       : 2;
+     unsigned long max_fetch                      : 2;
+     unsigned long                                : 7;
+     unsigned long rb_no_update                   : 1;
+     unsigned long                                : 3;
+     unsigned long rb_rptr_wr_ena                 : 1;
+     } cp_rb_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_rb_cntl_t f;
+} cp_rb_cntl_u;
+
+typedef struct _cp_rb_base_t {
+     unsigned long                                : 2;
+     unsigned long rb_base                        : 22;
+     unsigned long                                : 8;
+     } cp_rb_base_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_rb_base_t f;
+} cp_rb_base_u;
+
+typedef struct _cp_rb_rptr_addr_t {
+     unsigned long rb_rptr_swap                   : 2;
+     unsigned long rb_rptr_addr                   : 22;
+     unsigned long                                : 8;
+     } cp_rb_rptr_addr_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_rb_rptr_addr_t f;
+} cp_rb_rptr_addr_u;
+
+typedef struct _cp_rb_rptr_t {
+     unsigned long rb_rptr                        : 23;
+     unsigned long                                : 9;
+     } cp_rb_rptr_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_rb_rptr_t f;
+} cp_rb_rptr_u;
+
+typedef struct _cp_rb_rptr_wr_t {
+     unsigned long rb_rptr_wr                     : 23;
+     unsigned long                                : 9;
+     } cp_rb_rptr_wr_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_rb_rptr_wr_t f;
+} cp_rb_rptr_wr_u;
+
+typedef struct _cp_rb_wptr_t {
+     unsigned long rb_wptr                        : 23;
+     unsigned long                                : 9;
+     } cp_rb_wptr_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_rb_wptr_t f;
+} cp_rb_wptr_u;
+
+typedef struct _cp_ib_base_t {
+     unsigned long                                : 2;
+     unsigned long ib_base                        : 22;
+     unsigned long                                : 8;
+     } cp_ib_base_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_ib_base_t f;
+} cp_ib_base_u;
+
+typedef struct _cp_ib_bufsz_t {
+     unsigned long ib_bufsz                       : 23;
+     unsigned long                                : 9;
+     } cp_ib_bufsz_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_ib_bufsz_t f;
+} cp_ib_bufsz_u;
+
+typedef struct _cp_csq_cntl_t {
+     unsigned long csq_cnt_primary                : 8;
+     unsigned long csq_cnt_indirect               : 8;
+     unsigned long                                : 12;
+     unsigned long csq_mode                       : 4;
+     } cp_csq_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_csq_cntl_t f;
+} cp_csq_cntl_u;
+
+typedef struct _cp_csq_aper_primary_t {
+     unsigned long cp_csq_aper_primary            : 32;
+     } cp_csq_aper_primary_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_csq_aper_primary_t f;
+} cp_csq_aper_primary_u;
+
+typedef struct _cp_csq_aper_indirect_t {
+     unsigned long cp_csq_aper_indirect           : 32;
+     } cp_csq_aper_indirect_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_csq_aper_indirect_t f;
+} cp_csq_aper_indirect_u;
+
+typedef struct _cp_me_cntl_t {
+     unsigned long me_stat                        : 16;
+     unsigned long me_statmux                     : 5;
+     unsigned long                                : 8;
+     unsigned long me_busy                        : 1;
+     unsigned long me_mode                        : 1;
+     unsigned long me_step                        : 1;
+     } cp_me_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_me_cntl_t f;
+} cp_me_cntl_u;
+
+typedef struct _cp_me_ram_addr_t {
+     unsigned long me_ram_addr                    : 8;
+     unsigned long                                : 24;
+     } cp_me_ram_addr_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_me_ram_addr_t f;
+} cp_me_ram_addr_u;
+
+typedef struct _cp_me_ram_raddr_t {
+     unsigned long me_ram_raddr                   : 8;
+     unsigned long                                : 24;
+     } cp_me_ram_raddr_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_me_ram_raddr_t f;
+} cp_me_ram_raddr_u;
+
+typedef struct _cp_me_ram_datah_t {
+     unsigned long me_ram_datah                   : 6;
+     unsigned long                                : 26;
+     } cp_me_ram_datah_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_me_ram_datah_t f;
+} cp_me_ram_datah_u;
+
+typedef struct _cp_me_ram_datal_t {
+     unsigned long me_ram_datal                   : 32;
+     } cp_me_ram_datal_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_me_ram_datal_t f;
+} cp_me_ram_datal_u;
+
+typedef struct _cp_debug_t {
+     unsigned long cp_debug                       : 32;
+     } cp_debug_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_debug_t f;
+} cp_debug_u;
+
+typedef struct _scratch_reg0_t {
+     unsigned long scratch_reg0                   : 32;
+     } scratch_reg0_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_reg0_t f;
+} scratch_reg0_u;
+
+typedef struct _scratch_reg1_t {
+     unsigned long scratch_reg1                   : 32;
+     } scratch_reg1_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_reg1_t f;
+} scratch_reg1_u;
+
+typedef struct _scratch_reg2_t {
+     unsigned long scratch_reg2                   : 32;
+     } scratch_reg2_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_reg2_t f;
+} scratch_reg2_u;
+
+typedef struct _scratch_reg3_t {
+     unsigned long scratch_reg3                   : 32;
+     } scratch_reg3_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_reg3_t f;
+} scratch_reg3_u;
+
+typedef struct _scratch_reg4_t {
+     unsigned long scratch_reg4                   : 32;
+     } scratch_reg4_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_reg4_t f;
+} scratch_reg4_u;
+
+typedef struct _scratch_reg5_t {
+     unsigned long scratch_reg5                   : 32;
+     } scratch_reg5_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_reg5_t f;
+} scratch_reg5_u;
+
+typedef struct _scratch_umsk_t {
+     unsigned long scratch_umsk                   : 6;
+     unsigned long                                : 10;
+     unsigned long scratch_swap                   : 2;
+     unsigned long                                : 14;
+     } scratch_umsk_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_umsk_t f;
+} scratch_umsk_u;
+
+typedef struct _scratch_addr_t {
+     unsigned long                                : 5;
+     unsigned long scratch_addr                   : 27;
+     } scratch_addr_t;
+
+typedef union {
+     unsigned long val : 32;
+     scratch_addr_t f;
+} scratch_addr_u;
+
+typedef struct _cp_csq_addr_t {
+     unsigned long                                : 2;
+     unsigned long csq_addr                       : 8;
+     unsigned long                                : 22;
+     } cp_csq_addr_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_csq_addr_t f;
+} cp_csq_addr_u;
+
+typedef struct _cp_csq_data_t {
+     unsigned long csq_data                       : 32;
+     } cp_csq_data_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_csq_data_t f;
+} cp_csq_data_u;
+
+typedef struct _cp_csq_stat_t {
+     unsigned long csq_rptr_primary               : 8;
+     unsigned long csq_wptr_primary               : 8;
+     unsigned long csq_rptr_indirect              : 8;
+     unsigned long csq_wptr_indirect              : 8;
+     } cp_csq_stat_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_csq_stat_t f;
+} cp_csq_stat_u;
+
+typedef struct _cp_stat_t {
+     unsigned long mru_busy                       : 1;
+     unsigned long mwu_busy                       : 1;
+     unsigned long rsiu_busy                      : 1;
+     unsigned long rciu_busy                      : 1;
+     unsigned long                                : 5;
+     unsigned long csf_primary_busy               : 1;
+     unsigned long csf_indirect_busy              : 1;
+     unsigned long csq_primary_busy               : 1;
+     unsigned long csq_indirect_busy              : 1;
+     unsigned long csi_busy                       : 1;
+     unsigned long                                : 14;
+     unsigned long guidma_busy                    : 1;
+     unsigned long viddma_busy                    : 1;
+     unsigned long cmdstrm_busy                   : 1;
+     unsigned long cp_busy                        : 1;
+     } cp_stat_t;
+
+typedef union {
+     unsigned long val : 32;
+     cp_stat_t f;
+} cp_stat_u;
+
+typedef struct _gen_int_cntl_t {
+     unsigned long crtc_vblank_mask               : 1;
+     unsigned long crtc_vline_mask                : 1;
+     unsigned long crtc_hwint1_mask               : 1;
+     unsigned long crtc_hwint2_mask               : 1;
+     unsigned long                                : 15;
+     unsigned long gui_idle_mask                  : 1;
+     unsigned long                                : 8;
+     unsigned long pm4_idle_int_mask              : 1;
+     unsigned long dvi_i2c_int_mask               : 1;
+     unsigned long                                : 2;
+     } gen_int_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     gen_int_cntl_t f;
+} gen_int_cntl_u;
+
+typedef struct _gen_int_status_rd_t {
+     unsigned long crtc_vblank_stat               : 1;
+     unsigned long crtc_vline_stat                : 1;
+     unsigned long crtc_hwint1_stat               : 1;
+     unsigned long crtc_hwint2_stat               : 1;
+     unsigned long                                : 15;
+     unsigned long gui_idle_stat                  : 1;
+     unsigned long                                : 8;
+     unsigned long pm4_idle_int_stat              : 1;
+     unsigned long dvi_i2c_int_stat               : 1;
+     unsigned long                                : 2;
+     } gen_int_status_rd_t;
+
+typedef union {
+     unsigned long val : 32;
+     gen_int_status_rd_t f;
+} gen_int_status_rd_u;
+
+typedef struct _gen_int_status_wr_t {
+     unsigned long crtc_vblank_stat_ak            : 1;
+     unsigned long crtc_vline_stat_ak             : 1;
+     unsigned long crtc_hwint1_stat_ak            : 1;
+     unsigned long crtc_hwint2_stat_ak            : 1;
+     unsigned long                                : 15;
+     unsigned long gui_idle_stat_ak               : 1;
+     unsigned long                                : 8;
+     unsigned long pm4_idle_int_ak                : 1;
+     unsigned long dvi_i2c_int_ak                 : 1;
+     unsigned long                                : 2;
+     } gen_int_status_wr_t;
+
+typedef union {
+     unsigned long val : 32;
+     gen_int_status_wr_t f;
+} gen_int_status_wr_u;
+
+typedef struct _lcd_format_t {
+     unsigned long lcd_type                       : 4;
+     unsigned long color_to_mono                  : 1;
+     unsigned long data_inv                       : 1;
+     unsigned long stn_fm                         : 2;
+     unsigned long tft_fm                         : 2;
+     unsigned long scan_lr_en                     : 1;
+     unsigned long scan_ud_en                     : 1;
+     unsigned long pol_inv                        : 1;
+     unsigned long rst_fm                         : 1;
+     unsigned long yuv_to_rgb                     : 1;
+     unsigned long hr_tft                         : 1;
+     unsigned long ulc_panel                      : 1;
+     unsigned long                                : 15;
+     } lcd_format_t;
+
+typedef union {
+     unsigned long val : 32;
+     lcd_format_t f;
+} lcd_format_u;
+
+typedef struct _graphic_ctrl_t {
+     unsigned long color_depth                    : 3;
+     unsigned long portrait_mode                  : 2;
+     unsigned long low_power_on                   : 1;
+     unsigned long req_freq                       : 4;
+     unsigned long en_crtc                        : 1;
+     unsigned long en_graphic_req                 : 1;
+     unsigned long en_graphic_crtc                : 1;
+     unsigned long total_req_graphic              : 9;
+     unsigned long lcd_pclk_on                    : 1;
+     unsigned long lcd_sclk_on                    : 1;
+     unsigned long pclk_running                   : 1;
+     unsigned long sclk_running                   : 1;
+     unsigned long                                : 6;
+     } graphic_ctrl_t;
+
+typedef union {
+     unsigned long val : 32;
+     graphic_ctrl_t f;
+} graphic_ctrl_u;
+
+typedef struct _graphic_offset_t {
+     unsigned long graphic_offset                 : 24;
+     unsigned long                                : 8;
+     } graphic_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     graphic_offset_t f;
+} graphic_offset_u;
+
+typedef struct _graphic_pitch_t {
+     unsigned long graphic_pitch                  : 11;
+     unsigned long                                : 21;
+     } graphic_pitch_t;
+
+typedef union {
+     unsigned long val : 32;
+     graphic_pitch_t f;
+} graphic_pitch_u;
+
+typedef struct _crtc_total_t {
+     unsigned long crtc_h_total                   : 10;
+     unsigned long                                : 6;
+     unsigned long crtc_v_total                   : 10;
+     unsigned long                                : 6;
+     } crtc_total_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_total_t f;
+} crtc_total_u;
+
+typedef struct _active_h_disp_t {
+     unsigned long active_h_start                 : 10;
+     unsigned long                                : 6;
+     unsigned long active_h_end                   : 10;
+     unsigned long                                : 6;
+     } active_h_disp_t;
+
+typedef union {
+     unsigned long val : 32;
+     active_h_disp_t f;
+} active_h_disp_u;
+
+typedef struct _active_v_disp_t {
+     unsigned long active_v_start                 : 10;
+     unsigned long                                : 6;
+     unsigned long active_v_end                   : 10;
+     unsigned long                                : 6;
+     } active_v_disp_t;
+
+typedef union {
+     unsigned long val : 32;
+     active_v_disp_t f;
+} active_v_disp_u;
+
+typedef struct _graphic_h_disp_t {
+     unsigned long graphic_h_start                : 10;
+     unsigned long                                : 6;
+     unsigned long graphic_h_end                  : 10;
+     unsigned long                                : 6;
+     } graphic_h_disp_t;
+
+typedef union {
+     unsigned long val : 32;
+     graphic_h_disp_t f;
+} graphic_h_disp_u;
+
+typedef struct _graphic_v_disp_t {
+     unsigned long graphic_v_start                : 10;
+     unsigned long                                : 6;
+     unsigned long graphic_v_end                  : 10;
+     unsigned long                                : 6;
+     } graphic_v_disp_t;
+
+typedef union {
+     unsigned long val : 32;
+     graphic_v_disp_t f;
+} graphic_v_disp_u;
+
+typedef struct _video_ctrl_t {
+     unsigned long video_mode                     : 1;
+     unsigned long keyer_en                       : 1;
+     unsigned long en_video_req                   : 1;
+     unsigned long en_graphic_req_video           : 1;
+     unsigned long en_video_crtc                  : 1;
+     unsigned long video_hor_exp                  : 2;
+     unsigned long video_ver_exp                  : 2;
+     unsigned long uv_combine                     : 1;
+     unsigned long total_req_video                : 9;
+     unsigned long video_ch_sel                   : 1;
+     unsigned long video_portrait                 : 2;
+     unsigned long yuv2rgb_en                     : 1;
+     unsigned long yuv2rgb_option                 : 1;
+     unsigned long video_inv_hor                  : 1;
+     unsigned long video_inv_ver                  : 1;
+     unsigned long gamma_sel                      : 2;
+     unsigned long dis_limit                      : 1;
+     unsigned long en_uv_hblend                   : 1;
+     unsigned long rgb_gamma_sel                  : 2;
+     } video_ctrl_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_ctrl_t f;
+} video_ctrl_u;
+
+typedef struct _graphic_key_t {
+     unsigned long keyer_color                    : 16;
+     unsigned long keyer_mask                     : 16;
+     } graphic_key_t;
+
+typedef union {
+     unsigned long val : 32;
+     graphic_key_t f;
+} graphic_key_u;
+
+typedef struct _video_y_offset_t {
+     unsigned long y_offset                       : 24;
+     unsigned long                                : 8;
+     } video_y_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_y_offset_t f;
+} video_y_offset_u;
+
+typedef struct _video_y_pitch_t {
+     unsigned long y_pitch                        : 11;
+     unsigned long                                : 21;
+     } video_y_pitch_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_y_pitch_t f;
+} video_y_pitch_u;
+
+typedef struct _video_u_offset_t {
+     unsigned long u_offset                       : 24;
+     unsigned long                                : 8;
+     } video_u_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_u_offset_t f;
+} video_u_offset_u;
+
+typedef struct _video_u_pitch_t {
+     unsigned long u_pitch                        : 11;
+     unsigned long                                : 21;
+     } video_u_pitch_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_u_pitch_t f;
+} video_u_pitch_u;
+
+typedef struct _video_v_offset_t {
+     unsigned long v_offset                       : 24;
+     unsigned long                                : 8;
+     } video_v_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_v_offset_t f;
+} video_v_offset_u;
+
+typedef struct _video_v_pitch_t {
+     unsigned long v_pitch                        : 11;
+     unsigned long                                : 21;
+     } video_v_pitch_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_v_pitch_t f;
+} video_v_pitch_u;
+
+typedef struct _video_h_pos_t {
+     unsigned long video_h_start                  : 10;
+     unsigned long                                : 6;
+     unsigned long video_h_end                    : 10;
+     unsigned long                                : 6;
+     } video_h_pos_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_h_pos_t f;
+} video_h_pos_u;
+
+typedef struct _video_v_pos_t {
+     unsigned long video_v_start                  : 10;
+     unsigned long                                : 6;
+     unsigned long video_v_end                    : 10;
+     unsigned long                                : 6;
+     } video_v_pos_t;
+
+typedef union {
+     unsigned long val : 32;
+     video_v_pos_t f;
+} video_v_pos_u;
+
+typedef struct _brightness_cntl_t {
+     unsigned long brightness                     : 7;
+     unsigned long                                : 25;
+     } brightness_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     brightness_cntl_t f;
+} brightness_cntl_u;
+
+typedef struct _cursor1_offset_t {
+     unsigned long cur1_offset                    : 24;
+     unsigned long cur1_x_offset                  : 4;
+     unsigned long cur1_y_offset                  : 4;
+     } cursor1_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor1_offset_t f;
+} cursor1_offset_u;
+
+typedef struct _cursor1_h_pos_t {
+     unsigned long cur1_h_start                   : 10;
+     unsigned long                                : 6;
+     unsigned long cur1_h_end                     : 10;
+     unsigned long                                : 5;
+     unsigned long cur1_en                        : 1;
+     } cursor1_h_pos_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor1_h_pos_t f;
+} cursor1_h_pos_u;
+
+typedef struct _cursor1_v_pos_t {
+     unsigned long cur1_v_start                   : 10;
+     unsigned long                                : 6;
+     unsigned long cur1_v_end                     : 10;
+     unsigned long                                : 6;
+     } cursor1_v_pos_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor1_v_pos_t f;
+} cursor1_v_pos_u;
+
+typedef struct _cursor1_color0_t {
+     unsigned long cur1_color0_r                  : 8;
+     unsigned long cur1_color0_g                  : 8;
+     unsigned long cur1_color0_b                  : 8;
+     unsigned long                                : 8;
+     } cursor1_color0_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor1_color0_t f;
+} cursor1_color0_u;
+
+typedef struct _cursor1_color1_t {
+     unsigned long cur1_color1_r                  : 8;
+     unsigned long cur1_color1_g                  : 8;
+     unsigned long cur1_color1_b                  : 8;
+     unsigned long                                : 8;
+     } cursor1_color1_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor1_color1_t f;
+} cursor1_color1_u;
+
+typedef struct _cursor2_offset_t {
+     unsigned long cur2_offset                    : 24;
+     unsigned long cur2_x_offset                  : 4;
+     unsigned long cur2_y_offset                  : 4;
+     } cursor2_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor2_offset_t f;
+} cursor2_offset_u;
+
+typedef struct _cursor2_h_pos_t {
+     unsigned long cur2_h_start                   : 10;
+     unsigned long                                : 6;
+     unsigned long cur2_h_end                     : 10;
+     unsigned long                                : 5;
+     unsigned long cur2_en                        : 1;
+     } cursor2_h_pos_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor2_h_pos_t f;
+} cursor2_h_pos_u;
+
+typedef struct _cursor2_v_pos_t {
+     unsigned long cur2_v_start                   : 10;
+     unsigned long                                : 6;
+     unsigned long cur2_v_end                     : 10;
+     unsigned long                                : 6;
+     } cursor2_v_pos_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor2_v_pos_t f;
+} cursor2_v_pos_u;
+
+typedef struct _cursor2_color0_t {
+     unsigned long cur2_color0_r                  : 8;
+     unsigned long cur2_color0_g                  : 8;
+     unsigned long cur2_color0_b                  : 8;
+     unsigned long                                : 8;
+     } cursor2_color0_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor2_color0_t f;
+} cursor2_color0_u;
+
+typedef struct _cursor2_color1_t {
+     unsigned long cur2_color1_r                  : 8;
+     unsigned long cur2_color1_g                  : 8;
+     unsigned long cur2_color1_b                  : 8;
+     unsigned long                                : 8;
+     } cursor2_color1_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor2_color1_t f;
+} cursor2_color1_u;
+
+typedef struct _disp_int_cntl_t {
+     unsigned long vline_int_pos                  : 10;
+     unsigned long                                : 6;
+     unsigned long hpos_int_pos                   : 10;
+     unsigned long                                : 4;
+     unsigned long vblank_int_pol                 : 1;
+     unsigned long frame_int_pol                  : 1;
+     } disp_int_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     disp_int_cntl_t f;
+} disp_int_cntl_u;
+
+typedef struct _crtc_ss_t {
+     unsigned long ss_start                       : 10;
+     unsigned long                                : 6;
+     unsigned long ss_end                         : 10;
+     unsigned long                                : 2;
+     unsigned long ss_align                       : 1;
+     unsigned long ss_pol                         : 1;
+     unsigned long ss_run_mode                    : 1;
+     unsigned long ss_en                          : 1;
+     } crtc_ss_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_ss_t f;
+} crtc_ss_u;
+
+typedef struct _crtc_ls_t {
+     unsigned long ls_start                       : 10;
+     unsigned long                                : 6;
+     unsigned long ls_end                         : 10;
+     unsigned long                                : 2;
+     unsigned long ls_align                       : 1;
+     unsigned long ls_pol                         : 1;
+     unsigned long ls_run_mode                    : 1;
+     unsigned long ls_en                          : 1;
+     } crtc_ls_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_ls_t f;
+} crtc_ls_u;
+
+typedef struct _crtc_rev_t {
+     unsigned long rev_pos                        : 10;
+     unsigned long                                : 6;
+     unsigned long rev_align                      : 1;
+     unsigned long rev_freq_nref                  : 5;
+     unsigned long rev_en                         : 1;
+     unsigned long                                : 9;
+     } crtc_rev_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_rev_t f;
+} crtc_rev_u;
+
+typedef struct _crtc_dclk_t {
+     unsigned long dclk_start                     : 10;
+     unsigned long                                : 6;
+     unsigned long dclk_end                       : 10;
+     unsigned long                                : 1;
+     unsigned long dclk_run_mode                  : 2;
+     unsigned long dclk_pol                       : 1;
+     unsigned long dclk_align                     : 1;
+     unsigned long dclk_en                        : 1;
+     } crtc_dclk_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_dclk_t f;
+} crtc_dclk_u;
+
+typedef struct _crtc_gs_t {
+     unsigned long gs_start                       : 10;
+     unsigned long                                : 6;
+     unsigned long gs_end                         : 10;
+     unsigned long                                : 3;
+     unsigned long gs_align                       : 1;
+     unsigned long gs_pol                         : 1;
+     unsigned long gs_en                          : 1;
+     } crtc_gs_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_gs_t f;
+} crtc_gs_u;
+
+typedef struct _crtc_vpos_gs_t {
+     unsigned long gs_vpos_start                  : 10;
+     unsigned long                                : 6;
+     unsigned long gs_vpos_end                    : 10;
+     unsigned long                                : 6;
+     } crtc_vpos_gs_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_vpos_gs_t f;
+} crtc_vpos_gs_u;
+
+typedef struct _crtc_gclk_t {
+     unsigned long gclk_start                     : 10;
+     unsigned long                                : 6;
+     unsigned long gclk_end                       : 10;
+     unsigned long                                : 3;
+     unsigned long gclk_align                     : 1;
+     unsigned long gclk_pol                       : 1;
+     unsigned long gclk_en                        : 1;
+     } crtc_gclk_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_gclk_t f;
+} crtc_gclk_u;
+
+typedef struct _crtc_goe_t {
+     unsigned long goe_start                      : 10;
+     unsigned long                                : 6;
+     unsigned long goe_end                        : 10;
+     unsigned long                                : 3;
+     unsigned long goe_align                      : 1;
+     unsigned long goe_pol                        : 1;
+     unsigned long goe_en                         : 1;
+     } crtc_goe_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_goe_t f;
+} crtc_goe_u;
+
+typedef struct _crtc_frame_t {
+     unsigned long crtc_fr_start                  : 10;
+     unsigned long                                : 6;
+     unsigned long crtc_fr_end                    : 10;
+     unsigned long                                : 4;
+     unsigned long crtc_frame_en                  : 1;
+     unsigned long crtc_frame_align               : 1;
+     } crtc_frame_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_frame_t f;
+} crtc_frame_u;
+
+typedef struct _crtc_frame_vpos_t {
+     unsigned long crtc_fr_vpos                   : 10;
+     unsigned long                                : 22;
+     } crtc_frame_vpos_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_frame_vpos_t f;
+} crtc_frame_vpos_u;
+
+typedef struct _gpio_data_t {
+     unsigned long gio_out                        : 16;
+     unsigned long gio_in                         : 16;
+     } gpio_data_t;
+
+typedef union {
+     unsigned long val : 32;
+     gpio_data_t f;
+} gpio_data_u;
+
+typedef struct _gpio_cntl1_t {
+     unsigned long gio_pd                         : 16;
+     unsigned long gio_schmen                     : 16;
+     } gpio_cntl1_t;
+
+typedef union {
+     unsigned long val : 32;
+     gpio_cntl1_t f;
+} gpio_cntl1_u;
+
+typedef struct _gpio_cntl2_t {
+     unsigned long gio_oe                         : 16;
+     unsigned long gio_srp                        : 1;
+     unsigned long gio_srn                        : 1;
+     unsigned long gio_sp                         : 4;
+     unsigned long gio_sn                         : 4;
+     unsigned long                                : 6;
+     } gpio_cntl2_t;
+
+typedef union {
+     unsigned long val : 32;
+     gpio_cntl2_t f;
+} gpio_cntl2_u;
+
+typedef struct _lcdd_cntl1_t {
+     unsigned long lcdd_pd                        : 18;
+     unsigned long lcdd_srp                       : 1;
+     unsigned long lcdd_srn                       : 1;
+     unsigned long lcdd_sp                        : 4;
+     unsigned long lcdd_sn                        : 4;
+     unsigned long lcdd_align                     : 1;
+     unsigned long                                : 3;
+     } lcdd_cntl1_t;
+
+typedef union {
+     unsigned long val : 32;
+     lcdd_cntl1_t f;
+} lcdd_cntl1_u;
+
+typedef struct _lcdd_cntl2_t {
+     unsigned long lcdd_oe                        : 18;
+     unsigned long                                : 14;
+     } lcdd_cntl2_t;
+
+typedef union {
+     unsigned long val : 32;
+     lcdd_cntl2_t f;
+} lcdd_cntl2_u;
+
+typedef struct _genlcd_cntl1_t {
+     unsigned long dclk_oe                        : 1;
+     unsigned long dclk_pd                        : 1;
+     unsigned long dclk_srp                       : 1;
+     unsigned long dclk_srn                       : 1;
+     unsigned long dclk_sp                        : 4;
+     unsigned long dclk_sn                        : 4;
+     unsigned long ss_oe                          : 1;
+     unsigned long ss_pd                          : 1;
+     unsigned long ls_oe                          : 1;
+     unsigned long ls_pd                          : 1;
+     unsigned long gs_oe                          : 1;
+     unsigned long gs_pd                          : 1;
+     unsigned long goe_oe                         : 1;
+     unsigned long goe_pd                         : 1;
+     unsigned long rev_oe                         : 1;
+     unsigned long rev_pd                         : 1;
+     unsigned long frame_oe                       : 1;
+     unsigned long frame_pd                       : 1;
+     unsigned long                                : 8;
+     } genlcd_cntl1_t;
+
+typedef union {
+     unsigned long val : 32;
+     genlcd_cntl1_t f;
+} genlcd_cntl1_u;
+
+typedef struct _genlcd_cntl2_t {
+     unsigned long gclk_oe                        : 1;
+     unsigned long gclk_pd                        : 1;
+     unsigned long gclk_srp                       : 1;
+     unsigned long gclk_srn                       : 1;
+     unsigned long gclk_sp                        : 4;
+     unsigned long gclk_sn                        : 4;
+     unsigned long genlcd_srp                     : 1;
+     unsigned long genlcd_srn                     : 1;
+     unsigned long genlcd_sp                      : 4;
+     unsigned long genlcd_sn                      : 4;
+     unsigned long                                : 10;
+     } genlcd_cntl2_t;
+
+typedef union {
+     unsigned long val : 32;
+     genlcd_cntl2_t f;
+} genlcd_cntl2_u;
+
+typedef struct _disp_debug_t {
+     unsigned long disp_debug                     : 32;
+     } disp_debug_t;
+
+typedef union {
+     unsigned long val : 32;
+     disp_debug_t f;
+} disp_debug_u;
+
+typedef struct _disp_db_buf_cntl_rd_t {
+     unsigned long en_db_buf                      : 1;
+     unsigned long update_db_buf_done             : 1;
+     unsigned long db_buf_cntl                    : 6;
+     unsigned long                                : 24;
+     } disp_db_buf_cntl_rd_t;
+
+typedef union {
+     unsigned long val : 32;
+     disp_db_buf_cntl_rd_t f;
+} disp_db_buf_cntl_rd_u;
+
+typedef struct _disp_db_buf_cntl_wr_t {
+     unsigned long en_db_buf                      : 1;
+     unsigned long update_db_buf                  : 1;
+     unsigned long db_buf_cntl                    : 6;
+     unsigned long                                : 24;
+     } disp_db_buf_cntl_wr_t;
+
+typedef union {
+     unsigned long val : 32;
+     disp_db_buf_cntl_wr_t f;
+} disp_db_buf_cntl_wr_u;
+
+typedef struct _disp_crc_sig_t {
+     unsigned long crc_sig_r                      : 6;
+     unsigned long crc_sig_g                      : 6;
+     unsigned long crc_sig_b                      : 6;
+     unsigned long crc_cont_en                    : 1;
+     unsigned long crc_en                         : 1;
+     unsigned long crc_mask_en                    : 1;
+     unsigned long crc_sig_cntl                   : 6;
+     unsigned long                                : 5;
+     } disp_crc_sig_t;
+
+typedef union {
+     unsigned long val : 32;
+     disp_crc_sig_t f;
+} disp_crc_sig_u;
+
+typedef struct _crtc_default_count_t {
+     unsigned long crtc_hcount_def                : 10;
+     unsigned long                                : 6;
+     unsigned long crtc_vcount_def                : 10;
+     unsigned long                                : 6;
+     } crtc_default_count_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_default_count_t f;
+} crtc_default_count_u;
+
+typedef struct _lcd_background_color_t {
+     unsigned long lcd_bg_red                     : 8;
+     unsigned long lcd_bg_green                   : 8;
+     unsigned long lcd_bg_blue                    : 8;
+     unsigned long                                : 8;
+     } lcd_background_color_t;
+
+typedef union {
+     unsigned long val : 32;
+     lcd_background_color_t f;
+} lcd_background_color_u;
+
+typedef struct _crtc_ps2_t {
+     unsigned long ps2_start                      : 10;
+     unsigned long                                : 6;
+     unsigned long ps2_end                        : 10;
+     unsigned long                                : 4;
+     unsigned long ps2_pol                        : 1;
+     unsigned long ps2_en                         : 1;
+     } crtc_ps2_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_ps2_t f;
+} crtc_ps2_u;
+
+typedef struct _crtc_ps2_vpos_t {
+     unsigned long ps2_vpos_start                 : 10;
+     unsigned long                                : 6;
+     unsigned long ps2_vpos_end                   : 10;
+     unsigned long                                : 6;
+     } crtc_ps2_vpos_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_ps2_vpos_t f;
+} crtc_ps2_vpos_u;
+
+typedef struct _crtc_ps1_active_t {
+     unsigned long ps1_h_start                    : 10;
+     unsigned long                                : 6;
+     unsigned long ps1_h_end                      : 10;
+     unsigned long                                : 3;
+     unsigned long ps1_pol                        : 1;
+     unsigned long ps1_en                         : 1;
+     unsigned long ps1_use_nactive                : 1;
+     } crtc_ps1_active_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_ps1_active_t f;
+} crtc_ps1_active_u;
+
+typedef struct _crtc_ps1_nactive_t {
+     unsigned long ps1_h_start_na                 : 10;
+     unsigned long                                : 6;
+     unsigned long ps1_h_end_na                   : 10;
+     unsigned long                                : 5;
+     unsigned long ps1_en_na                      : 1;
+     } crtc_ps1_nactive_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_ps1_nactive_t f;
+} crtc_ps1_nactive_u;
+
+typedef struct _crtc_gclk_ext_t {
+     unsigned long gclk_alter_start               : 10;
+     unsigned long                                : 6;
+     unsigned long gclk_alter_width               : 2;
+     unsigned long gclk_en_alter                  : 1;
+     unsigned long gclk_db_width                  : 2;
+     unsigned long                                : 11;
+     } crtc_gclk_ext_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_gclk_ext_t f;
+} crtc_gclk_ext_u;
+
+typedef struct _crtc_alw_t {
+     unsigned long alw_hstart                     : 10;
+     unsigned long                                : 6;
+     unsigned long alw_hend                       : 10;
+     unsigned long                                : 4;
+     unsigned long alw_delay                      : 1;
+     unsigned long alw_en                         : 1;
+     } crtc_alw_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_alw_t f;
+} crtc_alw_u;
+
+typedef struct _crtc_alw_vpos_t {
+     unsigned long alw_vstart                     : 10;
+     unsigned long                                : 6;
+     unsigned long alw_vend                       : 10;
+     unsigned long                                : 6;
+     } crtc_alw_vpos_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_alw_vpos_t f;
+} crtc_alw_vpos_u;
+
+typedef struct _crtc_psk_t {
+     unsigned long psk_vstart                     : 10;
+     unsigned long                                : 6;
+     unsigned long psk_vend                       : 10;
+     unsigned long                                : 4;
+     unsigned long psk_pol                        : 1;
+     unsigned long psk_en                         : 1;
+     } crtc_psk_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_psk_t f;
+} crtc_psk_u;
+
+typedef struct _crtc_psk_hpos_t {
+     unsigned long psk_hstart                     : 10;
+     unsigned long                                : 6;
+     unsigned long psk_hend                       : 10;
+     unsigned long                                : 6;
+     } crtc_psk_hpos_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_psk_hpos_t f;
+} crtc_psk_hpos_u;
+
+typedef struct _crtc_cv4_start_t {
+     unsigned long cv4_vstart                     : 10;
+     unsigned long                                : 20;
+     unsigned long cv4_pol                        : 1;
+     unsigned long cv4_en                         : 1;
+     } crtc_cv4_start_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_cv4_start_t f;
+} crtc_cv4_start_u;
+
+typedef struct _crtc_cv4_end_t {
+     unsigned long cv4_vend1                      : 10;
+     unsigned long                                : 6;
+     unsigned long cv4_vend2                      : 10;
+     unsigned long                                : 6;
+     } crtc_cv4_end_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_cv4_end_t f;
+} crtc_cv4_end_u;
+
+typedef struct _crtc_cv4_hpos_t {
+     unsigned long cv4_hstart                     : 10;
+     unsigned long                                : 6;
+     unsigned long cv4_hend                       : 10;
+     unsigned long                                : 6;
+     } crtc_cv4_hpos_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_cv4_hpos_t f;
+} crtc_cv4_hpos_u;
+
+typedef struct _crtc_eck_t {
+     unsigned long eck_freq1                      : 3;
+     unsigned long eck_en                         : 1;
+     unsigned long                                : 28;
+     } crtc_eck_t;
+
+typedef union {
+     unsigned long val : 32;
+     crtc_eck_t f;
+} crtc_eck_u;
+
+typedef struct _refresh_cntl_t {
+     unsigned long ref_frame                      : 3;
+     unsigned long nref_frame                     : 5;
+     unsigned long ref_cntl                       : 1;
+     unsigned long stop_sm_nref                   : 1;
+     unsigned long stop_req_nref                  : 1;
+     unsigned long                                : 21;
+     } refresh_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     refresh_cntl_t f;
+} refresh_cntl_u;
+
+typedef struct _genlcd_cntl3_t {
+     unsigned long ps1_oe                         : 1;
+     unsigned long ps1_pd                         : 1;
+     unsigned long ps2_oe                         : 1;
+     unsigned long ps2_pd                         : 1;
+     unsigned long rev2_oe                        : 1;
+     unsigned long rev2_pd                        : 1;
+     unsigned long awl_oe                         : 1;
+     unsigned long awl_pd                         : 1;
+     unsigned long dinv_oe                        : 1;
+     unsigned long dinv_pd                        : 1;
+     unsigned long psk_out                        : 1;
+     unsigned long psd_out                        : 1;
+     unsigned long eck_out                        : 1;
+     unsigned long cv4_out                        : 1;
+     unsigned long ps1_out                        : 1;
+     unsigned long ps2_out                        : 1;
+     unsigned long rev_out                        : 1;
+     unsigned long rev2_out                       : 1;
+     unsigned long                                : 14;
+     } genlcd_cntl3_t;
+
+typedef union {
+     unsigned long val : 32;
+     genlcd_cntl3_t f;
+} genlcd_cntl3_u;
+
+typedef struct _gpio_data2_t {
+     unsigned long gio2_out                       : 16;
+     unsigned long gio2_in                        : 16;
+     } gpio_data2_t;
+
+typedef union {
+     unsigned long val : 32;
+     gpio_data2_t f;
+} gpio_data2_u;
+
+typedef struct _gpio_cntl3_t {
+     unsigned long gio2_pd                        : 16;
+     unsigned long gio2_schmen                    : 16;
+     } gpio_cntl3_t;
+
+typedef union {
+     unsigned long val : 32;
+     gpio_cntl3_t f;
+} gpio_cntl3_u;
+
+typedef struct _gpio_cntl4_t {
+     unsigned long gio2_oe                        : 16;
+     unsigned long                                : 16;
+     } gpio_cntl4_t;
+
+typedef union {
+     unsigned long val : 32;
+     gpio_cntl4_t f;
+} gpio_cntl4_u;
+
+typedef struct _chip_strap_t {
+     unsigned long config_strap                   : 8;
+     unsigned long pkg_strap                      : 1;
+     unsigned long                                : 23;
+     } chip_strap_t;
+
+typedef union {
+     unsigned long val : 32;
+     chip_strap_t f;
+} chip_strap_u;
+
+typedef struct _disp_debug2_t {
+     unsigned long disp_debug2                    : 32;
+     } disp_debug2_t;
+
+typedef union {
+     unsigned long val : 32;
+     disp_debug2_t f;
+} disp_debug2_u;
+
+typedef struct _debug_bus_cntl_t {
+     unsigned long debug_testmux                  : 4;
+     unsigned long debug_testsel                  : 4;
+     unsigned long debug_gioa_sel                 : 2;
+     unsigned long debug_giob_sel                 : 2;
+     unsigned long debug_clk_sel                  : 1;
+     unsigned long debug_clk_inv                  : 1;
+     unsigned long                                : 2;
+     unsigned long debug_bus                      : 16;
+     } debug_bus_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug_bus_cntl_t f;
+} debug_bus_cntl_u;
+
+typedef struct _gamma_value1_t {
+     unsigned long gamma1                         : 8;
+     unsigned long gamma2                         : 8;
+     unsigned long gamma3                         : 8;
+     unsigned long gamma4                         : 8;
+     } gamma_value1_t;
+
+typedef union {
+     unsigned long val : 32;
+     gamma_value1_t f;
+} gamma_value1_u;
+
+typedef struct _gamma_value2_t {
+     unsigned long gamma5                         : 8;
+     unsigned long gamma6                         : 8;
+     unsigned long gamma7                         : 8;
+     unsigned long gamma8                         : 8;
+     } gamma_value2_t;
+
+typedef union {
+     unsigned long val : 32;
+     gamma_value2_t f;
+} gamma_value2_u;
+
+typedef struct _gamma_slope_t {
+     unsigned long slope1                         : 3;
+     unsigned long slope2                         : 3;
+     unsigned long slope3                         : 3;
+     unsigned long slope4                         : 3;
+     unsigned long slope5                         : 3;
+     unsigned long slope6                         : 3;
+     unsigned long slope7                         : 3;
+     unsigned long slope8                         : 3;
+     unsigned long                                : 8;
+     } gamma_slope_t;
+
+typedef union {
+     unsigned long val : 32;
+     gamma_slope_t f;
+} gamma_slope_u;
+
+typedef struct _gen_status_t {
+     unsigned long status                         : 16;
+     unsigned long                                : 16;
+     } gen_status_t;
+
+typedef union {
+     unsigned long val : 32;
+     gen_status_t f;
+} gen_status_u;
+
+typedef struct _hw_int_t {
+     unsigned long hwint1_pos                     : 5;
+     unsigned long hwint2_pos                     : 5;
+     unsigned long hwint1_pol                     : 1;
+     unsigned long hwint2_pol                     : 1;
+     unsigned long hwint1_en_db                   : 1;
+     unsigned long hwint2_en_db                   : 1;
+     unsigned long                                : 18;
+     } hw_int_t;
+
+typedef union {
+     unsigned long val : 32;
+     hw_int_t f;
+} hw_int_u;
+
+typedef struct _dst_offset_t {
+     unsigned long dst_offset                     : 24;
+     unsigned long                                : 8;
+     } dst_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_offset_t f;
+} dst_offset_u;
+
+typedef struct _dst_pitch_t {
+     unsigned long dst_pitch                      : 14;
+     unsigned long mc_dst_pitch_mul               : 2;
+     unsigned long                                : 16;
+     } dst_pitch_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_pitch_t f;
+} dst_pitch_u;
+
+typedef struct _dst_pitch_offset_t {
+     unsigned long dst_offset                     : 20;
+     unsigned long dst_pitch                      : 10;
+     unsigned long mc_dst_pitch_mul               : 2;
+     } dst_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_pitch_offset_t f;
+} dst_pitch_offset_u;
+
+typedef struct _dst_x_t {
+     unsigned long dst_x                          : 14;
+     unsigned long                                : 18;
+     } dst_x_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_x_t f;
+} dst_x_u;
+
+typedef struct _dst_y_t {
+     unsigned long dst_y                          : 14;
+     unsigned long                                : 18;
+     } dst_y_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_y_t f;
+} dst_y_u;
+
+typedef struct _dst_x_y_t {
+     unsigned long dst_y                          : 14;
+     unsigned long                                : 2;
+     unsigned long dst_x                          : 14;
+     unsigned long                                : 2;
+     } dst_x_y_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_x_y_t f;
+} dst_x_y_u;
+
+typedef struct _dst_y_x_t {
+     unsigned long dst_x                          : 14;
+     unsigned long                                : 2;
+     unsigned long dst_y                          : 14;
+     unsigned long                                : 2;
+     } dst_y_x_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_y_x_t f;
+} dst_y_x_u;
+
+typedef struct _dst_width_t {
+     unsigned long dst_width_b0                   : 8;
+     unsigned long dst_width_b1                   : 6;
+     unsigned long                                : 18;
+     } dst_width_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_width_t f;
+} dst_width_u;
+
+typedef struct _dst_height_t {
+     unsigned long dst_height                     : 14;
+     unsigned long                                : 18;
+     } dst_height_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_height_t f;
+} dst_height_u;
+
+typedef struct _dst_width_height_t {
+     unsigned long dst_height                     : 14;
+     unsigned long                                : 2;
+     unsigned long dst_width_b0                   : 8;
+     unsigned long dst_width_b1                   : 6;
+     unsigned long                                : 2;
+     } dst_width_height_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_width_height_t f;
+} dst_width_height_u;
+
+typedef struct _dst_height_width_t {
+     unsigned long dst_width_b0                   : 8;
+     unsigned long dst_width_b1                   : 6;
+     unsigned long                                : 2;
+     unsigned long dst_height                     : 14;
+     unsigned long                                : 2;
+     } dst_height_width_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_height_width_t f;
+} dst_height_width_u;
+
+typedef struct _dst_height_width_8_t {
+     unsigned long                                : 16;
+     unsigned long dst_width_b0                   : 8;
+     unsigned long dst_height                     : 8;
+     } dst_height_width_8_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_height_width_8_t f;
+} dst_height_width_8_u;
+
+typedef struct _dst_height_y_t {
+     unsigned long dst_y                          : 14;
+     unsigned long                                : 2;
+     unsigned long dst_height                     : 14;
+     unsigned long                                : 2;
+     } dst_height_y_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_height_y_t f;
+} dst_height_y_u;
+
+typedef struct _dst_width_x_t {
+     unsigned long dst_x                          : 14;
+     unsigned long                                : 2;
+     unsigned long dst_width_b0                   : 8;
+     unsigned long dst_width_b1                   : 6;
+     unsigned long                                : 2;
+     } dst_width_x_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_width_x_t f;
+} dst_width_x_u;
+
+typedef struct _dst_width_x_incy_t {
+     unsigned long dst_x                          : 14;
+     unsigned long                                : 2;
+     unsigned long dst_width_b0                   : 8;
+     unsigned long dst_width_b1                   : 6;
+     unsigned long                                : 2;
+     } dst_width_x_incy_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_width_x_incy_t f;
+} dst_width_x_incy_u;
+
+typedef struct _dst_line_start_t {
+     unsigned long dst_start_x                    : 14;
+     unsigned long                                : 2;
+     unsigned long dst_start_y                    : 14;
+     unsigned long                                : 2;
+     } dst_line_start_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_line_start_t f;
+} dst_line_start_u;
+
+typedef struct _dst_line_end_t {
+     unsigned long dst_end_x                      : 14;
+     unsigned long                                : 2;
+     unsigned long dst_end_y_b0                   : 8;
+     unsigned long dst_end_y_b1                   : 6;
+     unsigned long                                : 2;
+     } dst_line_end_t;
+
+typedef union {
+     unsigned long val : 32;
+     dst_line_end_t f;
+} dst_line_end_u;
+
+typedef struct _brush_offset_t {
+     unsigned long brush_offset                   : 24;
+     unsigned long                                : 8;
+     } brush_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     brush_offset_t f;
+} brush_offset_u;
+
+typedef struct _brush_y_x_t {
+     unsigned long brush_x                        : 5;
+     unsigned long                                : 3;
+     unsigned long brush_y                        : 3;
+     unsigned long                                : 21;
+     } brush_y_x_t;
+
+typedef union {
+     unsigned long val : 32;
+     brush_y_x_t f;
+} brush_y_x_u;
+
+typedef struct _dp_brush_frgd_clr_t {
+     unsigned long dp_brush_frgd_clr              : 32;
+     } dp_brush_frgd_clr_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_brush_frgd_clr_t f;
+} dp_brush_frgd_clr_u;
+
+typedef struct _dp_brush_bkgd_clr_t {
+     unsigned long dp_brush_bkgd_clr              : 32;
+     } dp_brush_bkgd_clr_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_brush_bkgd_clr_t f;
+} dp_brush_bkgd_clr_u;
+
+typedef struct _src2_offset_t {
+     unsigned long src2_offset                    : 24;
+     unsigned long                                : 8;
+     } src2_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_offset_t f;
+} src2_offset_u;
+
+typedef struct _src2_pitch_t {
+     unsigned long src2_pitch                     : 14;
+     unsigned long src2_pitch_mul                 : 2;
+     unsigned long                                : 16;
+     } src2_pitch_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_pitch_t f;
+} src2_pitch_u;
+
+typedef struct _src2_pitch_offset_t {
+     unsigned long src2_offset                    : 20;
+     unsigned long                                : 2;
+     unsigned long src2_pitch                     : 8;
+     unsigned long src2_pitch_mul                 : 2;
+     } src2_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_pitch_offset_t f;
+} src2_pitch_offset_u;
+
+typedef struct _src2_x_t {
+     unsigned long src_x                          : 14;
+     unsigned long                                : 18;
+     } src2_x_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_x_t f;
+} src2_x_u;
+
+typedef struct _src2_y_t {
+     unsigned long src_y                          : 14;
+     unsigned long                                : 18;
+     } src2_y_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_y_t f;
+} src2_y_u;
+
+typedef struct _src2_x_y_t {
+     unsigned long src_y                          : 14;
+     unsigned long                                : 2;
+     unsigned long src_x                          : 14;
+     unsigned long                                : 2;
+     } src2_x_y_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_x_y_t f;
+} src2_x_y_u;
+
+typedef struct _src2_width_t {
+     unsigned long src2_width                     : 14;
+     unsigned long                                : 18;
+     } src2_width_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_width_t f;
+} src2_width_u;
+
+typedef struct _src2_height_t {
+     unsigned long src2_height                    : 14;
+     unsigned long                                : 18;
+     } src2_height_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_height_t f;
+} src2_height_u;
+
+typedef struct _src2_inc_t {
+     unsigned long src2_xinc                      : 6;
+     unsigned long                                : 2;
+     unsigned long src2_yinc                      : 6;
+     unsigned long                                : 18;
+     } src2_inc_t;
+
+typedef union {
+     unsigned long val : 32;
+     src2_inc_t f;
+} src2_inc_u;
+
+typedef struct _src_offset_t {
+     unsigned long src_offset                     : 24;
+     unsigned long                                : 8;
+     } src_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_offset_t f;
+} src_offset_u;
+
+typedef struct _src_pitch_t {
+     unsigned long src_pitch                      : 14;
+     unsigned long src_pitch_mul                  : 2;
+     unsigned long                                : 16;
+     } src_pitch_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_pitch_t f;
+} src_pitch_u;
+
+typedef struct _src_pitch_offset_t {
+     unsigned long src_offset                     : 20;
+     unsigned long src_pitch                      : 10;
+     unsigned long src_pitch_mul                  : 2;
+     } src_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_pitch_offset_t f;
+} src_pitch_offset_u;
+
+typedef struct _src_x_t {
+     unsigned long src_x                          : 14;
+     unsigned long                                : 18;
+     } src_x_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_x_t f;
+} src_x_u;
+
+typedef struct _src_y_t {
+     unsigned long src_y                          : 14;
+     unsigned long                                : 18;
+     } src_y_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_y_t f;
+} src_y_u;
+
+typedef struct _src_x_y_t {
+     unsigned long src_y                          : 14;
+     unsigned long                                : 2;
+     unsigned long src_x                          : 14;
+     unsigned long                                : 2;
+     } src_x_y_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_x_y_t f;
+} src_x_y_u;
+
+typedef struct _src_y_x_t {
+     unsigned long src_x                          : 14;
+     unsigned long                                : 2;
+     unsigned long src_y                          : 14;
+     unsigned long                                : 2;
+     } src_y_x_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_y_x_t f;
+} src_y_x_u;
+
+typedef struct _src_width_t {
+     unsigned long src_width                      : 14;
+     unsigned long                                : 18;
+     } src_width_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_width_t f;
+} src_width_u;
+
+typedef struct _src_height_t {
+     unsigned long src_height                     : 14;
+     unsigned long                                : 18;
+     } src_height_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_height_t f;
+} src_height_u;
+
+typedef struct _src_inc_t {
+     unsigned long src_xinc                       : 6;
+     unsigned long                                : 2;
+     unsigned long src_yinc                       : 6;
+     unsigned long                                : 18;
+     } src_inc_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_inc_t f;
+} src_inc_u;
+
+typedef struct _host_data0_t {
+     unsigned long host_data                      : 32;
+     } host_data0_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data0_t f;
+} host_data0_u;
+
+typedef struct _host_data1_t {
+     unsigned long host_data                      : 32;
+     } host_data1_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data1_t f;
+} host_data1_u;
+
+typedef struct _host_data2_t {
+     unsigned long host_data                      : 32;
+     } host_data2_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data2_t f;
+} host_data2_u;
+
+typedef struct _host_data3_t {
+     unsigned long host_data                      : 32;
+     } host_data3_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data3_t f;
+} host_data3_u;
+
+typedef struct _host_data4_t {
+     unsigned long host_data                      : 32;
+     } host_data4_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data4_t f;
+} host_data4_u;
+
+typedef struct _host_data5_t {
+     unsigned long host_data                      : 32;
+     } host_data5_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data5_t f;
+} host_data5_u;
+
+typedef struct _host_data6_t {
+     unsigned long host_data                      : 32;
+     } host_data6_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data6_t f;
+} host_data6_u;
+
+typedef struct _host_data7_t {
+     unsigned long host_data                      : 32;
+     } host_data7_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data7_t f;
+} host_data7_u;
+
+typedef struct _host_data_last_t {
+     unsigned long host_data_last                 : 32;
+     } host_data_last_t;
+
+typedef union {
+     unsigned long val : 32;
+     host_data_last_t f;
+} host_data_last_u;
+
+typedef struct _dp_src_frgd_clr_t {
+     unsigned long dp_src_frgd_clr                : 32;
+     } dp_src_frgd_clr_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_src_frgd_clr_t f;
+} dp_src_frgd_clr_u;
+
+typedef struct _dp_src_bkgd_clr_t {
+     unsigned long dp_src_bkgd_clr                : 32;
+     } dp_src_bkgd_clr_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_src_bkgd_clr_t f;
+} dp_src_bkgd_clr_u;
+
+typedef struct _sc_left_t {
+     unsigned long sc_left                        : 14;
+     unsigned long                                : 18;
+     } sc_left_t;
+
+typedef union {
+     unsigned long val : 32;
+     sc_left_t f;
+} sc_left_u;
+
+typedef struct _sc_right_t {
+     unsigned long sc_right                       : 14;
+     unsigned long                                : 18;
+     } sc_right_t;
+
+typedef union {
+     unsigned long val : 32;
+     sc_right_t f;
+} sc_right_u;
+
+typedef struct _sc_top_t {
+     unsigned long sc_top                         : 14;
+     unsigned long                                : 18;
+     } sc_top_t;
+
+typedef union {
+     unsigned long val : 32;
+     sc_top_t f;
+} sc_top_u;
+
+typedef struct _sc_bottom_t {
+     unsigned long sc_bottom                      : 14;
+     unsigned long                                : 18;
+     } sc_bottom_t;
+
+typedef union {
+     unsigned long val : 32;
+     sc_bottom_t f;
+} sc_bottom_u;
+
+typedef struct _src_sc_right_t {
+     unsigned long sc_right                       : 14;
+     unsigned long                                : 18;
+     } src_sc_right_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_sc_right_t f;
+} src_sc_right_u;
+
+typedef struct _src_sc_bottom_t {
+     unsigned long sc_bottom                      : 14;
+     unsigned long                                : 18;
+     } src_sc_bottom_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_sc_bottom_t f;
+} src_sc_bottom_u;
+
+typedef struct _dp_cntl_t {
+     unsigned long dst_x_dir                      : 1;
+     unsigned long dst_y_dir                      : 1;
+     unsigned long src_x_dir                      : 1;
+     unsigned long src_y_dir                      : 1;
+     unsigned long dst_major_x                    : 1;
+     unsigned long src_major_x                    : 1;
+     unsigned long                                : 26;
+     } dp_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_cntl_t f;
+} dp_cntl_u;
+
+typedef struct _dp_cntl_dst_dir_t {
+     unsigned long                                : 15;
+     unsigned long dst_y_dir                      : 1;
+     unsigned long                                : 15;
+     unsigned long dst_x_dir                      : 1;
+     } dp_cntl_dst_dir_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_cntl_dst_dir_t f;
+} dp_cntl_dst_dir_u;
+
+typedef struct _dp_datatype_t {
+     unsigned long dp_dst_datatype                : 4;
+     unsigned long                                : 4;
+     unsigned long dp_brush_datatype              : 4;
+     unsigned long dp_src2_type                   : 1;
+     unsigned long dp_src2_datatype               : 3;
+     unsigned long dp_src_datatype                : 3;
+     unsigned long                                : 11;
+     unsigned long dp_byte_pix_order              : 1;
+     unsigned long                                : 1;
+     } dp_datatype_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_datatype_t f;
+} dp_datatype_u;
+
+typedef struct _dp_mix_t {
+     unsigned long                                : 8;
+     unsigned long dp_src_source                  : 3;
+     unsigned long dp_src2_source                 : 3;
+     unsigned long                                : 2;
+     unsigned long dp_rop3                        : 8;
+     unsigned long dp_op                          : 1;
+     unsigned long                                : 7;
+     } dp_mix_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_mix_t f;
+} dp_mix_u;
+
+typedef struct _dp_write_msk_t {
+     unsigned long dp_write_msk                   : 32;
+     } dp_write_msk_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_write_msk_t f;
+} dp_write_msk_u;
+
+typedef struct _clr_cmp_clr_src_t {
+     unsigned long clr_cmp_clr_src                : 32;
+     } clr_cmp_clr_src_t;
+
+typedef union {
+     unsigned long val : 32;
+     clr_cmp_clr_src_t f;
+} clr_cmp_clr_src_u;
+
+typedef struct _clr_cmp_clr_dst_t {
+     unsigned long clr_cmp_clr_dst                : 32;
+     } clr_cmp_clr_dst_t;
+
+typedef union {
+     unsigned long val : 32;
+     clr_cmp_clr_dst_t f;
+} clr_cmp_clr_dst_u;
+
+typedef struct _clr_cmp_cntl_t {
+     unsigned long clr_cmp_fcn_src                : 3;
+     unsigned long                                : 5;
+     unsigned long clr_cmp_fcn_dst                : 3;
+     unsigned long                                : 13;
+     unsigned long clr_cmp_src                    : 2;
+     unsigned long                                : 6;
+     } clr_cmp_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     clr_cmp_cntl_t f;
+} clr_cmp_cntl_u;
+
+typedef struct _clr_cmp_msk_t {
+     unsigned long clr_cmp_msk                    : 32;
+     } clr_cmp_msk_t;
+
+typedef union {
+     unsigned long val : 32;
+     clr_cmp_msk_t f;
+} clr_cmp_msk_u;
+
+typedef struct _default_pitch_offset_t {
+     unsigned long default_offset                 : 20;
+     unsigned long default_pitch                  : 10;
+     unsigned long                                : 2;
+     } default_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     default_pitch_offset_t f;
+} default_pitch_offset_u;
+
+typedef struct _default_sc_bottom_right_t {
+     unsigned long default_sc_right               : 14;
+     unsigned long                                : 2;
+     unsigned long default_sc_bottom              : 14;
+     unsigned long                                : 2;
+     } default_sc_bottom_right_t;
+
+typedef union {
+     unsigned long val : 32;
+     default_sc_bottom_right_t f;
+} default_sc_bottom_right_u;
+
+typedef struct _default2_sc_bottom_right_t {
+     unsigned long default_sc_right               : 14;
+     unsigned long                                : 2;
+     unsigned long default_sc_bottom              : 14;
+     unsigned long                                : 2;
+     } default2_sc_bottom_right_t;
+
+typedef union {
+     unsigned long val : 32;
+     default2_sc_bottom_right_t f;
+} default2_sc_bottom_right_u;
+
+typedef struct _ref1_pitch_offset_t {
+     unsigned long offset                         : 20;
+     unsigned long                                : 2;
+     unsigned long pitch                          : 8;
+     unsigned long                                : 2;
+     } ref1_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     ref1_pitch_offset_t f;
+} ref1_pitch_offset_u;
+
+typedef struct _ref2_pitch_offset_t {
+     unsigned long offset                         : 20;
+     unsigned long                                : 2;
+     unsigned long pitch                          : 8;
+     unsigned long                                : 2;
+     } ref2_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     ref2_pitch_offset_t f;
+} ref2_pitch_offset_u;
+
+typedef struct _ref3_pitch_offset_t {
+     unsigned long offset                         : 20;
+     unsigned long                                : 2;
+     unsigned long pitch                          : 8;
+     unsigned long                                : 2;
+     } ref3_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     ref3_pitch_offset_t f;
+} ref3_pitch_offset_u;
+
+typedef struct _ref4_pitch_offset_t {
+     unsigned long offset                         : 20;
+     unsigned long                                : 2;
+     unsigned long pitch                          : 8;
+     unsigned long                                : 2;
+     } ref4_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     ref4_pitch_offset_t f;
+} ref4_pitch_offset_u;
+
+typedef struct _ref5_pitch_offset_t {
+     unsigned long offset                         : 20;
+     unsigned long                                : 2;
+     unsigned long pitch                          : 8;
+     unsigned long                                : 2;
+     } ref5_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     ref5_pitch_offset_t f;
+} ref5_pitch_offset_u;
+
+typedef struct _ref6_pitch_offset_t {
+     unsigned long offset                         : 20;
+     unsigned long                                : 2;
+     unsigned long pitch                          : 8;
+     unsigned long                                : 2;
+     } ref6_pitch_offset_t;
+
+typedef union {
+     unsigned long val : 32;
+     ref6_pitch_offset_t f;
+} ref6_pitch_offset_u;
+
+typedef struct _dp_gui_master_cntl_t {
+     unsigned long gmc_src_pitch_offset_cntl      : 1;
+     unsigned long gmc_dst_pitch_offset_cntl      : 1;
+     unsigned long gmc_src_clipping               : 1;
+     unsigned long gmc_dst_clipping               : 1;
+     unsigned long gmc_brush_datatype             : 4;
+     unsigned long gmc_dst_datatype               : 4;
+     unsigned long gmc_src_datatype               : 3;
+     unsigned long gmc_byte_pix_order             : 1;
+     unsigned long gmc_default_sel                : 1;
+     unsigned long gmc_rop3                       : 8;
+     unsigned long gmc_dp_src_source              : 3;
+     unsigned long gmc_clr_cmp_fcn_dis            : 1;
+     unsigned long                                : 1;
+     unsigned long gmc_wr_msk_dis                 : 1;
+     unsigned long gmc_dp_op                      : 1;
+     } dp_gui_master_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     dp_gui_master_cntl_t f;
+} dp_gui_master_cntl_u;
+
+typedef struct _sc_top_left_t {
+     unsigned long sc_left                        : 14;
+     unsigned long                                : 2;
+     unsigned long sc_top                         : 14;
+     unsigned long                                : 2;
+     } sc_top_left_t;
+
+typedef union {
+     unsigned long val : 32;
+     sc_top_left_t f;
+} sc_top_left_u;
+
+typedef struct _sc_bottom_right_t {
+     unsigned long sc_right                       : 14;
+     unsigned long                                : 2;
+     unsigned long sc_bottom                      : 14;
+     unsigned long                                : 2;
+     } sc_bottom_right_t;
+
+typedef union {
+     unsigned long val : 32;
+     sc_bottom_right_t f;
+} sc_bottom_right_u;
+
+typedef struct _src_sc_bottom_right_t {
+     unsigned long sc_right                       : 14;
+     unsigned long                                : 2;
+     unsigned long sc_bottom                      : 14;
+     unsigned long                                : 2;
+     } src_sc_bottom_right_t;
+
+typedef union {
+     unsigned long val : 32;
+     src_sc_bottom_right_t f;
+} src_sc_bottom_right_u;
+
+typedef struct _global_alpha_t {
+     unsigned long alpha_r                        : 8;
+     unsigned long alpha_g                        : 8;
+     unsigned long alpha_b                        : 8;
+     unsigned long alpha_a                        : 8;
+     } global_alpha_t;
+
+typedef union {
+     unsigned long val : 32;
+     global_alpha_t f;
+} global_alpha_u;
+
+typedef struct _filter_coef_t {
+     unsigned long c_4                            : 4;
+     unsigned long c_3                            : 4;
+     unsigned long c_2                            : 4;
+     unsigned long c_1                            : 4;
+     unsigned long c1                             : 4;
+     unsigned long c2                             : 4;
+     unsigned long c3                             : 4;
+     unsigned long c4                             : 4;
+     } filter_coef_t;
+
+typedef union {
+     unsigned long val : 32;
+     filter_coef_t f;
+} filter_coef_u;
+
+typedef struct _mvc_cntl_start_t {
+     unsigned long mc_cntl_src_1_index            : 4;
+     unsigned long mc_cntl_dst_offset             : 20;
+     unsigned long mc_dst_pitch_mul               : 2;
+     unsigned long mc_cntl_src_2_index            : 3;
+     unsigned long mc_cntl_width_height_sel       : 3;
+     } mvc_cntl_start_t;
+
+typedef union {
+     unsigned long val : 32;
+     mvc_cntl_start_t f;
+} mvc_cntl_start_u;
+
+typedef struct _e2_arithmetic_cntl_t {
+     unsigned long opcode                         : 5;
+     unsigned long shiftright                     : 4;
+     unsigned long clamp                          : 1;
+     unsigned long rounding                       : 2;
+     unsigned long filter_n                       : 3;
+     unsigned long                                : 1;
+     unsigned long srcblend_inv                   : 1;
+     unsigned long srcblend                       : 4;
+     unsigned long                                : 3;
+     unsigned long dstblend_inv                   : 1;
+     unsigned long dstblend                       : 4;
+     unsigned long dst_signed                     : 1;
+     unsigned long autoinc                        : 1;
+     unsigned long                                : 1;
+     } e2_arithmetic_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     e2_arithmetic_cntl_t f;
+} e2_arithmetic_cntl_u;
+
+typedef struct _debug0_t {
+     unsigned long debug0_r                       : 8;
+     unsigned long                                : 8;
+     unsigned long debug0_rw                      : 8;
+     unsigned long                                : 8;
+     } debug0_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug0_t f;
+} debug0_u;
+
+typedef struct _debug1_t {
+     unsigned long debug1_r                       : 8;
+     unsigned long                                : 8;
+     unsigned long debug1_rw                      : 8;
+     unsigned long                                : 8;
+     } debug1_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug1_t f;
+} debug1_u;
+
+typedef struct _debug2_t {
+     unsigned long debug2_r                       : 8;
+     unsigned long                                : 8;
+     unsigned long debug2_rw                      : 8;
+     unsigned long                                : 8;
+     } debug2_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug2_t f;
+} debug2_u;
+
+typedef struct _debug3_t {
+     unsigned long                                : 32;
+     } debug3_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug3_t f;
+} debug3_u;
+
+typedef struct _debug4_t {
+     unsigned long                                : 32;
+     } debug4_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug4_t f;
+} debug4_u;
+
+typedef struct _debug5_t {
+     unsigned long                                : 32;
+     } debug5_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug5_t f;
+} debug5_u;
+
+typedef struct _debug6_t {
+     unsigned long                                : 32;
+     } debug6_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug6_t f;
+} debug6_u;
+
+typedef struct _debug7_t {
+     unsigned long                                : 32;
+     } debug7_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug7_t f;
+} debug7_u;
+
+typedef struct _debug8_t {
+     unsigned long                                : 32;
+     } debug8_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug8_t f;
+} debug8_u;
+
+typedef struct _debug9_t {
+     unsigned long                                : 32;
+     } debug9_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug9_t f;
+} debug9_u;
+
+typedef struct _debug10_t {
+     unsigned long                                : 32;
+     } debug10_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug10_t f;
+} debug10_u;
+
+typedef struct _debug11_t {
+     unsigned long                                : 32;
+     } debug11_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug11_t f;
+} debug11_u;
+
+typedef struct _debug12_t {
+     unsigned long                                : 32;
+     } debug12_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug12_t f;
+} debug12_u;
+
+typedef struct _debug13_t {
+     unsigned long                                : 32;
+     } debug13_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug13_t f;
+} debug13_u;
+
+typedef struct _debug14_t {
+     unsigned long                                : 32;
+     } debug14_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug14_t f;
+} debug14_u;
+
+typedef struct _debug15_t {
+     unsigned long                                : 32;
+     } debug15_t;
+
+typedef union {
+     unsigned long val : 32;
+     debug15_t f;
+} debug15_u;
+
+typedef struct _eng_cntl_t {
+     unsigned long erc_reg_rd_ws                  : 1;
+     unsigned long erc_reg_wr_ws                  : 1;
+     unsigned long erc_idle_reg_wr                : 1;
+     unsigned long dis_engine_triggers            : 1;
+     unsigned long dis_rop_src_uses_dst_w_h       : 1;
+     unsigned long dis_src_uses_dst_dirmaj        : 1;
+     unsigned long                                : 6;
+     unsigned long force_3dclk_when_2dclk         : 1;
+     unsigned long                                : 19;
+     } eng_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     eng_cntl_t f;
+} eng_cntl_u;
+
+typedef struct _eng_perf_cnt_t {
+     unsigned long perf_cnt                       : 20;
+     unsigned long perf_sel                       : 4;
+     unsigned long perf_en                        : 1;
+     unsigned long                                : 3;
+     unsigned long perf_clr                       : 1;
+     unsigned long                                : 3;
+     } eng_perf_cnt_t;
+
+typedef union {
+     unsigned long val : 32;
+     eng_perf_cnt_t f;
+} eng_perf_cnt_u;
+
+typedef struct _idct_runs_t {
+     unsigned long idct_runs_3                    : 8;
+     unsigned long idct_runs_2                    : 8;
+     unsigned long idct_runs_1                    : 8;
+     unsigned long idct_runs_0                    : 8;
+     } idct_runs_t;
+
+typedef union {
+     unsigned long val : 32;
+     idct_runs_t f;
+} idct_runs_u;
+
+typedef struct _idct_levels_t {
+     unsigned long idct_level_hi                  : 16;
+     unsigned long idct_level_lo                  : 16;
+     } idct_levels_t;
+
+typedef union {
+     unsigned long val : 32;
+     idct_levels_t f;
+} idct_levels_u;
+
+typedef struct _idct_control_t {
+     unsigned long idct_ctl_luma_rd_format        : 2;
+     unsigned long idct_ctl_chroma_rd_format      : 2;
+     unsigned long idct_ctl_scan_pattern          : 1;
+     unsigned long idct_ctl_intra                 : 1;
+     unsigned long idct_ctl_flush                 : 1;
+     unsigned long idct_ctl_passthru              : 1;
+     unsigned long idct_ctl_sw_reset              : 1;
+     unsigned long idct_ctl_constreq              : 1;
+     unsigned long idct_ctl_scramble              : 1;
+     unsigned long idct_ctl_alt_scan              : 1;
+     unsigned long                                : 20;
+     } idct_control_t;
+
+typedef union {
+     unsigned long val : 32;
+     idct_control_t f;
+} idct_control_u;
+
+typedef struct _idct_auth_control_t {
+     unsigned long control_bits                   : 32;
+     } idct_auth_control_t;
+
+typedef union {
+     unsigned long val : 32;
+     idct_auth_control_t f;
+} idct_auth_control_u;
+
+typedef struct _idct_auth_t {
+     unsigned long auth                           : 32;
+     } idct_auth_t;
+
+typedef union {
+     unsigned long val : 32;
+     idct_auth_t f;
+} idct_auth_u;
+
+typedef struct _mem_cntl_t {
+     unsigned long                                : 1;
+     unsigned long en_mem_ch1                     : 1;
+     unsigned long en_mem_ch2                     : 1;
+     unsigned long int_mem_mapping                : 1;
+     unsigned long                                : 28;
+     } mem_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     mem_cntl_t f;
+} mem_cntl_u;
+
+typedef struct _mem_arb_t {
+     unsigned long disp_time_slot                 : 4;
+     unsigned long disp_timer                     : 4;
+     unsigned long arb_option                     : 1;
+     unsigned long                                : 23;
+     } mem_arb_t;
+
+typedef union {
+     unsigned long val : 32;
+     mem_arb_t f;
+} mem_arb_u;
+
+typedef struct _mc_fb_location_t {
+     unsigned long mc_fb_start                    : 16;
+     unsigned long mc_fb_top                      : 16;
+     } mc_fb_location_t;
+
+typedef union {
+     unsigned long val : 32;
+     mc_fb_location_t f;
+} mc_fb_location_u;
+
+typedef struct _mem_ext_cntl_t {
+     unsigned long mem_ext_enable                 : 1;
+     unsigned long mem_ap_enable                  : 1;
+     unsigned long mem_addr_mapping               : 2;
+     unsigned long mem_wdoe_cntl                  : 2;
+     unsigned long mem_wdoe_extend                : 1;
+     unsigned long                                : 1;
+     unsigned long mem_page_timer                 : 8;
+     unsigned long mem_dynamic_cke                : 1;
+     unsigned long mem_sdram_tri_en               : 1;
+     unsigned long mem_self_refresh_en            : 1;
+     unsigned long mem_power_down                 : 1;
+     unsigned long mem_hw_power_down_en           : 1;
+     unsigned long mem_power_down_stat            : 1;
+     unsigned long                                : 3;
+     unsigned long mem_pd_mck                     : 1;
+     unsigned long mem_pd_ma                      : 1;
+     unsigned long mem_pd_mdq                     : 1;
+     unsigned long mem_tristate_mck               : 1;
+     unsigned long mem_tristate_ma                : 1;
+     unsigned long mem_tristate_mcke              : 1;
+     unsigned long mem_invert_mck                 : 1;
+     } mem_ext_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     mem_ext_cntl_t f;
+} mem_ext_cntl_u;
+
+typedef struct _mc_ext_mem_location_t {
+     unsigned long mc_ext_mem_start               : 16;
+     unsigned long mc_ext_mem_top                 : 16;
+     } mc_ext_mem_location_t;
+
+typedef union {
+     unsigned long val : 32;
+     mc_ext_mem_location_t f;
+} mc_ext_mem_location_u;
+
+typedef struct _mem_ext_timing_cntl_t {
+     unsigned long mem_trp                        : 2;
+     unsigned long mem_trcd                       : 2;
+     unsigned long mem_tras                       : 3;
+     unsigned long                                : 1;
+     unsigned long mem_trrd                       : 2;
+     unsigned long mem_tr2w                       : 2;
+     unsigned long mem_twr                        : 2;
+     unsigned long                                : 4;
+     unsigned long mem_twr_mode                   : 1;
+     unsigned long                                : 1;
+     unsigned long mem_refresh_dis                : 1;
+     unsigned long                                : 3;
+     unsigned long mem_refresh_rate               : 8;
+     } mem_ext_timing_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     mem_ext_timing_cntl_t f;
+} mem_ext_timing_cntl_u;
+
+typedef struct _mem_sdram_mode_reg_t {
+     unsigned long mem_mode_reg                   : 14;
+     unsigned long                                : 2;
+     unsigned long mem_read_latency               : 2;
+     unsigned long mem_schmen_latency             : 2;
+     unsigned long mem_cas_latency                : 2;
+     unsigned long mem_schmen_extend              : 1;
+     unsigned long                                : 8;
+     unsigned long mem_sdram_reset                : 1;
+     } mem_sdram_mode_reg_t;
+
+typedef union {
+     unsigned long val : 32;
+     mem_sdram_mode_reg_t f;
+} mem_sdram_mode_reg_u;
+
+typedef struct _mem_io_cntl_t {
+     unsigned long mem_sn_mck                     : 4;
+     unsigned long mem_sn_ma                      : 4;
+     unsigned long mem_sn_mdq                     : 4;
+     unsigned long mem_srn_mck                    : 1;
+     unsigned long mem_srn_ma                     : 1;
+     unsigned long mem_srn_mdq                    : 1;
+     unsigned long                                : 1;
+     unsigned long mem_sp_mck                     : 4;
+     unsigned long mem_sp_ma                      : 4;
+     unsigned long mem_sp_mdq                     : 4;
+     unsigned long mem_srp_mck                    : 1;
+     unsigned long mem_srp_ma                     : 1;
+     unsigned long mem_srp_mdq                    : 1;
+     unsigned long                                : 1;
+     } mem_io_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     mem_io_cntl_t f;
+} mem_io_cntl_u;
+
+typedef struct _mc_debug_t {
+     unsigned long mc_debug                       : 32;
+     } mc_debug_t;
+
+typedef union {
+     unsigned long val : 32;
+     mc_debug_t f;
+} mc_debug_u;
+
+typedef struct _mc_bist_ctrl_t {
+     unsigned long mc_bist_ctrl                   : 32;
+     } mc_bist_ctrl_t;
+
+typedef union {
+     unsigned long val : 32;
+     mc_bist_ctrl_t f;
+} mc_bist_ctrl_u;
+
+typedef struct _mc_bist_collar_read_t {
+     unsigned long mc_bist_collar_read            : 32;
+     } mc_bist_collar_read_t;
+
+typedef union {
+     unsigned long val : 32;
+     mc_bist_collar_read_t f;
+} mc_bist_collar_read_u;
+
+typedef struct _tc_mismatch_t {
+     unsigned long tc_mismatch                    : 24;
+     unsigned long                                : 8;
+     } tc_mismatch_t;
+
+typedef union {
+     unsigned long val : 32;
+     tc_mismatch_t f;
+} tc_mismatch_u;
+
+typedef struct _mc_perf_mon_cntl_t {
+     unsigned long clr_perf                       : 1;
+     unsigned long en_perf                        : 1;
+     unsigned long                                : 2;
+     unsigned long perf_op_a                      : 2;
+     unsigned long perf_op_b                      : 2;
+     unsigned long                                : 8;
+     unsigned long monitor_period                 : 8;
+     unsigned long perf_count_a_overflow          : 1;
+     unsigned long perf_count_b_overflow          : 1;
+     unsigned long                                : 6;
+     } mc_perf_mon_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     mc_perf_mon_cntl_t f;
+} mc_perf_mon_cntl_u;
+
+typedef struct _mc_perf_counters_t {
+     unsigned long mc_perf_counter_a              : 16;
+     unsigned long mc_perf_counter_b              : 16;
+     } mc_perf_counters_t;
+
+typedef union {
+     unsigned long val : 32;
+     mc_perf_counters_t f;
+} mc_perf_counters_u;
+
+typedef struct _wait_until_t {
+     unsigned long wait_crtc_pflip                : 1;
+     unsigned long wait_re_crtc_vline             : 1;
+     unsigned long wait_fe_crtc_vline             : 1;
+     unsigned long wait_crtc_vline                : 1;
+     unsigned long wait_dma_viph0_idle            : 1;
+     unsigned long wait_dma_viph1_idle            : 1;
+     unsigned long wait_dma_viph2_idle            : 1;
+     unsigned long wait_dma_viph3_idle            : 1;
+     unsigned long wait_dma_vid_idle              : 1;
+     unsigned long wait_dma_gui_idle              : 1;
+     unsigned long wait_cmdfifo                   : 1;
+     unsigned long wait_ov0_flip                  : 1;
+     unsigned long wait_ov0_slicedone             : 1;
+     unsigned long                                : 1;
+     unsigned long wait_2d_idle                   : 1;
+     unsigned long wait_3d_idle                   : 1;
+     unsigned long wait_2d_idleclean              : 1;
+     unsigned long wait_3d_idleclean              : 1;
+     unsigned long wait_host_idleclean            : 1;
+     unsigned long wait_extern_sig                : 1;
+     unsigned long cmdfifo_entries                : 7;
+     unsigned long                                : 3;
+     unsigned long wait_both_crtc_pflip           : 1;
+     unsigned long eng_display_select             : 1;
+     } wait_until_t;
+
+typedef union {
+     unsigned long val : 32;
+     wait_until_t f;
+} wait_until_u;
+
+typedef struct _isync_cntl_t {
+     unsigned long isync_any2d_idle3d             : 1;
+     unsigned long isync_any3d_idle2d             : 1;
+     unsigned long isync_trig2d_idle3d            : 1;
+     unsigned long isync_trig3d_idle2d            : 1;
+     unsigned long isync_wait_idlegui             : 1;
+     unsigned long isync_cpscratch_idlegui        : 1;
+     unsigned long                                : 26;
+     } isync_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     isync_cntl_t f;
+} isync_cntl_u;
+
+typedef struct _rbbm_guicntl_t {
+     unsigned long host_data_swap                 : 2;
+     unsigned long                                : 30;
+     } rbbm_guicntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_guicntl_t f;
+} rbbm_guicntl_u;
+
+typedef struct _rbbm_status_t {
+     unsigned long cmdfifo_avail                  : 7;
+     unsigned long                                : 1;
+     unsigned long hirq_on_rbb                    : 1;
+     unsigned long cprq_on_rbb                    : 1;
+     unsigned long cfrq_on_rbb                    : 1;
+     unsigned long hirq_in_rtbuf                  : 1;
+     unsigned long cprq_in_rtbuf                  : 1;
+     unsigned long cfrq_in_rtbuf                  : 1;
+     unsigned long cf_pipe_busy                   : 1;
+     unsigned long eng_ev_busy                    : 1;
+     unsigned long cp_cmdstrm_busy                : 1;
+     unsigned long e2_busy                        : 1;
+     unsigned long rb2d_busy                      : 1;
+     unsigned long rb3d_busy                      : 1;
+     unsigned long se_busy                        : 1;
+     unsigned long re_busy                        : 1;
+     unsigned long tam_busy                       : 1;
+     unsigned long tdm_busy                       : 1;
+     unsigned long pb_busy                        : 1;
+     unsigned long                                : 6;
+     unsigned long gui_active                     : 1;
+     } rbbm_status_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_status_t f;
+} rbbm_status_u;
+
+typedef struct _rbbm_cntl_t {
+     unsigned long rb_settle                      : 4;
+     unsigned long abortclks_hi                   : 3;
+     unsigned long                                : 1;
+     unsigned long abortclks_cp                   : 3;
+     unsigned long                                : 1;
+     unsigned long abortclks_cfifo                : 3;
+     unsigned long                                : 2;
+     unsigned long cpq_data_swap                  : 1;
+     unsigned long                                : 3;
+     unsigned long no_abort_idct                  : 1;
+     unsigned long no_abort_bios                  : 1;
+     unsigned long no_abort_fb                    : 1;
+     unsigned long no_abort_cp                    : 1;
+     unsigned long no_abort_hi                    : 1;
+     unsigned long no_abort_hdp                   : 1;
+     unsigned long no_abort_mc                    : 1;
+     unsigned long no_abort_aic                   : 1;
+     unsigned long no_abort_vip                   : 1;
+     unsigned long no_abort_disp                  : 1;
+     unsigned long no_abort_cg                    : 1;
+     } rbbm_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_cntl_t f;
+} rbbm_cntl_u;
+
+typedef struct _rbbm_soft_reset_t {
+     unsigned long soft_reset_cp                  : 1;
+     unsigned long soft_reset_hi                  : 1;
+     unsigned long reserved3                      : 3;
+     unsigned long soft_reset_e2                  : 1;
+     unsigned long reserved2                      : 2;
+     unsigned long soft_reset_mc                  : 1;
+     unsigned long reserved1                      : 2;
+     unsigned long soft_reset_disp                : 1;
+     unsigned long soft_reset_cg                  : 1;
+     unsigned long                                : 19;
+     } rbbm_soft_reset_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_soft_reset_t f;
+} rbbm_soft_reset_u;
+
+typedef struct _nqwait_until_t {
+     unsigned long wait_gui_idle                  : 1;
+     unsigned long                                : 31;
+     } nqwait_until_t;
+
+typedef union {
+     unsigned long val : 32;
+     nqwait_until_t f;
+} nqwait_until_u;
+
+typedef struct _rbbm_debug_t {
+     unsigned long rbbm_debug                     : 32;
+     } rbbm_debug_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_debug_t f;
+} rbbm_debug_u;
+
+typedef struct _rbbm_cmdfifo_addr_t {
+     unsigned long cmdfifo_addr                   : 6;
+     unsigned long                                : 26;
+     } rbbm_cmdfifo_addr_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_cmdfifo_addr_t f;
+} rbbm_cmdfifo_addr_u;
+
+typedef struct _rbbm_cmdfifo_datal_t {
+     unsigned long cmdfifo_datal                  : 32;
+     } rbbm_cmdfifo_datal_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_cmdfifo_datal_t f;
+} rbbm_cmdfifo_datal_u;
+
+typedef struct _rbbm_cmdfifo_datah_t {
+     unsigned long cmdfifo_datah                  : 12;
+     unsigned long                                : 20;
+     } rbbm_cmdfifo_datah_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_cmdfifo_datah_t f;
+} rbbm_cmdfifo_datah_u;
+
+typedef struct _rbbm_cmdfifo_stat_t {
+     unsigned long cmdfifo_rptr                   : 6;
+     unsigned long                                : 2;
+     unsigned long cmdfifo_wptr                   : 6;
+     unsigned long                                : 18;
+     } rbbm_cmdfifo_stat_t;
+
+typedef union {
+     unsigned long val : 32;
+     rbbm_cmdfifo_stat_t f;
+} rbbm_cmdfifo_stat_u;
+
+typedef struct _clk_pin_cntl_t {
+     unsigned long osc_en                         : 1;
+     unsigned long osc_gain                       : 5;
+     unsigned long dont_use_xtalin                : 1;
+     unsigned long xtalin_pm_en                   : 1;
+     unsigned long xtalin_dbl_en                  : 1;
+     unsigned long                                : 7;
+     unsigned long cg_debug                       : 16;
+     } clk_pin_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     clk_pin_cntl_t f;
+} clk_pin_cntl_u;
+
+typedef struct _pll_ref_fb_div_t {
+     unsigned long pll_ref_div                    : 4;
+     unsigned long                                : 4;
+     unsigned long pll_fb_div_int                 : 6;
+     unsigned long                                : 2;
+     unsigned long pll_fb_div_frac                : 3;
+     unsigned long                                : 1;
+     unsigned long pll_reset_time                 : 4;
+     unsigned long pll_lock_time                  : 8;
+     } pll_ref_fb_div_t;
+
+typedef union {
+     unsigned long val : 32;
+     pll_ref_fb_div_t f;
+} pll_ref_fb_div_u;
+
+typedef struct _pll_cntl_t {
+     unsigned long pll_pwdn                       : 1;
+     unsigned long pll_reset                      : 1;
+     unsigned long pll_pm_en                      : 1;
+     unsigned long pll_mode                       : 1;
+     unsigned long pll_refclk_sel                 : 1;
+     unsigned long pll_fbclk_sel                  : 1;
+     unsigned long pll_tcpoff                     : 1;
+     unsigned long pll_pcp                        : 3;
+     unsigned long pll_pvg                        : 3;
+     unsigned long pll_vcofr                      : 1;
+     unsigned long pll_ioffset                    : 2;
+     unsigned long pll_pecc_mode                  : 2;
+     unsigned long pll_pecc_scon                  : 2;
+     unsigned long pll_dactal                     : 4;
+     unsigned long pll_cp_clip                    : 2;
+     unsigned long pll_conf                       : 3;
+     unsigned long pll_mbctrl                     : 2;
+     unsigned long pll_ring_off                   : 1;
+     } pll_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     pll_cntl_t f;
+} pll_cntl_u;
+
+typedef struct _sclk_cntl_t {
+     unsigned long sclk_src_sel                   : 2;
+     unsigned long                                : 2;
+     unsigned long sclk_post_div_fast             : 4;
+     unsigned long sclk_clkon_hys                 : 3;
+     unsigned long sclk_post_div_slow             : 4;
+     unsigned long disp_cg_ok2switch_en           : 1;
+     unsigned long sclk_force_reg                 : 1;
+     unsigned long sclk_force_disp                : 1;
+     unsigned long sclk_force_mc                  : 1;
+     unsigned long sclk_force_extmc               : 1;
+     unsigned long sclk_force_cp                  : 1;
+     unsigned long sclk_force_e2                  : 1;
+     unsigned long sclk_force_e3                  : 1;
+     unsigned long sclk_force_idct                : 1;
+     unsigned long sclk_force_bist                : 1;
+     unsigned long busy_extend_cp                 : 1;
+     unsigned long busy_extend_e2                 : 1;
+     unsigned long busy_extend_e3                 : 1;
+     unsigned long busy_extend_idct               : 1;
+     unsigned long                                : 3;
+     } sclk_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     sclk_cntl_t f;
+} sclk_cntl_u;
+
+typedef struct _pclk_cntl_t {
+     unsigned long pclk_src_sel                   : 2;
+     unsigned long                                : 2;
+     unsigned long pclk_post_div                  : 4;
+     unsigned long                                : 8;
+     unsigned long pclk_force_disp                : 1;
+     unsigned long                                : 15;
+     } pclk_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     pclk_cntl_t f;
+} pclk_cntl_u;
+
+typedef struct _clk_test_cntl_t {
+     unsigned long testclk_sel                    : 4;
+     unsigned long                                : 3;
+     unsigned long start_check_freq               : 1;
+     unsigned long tstcount_rst                   : 1;
+     unsigned long                                : 15;
+     unsigned long test_count                     : 8;
+     } clk_test_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     clk_test_cntl_t f;
+} clk_test_cntl_u;
+
+typedef struct _pwrmgt_cntl_t {
+     unsigned long pwm_enable                     : 1;
+     unsigned long                                : 1;
+     unsigned long pwm_mode_req                   : 2;
+     unsigned long pwm_wakeup_cond                : 2;
+     unsigned long pwm_fast_noml_hw_en            : 1;
+     unsigned long pwm_noml_fast_hw_en            : 1;
+     unsigned long pwm_fast_noml_cond             : 4;
+     unsigned long pwm_noml_fast_cond             : 4;
+     unsigned long pwm_idle_timer                 : 8;
+     unsigned long pwm_busy_timer                 : 8;
+     } pwrmgt_cntl_t;
+
+typedef union {
+     unsigned long val : 32;
+     pwrmgt_cntl_t f;
+} pwrmgt_cntl_u;
+
+typedef struct _pwrmgt_status_t {
+     unsigned long pwm_mode                       : 2;
+     unsigned long                                : 30;
+     } pwrmgt_status_t;
+
+typedef union {
+     unsigned long val : 32;
+     pwrmgt_status_t f;
+} pwrmgt_status_u;
+
+typedef struct _cursor_offset_t {
+    unsigned long cur_offset                    : 24;
+    unsigned long cur_x_offset                  : 4;
+    unsigned long cur_y_offset                  : 4;
+} cursor_offset_t;
+
+typedef union {
+    unsigned long val : 32;
+    cursor_offset_t f;
+} cursor_offset_u;
+
+typedef struct _cursor_h_pos_t {
+    unsigned long cur_h_start                   : 10;
+    unsigned long                                : 6;
+    unsigned long cur_h_end                     : 10;
+    unsigned long                                : 5;
+    unsigned long cur_en                        : 1;
+} cursor_h_pos_t;
+
+typedef union {
+    unsigned long val : 32;
+    cursor_h_pos_t f;
+} cursor_h_pos_u;
+
+typedef struct _cursor_v_pos_t {
+    unsigned long cur_v_start                   : 10;
+    unsigned long                                : 6;
+    unsigned long cur_v_end                     : 10;
+    unsigned long                                : 6;
+} cursor_v_pos_t;
+
+typedef union {
+    unsigned long val : 32;
+    cursor_v_pos_t f;
+} cursor_v_pos_u;
+
+typedef struct _cursor_color_t {
+     unsigned long cur_color_r                  : 8;
+     unsigned long cur_color_g                  : 8;
+     unsigned long cur_color_b                  : 8;
+     unsigned long                              : 8;
+} cursor_color_t;
+
+typedef union {
+     unsigned long val : 32;
+     cursor_color_t f;
+} cursor_color_u;
+
+#endif
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_stub.c
@@ -0,0 +1,95 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+#include "imageon.h"
+#include "imageon_regs.h"
+#include "klinux.h"
+
+extern W100CardEntry w100_cards[];
+
+static Bool
+FindW100(CARD16 vendor, CARD16 device, KdCardAttr * attr)
+{
+    CARD8 *mmio;
+    CARD32 chip_id;
+    Bool found = FALSE;
+
+    mmio = KdMapDevice(W100_REG_BASE, W100_REG_SIZE);
+    KdSetMappedMode((CARD32) mmio, W100_REG_SIZE,
+                    KD_MAPPED_MODE_REGISTERS);
+
+    chip_id = (*(VOL32 *)(mmio + mmCHIP_ID));
+    if ((vendor | (device << 16)) == chip_id) {
+        ErrorF("(I) Found W100 Chip ID: %08x\n\n", chip_id);
+        attr->deviceID = device;
+        attr->vendorID = vendor;
+        found = TRUE;
+    }
+    KdUnmapDevice(mmio, W100_REG_SIZE);
+    return found;
+}
+
+
+void
+InitCard(char *name)
+{
+    int i;
+    W100CardEntry *entry;
+    KdCardAttr attr;
+
+    for (entry = w100_cards; entry->name; entry++) {
+        if (FindW100(entry->vendor, entry->device, &attr)) {
+            KdCardInfoAdd(&W100Funcs, &attr, 0);
+            break;
+        }
+    }
+}
+
+void
+InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
+{
+    KdInitOutput(pScreenInfo, argc, argv);
+}
+
+void
+InitInput(int argc, char **argv)
+{
+    KdInitInput(&LinuxMouseFuncs, &LinuxKeyboardFuncs);
+#ifdef TOUCHSCREEN
+    KdAddMouseDriver(&TsFuncs);
+#endif
+}
+
+void
+ddxUseMsg(void)
+{
+    KdUseMsg();
+}
+
+int
+ddxProcessArgument(int argc, char **argv, int i)
+{
+    return KdProcessArgument(argc, argv, i);
+}
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_support.c
@@ -0,0 +1,1474 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+
+#include <sys/time.h>
+
+#include "imageon.h"
+#include "imageon_regs.h"
+#include "imageon_const.h"
+
+CARD8 W100SolidRop[16] = {
+    /* GXclear        */ 0x00,    /* 0 */
+    /* GXand          */ 0xa0,    /* src AND dst */
+    /* GXandReverse   */ 0x50,    /* src AND NOT dst */
+    /* GXcopy         */ 0xf0,    /* src */
+    /* GXandInverted  */ 0x0a,    /* NOT src AND dst */
+    /* GXnoop         */ 0xaa,    /* dst */
+    /* GXxor          */ 0x5a,    /* src XOR dst */
+    /* GXor           */ 0xfa,    /* src OR dst */
+    /* GXnor          */ 0x05,    /* NOT src AND NOT dst */
+    /* GXequiv        */ 0xa5,    /* NOT src XOR dst */
+    /* GXinvert       */ 0x55,    /* NOT dst */
+    /* GXorReverse    */ 0xf5,    /* src OR NOT dst */
+    /* GXcopyInverted */ 0x0f,    /* NOT src */
+    /* GXorInverted   */ 0xaf,    /* NOT src OR dst */
+    /* GXnand         */ 0x5f,    /* NOT src OR NOT dst */
+    /* GXset          */ 0xff,    /* 1 */
+};
+
+CARD8 W100BltRop[16] = {
+    /* GXclear        */ 0x00,    /* 0 */
+    /* GXand          */ 0x88,    /* src AND dst */
+    /* GXandReverse   */ 0x44,    /* src AND NOT dst */
+    /* GXcopy         */ 0xcc,    /* src */
+    /* GXandInverted  */ 0x22,    /* NOT src AND dst */
+    /* GXnoop         */ 0xaa,    /* dst */
+    /* GXxor          */ 0x66,    /* src XOR dst */
+    /* GXor           */ 0xee,    /* src OR dst */
+    /* GXnor          */ 0x11,    /* NOT src AND NOT dst */
+    /* GXequiv        */ 0x99,    /* NOT src XOR dst */
+    /* GXinvert       */ 0x55,    /* NOT dst */
+    /* GXorReverse    */ 0xdd,    /* src OR NOT dst */
+    /* GXcopyInverted */ 0x33,    /* NOT src */
+    /* GXorInverted   */ 0xbb,    /* NOT src OR dst */
+    /* GXnand         */ 0x77,    /* NOT src OR NOT dst */
+    /* GXset          */ 0xff,    /* 1 */
+};
+
+extern W100ModeSpec w100_modes[];
+extern W100StartupInfo w100StartupInfo;
+
+void W100DisableDisplayUpdate(W100CardInfo *w100c)
+{
+    disp_db_buf_cntl_wr_u disp_db_buf_cntl;
+
+    disp_db_buf_cntl.f.db_buf_cntl = 30;
+    disp_db_buf_cntl.f.en_db_buf = 0;
+    disp_db_buf_cntl.f.update_db_buf = 0;
+    MMIO_OUT32(mmDISP_DB_BUF_CNTL, disp_db_buf_cntl.val);
+}
+
+void W100EnableDisplayUpdate(W100CardInfo *w100c)
+{
+    disp_db_buf_cntl_wr_u disp_db_buf_cntl;
+
+    disp_db_buf_cntl.f.db_buf_cntl = 30;
+    disp_db_buf_cntl.f.en_db_buf = 1;
+    disp_db_buf_cntl.f.update_db_buf = 1;
+    MMIO_OUT32(mmDISP_DB_BUF_CNTL, disp_db_buf_cntl.val);
+}
+
+void W100SetupGraphicEngine(W100CardInfo *w100c)
+{
+    eng_cntl_u eng_cntl;
+    sc_bottom_right_u bottomright;
+    rbbm_cntl_u rbbm_cntl;
+    dst_pitch_u dpitch;
+    dst_offset_u doffset;
+    src_pitch_u spitch;
+    src_offset_u soffset;
+    sc_top_left_u tl;
+    sc_bottom_right_u br;
+    src_sc_bottom_right_u srcbr;
+    dp_gui_master_cntl_u gmc;
+    dp_mix_u dp_mix;
+    dp_cntl_u dp_cntl;
+    dp_datatype_u dp_datatype;
+
+    DBG_IMAGEON(("W100SetupGraphicEngine(offset:%p, pitch:%d)\n",
+                 w100c->hw_window.offset, 
+                 w100c->hw_window.width));
+
+    eng_cntl.val = MMIO_IN32(mmENG_CNTL);
+    eng_cntl.f.erc_reg_wr_ws = 0;
+    MMIO_OUT32(mmENG_CNTL, eng_cntl.val);
+
+    rbbm_cntl.val = 0;
+    rbbm_cntl.f.abortclks_hi = 4;
+    rbbm_cntl.f.abortclks_cp = 4;
+    rbbm_cntl.f.abortclks_cfifo = 2;
+    MMIO_OUT32(mmRBBM_CNTL, rbbm_cntl.val);
+
+    bottomright.val = 0;
+    bottomright.f.sc_bottom = 0x1fff;
+    bottomright.f.sc_right = 0x1fff;
+    MMIO_OUT32(mmDEFAULT_SC_BOTTOM_RIGHT, bottomright.val);
+
+    dpitch.val = 0;
+    dpitch.f.dst_pitch = w100c->hw_window.width;
+    MMIO_OUT32(mmDST_PITCH, dpitch.val);
+
+    doffset.val = 0;
+    doffset.f.dst_offset = (CARD32) w100c->hw_window.offset;
+    MMIO_OUT32(mmDST_OFFSET, doffset.val);
+
+    spitch.val = 0;
+    spitch.f.src_pitch = w100c->hw_window.width;
+    MMIO_OUT32(mmSRC_PITCH, spitch.val);
+    soffset.val = 0;
+    soffset.f.src_offset = (CARD32) w100c->hw_window.offset;
+    MMIO_OUT32(mmSRC_OFFSET, soffset.val);
+
+    tl.f.sc_left = tl.f.sc_top = 0;
+    br.f.sc_right = br.f.sc_bottom = 0x1fff;
+    MMIO_OUT32(mmSC_TOP_LEFT, tl.val);
+    MMIO_OUT32(mmSC_BOTTOM_RIGHT, br.val);
+
+    srcbr.f.sc_right = srcbr.f.sc_bottom = 0x1fff;
+    MMIO_OUT32(mmSRC_SC_BOTTOM_RIGHT, br.val);
+
+    gmc.val = dp_datatype.val = dp_mix.val = dp_cntl.val = 0;
+
+    dp_cntl.f.dst_x_dir = 1;
+    dp_cntl.f.dst_y_dir = 1;
+    dp_cntl.f.src_x_dir = 1;
+    dp_cntl.f.src_y_dir = 1;
+    dp_cntl.f.dst_major_x = 1;
+    dp_cntl.f.src_major_x = 1;
+    MMIO_OUT32(mmDP_CNTL, dp_cntl.val);
+
+    gmc.f.gmc_src_pitch_offset_cntl = 1;
+    gmc.f.gmc_dst_pitch_offset_cntl = 1;
+    gmc.f.gmc_src_clipping = 1;
+    gmc.f.gmc_dst_clipping = 1;
+    gmc.f.gmc_brush_datatype = DP_BRUSH_SOLIDCOLOR;
+    gmc.f.gmc_dst_datatype = DP_DST_16BPP_1555;
+    gmc.f.gmc_src_datatype = DP_SRC_SOLID_COLOR_BLT;
+    gmc.f.gmc_byte_pix_order = DP_PIX_ORDER_LSB2MSB;
+    gmc.f.gmc_default_sel = 0;
+    gmc.f.gmc_rop3 = W100SolidRop[GXcopy];
+    gmc.f.gmc_dp_src_source = DP_SRC_MEM_RECTANGULAR;
+    gmc.f.gmc_clr_cmp_fcn_dis = 1;
+    gmc.f.gmc_wr_msk_dis = 1;
+    gmc.f.gmc_dp_op = DP_OP_ROP;
+    MMIO_OUT32(mmDP_GUI_MASTER_CNTL, gmc.val);
+
+    dp_datatype.f.dp_dst_datatype = gmc.f.gmc_dst_datatype;
+    dp_datatype.f.dp_brush_datatype = gmc.f.gmc_brush_datatype;
+    dp_datatype.f.dp_src2_type = 0;
+    dp_datatype.f.dp_src2_datatype = gmc.f.gmc_src_datatype;
+    dp_datatype.f.dp_src_datatype = gmc.f.gmc_src_datatype;
+    dp_datatype.f.dp_byte_pix_order = gmc.f.gmc_byte_pix_order;
+    MMIO_OUT32(mmDP_DATATYPE, dp_datatype.val);
+
+    dp_mix.f.dp_src_source = gmc.f.gmc_dp_src_source;
+    dp_mix.f.dp_src2_source = gmc.f.gmc_dp_src_source;
+    dp_mix.f.dp_rop3 = gmc.f.gmc_rop3;
+    dp_mix.f.dp_op = gmc.f.gmc_dp_op;
+    MMIO_OUT32(mmDP_MIX, dp_mix.val);
+}
+
+void W100ResetGraphicEngine(W100CardInfo *w100c)
+{
+    rbbm_soft_reset_u sreset;
+    sclk_cntl_u sclk_cntl;
+    CARD32 restore_sclk;
+
+    ErrorF("->W100ResetGraphicEngine\n");
+    sclk_cntl.val = restore_sclk = MMIO_IN32(mmSCLK_CNTL);
+
+    sclk_cntl.f.sclk_force_e2   = 1;
+    sclk_cntl.f.sclk_force_e3   = 1;
+    sclk_cntl.f.sclk_force_idct = 1;
+    MMIO_OUT32(mmSCLK_CNTL, sclk_cntl.val);
+    
+    sreset.val = 0;
+    sreset.f.soft_reset_e2 = 1;
+    MMIO_OUT32(mmRBBM_SOFT_RESET, sreset.val);
+    sreset.f.soft_reset_e2 = 0;
+    MMIO_OUT32(mmRBBM_SOFT_RESET, 0);
+
+    MMIO_OUT32(mmSCLK_CNTL, restore_sclk);
+    ErrorF("<-W100ResetGraphicEngine\n");
+}
+
+W100ModeSpec *W100GetModeSpec(W100CardInfo *w100c, W100Mode *mode)
+{
+    W100ModeSpec *modes;
+    for (modes = w100_modes; modes->width; modes++) {
+        if ((modes->bpp == mode->bpp) &&
+            (((modes->width == mode->width) &&
+              (modes->height == mode->height)) ||
+             ((modes->width == mode->height) &&
+              (modes->height == mode->width)))) {
+            return modes;
+        }
+    }
+    ErrorF("No matching mode spec for %dx%d@%d\n", 
+           mode->width, mode->height, mode->bpp);
+    return NULL;
+}
+
+W100ModeSpec *W100GetBestMode(W100CardInfo *w100c, int width, int height)
+{
+    unsigned int best_x = 0xffffffff;
+    unsigned int best_y = 0xffffffff;
+    W100ModeSpec *modes, *best_mode = NULL;
+    for (modes = w100_modes; modes->width; modes++) {
+        if (modes->supported) {
+            if (((modes->width >= width) && (modes->width < best_x)) &&
+                ((modes->height >= height) && (modes->height < best_y))) {
+                best_mode = modes;
+                best_x = modes->width;
+                best_y = modes->height;
+            } else if (((modes->width >= height) && (modes->width < best_y)) &&
+                       ((modes->height >= width) && (modes->height < best_x))) {
+                best_mode = modes;
+                best_x = modes->height;
+                best_y = modes->width;
+            }
+        }
+    }
+    if (!best_mode) {
+        ErrorF("No matching mode spec for %dx%d\n", width, height);
+    }
+    return best_mode;
+}
+
+Bool W100GetFbMode(W100CardInfo *w100c, W100Mode *mode)
+{
+    struct fb_var_screeninfo vinfo;
+    int i;
+
+    if (ioctl(w100c->fbdev.fd, FBIOGET_VSCREENINFO, &vinfo) != 0) {
+        ErrorF("Unable to get framebuffer mode\n");
+        return FALSE;
+    }
+
+    mode->width = vinfo.xres;
+    mode->height = vinfo.yres;
+    mode->bpp = vinfo.bits_per_pixel;
+}
+
+Bool W100CheckFbMode(W100CardInfo *w100c, W100ModeSpec *modes)
+{
+    struct fb_var_screeninfo vinfo;
+
+    vinfo.xres = vinfo.xres_virtual = modes->width;
+    vinfo.yres = vinfo.yres_virtual = modes->height;
+    vinfo.bits_per_pixel            = modes->bpp;
+    vinfo.activate = FB_ACTIVATE_TEST;
+    
+    if (ioctl(w100c->fbdev.fd, FBIOPUT_VSCREENINFO, &vinfo) != 0) {
+        ErrorF("(W) Mode %dx%d@%d not supported\n", 
+               vinfo.xres,
+               vinfo.yres,
+               vinfo.bits_per_pixel);
+        return FALSE;
+    }
+    DBG_IMAGEON(("(I) Mode %dx%d@%d supported\n", 
+                 vinfo.xres,
+                 vinfo.yres,
+                 vinfo.bits_per_pixel));
+    return TRUE;
+}
+
+Bool W100SetFbMode(W100CardInfo *w100c)
+{
+    struct fb_var_screeninfo vinfo;
+    int randr = KdSubRotation(w100c->hw_window.randr, w100StartupInfo.randr);
+
+    if (randr & (RR_Rotate_0 | RR_Rotate_180)) {
+        vinfo.xres = vinfo.xres_virtual = w100c->hw_window.mode->width;
+        vinfo.yres = vinfo.yres_virtual = w100c->hw_window.mode->height;
+    } else {
+        vinfo.xres = vinfo.xres_virtual = w100c->hw_window.mode->height;
+        vinfo.yres = vinfo.yres_virtual = w100c->hw_window.mode->width;
+    }
+    vinfo.bits_per_pixel            = w100c->hw_window.mode->bpp;
+    vinfo.activate = FB_ACTIVATE_NOW;
+    int flip = (w100c->hw_window.randr > RR_Rotate_90) ? 1 : 0;
+
+    DBG_IMAGEON(("Asking framebuffer for mode %dx%d@%d. Flipped:%d\n",
+                 vinfo.xres, vinfo.yres, vinfo.bits_per_pixel, flip));
+    if (ioctl(w100c->fbdev.fd, FBIOPUT_VSCREENINFO, &vinfo) != 0) {
+        ErrorF("Error setting mode %dx%d@%d\n", 
+               vinfo.xres,
+               vinfo.yres,
+               vinfo.bits_per_pixel);
+        return FALSE;
+    }
+    W100SysFsSet(w100c, W100_SYSFS_BASE "flip", flip ? "1" : "0");
+    return TRUE;
+}
+
+void W100SetupGraphicWindow(W100CardInfo *w100c)
+{
+    DBG_IMAGEON(("W100SetupGraphicWindow(width:%d,height:%d,randr:%d)\n",
+                 w100c->hw_window.width,
+                 w100c->hw_window.height,
+                 w100c->hw_window.randr));
+
+    if (!W100SetFbMode(w100c)) {
+        ErrorF("Error Setting Graphic Window\n");
+    }
+}
+
+void W100EnableGraphicWindow(W100CardInfo *w100c)
+{
+    graphic_ctrl_u gc;
+    
+    gc.val = MMIO_IN32(mmGRAPHIC_CTRL);
+    gc.f.en_graphic_crtc = 1;
+    gc.f.en_graphic_req = 1;
+    W100DisableDisplayUpdate(w100c);
+    MMIO_OUT32(mmGRAPHIC_CTRL, gc.val);
+    W100EnableDisplayUpdate(w100c);
+}
+
+void W100DisableGraphicWindow(W100CardInfo *w100c)
+{
+    graphic_ctrl_u gc;
+    
+    gc.val = MMIO_IN32(mmGRAPHIC_CTRL);
+    gc.f.en_graphic_crtc = 0;
+    gc.f.en_graphic_req = 0;
+    W100DisableDisplayUpdate(w100c);
+    MMIO_OUT32(mmGRAPHIC_CTRL, gc.val);
+    W100EnableDisplayUpdate(w100c);
+}
+
+inline Bool W100WaitCmdFifoEntries(W100CardInfo *w100c, int entries)
+{
+    rbbm_status_u rbbmStatus;
+    TIMEOUT_LOCALS;
+
+    if (entries > W100_CMDFIFO_SIZE)
+        return FALSE;
+
+    if (entries <= w100c->cmdfifo_entries) {
+        w100c->cmdfifo_entries -= entries;
+        return TRUE;
+    }
+
+    WHILE_NOT_TIMEOUT(.2) {
+        rbbmStatus.val = MMIO_IN32(mmRBBM_STATUS);
+        w100c->cmdfifo_entries = rbbmStatus.f.cmdfifo_avail;
+        if (w100c->cmdfifo_entries >= entries) {
+            break;
+        }
+    }
+    if (TIMEDOUT()) {
+        ErrorF("Not enough CMDFIFO entries: %d (%d needed)\n", 
+               w100c->cmdfifo_entries, entries);
+        return FALSE;
+    }
+    w100c->cmdfifo_entries -= entries;
+    return TRUE;
+}
+
+Bool W100WaitIdle(W100CardInfo *w100c)
+{
+    rbbm_status_u rbbm_status;
+    TIMEOUT_LOCALS;
+
+    DBG_IMAGEON(("W100WaitIdle\n"));
+    if (!W100WaitCmdFifoEntries(w100c, W100_CMDFIFO_SIZE)) {
+        return FALSE;
+    }
+
+    WHILE_NOT_TIMEOUT(.2) {
+        rbbm_status.val = MMIO_IN32(mmRBBM_STATUS);
+        if (rbbm_status.f.gui_active == 0) {
+            break;
+        }
+    }
+    if (TIMEDOUT()) {
+        ErrorF("Timeout waiting for idle. rbbm_status: 0x%08x\n"
+               "  .cmdfifo_avail   : %d\n"
+               "  .cf_pipe_busy    : %d\n"
+               "  .eng_ev_busy     : %d\n"
+               "  .cp_cmdstrm_busy : %d\n"
+               "  .e2_busy         : %d\n"
+               "  .rb2d_busy       : %d\n"
+               "  .rb3d_busy       : %d\n"
+               "  .se_busy         : %d\n"
+               "  .re_busy         : %d\n"
+               "  .tam_busy        : %d\n"
+               "  .tdm_busy        : %d\n"
+               "  .pb_busy         : %d\n"
+               "  .gui_active      : %d\n",
+               rbbm_status.val,
+               rbbm_status.f.cmdfifo_avail,
+               rbbm_status.f.cf_pipe_busy,
+               rbbm_status.f.eng_ev_busy,
+               rbbm_status.f.cp_cmdstrm_busy,
+               rbbm_status.f.e2_busy,
+               rbbm_status.f.rb2d_busy,
+               rbbm_status.f.rb3d_busy,
+               rbbm_status.f.se_busy,
+               rbbm_status.f.re_busy,
+               rbbm_status.f.tam_busy,
+               rbbm_status.f.tdm_busy,
+               rbbm_status.f.pb_busy,
+               rbbm_status.f.gui_active);
+        ErrorF("Last context:  src(datatype:%d,pitch:%d,offset:0x%08x)\n"
+               "               dst(datatype:%d,pitch:%d,offset:0x%08x)\n"
+               "               xform(dx:%d,dy:%d)\n"
+               "               mask(pm:0x%08x,enable:%d)\n",
+               w100c->ctx.src.datatype,
+               w100c->ctx.src.pitch,
+               w100c->ctx.src.offset,
+               w100c->ctx.dst.datatype,
+               w100c->ctx.dst.pitch,
+               w100c->ctx.dst.offset,
+               w100c->ctx.xform.dx,
+               w100c->ctx.xform.dy,
+               w100c->ctx.mask.pm,
+               w100c->ctx.mask.enable);
+
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+void W100ResetContext(W100CardInfo *w100c)
+{
+    w100c->ctx.dst.datatype = DP_DST_16BPP_1555;
+    w100c->ctx.dst.pitch = 0;
+    w100c->ctx.dst.offset = 0;
+    w100c->ctx.dst.videomem = 0;
+
+    w100c->ctx.src.datatype = DP_SRC_COLOR_SAME_AS_DST;
+    w100c->ctx.src.pitch = 0;
+    w100c->ctx.src.offset = 0;
+    w100c->ctx.src.videomem = 0;
+
+    w100c->ctx.xform.dx = 0;
+    w100c->ctx.xform.dy = 0;
+    w100c->ctx.xform.randr = 0;
+    w100c->ctx.xform.mirror = FALSE;
+    w100c->ctx.xform.dataPath = 0x0000003f;
+
+    w100c->ctx.mask.pm = 0;
+    w100c->ctx.mask.enable = FALSE;
+}
+
+CARD32 W100ComputeSolidGmc(W100CardInfo *w100c, CARD8 alu)
+{
+    dp_gui_master_cntl_u gmc;
+
+    gmc.val = 0;
+    gmc.f.gmc_dst_pitch_offset_cntl = 1;
+    gmc.f.gmc_dst_clipping = 0;
+    gmc.f.gmc_brush_datatype = DP_BRUSH_SOLIDCOLOR;
+    gmc.f.gmc_dst_datatype = w100c->ctx.dst.datatype;
+    gmc.f.gmc_dp_op = DP_OP_ROP;
+    gmc.f.gmc_byte_pix_order = DP_PIX_ORDER_LSB2MSB;
+    gmc.f.gmc_dp_src_source = DP_SRC_MEM_RECTANGULAR;
+    gmc.f.gmc_rop3 = W100SolidRop[alu];
+    gmc.f.gmc_clr_cmp_fcn_dis = 1;
+    if (w100c->ctx.mask.enable) {
+        gmc.f.gmc_wr_msk_dis = 0;
+    } else {
+        gmc.f.gmc_wr_msk_dis = 1;
+    }
+    return gmc.val;
+}
+
+CARD32 W100ComputeCopyGmc(W100CardInfo *w100c, CARD8 alu)
+{
+    dp_gui_master_cntl_u gmc;
+
+    gmc.val = 0;
+    gmc.f.gmc_src_pitch_offset_cntl = 1;
+    gmc.f.gmc_dst_pitch_offset_cntl = 1;
+    gmc.f.gmc_dst_clipping = 0;
+    gmc.f.gmc_src_clipping = 0;
+    gmc.f.gmc_src_datatype = w100c->ctx.src.datatype;
+    gmc.f.gmc_dp_src_source = DP_SRC_MEM_RECTANGULAR;
+    gmc.f.gmc_brush_datatype = DP_BRUSH_NONE;
+    gmc.f.gmc_dst_datatype = w100c->ctx.dst.datatype;
+    gmc.f.gmc_dp_op = DP_OP_ROP;
+    gmc.f.gmc_byte_pix_order = DP_PIX_ORDER_LSB2MSB;
+    gmc.f.gmc_rop3 = W100BltRop[alu];
+    gmc.f.gmc_clr_cmp_fcn_dis = 1;
+    if (w100c->ctx.mask.enable) {
+        gmc.f.gmc_wr_msk_dis = 0;
+    } else {
+        gmc.f.gmc_wr_msk_dis = 1;
+    }
+    return gmc.val;
+}
+
+CARD32 W100ComputeAritGmc(W100CardInfo *w100c, CARD8 alu)
+{
+    dp_gui_master_cntl_u gmc;
+
+    gmc.val = 0;
+    gmc.f.gmc_src_pitch_offset_cntl = 1;
+    gmc.f.gmc_dst_pitch_offset_cntl = 1;
+    gmc.f.gmc_dst_clipping = 0;
+    gmc.f.gmc_src_clipping = 0;
+    gmc.f.gmc_src_datatype = w100c->ctx.src.datatype;
+    gmc.f.gmc_dst_datatype = w100c->ctx.dst.datatype;
+    gmc.f.gmc_dp_src_source = DP_SRC_MEM_RECTANGULAR;
+    gmc.f.gmc_brush_datatype = DP_BRUSH_NONE;
+    gmc.f.gmc_dp_op = DP_OP_ARITHMETIC;
+    gmc.f.gmc_byte_pix_order = DP_PIX_ORDER_LSB2MSB;
+    gmc.f.gmc_rop3 = W100BltRop[alu];
+    gmc.f.gmc_clr_cmp_fcn_dis = 1;
+    if (w100c->ctx.mask.enable) {
+        gmc.f.gmc_wr_msk_dis = 0;
+    } else {
+        gmc.f.gmc_wr_msk_dis = 1;
+    }
+    return gmc.val;
+}
+
+void W100SetXForm(W100CardInfo *w100c, int dx, int dy)
+{
+    dp_cntl_u dp_cntl;
+
+    w100c->ctx.xform.dx = dx;
+    w100c->ctx.xform.dy = dy;
+
+    dp_cntl.val = 0;
+    dp_cntl.f.src_x_dir = 1;
+    dp_cntl.f.src_y_dir = 1;
+    dp_cntl.f.src_major_x = 1;
+    dp_cntl.f.dst_major_x = 1;
+
+    if (dx >= 0) {
+        dp_cntl.f.dst_x_dir = 1;
+    } else {
+        dp_cntl.f.dst_x_dir = 0;
+    }
+    if (dy >= 0) {
+        dp_cntl.f.dst_y_dir = 1;
+    } else {
+        dp_cntl.f.dst_y_dir = 0;
+    }
+    w100c->ctx.xform.dataPath = dp_cntl.val;
+}
+
+void W100SetRotation(W100CardInfo *w100c, 
+                     int randr, 
+                     Bool mirror)
+{
+    dp_cntl_u dp_cntl;
+    w100c->ctx.xform.randr = randr;
+    w100c->ctx.xform.mirror = mirror;
+    dp_cntl.val = 0;
+    dp_cntl.f.src_x_dir = 1;
+    dp_cntl.f.src_y_dir = 1;
+    dp_cntl.f.src_major_x = 1;
+
+
+    switch (randr & RR_Rotate_All) {
+    case RR_Rotate_0:
+        dp_cntl.f.dst_x_dir   = mirror ? 0 : 1;
+        dp_cntl.f.dst_y_dir   = 1;
+        dp_cntl.f.dst_major_x = 1;
+        break;
+    case RR_Rotate_90:
+        dp_cntl.f.dst_x_dir   = 0;
+        dp_cntl.f.dst_y_dir   = mirror ? 0 : 1; 
+        dp_cntl.f.dst_major_x = 0;
+        break;
+    case RR_Rotate_180:
+        dp_cntl.f.dst_x_dir   = mirror ? 1 : 0;
+        dp_cntl.f.dst_y_dir   = 0;
+        dp_cntl.f.dst_major_x = 1;
+        break;
+    case RR_Rotate_270:
+        dp_cntl.f.dst_x_dir   = 1;
+        dp_cntl.f.dst_y_dir   = mirror ? 1 : 0;
+        dp_cntl.f.dst_major_x = 0;
+        break;
+    }
+    w100c->ctx.xform.dataPath = dp_cntl.val;        
+}
+
+void W100SetPixelMask(W100CardInfo *w100c, Pixel mask)
+{
+    if (mask != 0xffffffff) {
+        w100c->ctx.mask.enable = TRUE;
+        w100c->ctx.mask.pm = mask;
+    } else {
+        w100c->ctx.mask.enable = FALSE;
+    }
+}
+
+Bool W100SetSource(KdScreenInfo *screen, 
+                   CARD32 srcPitch, 
+                   CARD32 srcOffset, 
+                   CARD8 bpp)
+{
+    W100CardInfo(screen);
+    int i;
+    w100c->ctx.src.pitch = srcPitch * 8 / bpp;
+    switch (bpp) {
+    case 1:
+        w100c->ctx.src.datatype = DP_SRC_1BPP_OPA;
+        break;
+    case 4:
+        w100c->ctx.src.datatype = DP_SRC_4BPP;
+        break;
+    case 12:
+        w100c->ctx.src.datatype = DP_SRC_12BPP_PACKED;
+        break;
+    case 8:
+    case 16:
+        w100c->ctx.src.datatype = DP_SRC_COLOR_SAME_AS_DST;
+        break;
+    default:
+        return FALSE;
+    }
+
+    for (i = 0; i < screen->num_videomem_areas; i++) {
+        KdVideoMemArea *vidmem = screen->videomem_areas[i];
+        if ((((CARD8*)srcOffset) >= vidmem->base) &&
+            (((CARD8*)srcOffset) <= (vidmem->base + vidmem->size))) {
+            w100c->ctx.src.offset = (CARD32) W100_HOST2CARD(srcOffset);
+            if (w100c->last_src_videomem != i) {
+                W100WaitIdle(w100c);
+            }
+            w100c->last_src_videomem = i;
+            DBG_IMAGEON(("Setting src(pitch:%d,offset:0x%08x,type:%d)\n",
+                         w100c->ctx.src.pitch,
+                         w100c->ctx.src.offset,
+                         w100c->ctx.src.datatype));
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+Bool W100SetDestination(KdScreenInfo *screen,
+                        CARD32 dstPitch, 
+                        CARD32 dstOffset, 
+                        CARD8 bpp)
+{
+    W100CardInfo(screen);
+    int i;
+    w100c->ctx.dst.pitch = dstPitch * 8 / bpp;
+    switch (bpp) {
+    case 8:
+        w100c->ctx.dst.datatype = DP_DST_8BPP;
+        break;
+    case 16:
+        w100c->ctx.dst.datatype = DP_DST_16BPP_1555;
+        break;
+    default:
+        return FALSE;
+    }
+
+    for (i = 0; i < screen->num_videomem_areas; i++) {
+        KdVideoMemArea *vidmem = screen->videomem_areas[i];
+        if ((((CARD8*)dstOffset) >= vidmem->base) &&
+            (((CARD8*)dstOffset) <= (vidmem->base + vidmem->size))) {
+            w100c->ctx.dst.offset = (CARD32) W100_HOST2CARD(dstOffset);
+            if (w100c->last_dst_videomem != i) {
+                W100WaitIdle(w100c);
+            }
+            w100c->last_dst_videomem = i;
+            DBG_IMAGEON(("Setting dst(pitch:%d,offset:0x%08x,type:%d)\n",
+                         w100c->ctx.dst.pitch,
+                         w100c->ctx.dst.offset,
+                         w100c->ctx.dst.datatype));
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+        
+Bool W100SetSourcePixmap(PixmapPtr pPix)
+{
+    KdScreenPriv(pPix->drawable.pScreen);
+
+    return W100SetSource(pScreenPriv->screen,
+                         pPix->devKind, 
+                         (CARD32) pPix->devPrivate.ptr,
+                         pPix->drawable.bitsPerPixel);
+}
+
+Bool W100SetDestinationPixmap(PixmapPtr pPix)
+{
+    KdScreenPriv(pPix->drawable.pScreen);
+
+    return W100SetDestination(pScreenPriv->screen,
+                              pPix->devKind, 
+                              (CARD32) pPix->devPrivate.ptr,
+                              pPix->drawable.bitsPerPixel);
+}
+
+void W100MapToDevice(W100CardInfo *w100c, BoxPtr src, BoxPtr dst)
+{
+    switch (w100c->hw_window.randr & RR_Rotate_All) {
+    case RR_Rotate_0:
+        dst->x1 = src->x1;
+        dst->y1 = src->y1;
+        dst->x2 = src->x2;
+        dst->y2 = src->y2;
+        break;
+    case RR_Rotate_90:
+        dst->x1 = w100c->hw_window.height - src->y2 - 1;
+        dst->y1 = src->x1;
+        dst->x2 = w100c->hw_window.height - src->y1 - 1;
+        dst->y2 = src->x2;
+        break;
+    case RR_Rotate_180:
+        dst->x1 = w100c->hw_window.width - src->x2 - 1;
+        dst->y1 = w100c->hw_window.height - src->y2 - 1;
+        dst->x2 = w100c->hw_window.width - src->x1 - 1;
+        dst->y2 = w100c->hw_window.height - src->y1 - 1;
+        break;
+    case RR_Rotate_270:
+        dst->x1 = src->y1;
+        dst->y1 = w100c->hw_window.width - src->x2 - 1;
+        dst->x2 = src->y2;
+        dst->y2 = w100c->hw_window.width - src->x1 - 1;
+        break;
+    }
+    DBG_IMAGEON(("MapToDevice (x1:%d,y1:%d,x2:%d,y2:%d)->(x1:%d,y1:%d,x2:%d,y2:%d)\n",
+                 src->x1, src->y1, src->x2, src->y2,
+                 dst->x1, dst->y1, dst->x2, dst->y2));
+}
+
+void W100MapFromDevice(W100CardInfo *w100c, BoxPtr src, BoxPtr dst)
+{
+    switch (w100c->hw_window.randr & RR_Rotate_All) {
+    case RR_Rotate_0:
+        dst->x1 = src->x1;
+        dst->y1 = src->y1;
+        dst->x2 = src->x2;
+        dst->y2 = src->y2;
+        break;
+    case RR_Rotate_90:
+        dst->x1 = src->y1;
+        dst->y1 = w100c->hw_window.height - src->x2 - 1;
+        dst->x2 = src->y2;
+        dst->y2 = w100c->hw_window.height - src->x1 - 1;
+        break;
+    case RR_Rotate_180:
+        dst->x1 = w100c->hw_window.width - src->x2 - 1;
+        dst->y1 = w100c->hw_window.height - src->y2 - 1;
+        dst->x2 = w100c->hw_window.width - src->x1 - 1;
+        dst->y2 = w100c->hw_window.height - src->y1 - 1;
+        break;
+    case RR_Rotate_270:
+        dst->x1 = w100c->hw_window.height - src->y2 - 1;
+        dst->y1 = src->x1;
+        dst->x2 = w100c->hw_window.width - src->y1 - 1;
+        dst->y2 = src->x2;
+        break;
+    }
+    DBG_IMAGEON(("MapFromDevice (x1:%d,y1:%d,x2:%d,y2:%d)->(x1:%d,y1:%d,x2:%d,y2:%d)\n",
+                 src->x1, src->y1, src->x2, src->y2,
+                 dst->x1, dst->y1, dst->x2, dst->y2));
+}
+
+void W100MoveTo(BoxPtr src, int x, int y)
+{
+    src->x1 += x;
+    src->y1 += y;
+    src->x2 += x;
+    src->y2 += y;
+}
+
+void W100ChangeOrigin(BoxPtr src, int x, int y)
+{
+    src->x1 -= x;
+    src->y1 -= y;
+    src->x2 -= x;
+    src->y2 -= y;
+}
+
+void W100ScaleBox(BoxPtr src, BoxPtr dst, int scale)
+{
+    if (scale >= 0) {
+        dst->x1 = src->x1 << scale;
+        dst->x2 = src->x2 << scale;
+        dst->y1 = src->y1 << scale;
+        dst->y2 = src->y2 << scale;
+    } else {
+        dst->x1 = src->x1 >> -scale;
+        dst->x2 = src->x2 >> -scale;
+        dst->y1 = src->y1 >> -scale;
+        dst->y2 = src->y2 >> -scale;
+    }
+}
+
+void W100TrajectoryOrigin(W100CardInfo *w100c, BoxPtr box, short *x, short *y)
+{
+    switch (w100c->ctx.xform.randr & RR_Rotate_All) {
+    case RR_Rotate_0:
+        if (w100c->ctx.xform.mirror) {
+            *x = box->x2;
+        } else {
+            *x = box->x1;
+        }
+        *y = box->y1;
+        break;
+    case RR_Rotate_90:
+        *x = box->x2;
+        if (w100c->ctx.xform.mirror) {
+            *y = box->y2;
+        } else {
+            *y = box->y1;
+        }
+        break;
+    case RR_Rotate_180:
+        if (w100c->ctx.xform.mirror) {
+            *x = box->x1;
+        } else {
+            *x = box->x2;
+        }
+        *y = box->y2;
+        break;
+    case RR_Rotate_270:
+        *x = box->x1;
+        if (w100c->ctx.xform.mirror) {
+            *y = box->y1;
+        } else {
+            *y = box->y2;
+        }
+    }
+}
+    
+CARD8 W100GetScaler(CARD16 dstsize, CARD16 srcsize)
+{
+    return W100_MAX(1, W100_MIN(31, ((16 * srcsize) + dstsize - 1) / dstsize));
+
+}
+
+CARD16 W100ApplyScaler(CARD16 srcsize, CARD8 scaler)
+{
+    return ((srcsize * 16) + (scaler - 1)) / scaler;
+}
+
+
+static void W100Blt(KdScreenInfo *screen,
+                    int randr, int bpp,
+                    CARD32 srcOffset,
+                    CARD16 srcPitch,
+                    BoxPtr srcBox,
+                    CARD32 dstOffset,
+                    CARD16 dstPitch,
+                    BoxPtr dstBox)
+{
+    ScreenPtr pScreen = screen->pScreen;
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    int fifoEntries = 9;
+    Bool hasXForm = FALSE;
+    eng_cntl_u eng_cntl;
+    src_x_y_u src_x_y;
+    dst_x_y_u dst_x_y;
+    src_width_u src_width;
+    src_height_u src_height;
+    dst_width_height_u dst_width_height;
+    CARD16 dstX;
+    CARD16 dstY;
+
+    if (randr & (RR_Rotate_90|RR_Rotate_270)) {
+        hasXForm = TRUE;
+        eng_cntl.val = w100c->regs.ENG_CNTL;
+        eng_cntl.f.dis_rop_src_uses_dst_w_h = 1;
+        eng_cntl.f.dis_src_uses_dst_dirmaj = 1;
+        fifoEntries += 4;
+    }
+
+    W100ResetContext(w100c);
+    W100SetRotation(w100c, randr, FALSE);
+    W100SetSource(screen, srcPitch, srcOffset, bpp);
+    W100SetDestination(screen, dstPitch, dstOffset, bpp);
+    W100TrajectoryOrigin(w100c, dstBox, &dstX, &dstY);
+
+    src_x_y.f.src_x = srcBox->x1;
+    src_x_y.f.src_y = srcBox->y1;
+    dst_x_y.f.dst_x = dstX;
+    dst_x_y.f.dst_y = dstY;
+    src_width.f.src_width = srcBox->x2 - srcBox->x1 + 1;
+    src_height.f.src_height = srcBox->y2 - srcBox->y1 + 1;
+    dst_width_height.f.dst_height = dstBox->y2 - dstBox->y1 + 1;
+    dst_width_height.f.dst_width_b0 = (dstBox->x2 - dstBox->x1 + 1) & 0xff;
+    dst_width_height.f.dst_width_b1 = ((dstBox->x2 - dstBox->x1 + 1) >> 8) & 0x3f;
+
+    DBG_IMAGEON(("W100Blt src(x:%d,y:%d,w:%d,h:%d) dst(x:%d,y:%d,w:%d,h:%d)\n",
+                 src_x_y.f.src_x,
+                 src_x_y.f.src_y,
+                 src_width.f.src_width,
+                 src_height.f.src_height,
+                 dst_x_y.f.dst_x,
+                 dst_x_y.f.dst_y,
+                 dst_width_height.f.dst_width_b0 |
+                 dst_width_height.f.dst_width_b1 << 8,
+                 dst_width_height.f.dst_height));
+    
+    if (W100WaitCmdFifoEntries(w100c, fifoEntries)) {
+        MMIO_OUT32(mmDST_PITCH,   w100c->ctx.dst.pitch);
+        MMIO_OUT32(mmDST_OFFSET,  w100c->ctx.dst.offset);
+        MMIO_OUT32(mmSRC_PITCH,   w100c->ctx.src.pitch);
+        MMIO_OUT32(mmSRC_OFFSET,  w100c->ctx.src.offset);    
+        MMIO_OUT32(mmDP_GUI_MASTER_CNTL, W100ComputeCopyGmc(w100c, GXcopy));
+        MMIO_OUT32(mmDP_CNTL, w100c->ctx.xform.dataPath);
+        if (hasXForm) {
+            MMIO_OUT32(mmENG_CNTL, eng_cntl.val);
+            MMIO_OUT32(mmSRC_WIDTH,        src_width.val);
+            MMIO_OUT32(mmSRC_HEIGHT,       src_height.val);
+        }
+        MMIO_OUT32(mmSRC_X_Y,          src_x_y.val);
+        MMIO_OUT32(mmDST_X_Y,          dst_x_y.val);
+        MMIO_OUT32(mmDST_WIDTH_HEIGHT, dst_width_height.val);
+        /* Restore state */
+        if (hasXForm) {
+            MMIO_OUT32(mmENG_CNTL, w100c->regs.ENG_CNTL);
+        }
+    } else {
+        ErrorF("Unable to perform Blitting\n");
+    }
+}
+
+static void W100StretchBlt(KdScreenInfo *screen, 
+                           int randr,
+                           int bpp,
+                           CARD32 srcOffset,
+                           CARD16 srcPitch,
+                           BoxPtr srcBox,
+                           CARD32 dstOffset,
+                           CARD16 dstPitch,
+                           BoxPtr dstBox,
+                           CARD8 xscaler,
+                           CARD8 yscaler)
+{
+    ScreenPtr pScreen = screen->pScreen;
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    Bool hasXForm = FALSE;
+    dp_datatype_u dp_datatype;
+    dp_mix_u dp_mix;
+    eng_cntl_u eng_cntl;
+    e2_arithmetic_cntl_u e2;
+    src_inc_u src_inc;
+    src_x_y_u src_x_y;
+    dst_x_y_u dst_x_y;
+    src_width_u src_width;
+    src_height_u src_height;
+    dst_width_height_u dst_width_height;
+    int firstStage = 10;
+    int secondStage = 10;
+    CARD16 dx, dy, sw, sh, dw, dh;
+    BoxRec dst;
+
+    DBG_IMAGEON(("W100StretchBlt(randr:%d,bpp:%d,"
+                 "src(x1:%d,y1:%d,x2:%d,y2:%d,pitch:%d,offset:%d),"
+                 "dst(x1:%d,y1:%d,x2:%d,y2:%d,pitch:%d,offset:%d),"
+                 "xscaler:%d,yscaler:%d)\n",
+                 randr, bpp,
+                 srcBox->x1, srcBox->y1, srcBox->x2, srcBox->y2, 
+                 srcPitch, srcOffset,
+                 dstBox->x1, dstBox->y1, dstBox->x2, dstBox->y2, 
+                 dstPitch, dstOffset,
+                 xscaler, yscaler));
+
+    sw = W100ApplyScaler(srcBox->x2 - srcBox->x1 + 1, xscaler);
+    sh = W100ApplyScaler(srcBox->y2 - srcBox->y1 + 1, yscaler);
+
+    if (randr & (RR_Rotate_90|RR_Rotate_270)) {
+        hasXForm = TRUE;
+        eng_cntl.val = w100c->regs.ENG_CNTL;
+        eng_cntl.f.dis_rop_src_uses_dst_w_h = 1;
+        eng_cntl.f.dis_src_uses_dst_dirmaj = 1;
+        ++firstStage;
+        ++secondStage;
+        dh = sw;
+        dw = sh;
+    } else {
+        dh = sh;
+        dw = sw;
+    }
+
+    dst.x1 = dstBox->x1;
+    dst.y1 = dstBox->y1;
+    dst.x2 = dst.x1 + dw - 1;
+    dst.y2 = dst.y1 + dh - 1;
+
+    W100ResetContext(w100c);
+    W100SetRotation(w100c, randr, FALSE);
+    W100SetSource(screen, srcPitch, srcOffset, bpp);
+    W100SetDestination(screen, dstPitch, dstOffset, bpp);
+    W100TrajectoryOrigin(w100c, &dst, &dx, &dy);
+
+    src_inc.val = 0;
+    src_inc.f.src_xinc = xscaler;
+    src_inc.f.src_yinc = yscaler;
+
+    dp_datatype.val = 0;
+    dp_datatype.f.dp_brush_datatype = DP_BRUSH_SOLIDCOLOR;
+    dp_datatype.f.dp_dst_datatype   = w100c->ctx.dst.datatype;
+    dp_datatype.f.dp_src_datatype   = w100c->ctx.src.datatype;
+    dp_datatype.f.dp_byte_pix_order = DP_PIX_ORDER_LSB2MSB;
+
+    dp_mix.val = 0;
+    dp_mix.f.dp_op          = DP_OP_ARITHMETIC;
+    dp_mix.f.dp_src_source  = DP_SRC_MEM_RECTANGULAR;
+    dp_mix.f.dp_rop3        = W100BltRop[GXcopy];
+    
+    e2.val = 0;
+    e2.f.opcode   = E2_OPC_STRETCH_SRC2;
+    e2.f.srcblend = E2_SRCBLEND_ZERO;
+    e2.f.dstblend = E2_DSTBLEND_ZERO;
+
+    src_x_y.f.src_x = srcBox->x1;
+    src_x_y.f.src_y = srcBox->y1;
+    dst_x_y.f.dst_x = dx;
+    dst_x_y.f.dst_y = dy;
+    src_width.f.src_width = sw + 1;
+    src_height.f.src_height = sh;
+    dst_width_height.f.dst_height = dh;
+    dst_width_height.f.dst_width_b0 = dw & 0xff;
+    dst_width_height.f.dst_width_b1 = (dw >> 8) & 0x3f;
+
+
+    if (W100WaitCmdFifoEntries(w100c, firstStage)) {
+        /* Set Source */
+        MMIO_OUT32(mmSRC_PITCH,   w100c->ctx.src.pitch);
+        MMIO_OUT32(mmSRC_OFFSET,  w100c->ctx.src.offset);
+
+        /* Set Destination */
+        MMIO_OUT32(mmDST_PITCH,   w100c->ctx.dst.pitch);
+        MMIO_OUT32(mmDST_OFFSET,  w100c->ctx.dst.offset);
+
+        /* Prepare for Stretch Operation */
+        MMIO_OUT32(mmDP_GUI_MASTER_CNTL, W100ComputeAritGmc(w100c, GXcopy));
+        MMIO_OUT32(mmDP_DATATYPE,        dp_datatype.val);
+        MMIO_OUT32(mmDP_MIX,             dp_mix.val);
+        MMIO_OUT32(mmE2_ARITHMETIC_CNTL, e2.val);
+
+        /* Set Data Trajectory */
+        if (hasXForm) {
+            MMIO_OUT32(mmENG_CNTL, eng_cntl.val);
+        }
+        MMIO_OUT32(mmDP_CNTL, w100c->ctx.xform.dataPath);
+    } else {
+        ErrorF("Error preparing for Stretch operation\n");
+        return;
+    }
+
+    if (W100WaitCmdFifoEntries(w100c, secondStage)) {
+        /* Perform blitting */
+        MMIO_OUT32(mmSRC_X_Y,          src_x_y.val);
+        MMIO_OUT32(mmDST_X_Y,          dst_x_y.val);
+        MMIO_OUT32(mmSRC_WIDTH,        src_width.val);
+        MMIO_OUT32(mmSRC_HEIGHT,       src_height.val);
+        MMIO_OUT32(mmSRC_INC,          src_inc.val);
+        MMIO_OUT32(mmDST_WIDTH_HEIGHT, dst_width_height.val);
+        /* Restore state */
+        if (hasXForm) {
+            MMIO_OUT32(mmENG_CNTL, w100c->regs.ENG_CNTL);
+        }
+    } else {
+        ErrorF("Error performing Stretch operation\n");
+    }
+}
+
+static void W100ScaledBlt(KdScreenInfo *screen, 
+                          int randr,
+                          int bpp,
+                          CARD32 srcOffset,
+                          CARD16 srcPitch,
+                          BoxPtr srcBox,
+                          CARD32 dstOffset,
+                          CARD16 dstPitch,
+                          BoxPtr dstBox,
+                          CARD8 xscaler,
+                          CARD8 yscaler)
+{
+    ScreenPtr pScreen = screen->pScreen;
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    Bool hasXForm = FALSE;
+    dp_datatype_u dp_datatype;
+    dp_mix_u dp_mix;
+    eng_cntl_u eng_cntl;
+    e2_arithmetic_cntl_u e2;
+    src_inc_u src_inc;
+    src_x_y_u src_x_y;
+    src2_x_y_u src2_x_y;
+    dst_x_y_u dst_x_y;
+    src_width_u src_width;
+    src_height_u src_height;
+    dst_width_height_u dst_width_height;
+    int firstStage = 11;
+    int secondStage = 11;
+    CARD16 dx, dy, sw, sh, dw, dh;
+    BoxRec dst;
+
+    DBG_IMAGEON(("W100ScaledBlt(randr:%d,bpp:%d,"
+                 "src(x1:%d,y1:%d,x2:%d,y2:%d,pitch:%d,offset:%d),"
+                 "dst(x1:%d,y1:%d,x2:%d,y2:%d,pitch:%d,offset:%d),"
+                 "xscaler:%d,yscaler:%d)\n",
+                 randr, bpp,
+                 srcBox->x1, srcBox->y1, srcBox->x2, srcBox->y2, 
+                 srcPitch, srcOffset,
+                 dstBox->x1, dstBox->y1, dstBox->x2, dstBox->y2, 
+                 dstPitch, dstOffset,
+                 xscaler, yscaler));
+
+    sw = W100ApplyScaler(srcBox->x2 - srcBox->x1 + 1, xscaler);
+    sh = W100ApplyScaler(srcBox->y2 - srcBox->y1 + 1, yscaler);
+    
+    if (randr & (RR_Rotate_90|RR_Rotate_270)) {
+        hasXForm = TRUE;
+        eng_cntl.val = w100c->regs.ENG_CNTL;
+        eng_cntl.f.dis_rop_src_uses_dst_w_h = 1;
+        eng_cntl.f.dis_src_uses_dst_dirmaj = 1;
+        ++firstStage;
+        ++secondStage;
+        dh = sw;
+        dw = sh;
+    } else {
+        dh = sh;
+        dw = sw;
+    }
+
+    dst.x1 = dstBox->x1;
+    dst.y1 = dstBox->y1;
+    dst.x2 = dst.x1 + dw - 1;
+    dst.y2 = dst.y1 + dh - 1;
+
+    W100ResetContext(w100c);
+    W100SetRotation(w100c, randr, FALSE);
+    W100SetSource(screen, srcPitch, srcOffset, bpp);
+    W100SetDestination(screen, dstPitch, dstOffset, bpp);
+    W100TrajectoryOrigin(w100c, &dst, &dx, &dy);
+
+    DBG_IMAGEON(("Corrected dst(x1:%d,y1:%d,x2:%d,y2:%d). Origin(%d,%d)\n",
+                 dst.x1, dst.y1, dst.x2, dst.y2,
+                 dx, dy));
+
+    src_inc.val = 0;
+    src_inc.f.src_xinc = xscaler;
+    src_inc.f.src_yinc = yscaler;
+
+    dp_datatype.val = 0;
+    dp_datatype.f.dp_brush_datatype = DP_BRUSH_SOLIDCOLOR;
+    dp_datatype.f.dp_src2_type      = 1;
+    dp_datatype.f.dp_dst_datatype   = w100c->ctx.dst.datatype;
+    dp_datatype.f.dp_src2_datatype  = w100c->ctx.src.datatype;
+    dp_datatype.f.dp_src_datatype   = w100c->ctx.src.datatype;
+    dp_datatype.f.dp_byte_pix_order = DP_PIX_ORDER_LSB2MSB;
+
+    dp_mix.val = 0;
+    dp_mix.f.dp_op          = DP_OP_ARITHMETIC;
+    dp_mix.f.dp_src_source  = DP_SRC_MEM_RECTANGULAR;
+    dp_mix.f.dp_src2_source = DP_SRC_MEM_RECTANGULAR;
+    dp_mix.f.dp_rop3        = W100BltRop[GXcopy];
+    
+    e2.val = 0;
+    e2.f.opcode   = E2_OPC_SCALE_SRC2;
+    e2.f.srcblend = E2_SRCBLEND_ZERO;
+    e2.f.dstblend = E2_DSTBLEND_ZERO;
+
+
+    src_x_y.f.src_x = srcBox->x1;
+    src_x_y.f.src_y = srcBox->y1;
+    src2_x_y.f.src_x = srcBox->x1;
+    src2_x_y.f.src_y = srcBox->y1 + 4;
+    dst_x_y.f.dst_x = dx;
+    dst_x_y.f.dst_y = dy;
+    src_width.f.src_width = sw + 1;
+    src_height.f.src_height = sh;
+    dst_width_height.f.dst_height = dh;
+    dst_width_height.f.dst_width_b0 = dw & 0xff;
+    dst_width_height.f.dst_width_b1 = (dw >> 8) & 0x3f;
+
+    if (W100WaitCmdFifoEntries(w100c, firstStage)) {
+        /* Set Source */
+        MMIO_OUT32(mmSRC_PITCH,   w100c->ctx.src.pitch);
+        MMIO_OUT32(mmSRC_OFFSET,  w100c->ctx.src.offset);    
+
+        /* Set Destination */
+        MMIO_OUT32(mmDST_PITCH,   w100c->ctx.dst.pitch);
+        MMIO_OUT32(mmDST_OFFSET,  w100c->ctx.dst.offset);
+        /* Set second source */
+        MMIO_OUT32(mmSRC2_PITCH,  w100c->ctx.src.pitch);
+        MMIO_OUT32(mmSRC2_OFFSET, w100c->ctx.src.offset);
+
+        /* Prepare for Stretch Operation */
+        MMIO_OUT32(mmDP_GUI_MASTER_CNTL, W100ComputeAritGmc(w100c, GXcopy));
+        MMIO_OUT32(mmDP_DATATYPE,        dp_datatype.val);
+        MMIO_OUT32(mmDP_MIX,             dp_mix.val);
+        MMIO_OUT32(mmE2_ARITHMETIC_CNTL, e2.val);
+        /* Set Data Trajectory */
+        if (hasXForm) {
+            MMIO_OUT32(mmENG_CNTL, eng_cntl.val);
+        }
+        MMIO_OUT32(mmDP_CNTL, w100c->ctx.xform.dataPath);
+    } else {
+        ErrorF("Unable to prepare for Scaled Blitting\n");
+        return;
+    }
+    if (W100WaitCmdFifoEntries(w100c, secondStage)) {
+        /* Perform blitting */
+        MMIO_OUT32(mmSRC_X_Y,          src_x_y.val);
+        MMIO_OUT32(mmSRC2_X_Y,         src2_x_y.val);
+        MMIO_OUT32(mmSRC2_WIDTH,       src_width.val);
+        MMIO_OUT32(mmSRC2_HEIGHT,      src_height.val);
+        MMIO_OUT32(mmSRC_INC,          src_inc.val);
+        MMIO_OUT32(mmSRC2_INC,         src_inc.val);
+        MMIO_OUT32(mmDST_X_Y,          dst_x_y.val);
+        MMIO_OUT32(mmSRC_WIDTH,        src_width.val);
+        MMIO_OUT32(mmSRC_HEIGHT,       src_height.val);
+        MMIO_OUT32(mmDST_WIDTH_HEIGHT, dst_width_height.val);
+        /* Restore state */
+        if (hasXForm) {
+            MMIO_OUT32(mmENG_CNTL, w100c->regs.ENG_CNTL);
+        }
+        /* Without this, solid blitting is no longer working correctly */
+        dp_datatype.f.dp_src2_type = 0;
+        MMIO_OUT32(mmDP_DATATYPE, dp_datatype.val);
+    } else {
+        ErrorF("Unable to perform Scaled Blitting\n");
+    }
+}
+
+void W100PlanarBlt(KdScreenInfo *screen,
+                   int planes, int planeOffsets[],
+                   int bpp, int randr,
+                   KdOffscreenArea *src,
+                   int srcW,
+                   int srcH,
+                   BoxPtr srcBox,
+                   KdOffscreenArea *dst,
+                   int dstW,
+                   int dstH,
+                   BoxPtr dstBox)
+{
+    ScreenPtr pScreen = screen->pScreen;
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+
+    CARD16 dstBoxW, dstBoxH, srcBoxW, srcBoxH;
+    CARD8 *srcOffset, *dstBase, *dstOffset;
+    int xerror, yerror;
+    unsigned int subsampling[] = {0, 1, 1};
+    int plane;
+    srcBoxW = srcBox->x2 - srcBox->x1 + 1;
+    srcBoxH = srcBox->y2 - srcBox->y1 + 1;
+    if (randr & (RR_Rotate_90 | RR_Rotate_270)) {
+        dstBoxW = dstBox->y2 - dstBox->y1 + 1;
+        dstBoxH = dstBox->x2 - dstBox->x1 + 1;
+    } else {
+        dstBoxW = dstBox->x2 - dstBox->x1 + 1;
+        dstBoxH = dstBox->y2 - dstBox->y1 + 1;
+    }
+
+    Bool stretch = ((srcBoxW != dstBoxW) || (srcBoxH != dstBoxH));
+    CARD8 xscaler, yscaler;
+    BoxRec dstb = *dstBox;
+
+    DBG_IMAGEON(("W100PlanarBlt(planes:%d,bpp:%d,randr:%d,"
+                 "src(x1:%d,y1:%d,x2:%d,y2:%d,w:%d,h:%d),"
+                 "dst(x1:%d,y1:%d,x2:%d,y2:%d,w:%d,h:%d)\n",
+                 planes, bpp, randr,
+                 srcBox->x1, srcBox->y1, srcBox->x2, srcBox->y2, srcW, srcH,
+                 dstBox->x1, dstBox->y1, dstBox->x2, dstBox->y2, dstW, dstH));
+
+    xerror = yerror = 0;
+    if (stretch) {
+        xscaler = W100GetScaler(dstBoxW, srcBoxW);
+        yscaler = W100GetScaler(dstBoxH, srcBoxH);
+        if (xscaler != 16 || yscaler != 16) {
+            xerror = (dstBoxW - W100ApplyScaler(srcBoxW, xscaler)) / 2;
+            yerror = (dstBoxH - W100ApplyScaler(srcBoxH, yscaler)) / 2;
+            DBG_IMAGEON(("Stretching with xscaler:%d,yscaler:%d,"
+                         "xerror:%d,yerror:%d\n", 
+                         xscaler, yscaler, xerror, yerror));
+        } else {
+            xerror = yerror = 0;
+            stretch = FALSE;
+        }
+    }
+
+    W100MoveTo(&dstb, xerror, yerror);
+
+    srcOffset = src->vidmem->base + src->offset;
+    dstBase = dst->vidmem->base + dst->offset;
+    for (plane = 0; plane < planes; plane++) {
+        BoxRec srcCBox;
+        BoxRec dstCBox;
+        dstOffset = dstBase + planeOffsets[plane];
+        W100ScaleBox(srcBox, &srcCBox, -subsampling[plane]);
+        W100ScaleBox(&dstb, &dstCBox, -subsampling[plane]);
+        if (stretch) {
+            W100ScaledBlt(screen, randr, bpp,
+                          (CARD32) srcOffset,
+                          srcW           >> subsampling[plane],
+                          &srcCBox,
+                          (CARD32) dstOffset,
+                          dstW           >> subsampling[plane],
+                          &dstCBox,
+                          xscaler, yscaler);
+        } else {
+            W100Blt(screen, randr, bpp,
+                    (CARD32) srcOffset,
+                    srcW     >> subsampling[plane],
+                    &srcCBox,
+                    (CARD32) dstOffset,
+                    dstW     >> subsampling[plane],
+                    &dstCBox);
+        }
+        srcOffset += (srcW * srcH) >> (subsampling[plane] * 2);
+    }
+}
+
+void W100SetBrightness(W100CardInfo *w100c, CARD8 value)
+{
+    brightness_cntl_u brightness;
+    brightness.val = 0;
+    brightness.f.brightness = value;
+    MMIO_OUT32(mmBRIGHTNESS_CNTL, brightness.val);
+}
+
+CARD8 W100GetBrightness(W100CardInfo *w100c)
+{
+    brightness_cntl_u brightness;
+    brightness.val = MMIO_IN32(mmBRIGHTNESS_CNTL);
+    return brightness.f.brightness;
+}
+
+int W100GetRotation(W100CardInfo *w100c)
+{
+    graphic_ctrl_u gc;
+    int randr;
+
+    gc.val = MMIO_IN32(mmGRAPHIC_CTRL);
+
+    switch (gc.f.portrait_mode) {
+    case 0:
+        randr = RR_Rotate_0;
+        break;
+    case 1:
+        randr = RR_Rotate_90;
+        break;
+    case 2:
+        randr = RR_Rotate_270;
+        break;
+    case 3:
+        randr = RR_Rotate_180;
+        break;
+    }
+    return randr;
+}
+
+Bool W100SysFsSet(W100CardInfo *w100c, const char *path, const char *value)
+{
+    FILE *fd;
+    if ((fd = fopen(path, "w")) == NULL) {
+        ErrorF("(E) Error in W100SysFsSet: Unable to open '%s'\n", path);
+        return FALSE;
+    }
+    fprintf(fd, "%s", value);
+    fclose(fd);
+    return TRUE;
+}
+
+Bool W100SysFsGet(W100CardInfo *w100c, const char *path, char *value)
+{
+    FILE *fd;
+    if ((fd = fopen(path, "r")) == NULL) {
+        ErrorF("(E) Error in W100SysFsGet: Unable to open '%s'\n", path);
+        return FALSE;
+    }
+    fscanf(fd, "%s", value);
+    fclose(fd);
+    return TRUE;
+}
+
+void W100TransformTsLibCoordinates(long *x, long *y, void *closure)
+{
+    W100CardInfo *w100c = closure;
+
+    if (w100c->hw_window.mode->width == 320) {
+        *x >>= 1;
+        *y >>= 1;
+    }
+}
+  
+void W100VSync(W100CardInfo *w100c)
+{
+    int timeout = 30000;  /* VSync timeout = 30[ms] > 16.8[ms] */
+    active_v_disp_u active_v_disp;
+    disp_int_cntl_u disp_int_cntl;
+    gen_int_cntl_u gen_int_cntl;
+    gen_int_status_wr_u gen_int_status;
+
+    active_v_disp.val = MMIO_IN32(mmACTIVE_V_DISP);
+
+    /*set vline pos */
+    disp_int_cntl.val = 0;
+    disp_int_cntl.f.vline_int_pos = active_v_disp.f.active_v_end;
+    MMIO_OUT32(mmDISP_INT_CNTL, disp_int_cntl.val);
+
+    /* disable vline irq */
+    gen_int_cntl.val = MMIO_IN32(mmGEN_INT_CNTL);
+    gen_int_cntl.f.crtc_vline_mask = 0;
+    MMIO_OUT32(mmGEN_INT_CNTL, gen_int_cntl.val);
+
+    /* clear vline irq status */
+    gen_int_status.val = 0;
+    gen_int_status.f.crtc_vline_stat_ak = 1;
+    MMIO_OUT32(mmGEN_INT_STATUS, gen_int_status.val);
+
+    /* enable vline irq */
+    gen_int_cntl.f.crtc_vline_mask = 1;
+    MMIO_OUT32(gen_int_cntl.val, mmGEN_INT_CNTL);
+
+    /* clear vline irq status */
+    MMIO_OUT32(mmGEN_INT_STATUS, gen_int_status.val);
+
+    while (timeout > 0) {
+        if (MMIO_IN32(mmGEN_INT_STATUS) & 0x00000002) {
+            break;
+        }
+        usleep(1);
+        timeout--;
+    }
+
+    /* disable vline irq */
+    gen_int_cntl.f.crtc_vline_mask = 0;
+    MMIO_OUT32(mmGEN_INT_CNTL, gen_int_cntl.val);
+
+    /* clear vline irq status */
+    MMIO_OUT32(mmGEN_INT_STATUS, gen_int_status.val);
+}
+      
+        
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_video.c
@@ -0,0 +1,1172 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+#include "imageon.h"
+#include "imageon_regs.h"
+#include "imageon_support.h"
+#include "imageon_const.h"
+#include "kaa.h"
+
+#include <X11/extensions/Xv.h>
+#include "fourcc.h"
+
+static Atom xvBrightness;
+static Atom xvMaxOverlaySize;
+static Atom xvColorKey;
+
+#define IMAGE_MAX_WIDTH  720
+#define IMAGE_MAX_HEIGHT 576
+
+#define W_ALIGN 0
+#define H_ALIGN 0
+
+#define OVL_W_ALIGN 16
+#define OVL_H_ALIGN 16
+
+#define OVL_MAX_SIZE 196608
+
+static KdVideoEncodingRec DummyEncoding[1] = {
+    {0, "XV_IMAGE", IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT, {1, 1}}
+};
+
+#define NUM_IMAGES    (4)
+static KdImageRec Images[NUM_IMAGES] = {
+    XVIMAGE_YUY2,
+    XVIMAGE_YV12,
+    XVIMAGE_I420,
+    XVIMAGE_UYVY
+};
+
+#define NUM_FORMATS    (3)
+static KdVideoFormatRec Formats[NUM_FORMATS] = {
+    {15, TrueColor},
+    {16, TrueColor},
+    {24, TrueColor}
+};
+
+#define NUM_ATTRIBUTES (3)
+static KdAttributeRec Attributes[NUM_ATTRIBUTES] = {
+    {XvSettable | XvGettable, 0,    (1 << 16) - 1, "XV_COLORKEY"},
+    {XvSettable | XvGettable, 0,    127,           "XV_BRIGHTNESS"},
+    {XvSettable | XvGettable, 0,    392960,        "XV_MAXOVERLAYSIZE"}
+};
+    
+#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
+
+#define NUM_OVL_RESIZERS (10)
+static struct {
+    CARD8 xfactor;
+    CARD8 yfactor;
+} ovlResizers[NUM_OVL_RESIZERS] = {
+    { 0, 0 }, 
+    { 0, 1 }, { 1, 0 }, { 1, 1 }, 
+    { 1, 2 }, { 2, 1 }, { 2, 2 }, 
+    { 2, 3 }, { 3, 2 }, { 3, 3 }
+};
+
+static int W100SurfaceSize(W100PortPrivPtr port, short w, short h)
+{
+    int size = 0;
+    DBG_IMAGEON(("W100SurfaceSize for id=%08x, w=%d, h=%d\n", 
+                 port->src.id, w, h));
+
+    switch (port->src.id) {
+    case FOURCC_YV12:
+    case FOURCC_I420:
+        size = (3 * w * h) / 2;
+        break;
+    case FOURCC_UYVY:
+    case FOURCC_YUY2:
+        size = w * h * 2;
+        break;
+    }
+    return size;
+}
+
+static void W100ClearSurface(KdScreenInfo *screen, 
+                             KdOffscreenArea *area,
+                             CARD16 x,
+                             CARD16 y,
+                             CARD16 pitch,
+                             CARD16 width,
+                             CARD16 height,
+                             int id)
+{
+    W100CardInfo(screen);
+    int nplanes;
+    unsigned int subsampling[] = {0, 1, 1};
+    unsigned int zero[] = {0, 0x80, 0x80};
+    int bpp;
+    int plane;
+    CARD8 *dstOffset = area->vidmem->base + area->offset;
+
+    switch (id) {
+    case FOURCC_UYVY:
+    case FOURCC_YUY2:
+        nplanes = 1;
+        bpp = 16;
+        break;
+    case FOURCC_YV12:
+    case FOURCC_I420:
+        nplanes = 3;
+        bpp = 8;
+    }
+
+    DBG_IMAGEON(("Clearing surface with planes:%d, bpp:%d, pitch:%d, height:%d\n",
+                 nplanes, bpp, pitch, height));
+
+    W100ResetContext(w100c);
+    for (plane = 0; plane < nplanes; plane++) {
+        W100SetDestination(screen,
+                           pitch >> subsampling[plane], 
+                           (CARD32) dstOffset, 
+                           bpp);
+        if (W100WaitCmdFifoEntries(w100c, 6)) {
+            MMIO_OUT32(mmDST_PITCH, w100c->ctx.dst.pitch);
+            MMIO_OUT32(mmDST_OFFSET, w100c->ctx.dst.offset);
+            MMIO_OUT32(mmDP_GUI_MASTER_CNTL, 
+                       W100ComputeSolidGmc(w100c, GXcopy));
+            MMIO_OUT32(mmDP_BRUSH_FRGD_CLR, zero[plane]);
+            MMIO_OUT32(mmDST_Y_X, 0);
+            MMIO_OUT32(mmDST_HEIGHT_WIDTH, (height << 16) | width);
+        } else {
+            ErrorF("Error clearing surface\n");
+            break;
+        }
+        dstOffset += (pitch * height) >> (subsampling[plane] * 2);
+    }
+}
+
+static void W100OverlaySetup(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+    CARD16 w, h, pitch;
+    video_ctrl_u     video_ctrl;
+    video_y_offset_u video_y_offset;
+    video_y_pitch_u  video_y_pitch;
+    video_u_offset_u video_u_offset;
+    video_u_pitch_u  video_u_pitch;
+    video_v_offset_u video_v_offset;
+    video_v_pitch_u  video_v_pitch;
+    graphic_key_u    graphic_key;
+    video_h_pos_u    video_hpos;
+    video_v_pos_u    video_vpos;
+    graphic_h_disp_u graphic_h_disp;
+    graphic_v_disp_u graphic_v_disp;
+
+    w = pitch = port->ovl.frame.x2 - port->ovl.frame.x1 + 1;
+    h = port->ovl.frame.y2 - port->ovl.frame.y1 + 1;
+
+    ErrorF("W100OverlaySetup(ovlX:%d,ovlY:%d,ovlWidth:%d,ovlHeight:%d,"
+           "videoHorExp:%d,videoVerExp:%d,YPlane:0x%08x,UPlane:0x%08x,"
+           "VPlane:0x%08x)\n",
+           port->ovl.frame.x1, port->ovl.frame.y1, w, h,
+           port->ovl.horExp, 
+           port->ovl.verExp,
+           port->planes.yplane, 
+           port->planes.uplane,
+           port->planes.vplane);
+
+    if (port->videoStatus & W100_OVERLAY_CONFIGURED) {
+        return;
+    }
+
+    w <<= port->ovl.horExp;
+    h <<= port->ovl.verExp;
+
+    video_ctrl.val = w100c->regs.VIDEO_CTRL;
+
+    video_ctrl.f.video_inv_hor = 0;
+    video_ctrl.f.video_inv_ver = 0;
+    video_ctrl.f.yuv2rgb_option = 0;
+    video_ctrl.f.video_hor_exp = port->ovl.horExp;
+    video_ctrl.f.video_ver_exp = port->ovl.verExp;
+    video_ctrl.f.video_ch_sel = 0;
+
+    video_ctrl.f.yuv2rgb_en = 1;
+    //Only support this, by the moment
+    video_ctrl.f.video_mode = OVLFORMAT_YUV420;
+
+
+    video_y_pitch.val = 0;
+    video_u_pitch.val = 0;
+    video_v_pitch.val = 0;
+    video_y_pitch.f.y_pitch = pitch;
+    video_u_pitch.f.u_pitch = pitch >> 1;
+    video_v_pitch.f.v_pitch = pitch >> 1;
+
+    video_y_offset.val = 0;
+    video_u_offset.val = 0;
+    video_v_offset.val = 0;
+    video_y_offset.f.y_offset = port->planes.yplane;
+    video_u_offset.f.u_offset = port->planes.uplane;
+    video_v_offset.f.v_offset = port->planes.vplane;
+
+    graphic_key.val = 0;
+    graphic_key.f.keyer_color = port->ovl.colorKey;
+    graphic_key.f.keyer_mask  = 0xffffUL;
+    video_ctrl.f.keyer_en = 1;
+
+    graphic_h_disp.val = w100c->regs.GRAPHIC_H_DISP;
+    graphic_v_disp.val = w100c->regs.GRAPHIC_V_DISP;
+
+    video_hpos.f.video_h_start = graphic_h_disp.f.graphic_h_start 
+        + port->ovl.frame.x1;
+    video_hpos.f.video_h_end = video_hpos.f.video_h_start + w;
+
+    video_vpos.f.video_v_start = graphic_v_disp.f.graphic_v_start 
+        + port->ovl.frame.y1;
+    video_vpos.f.video_v_end = video_vpos.f.video_v_start + h;
+    if (video_hpos.f.video_h_end > graphic_h_disp.f.graphic_h_end) {
+        w = graphic_h_disp.f.graphic_h_end - video_hpos.f.video_h_start;
+    }
+
+    //This is possibly not valid for non planar modes
+    video_ctrl.f.total_req_video = (w + 3) / 4;
+
+    W100DisableDisplayUpdate(w100c);
+    //This need to be tuned deeply, to get an stable
+    //overlay image:
+    //Best results seems to be present with 0x40xxxxxx
+    //But overlay surface must be located in a 8 dot multiple
+    MMIO_OUT32(mmDISP_DEBUG2, 
+               (w100c->regs.DISP_DEBUG2 & ~0xff000000) | 0x40000000 );
+    MMIO_OUT32(mmGRAPHIC_KEY, graphic_key.val);
+    MMIO_OUT32(mmVIDEO_Y_OFFSET, video_y_offset.val);
+    MMIO_OUT32(mmVIDEO_Y_PITCH, video_y_pitch.val);
+    MMIO_OUT32(mmVIDEO_U_OFFSET, video_u_offset.val);
+    MMIO_OUT32(mmVIDEO_U_PITCH, video_u_pitch.val);
+    MMIO_OUT32(mmVIDEO_V_OFFSET, video_v_offset.val);
+    MMIO_OUT32(mmVIDEO_V_PITCH, video_v_pitch.val);
+    MMIO_OUT32(mmVIDEO_CTRL, video_ctrl.val);
+    MMIO_OUT32(mmVIDEO_H_POS, video_hpos.val);
+    MMIO_OUT32(mmVIDEO_V_POS, video_vpos.val);
+    W100EnableDisplayUpdate(w100c);
+
+    port->videoCtrl = video_ctrl.val;
+    port->videoStatus |= W100_OVERLAY_CONFIGURED;
+}
+
+static void W100OverlayEnable(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+    video_ctrl_u video_ctrl;
+
+    if (!(port->videoStatus & W100_OVERLAY_CONFIGURED)) {
+        W100OverlaySetup(screen);
+    }
+
+    if (!(port->videoStatus & W100_OVERLAY_ON)) {
+        ErrorF("W100OverlayEnable()\n");
+        video_ctrl.val = port->videoCtrl;
+        video_ctrl.f.en_video_req = 1;
+        video_ctrl.f.en_video_crtc = 1;
+        video_ctrl.f.en_graphic_req_video = 1;
+        W100DisableDisplayUpdate(w100c);
+        MMIO_OUT32(mmVIDEO_CTRL, video_ctrl.val);
+        W100EnableDisplayUpdate(w100c);
+        port->videoCtrl = video_ctrl.val;
+        port->videoStatus |= W100_OVERLAY_ON;
+    }
+}
+
+static void W100OverlayDisable(KdScreenInfo *screen)
+{
+
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+
+    video_ctrl_u video_ctrl;
+
+    if ((port->videoStatus & W100_OVERLAY_ON)) {
+        ErrorF("W100OverlayDisable()\n");
+        video_ctrl.val = port->videoCtrl;
+        video_ctrl.f.en_video_req = 0;
+        video_ctrl.f.en_video_crtc = 0;
+        video_ctrl.f.en_graphic_req_video = 0;
+        W100DisableDisplayUpdate(w100c);
+        MMIO_OUT32(mmVIDEO_CTRL, video_ctrl.val);
+        W100EnableDisplayUpdate(w100c);
+        port->videoCtrl = video_ctrl.val;
+        port->videoStatus &= ~W100_OVERLAY_ON;
+    }
+}
+
+static void W100VideoSave(ScreenPtr pScreen, KdOffscreenArea *area)
+{
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+
+    if (port->src.surface == area) {
+        port->src.surface = NULL;
+    }
+
+    if (port->ovl.surface == area) {
+        port->ovl.surface = NULL;
+    }
+}
+
+static void W100SaveSurface(CARD8 *src, int size, const char *file)
+{
+    int fd;
+    if (fd = open(file, O_WRONLY | O_CREAT | O_TRUNC,
+                  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) {
+        write(fd, (void*) src, size);
+        close(fd);
+    }
+}
+    
+static void W100HostPlanarData(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+    KdOffscreenArea *dst = port->src.surface;
+    CARD8 *src = port->src.buffer;
+    CARD16 srcPitch = port->src.width; //WARN: padding?
+    CARD16 srcHeight = port->src.height;
+    CARD16 dstPitch = port->src.box.x2 - port->src.box.x1 + 1; //WARN: padding?
+    CARD16 dstHeight = port->src.box.y2 - port->src.box.y1 + 1;
+    CARD16 srcX = port->src.box.x1;
+    CARD16 srcY = port->src.box.y1;
+    CARD16 dstX = 0;
+    CARD16 dstY = 0;
+    CARD16 w = dstPitch;
+    CARD16 h = dstHeight;
+    CARD8 *dstBase = dst->vidmem->base + dst->offset;
+    CARD8 *dstPtr;
+    CARD8 *srcPtr;
+    int i;
+
+    srcPtr = src + (srcY * srcPitch) + srcX;
+    dstPtr = dstBase + (dstY * dstPitch) + dstX;
+
+    DBG_IMAGEON(("W100HostPlanarData(src(pitch:%d,offset:0x%08x,x:%d,y:%d),"
+                 "dst(pitch:%d,offset:0x%08x,x:%d,y:%d), w:%d,h:%d)\n",
+                 srcPitch, srcPtr, srcX, srcY,
+                 dstPitch, dstPtr, dstX, dstY,
+                 w, h));
+
+    /* Copy Y plane */
+    for (i = 0; i < h; i++) {
+        memcpy(dstPtr, srcPtr, w);
+        dstPtr += dstPitch;
+        srcPtr += srcPitch;
+    }
+    /* Copy U plane */
+    dstPtr = dstBase + (dstHeight * dstPitch) //Start of U Plane
+        + (dstX >> 1)                         //X Offset
+        + ((dstY * dstPitch) >> 2);           //Y Offset
+    if (port->src.id == FOURCC_I420) {
+        srcPtr = src + (srcHeight * srcPitch) //Start of U Plane
+            + (srcX >> 1)                     //X Offset
+            + ((srcY * srcPitch) >> 2);       //Y Offset
+    } else {
+        srcPtr = src + ((5 * srcHeight * srcPitch) / 4) //Start of U Plane
+            + (srcX >> 1)                               //X Offset
+            + ((srcY * srcPitch) >> 2);                 //Y Offset
+    }
+    for (i = 0; i < (h >> 1); i++) {
+        memcpy(dstPtr, srcPtr, w >> 1);  //U Plane scanline
+        srcPtr += srcPitch >> 1;
+        dstPtr += dstPitch >> 1;
+    }
+
+    /* Copy V plane */
+    dstPtr = dstBase + ((5 * dstHeight * dstPitch) / 4) //Start of V Plane
+        + (dstX >> 1)                         //X Offset
+        + ((dstY * dstPitch) >> 2);           //Y Offset
+    if (port->src.id == FOURCC_I420) {
+        srcPtr = src + ((5 * srcHeight * srcPitch) / 4) //Start of V Plane
+            + (srcX >> 1)                               //X Offset
+            + ((srcY * srcPitch) >> 2);                 //Y Offset
+    } else {
+        srcPtr = src + (srcHeight * srcPitch) //Start of V Plane
+            + (srcX >> 1)                     //X Offset
+            + ((srcY * srcPitch) >> 2);       //Y Offset
+    }
+    for (i = 0; i < (h >> 1); i++) {
+        memcpy(dstPtr, srcPtr, w >> 1);  //V Plane scanline
+        srcPtr += srcPitch >> 1;
+        dstPtr += dstPitch >> 1;
+    }
+}
+
+static void W100HostPackedData(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+    KdOffscreenArea *dst = port->src.surface;
+    CARD8 *src = port->src.buffer;
+    CARD16 srcPitch = port->src.width << 1; //WARN: padding?
+    CARD16 dstPitch = (port->src.box.x2 - port->src.box.x1 + 1) << 1;
+    CARD16 srcX = port->src.box.x1;
+    CARD16 srcY = port->src.box.y1;
+    CARD16 dstX = 0;
+    CARD16 dstY = 0;
+    CARD16 w = port->src.box.x2 - port->src.box.x1 + 1;
+    CARD16 h = port->src.box.y2 - port->src.box.y1 + 1;
+ 
+    CARD8 *dstBase = dst->vidmem->base + dst->offset;
+    CARD8 *dstPtr = dstBase + (dstY * dstPitch) + (dstX << 1);
+    CARD8 *srcPtr = src + (srcY + srcPitch) + (srcX << 1);
+
+    DBG_IMAGEON(("W100HostPackedData(src(pitch:%d,offset:0x%08x,x:%d,y:%d),"
+                 "dst(pitch:%d,offset:0x%08x,x:%d,y:%d), w:%d,h:%d)\n",
+                 srcPitch, srcPtr, srcX, srcY,
+                 dstPitch, dstPtr, dstX, dstY,
+                 w, h));
+    while (h--) {
+        memcpy(dstPtr, srcPtr, (w << 1)); /* 16bpp assumed */
+        srcPtr += srcPitch;
+        dstPtr += dstPitch;
+    }
+}
+                               
+                               
+static void W100StopVideo(KdScreenInfo *screen, pointer data, Bool exit)
+{
+    W100CardInfo(screen);
+    W100PortPrivPtr port = (W100PortPrivPtr)data;
+
+    DBG_IMAGEON(("W100StopVideo(exit:%d)\n", exit));
+
+    REGION_EMPTY(screen->pScreen, &port->clip);
+    
+    if (exit) {
+        if (port->videoStatus & W100_OVERLAY_ON) {
+            W100OverlayDisable(screen);
+        }
+        if (port->src.surface) {
+            KdOffscreenFree(screen->pScreen, port->src.surface);
+            port->src.surface = NULL;
+        }
+
+        if (port->ovl.surface) {
+            KdOffscreenFree(screen->pScreen, port->ovl.surface);
+            port->ovl.surface = NULL;
+        }
+        port->src.id = -1; // Just to avoid cached values.
+    } else {
+        if (port->videoStatus & W100_OVERLAY_ON) {
+            W100OverlayDisable(screen);
+        }
+    }
+}
+
+static int W100SetPortAttribute(KdScreenInfo *screen, 
+                                Atom attribute, 
+                                int value, 
+                                pointer data)
+{
+    W100CardInfo(screen);
+    W100PortPrivPtr port = (W100PortPrivPtr)data;
+
+    if (attribute == xvBrightness) {
+        DBG_IMAGEON(("Setting Brightness attribute to %d\n", value));
+        W100SetBrightness(w100c, value);
+        port->ovl.brightness = value;
+    } else if (attribute == xvMaxOverlaySize) {
+        DBG_IMAGEON(("Setting MaxOverlaySize to %d\n", value));
+        port->ovl.maxSize = value;
+    } else if (attribute == xvColorKey) {
+        DBG_IMAGEON(("Setting ColorKey attribute to %d\n", value));
+        port->ovl.colorKey = value;
+    }
+    return Success;
+}
+
+static int W100GetPortAttribute(KdScreenInfo *screen, 
+                                Atom attribute,
+                                int *value, 
+                                pointer data)
+{
+    W100CardInfo(screen);
+    W100PortPrivPtr port = (W100PortPrivPtr)data;
+
+    if (attribute == xvBrightness) {
+        DBG_IMAGEON(("Getting Brightness attribute\n"));
+        *value = port->ovl.brightness;
+    } else if (attribute == xvMaxOverlaySize) {
+        *value = port->ovl.maxSize;
+        DBG_IMAGEON(("Getting Contrast attribute\n"));
+    } else if (attribute == xvColorKey) {
+        DBG_IMAGEON(("Getting ColorKey attribute\n"));
+        *value = port->ovl.colorKey;
+    }
+    return Success;
+}
+
+static void W100QueryBestSize(KdScreenInfo *screen,
+                              Bool motion,
+                              short vid_w, short vid_h, /*Video dimensions */
+                              short drw_w, short drw_h, /*Drawable dimensions */
+                              unsigned int *p_w, 
+                              unsigned int *p_h,
+                              pointer data)
+{
+    DBG_IMAGEON(("W100QueryBestSize(vid_w:%d,vid_h:%d,drw_w:%d,drw_h:%d)\n",
+                 vid_w, vid_h, drw_w, drw_h));
+    int xscaler = W100GetScaler(drw_w, vid_w);
+    int yscaler = W100GetScaler(drw_h, vid_h);
+    *p_w = W100ApplyScaler(vid_w, xscaler);
+    *p_h = W100ApplyScaler(vid_h, yscaler);
+}
+
+static int W100QueryImageAttributes(KdScreenInfo *screen, 
+                                    int id, 
+                                    unsigned short *w, unsigned short *h, 
+                                    int *pitches, int *offsets)
+{
+    int size, tmp;
+
+    DBG_IMAGEON(("W100QueryImageAttributes(id:%d,w:%d,h:%d)\n", id, *w, *h));
+
+    if (*w > IMAGE_MAX_WIDTH) {
+        *w = IMAGE_MAX_WIDTH;
+    }
+    if (*h > IMAGE_MAX_HEIGHT) {
+        *h = IMAGE_MAX_HEIGHT;
+    }
+
+    if (W_ALIGN) {
+        *w = (*w + (W_ALIGN - 1)) & ~(W_ALIGN - 1);
+    }
+    if (H_ALIGN) {
+        *h = (*h + (H_ALIGN - 1)) & ~(H_ALIGN - 1);
+    }
+    
+    if (offsets) {
+        offsets[0] = 0;
+    }
+
+    switch (id) {
+        /* Planar formats */
+    case FOURCC_YV12:
+    case FOURCC_I420:
+	*h = (*h + 1) & ~1;
+	size = (*w + 3) & ~3;
+	if (pitches) pitches[0] = size;
+	size *= *h;
+	if (offsets) offsets[1] = size;
+	tmp = ((*w >> 1) + 3) & ~3;
+	if (pitches) pitches[1] = pitches[2] = tmp;
+	tmp *= (*h >> 1); 
+	size += tmp; 
+	if (offsets) offsets[2] = size;
+	size += tmp;
+	break;
+        /* Packed Formats */
+    case FOURCC_UYVY:
+    case FOURCC_YUY2:
+    default:
+	size = *w << 1;
+	if (pitches) pitches[0] = size;
+	size *= *h;
+	break;
+    }
+    return size;
+}
+
+static void W100ClipVideo(BoxPtr src, BoxPtr dst, BoxPtr extents,
+                          short width, short height)
+{
+    INT32 vscale, hscale, delta;
+    INT32 diff, x1, x2, y1, y2;
+
+    hscale = ((src->x2 - src->x1) << 16) / (dst->x2 - dst->x1);
+    vscale = ((src->y2 - src->y1) << 16) / (dst->y2 - dst->y1);
+
+    x1 = src->x1 << 16;
+    x2 = src->x2 << 16;
+    y1 = src->y1 << 16;
+    y2 = src->y2 << 16;
+
+    diff = extents->x1 - dst->x1;
+    if (diff > 0) {
+        dst->x1 = extents->x1;
+        x1 += diff * hscale;
+    }
+
+    diff = dst->x2 - extents->x2;
+    if (diff > 0) {
+        dst->x2 = extents->x2;
+        x2 -= diff * hscale;
+    }
+
+    diff = extents->y1 - dst->y1;
+    if (diff > 0) {
+        dst->y1 = extents->y1;
+        y1 += diff * vscale;
+    }
+
+    diff = dst->y2 - extents->y2;
+    if (diff > 0) {
+        dst->y2 = extents->y2;
+        y2 -= diff * vscale;
+    }
+
+    if (x1 < 0) {
+        diff = (- x1 + hscale - 1) / hscale;
+        dst->x1 += diff;
+        x1 += diff * hscale;
+    }
+
+    delta = x2 - (width << 16);
+    if (delta > 0) {
+        diff = (delta + hscale - 1) / hscale;
+        dst->x2 -= diff;
+        x2 -= diff * hscale;
+    }
+
+    if (y1 < 0) {
+        diff = (- y1 + vscale - 1) / vscale;
+        dst->y1 += diff;
+        y1 += diff * vscale;
+    }
+    delta = y2 - (height << 16);
+    if (delta > 0) {
+        diff = (delta + vscale - 1) / vscale;
+        dst->y2 -= diff;
+        y2 -= diff * vscale;
+    }
+  
+    src->x1 = x1 >> 16;
+    src->x2 = x2 >> 16;
+    src->y1 = y1 >> 16;
+    src->y2 = y2 >> 16;
+}
+
+static Bool W100SetOverlaySource(W100PortPrivPtr port,
+                                 unsigned char *buffer,
+                                 int id,
+                                 short src_x, short src_y,
+                                 short src_w, short src_h,
+                                 short width, short height,
+                                 short drw_x, short drw_y, 
+                                 short drw_w, short drw_h,
+                                 RegionPtr clipBoxes)
+{
+    
+    BoxRec srcBox, dstBox;
+    Bool changed = FALSE;
+
+    srcBox.x1 = src_x;
+    srcBox.x2 = src_x + src_w - 1;
+    srcBox.y1 = src_y;
+    srcBox.y2 = src_y + src_h - 1;
+
+    dstBox.x1 = drw_x;
+    dstBox.x2 = drw_x + drw_w - 1;
+    dstBox.y1 = drw_y;
+    dstBox.y2 = drw_y + drw_h - 1;
+
+    W100ClipVideo(&srcBox, &dstBox,
+                  REGION_EXTENTS(pScreen, clipBoxes),
+                  width, height);
+
+    port->src.buffer = buffer;
+    port->ovl.changed = FALSE;
+
+    if (port->src.id != id) {
+        port->src.id = id;
+        changed = TRUE;
+        port->ovl.changed = TRUE;
+    }
+    if (port->src.box.x1 != srcBox.x1) {
+        port->src.box.x1 = srcBox.x1;
+        changed = TRUE;
+    }
+    if (port->src.box.x2 != srcBox.x2) {
+        port->src.box.x2 = srcBox.x2;
+        changed = TRUE;
+    }
+    if (port->src.box.y1 != srcBox.y1) {
+        port->src.box.y1 = srcBox.y1;
+        changed = TRUE;
+    }
+    if (port->src.box.y2 != srcBox.y2) {
+        port->src.box.y2 = srcBox.y2;
+        changed = TRUE;
+    }
+    if (port->src.width != width) {
+        port->src.width = width;
+        changed = TRUE;
+    }
+    if (port->src.height != height) {
+        port->src.height = height;
+        changed = TRUE;
+    }
+
+    if (port->dst.box.x1 != dstBox.x1) {
+        port->dst.box.x1 = dstBox.x1;
+        changed = TRUE;
+    }
+    if (port->dst.box.x2 != dstBox.x2) {
+        port->dst.box.x2 = dstBox.x2;
+        changed = TRUE;
+    }
+    if (port->dst.box.y1 != dstBox.y1) {
+        port->dst.box.y1 = dstBox.y1;
+        changed = TRUE;
+    }
+    if (port->dst.box.y2 != dstBox.y2) {
+        port->dst.box.y2 = dstBox.y2;
+        changed = TRUE;
+    }
+
+    if (changed) {
+        port->src.size = W100SurfaceSize(port, 
+                                         srcBox.x2 - srcBox.x1 + 1,
+                                         srcBox.y2 - srcBox.y1 + 1);
+    }
+    port->changed = changed;
+    return changed;
+}
+
+
+
+static int W100SetOverlaySurfaces(KdScreenInfo *screen,
+                                  short x, short y, short w, short h)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+
+    if (port->ovl.changed ||
+        (port->ovl.frame.x1 != x) ||
+        (port->ovl.frame.y1 != y) ||
+        (port->ovl.frame.x2 != (x + w - 1)) ||
+        (port->ovl.frame.y2 != (y + h - 1))) {
+
+        port->ovl.changed = TRUE;
+        port->ovl.frame.x1 = x;
+        port->ovl.frame.x2 = x + w - 1;
+        port->ovl.frame.y1 = y;
+        port->ovl.frame.y2 = y + h - 1;
+
+        W100MapToDevice(w100c, &port->dst.box, &port->ovl.box);
+        W100ChangeOrigin(&port->ovl.box,
+                         port->ovl.frame.x1, port->ovl.frame.y1);
+        port->ovl.box.x2 >>= port->ovl.horExp;
+        port->ovl.box.y2 >>= port->ovl.verExp;
+        DBG_IMAGEON(("Translated ovl.box(x1:%d,y1:%d,x2:%d,y2:%d)\n",
+                     port->ovl.box.x1, port->ovl.box.y1,
+                     port->ovl.box.x2, port->ovl.box.y2));
+    }
+    
+    switch (port->src.id) {
+    case FOURCC_YV12:
+    case FOURCC_I420:
+        port->planes.size = 3;
+        port->planes.offset[0] = 0;
+        port->planes.offset[1] = w * h;
+        port->planes.offset[2] = (5 * (w * h)) / 4;
+        port->planes.bpp = 8;
+        break;
+    case FOURCC_UYVY:
+    case FOURCC_YUY2:
+        port->planes.size = 1;
+        port->planes.offset[0] = 0;
+        port->planes.bpp = 16;
+        break;
+    }
+
+    if (port->ovl.surface && port->ovl.size != port->ovl.surface->size) {
+        KdOffscreenFree(screen->pScreen, port->ovl.surface);
+        KdOffscreenFree(screen->pScreen, port->src.surface);
+        port->ovl.surface = NULL;
+        port->src.surface = NULL;
+    }
+    if (port->src.surface && port->src.size != port->src.surface->size) {
+        KdOffscreenFree(screen->pScreen, port->src.surface);
+        port->src.surface = NULL;
+    }
+
+    if (!port->ovl.surface) {
+        port->ovl.surface = KdOffscreenAllocPrio(screen->pScreen,
+                                                 port->ovl.size, 0, TRUE,
+                                                 W100VideoSave,
+                                                 port,
+                                                 KD_VIDMEM_MAXPRIO,
+                                                 KD_VIDMEM_MAXPRIO,
+                                                 TRUE);
+        if (!port->ovl.surface) {
+            ErrorF("Using external memory for overlay surface. "
+                   "Expect bad performance\n");
+            port->ovl.surface = KdOffscreenAlloc(screen->pScreen,
+                                                 port->ovl.size, 0, TRUE, 
+                                                 W100VideoSave,
+                                                 port);
+        }
+        if (!port->ovl.surface) {
+            ErrorF("Unable to allocate %d bytes for overlay surface\n",
+                   port->ovl.size);
+            return BadAlloc;
+        }
+
+        W100ClearSurface(screen, port->ovl.surface,
+                         0, 0, 
+                         (w * port->planes.bpp / 8),
+                         w, h, port->src.id);
+    }
+    if (!port->src.surface) {
+        port->src.surface = KdOffscreenAlloc(screen->pScreen,
+                                             port->src.size, 0, TRUE, 
+                                             W100VideoSave,
+                                             port);
+        if (!port->src.surface) {
+            ErrorF("Unable to allocate %d bytes for offscreen surface\n",
+                   port->src.size);
+            return BadAlloc;
+        }
+    }
+
+    CARD32 baseAddr = (CARD32) W100_HOST2CARD(port->ovl.surface->vidmem->base +
+                                              port->ovl.surface->offset);
+
+
+    switch (port->src.id) {
+    case FOURCC_YV12:
+    case FOURCC_I420:
+        port->planes.yplane = baseAddr + port->planes.offset[0];
+        port->planes.uplane = baseAddr + port->planes.offset[1];
+        port->planes.vplane = baseAddr + port->planes.offset[2];
+        break;
+    case FOURCC_UYVY:
+    case FOURCC_YUY2:
+        port->planes.yplane = baseAddr + port->planes.offset[0];
+        port->planes.uplane = 0;
+        port->planes.vplane = 0;
+        break;
+    }
+
+    return Success;
+}
+                                   
+static int W100OvlSetup(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+    BoxRec ovlBox;
+    short x, y, w, h;
+    int i;
+
+    W100MapToDevice(w100c, &port->dst.box, &ovlBox);
+
+    x = ovlBox.x1 & ~7;
+    y = ovlBox.y1;
+
+    for (i = 0; i < NUM_OVL_RESIZERS; i++) {
+        w = (ovlBox.x2 - x + 1) >> ovlResizers[i].xfactor;
+        h = (ovlBox.y2 - y + 1) >> ovlResizers[i].yfactor;
+        w = W100_ALIGN(w, OVL_W_ALIGN);
+        h = W100_ALIGN(h, OVL_H_ALIGN);
+        port->ovl.size = W100SurfaceSize(port, w, h);
+        DBG_IMAGEON(("Trying overlay surface (x:%d,y:%d,w:%d,h:%d). Size %d."
+                     " xfactor:%d, yfactor:%d\n",
+                     x, y, w, h, port->ovl.size,
+                     ovlResizers[i].xfactor,
+                     ovlResizers[i].yfactor));
+        if (port->ovl.size <= port->ovl.maxSize) {
+            ErrorF("Using (x=%d,y=%d,w=%d,h=%d) overlay surface (%d bytes). "
+                   "Resizer(xfactor:%d,yfactor:%d)\n",
+                   x, y, w, h, port->ovl.size,
+                   ovlResizers[i].xfactor, ovlResizers[i].yfactor);
+            port->ovl.horExp = ovlResizers[i].xfactor;
+            port->ovl.verExp = ovlResizers[i].yfactor;
+            return W100SetOverlaySurfaces(screen, x, y, w, h);
+        }
+    }
+    return BadAlloc;
+}
+    
+static void W100OvlHostData(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+
+    W100WaitIdle(w100c);
+    switch (port->src.id) {
+    case FOURCC_YV12:
+    case FOURCC_I420:
+        W100HostPlanarData(screen);
+        break;
+    case FOURCC_UYVY:
+    case FOURCC_YUY2:
+        W100HostPackedData(screen);
+        break;
+    }
+}
+
+static void W100OvlBlt(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100CardInfo(screen);
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+    static int frame = 0;
+    int srcW = port->src.box.x2 - port->src.box.x1 + 1;
+    int srcH = port->src.box.y2 - port->src.box.y1 + 1;
+    int dstW = port->ovl.frame.x2 - port->ovl.frame.x1 + 1;
+    int dstH = port->ovl.frame.y2 - port->ovl.frame.y1 + 1;
+
+    DBG_IMAGEON(("ovl.box(x1:%d,y1:%d,x2:%d,y2:%d),"
+                 "src.box(x1:%d,y1:%d,x2:%d,y2:%d),"
+                 "dstW:%d, dstH:%d\n",
+                 port->ovl.box.x1, port->ovl.box.y1,
+                 port->ovl.box.x2, port->ovl.box.y2,
+                 port->src.box.x1, port->src.box.y1,
+                 port->src.box.x2, port->src.box.y2,
+                 dstW, dstH));
+
+    W100PlanarBlt(screen,                        //KdScreenInfo* screen
+                  port->planes.size,             //int planes
+                  port->planes.offset,           //int planeOffsets[]
+                  port->planes.bpp,              //int bpp
+                  w100c->hw_window.randr,        //int randr
+                  port->src.surface,             //KdOffscrenArea *src
+                  srcW,                          //int srcW
+                  srcH,                          //int srcH
+                  &port->src.box,                //BoxPtr srcBox
+                  port->ovl.surface,             //KdOffscreenArea *dst
+                  dstW,                          //int dstW
+                  dstH,                          //int dstH
+                  &port->ovl.box);               //BoxPtr dstBox
+
+#if 0
+    if (++frame == 10) {
+    W100SaveSurface(port->src.surface->vidmem->base +
+                    port->src.surface->offset, 
+                    port->src.surface->size, 
+                    "/media/card/kdrive/source.yuv");
+    W100SaveSurface(port->ovl.surface->vidmem->base +
+                    port->ovl.surface->offset, 
+                    port->ovl.surface->size, 
+                    "/media/card/kdrive/ovl.yuv");
+    exit(1);
+    }
+#endif
+}
+
+static void W100OvlUpdate(KdScreenInfo *screen)
+{
+    W100ScreenInfo *w100s = screen->driver;
+    W100PortPrivPtr port = w100s->pAdaptor->pPortPrivates[0].ptr;
+
+    if (port->videoStatus & W100_OVERLAY_ON) {
+        W100OverlayDisable(screen);
+    }
+    port->videoStatus &= ~W100_OVERLAY_CONFIGURED;
+
+    W100OverlayEnable(screen);
+}
+
+static int W100PutImage(KdScreenInfo *screen, 
+                        DrawablePtr pDraw,        /* Destination drawable */
+                        short src_x, short src_y, /* Source coordinates   */
+                        short drw_x, short drw_y, /* Destination coordinates */
+                        short src_w, short src_h, /* Source rectangle to put */
+                        short drw_w, short drw_h, /* Destination size */
+                        int id,                   /* FOURCC id        */
+                        unsigned char *buffer,    /* Source data      */
+                        short width,              /* Source width     */
+                        short height,             /* Source height    */
+                        Bool sync,                /* Sync before returning */
+                        RegionPtr clipBoxes,
+                        pointer data)
+{
+    ScreenPtr pScreen = screen->pScreen;
+    KdScreenPriv(pScreen);
+    W100CardInfo(pScreenPriv);
+    W100ScreenInfo(pScreenPriv);
+    W100PortPrivPtr port = (W100PortPrivPtr) data;
+    int errCode;
+
+    DBG_IMAGEON(("W100PutImage(src(x:%d,y:%d,w:%d,h:%d),"
+                 "drw(x:%d,y:%d,w:%d,h:%d),"
+                 "width:%d,height:%d), buffer:%p)\n",
+                 src_x,src_y,src_w,src_h,
+                 drw_x,drw_y,drw_w,drw_h,
+                 width, height,
+                 buffer));
+
+    if (W100SetOverlaySource(port, buffer, id, 
+                             src_x, src_y, src_w, src_h, 
+                             width, height,
+                             drw_x, drw_y, drw_w, drw_h, 
+                             clipBoxes)) {
+        if ((errCode = W100OvlSetup(screen)) != Success) {
+            return errCode;
+        }
+    }
+    W100OvlHostData(screen);
+    /* Update cliplist */
+    if(!REGION_EQUAL(screen->pScreen, &port->clip, clipBoxes)) {
+	REGION_COPY(screen->pScreen, &port->clip, clipBoxes);
+	KXVPaintRegion(pDraw, &port->clip, port->ovl.colorKey);
+    }
+    
+    W100OvlBlt(screen);
+
+    if (port->ovl.changed) {
+        W100OvlUpdate(screen);
+    }
+    return Success;
+}
+    
+static KdVideoAdaptorPtr 
+W100SetupImageVideo(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100CardInfo(pScreenPriv);
+    KdVideoAdaptorPtr adaptor;
+    W100PortPrivPtr port;
+
+    adaptor = xcalloc(1, sizeof(KdVideoAdaptorRec) 
+                      +  sizeof(W100PortPrivRec) 
+                      +  sizeof(DevUnion));
+    if (adaptor == NULL) {
+        return NULL;
+    }
+
+    adaptor->type = XvWindowMask | XvInputMask | XvImageMask;
+    adaptor->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
+    adaptor->name = "ATI (C) Imageon Video Overlay";
+    adaptor->nEncodings = 1;
+    adaptor->pEncodings = DummyEncoding;
+    adaptor->nFormats = NUM_FORMATS;
+    adaptor->pFormats = Formats;
+    adaptor->nPorts = 1;
+    adaptor->pPortPrivates = (DevUnion*)(&adaptor[1]);
+
+    port = (W100PortPrivPtr)(&adaptor->pPortPrivates[1]);
+
+    adaptor->pPortPrivates[0].ptr = (pointer)(port);
+
+    adaptor->nAttributes = NUM_ATTRIBUTES;
+    adaptor->pAttributes = Attributes;
+    adaptor->pImages = Images;
+    adaptor->nImages = NUM_IMAGES;
+    adaptor->PutVideo = NULL;
+    adaptor->PutStill = NULL;
+    adaptor->GetVideo = NULL;
+    adaptor->GetStill = NULL;
+    adaptor->StopVideo = W100StopVideo;
+    adaptor->SetPortAttribute = W100SetPortAttribute;
+    adaptor->GetPortAttribute = W100GetPortAttribute;
+    adaptor->QueryBestSize = W100QueryBestSize;
+    adaptor->PutImage = W100PutImage;
+    adaptor->ReputImage = NULL;
+    adaptor->QueryImageAttributes = W100QueryImageAttributes;
+
+    REGION_INIT(pScreen, &port->clip, NullBox, 0);
+
+    w100s->pAdaptor = adaptor;
+
+    xvBrightness     = MAKE_ATOM("XV_BRIGHTNESS");
+    xvColorKey       = MAKE_ATOM("XV_COLORKEY");
+    xvMaxOverlaySize = MAKE_ATOM("XV_MAXOVERLAYSIZE");
+
+    port->ovl.maxSize = OVL_MAX_SIZE;
+    port->ovl.colorKey = 0xff00;
+    port->ovl.brightness = W100GetBrightness(w100c);
+    return adaptor;
+}
+
+Bool W100InitVideo(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+    W100CardInfo(pScreenPriv);
+    KdScreenInfo *screen = pScreenPriv->screen;
+    KdVideoAdaptorPtr *adaptors, *newAdaptors = NULL;
+    KdVideoAdaptorPtr newAdaptor = NULL;
+    int num_adaptors;
+    
+    w100s->pAdaptor = NULL;
+
+    if (w100c->reg_base == NULL)
+        return FALSE;
+
+    num_adaptors = KdXVListGenericAdaptors(screen, &adaptors);
+
+    newAdaptor = W100SetupImageVideo(pScreen);
+
+    if (newAdaptor) {
+        if (!num_adaptors) {
+            num_adaptors = 1;
+            adaptors = &newAdaptor;
+        } else {
+            newAdaptors = xalloc((num_adaptors + 1) * 
+                                 sizeof(KdVideoAdaptorPtr *));
+            if (newAdaptors) {
+                memcpy(newAdaptors, adaptors, num_adaptors *
+                       sizeof(KdVideoAdaptorPtr));
+                newAdaptors[num_adaptors] = newAdaptor;
+                adaptors = newAdaptors;
+                num_adaptors++;
+            }
+        }
+    }
+
+    if (num_adaptors)
+        KdXVScreenInit(pScreen, adaptors, num_adaptors);
+
+    if (newAdaptors)
+        xfree(newAdaptors);
+    
+    return TRUE;
+}
+
+void
+W100FiniVideo(ScreenPtr pScreen)
+{
+    KdScreenPriv(pScreen);
+    W100ScreenInfo(pScreenPriv);
+    KdVideoAdaptorPtr adaptor = w100s->pAdaptor;
+    W100PortPrivPtr port;
+    int i;
+
+    if (!adaptor)
+        return;
+
+    port = (W100PortPrivPtr)(&adaptor->pPortPrivates[0].ptr);
+    REGION_UNINIT(pScreen, &port->clip);
+
+    xfree(adaptor);
+    w100s->pAdaptor = NULL;
+}
+
--- /dev/null
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/imageon/imageon_support.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright Â© 2007 Manuel Teira
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Manuel Teira not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Manuel Teira makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * MANUEL TEIRA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL MANUEL TEIRA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _IMAGEON_SUPPORT_H_
+#define _IMAGEON_SUPPORT_H
+
+#include "imageon.h"
+
+extern CARD8 W100SolidRop[16];
+extern CARD8 W100BltRop[16];
+
+/* Card control */
+void W100DisableDisplayUpdate(W100CardInfo *w100c);
+void W100EnableDisplayUpdate(W100CardInfo *w100c);
+void W100SetupGraphicEngine(W100CardInfo *w100c);
+void W100ResetGraphicEngine(W100CardInfo *w100c);
+void W100SetupGraphicWindow(W100CardInfo *w100c);
+void W100EnableGraphicWindow(W100CardInfo *w100c);
+void W100DisableGraphicWindow(W100CardInfo *w100c);
+void W100VSync(W100CardInfo *w100c);
+
+/* Wait for card slots */
+__inline__ Bool W100WaitCmdFifoEntries(W100CardInfo *w100c, int entries);
+Bool W100WaitIdle(W100CardInfo *w100c);
+
+/* Set context of the current operation */
+void W100ResetContext(W100CardInfo *w100c);
+CARD32 W100ComputeSolidGmc(W100CardInfo *w100c, CARD8 alu);
+CARD32 W100ComputeCopyGmc(W100CardInfo *w100c, CARD8 alu);
+CARD32 W100ComputeAritGmc(W100CardInfo *w100c, CARD8 alu);
+void W100SetXForm(W100CardInfo *w100c, int dx, int dy);
+void W100SetRotation(W100CardInfo *w100c, int randr, Bool mirror);
+void W100SetPixelMask(W100CardInfo *w100c, Pixel mask);
+Bool W100SetSource(KdScreenInfo *screen, CARD32 srcPitch, 
+                   CARD32 srcOffset, CARD8 bpp);
+Bool W100SetDestination(KdScreenInfo *screen, CARD32 dstPitch, 
+                        CARD32 dstOffset, CARD8 bpp);
+Bool W100SetSourcePixmap(PixmapPtr pPix);
+Bool W100SetDestinationPixmap(PixmapPtr pPix);
+
+/* Scaler related functions */
+CARD8 W100GetScaler(CARD16 dstsize, CARD16 srcsize);
+CARD16 W100ApplyScaler(CARD16 srcsize, CARD8 scaler);
+
+/* Blitting functions */
+void W100PlanarBlt(KdScreenInfo *screen, int planes, int planeOffsets[],
+                   int bpp, int randr,
+                   KdOffscreenArea *src, int srcW, int srcH, BoxPtr srcBox,
+                   KdOffscreenArea *dst, int dstW, int dstH, BoxPtr dstBox);
+static void W100ScaledBlt(KdScreenInfo *screen, int randr, int bpp,
+                          CARD32 srcOffset, CARD16 srcPitch, BoxPtr srcBox,
+                          CARD32 dstOffset, CARD16 dstPitch, BoxPtr dstBox,
+                          CARD8 xscaler, CARD8 yscaler);
+static void W100StretchBlt(KdScreenInfo *screen, int randr, int bpp,
+                          CARD32 srcOffset, CARD16 srcPitch, BoxPtr srcBox,
+                          CARD32 dstOffset, CARD16 dstPitch, BoxPtr dstBox,
+                          CARD8 xscaler, CARD8 yscaler);
+static void W100Blt(KdScreenInfo *screen, int randr, int bpp,
+                    CARD32 srcOffset, CARD16 srcPitch, BoxPtr srcBox,
+                    CARD32 dstOffset, CARD16 dstPitch, BoxPtr dstBox);
+
+/* Brightness functions */
+CARD8 W100GetBrightness(W100CardInfo *w100c);
+void W100SetBrightness(W100CardInfo *w100c, CARD8 value);
+
+
+/* Get and set mode and rotation info */
+int W100GetRotation(W100CardInfo *w100c);
+W100ModeSpec *W100GetModeSpec(W100CardInfo *w100c, W100Mode *mode);
+Bool W100GetFbMode(W100CardInfo *w100c, W100Mode *mode);
+Bool W100CheckFbMode(W100CardInfo *w100c, W100ModeSpec *modes);
+W100ModeSpec *W100GetBestMode(W100CardInfo *w100c, int width, int height);
+
+/* SysFS helpers */
+Bool W100SysFsGet(W100CardInfo *w100c, const char *path, char *value);
+Bool W100SysFsSet(W100CardInfo *w100c, const char *path, const char *value);
+
+/* Coordinate transformations */
+void W100TransformTsLibCoordinates(long *x, long *y, void *closure);
+void W100MapToDevice(W100CardInfo *w100c, BoxPtr src, BoxPtr dst);
+void W100MapFromDevice(W100CardInfo *w100c, BoxPtr src, BoxPtr dst);
+void W100ChangeOrigin(BoxPtr src, int x, int y);
+void W100TrajectoryOrigin(W100CardInfo *w100c, BoxPtr box, short *x, short *y);
+void W100ScaleBox(BoxPtr src, BoxPtr dst, int scale);
+void W100MoveTo(BoxPtr src, int x, int y);
+
+
+
+#endif
--- xorg-server-X11R7.1-1.1.0.work/hw/kdrive/linux/tslib.c~kdrive-imageon
+++ xorg-server-X11R7.1-1.1.0.work/hw/kdrive/linux/tslib.c
@@ -92,6 +92,10 @@
 void (*tslib_raw_event_hook)(int x, int y, int pressure, void *closure);
 void *tslib_raw_event_closure;
 
+/* To support randr hot resolution change */
+void (*tslib_transform_coords)(long *x, long *y, void *closure);
+void *tslib_transform_closure;
+
 int TsInputType = 0;
 int KdTsPhyScreen = 0; 		/* XXX Togo .. */
 
@@ -121,7 +125,9 @@
 	flags = (event.pressure) ? KD_BUTTON_1 : 0;
 	x = event.x;
 	y = event.y;
-	
+	if (tslib_transform_coords) {
+		tslib_transform_coords(&x, &y, tslib_transform_closure);
+	}
 	KdEnqueueMouseEvent (mi, flags, x, y);
       }
 }
