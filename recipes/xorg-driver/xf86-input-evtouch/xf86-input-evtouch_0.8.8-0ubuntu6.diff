--- xf86-input-evtouch-0.8.8.orig/evtouch.c
+++ xf86-input-evtouch-0.8.8/evtouch.c
@@ -30,8 +30,8 @@
 
 #define _evdev_touch_C_
 
-#include <xf86Version.h>
-#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(3,9,0,0,0)
+#include <xorgVersion.h>
+#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(3,9,0,0,0)
 #define XFREE86_V4
 #endif
 
@@ -74,7 +74,6 @@
 #include "xf86_OSproc.h"
 #include "xf86Xinput.h"
 #include "exevents.h"
-#include "xf86OSmouse.h"
 #include "randrstr.h"
 
 #ifndef NEED_XF86_TYPES
@@ -139,7 +138,7 @@
         "Kenan Esau",
         MODINFOSTRING1,
         MODINFOSTRING2,
-        XF86_VERSION_CURRENT,
+        XORG_VERSION_CURRENT,
         0, 8, 8,
         ABI_CLASS_XINPUT,
         ABI_XINPUT_VERSION,
@@ -653,14 +652,13 @@
          * Device reports motions on 2 axes in absolute coordinates.
          * Axes min and max values are reported in raw coordinates.
          */
-        if (InitValuatorClassDeviceStruct(dev, 2, xf86GetMotionEvents,
+        if (InitValuatorClassDeviceStruct(dev, 2,
                                           local->history_size, Absolute) == FALSE)
         {
                 ErrorF ("Unable to allocate EVTouch touchscreen ValuatorClassDeviceStruct\n");
                 return !Success;
         }
 
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
         xf86InitValuatorAxisStruct(dev, 0, 0, priv->screen_width,
                                    1024,
                                    EV_AXIS_MIN_RES /* min_res */ ,
@@ -671,10 +669,6 @@
                                    EV_AXIS_MIN_RES /* min_res */ ,
                                    EV_AXIS_MAX_RES /* max_res */ );
         xf86InitValuatorDefaults(dev, 1);
-#else
-	xf86InitValuatorAxisStruct(dev, 0, priv->min_x, priv->max_x,
-        xf86InitValuatorDefaults(dev, 1);
-#endif
 
         /* Initial position of pointer on screen: Centered */
         priv->cur_x=(priv->max_x - priv->min_x)/2;
--- xf86-input-evtouch-0.8.8.orig/debian/changelog
+++ xf86-input-evtouch-0.8.8/debian/changelog
@@ -0,0 +1,259 @@
+xf86-input-evtouch (0.8.8-0ubuntu6) karmic; urgency=low
+
+  * Add debian/fdi/50-touchpack.fdi to support TouchPack touchscreen devices
+    (Clevo TN120 series, ASUS EeeTOP, Winux Tablet, ...)
+    (LP: #401039)
+
+ -- Mirsal Ennaime <mirsal@winux.fr>  Sat, 24 Oct 2009 18:10:18 +0200
+
+xf86-input-evtouch (0.8.8-0ubuntu5) karmic; urgency=low
+
+  * control: Add dependencies for ttf-freefont and x-ttcidfont-conf.
+    These dependencies are required by one of the earlier patches.
+    (LP: #299178)
+  * Add debian/fdi/50-elo-2700.fdi to support EloTouch 2700 IntelliTouch
+    Touchmonitor Interface.
+    (LP: #362308)
+  * Add debian/fdi/50-gunze.fdi to support GUNZE USB Touch Panel
+    (LP: #368135)
+
+ -- Bryce Harrington <bryce@ubuntu.com>  Wed, 14 Oct 2009 02:10:14 -0700
+
+xf86-input-evtouch (0.8.8-0ubuntu4) karmic; urgency=low
+
+  * Add debian/fdi/50-ideaco-idc6681.fdi to support IDEACO IDC 6681
+    touchscreen.
+    (LP: #378357)
+
+ -- Bryce Harrington <bryce@ubuntu.com>  Wed, 14 Oct 2009 01:35:50 -0700
+
+xf86-input-evtouch (0.8.8-0ubuntu3) jaunty; urgency=low
+
+  * 21_more_calibration_fixups.patch: Make calibration work on xserver-1.6
+
+ -- Thomas Jaeger <ThJaeger@gmail.com>  Sun, 22 Mar 2009 20:58:58 -0400
+
+xf86-input-evtouch (0.8.8-0ubuntu2) jaunty; urgency=low
+
+  * install fdi files to /usr/share/hal/fdi/policy/20thirdparty so we make
+    sure its not synaptics that gets used.
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Wed, 28 Jan 2009 16:17:39 +0100
+
+xf86-input-evtouch (0.8.8-0ubuntu1) jaunty; urgency=low
+
+  * New upstream release, packaged by Thomas Jaeger (ThJaeger@gmail.com)
+    Thanks a lot for fixing the header issues !! (LP: #312098)
+    - fix rotation issues (LP: #222164)
+  * 20_fix_calibrate_submission_directions.patch, point lshal submission to a
+    LP bug instead of pointing people to a subscription only
+    mailing list (LP: #307503)
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Wed, 14 Jan 2009 14:04:58 -0500
+
+xf86-input-evtouch (0.8.7-4build2) jaunty; urgency=low
+
+  * Rebuild against the new xserver.
+
+ -- Timo Aaltonen <tjaalton@ubuntu.com>  Mon, 15 Dec 2008 11:49:43 +0200
+
+xf86-input-evtouch (0.8.7-4build1) intrepid; urgency=low
+
+  * Rebuild due to x11proto-input fix in 283921
+
+ -- Bryce Harrington <bryce@ubuntu.com>  Sat, 18 Oct 2008 01:45:02 -0700
+
+xf86-input-evtouch (0.8.7-3ubuntu12) intrepid; urgency=low
+
+  * add more touchscreen .fdi files
+  * install all touchscreen .fdi files to /usr/share/hal/fdi/policy/10osvendor
+    with sequence number 50 so they will override evdev and mouse settings
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Thu, 16 Oct 2008 01:50:09 +0200
+
+xf86-input-evtouch (0.8.7-3ubuntu11) intrepid; urgency=low
+
+  * fix .fdi install location to make sure hal doesnt prefer mouse settings
+    for evtouch devices
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Mon, 29 Sep 2008 22:39:37 +0200
+
+xf86-input-evtouch (0.8.7-3ubuntu10) intrepid; urgency=low
+
+  * update halification patch of calibration script to make sure it doesnt
+    fire if no evtouch capable device is in hal.
+  * add .fdi file for Fujitsu lifebook (and other Fujitsu driven touchscreen
+    devices with Fujitsu USB Touch Panel).
+  * add sane defaults to ideaco and eGalax fdi files.
+  * add selection of dialog frontends to show the info in X.
+  * move zenity to recommends, add xdialog and kdebase-bin (for kdialog) as
+    different dialog options.
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Thu, 25 Sep 2008 19:57:51 +0200
+
+xf86-input-evtouch (0.8.7-3ubuntu9) intrepid; urgency=low
+
+  * quieten down initscript a bit (we dont want a newline for each applied
+    value on screen)
+  * call initscript at end of calibration, so new values are applied without
+    having to restart the system.
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Thu, 25 Sep 2008 13:27:41 +0200
+
+xf86-input-evtouch (0.8.7-3ubuntu8) intrepid; urgency=low
+
+  * add 09_calibrate-script-halification.patch, adds hal functionallity to
+    calibration tool, makes the script work under X and gives useful output
+    through zenity dialogs
+  * add 10_ev_calibrate_fixups.patch, fix ev_calibrate.c to use a useful font
+    in calibration, make it write to /etc/evtouch/config in a format that can
+    be parsed by the evtouch hal-set-property initscript
+  * add calibrate.desktop and calibrate icon file (uuencoded), add sharutils
+    to build-deps
+  * make sure /etc/evtouch dir is created by the package so ev_calibrate can
+    write its config there.
+  * add hal to dependencies, zenity to suggests
+  * add xserver-xorg-input-evtouch initscript to apply calibration data on
+    system boot via hal-set-property
+  * include .fdi files for ideaco and eGalax touchscreens (hopefully there
+    will be more soon)
+  * closes (LP: #261873)
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Thu, 25 Sep 2008 00:54:44 +0200
+
+xf86-input-evtouch (0.8.7-3ubuntu7) intrepid; urgency=low
+
+  * add CURSORDIR to debian/rules to make calibration tool work
+  * link calibration tools to /usr/bin so the low level calibration tools work
+    on a basic level
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Wed, 24 Sep 2008 13:27:49 +0200
+
+xf86-input-evtouch (0.8.7-3ubuntu6) intrepid; urgency=low
+
+  * add libtouch.c to 08_fix_xf86memset.patch. (LP: #254848)
+
+ -- Timo Aaltonen <tepsipakki@ubuntu.com>  Thu, 07 Aug 2008 11:36:17 +0300
+
+xf86-input-evtouch (0.8.7-3ubuntu5) intrepid; urgency=low
+
+  * add 08_fix_xf86memset.patch, fixes (LP: #254848)
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Tue, 05 Aug 2008 17:46:19 +0200
+
+xf86-input-evtouch (0.8.7-3ubuntu4) intrepid; urgency=low
+
+  * Uh, ok. Don't apply 04_include_xf86_ansic_h.patch. (FTBFS)
+
+ -- Timo Aaltonen <tepsipakki@ubuntu.com>  Tue, 08 Jul 2008 14:22:13 +0300
+
+xf86-input-evtouch (0.8.7-3ubuntu3) intrepid; urgency=low
+
+  * libtouch.c: don't #include <xf86_ansic.h>. It is no more. (FTBFS)
+
+ -- Timo Aaltonen <tepsipakki@ubuntu.com>  Tue, 08 Jul 2008 14:13:32 +0300
+
+xf86-input-evtouch (0.8.7-3ubuntu2) intrepid; urgency=low
+
+  * Rebuild against the new xserver-xorg-dev.
+
+ -- Timo Aaltonen <tepsipakki@ubuntu.com>  Mon, 07 Jul 2008 17:44:38 +0300
+
+xf86-input-evtouch (0.8.7-3ubuntu1) hardy; urgency=low
+
+  * Merge from debian unstable, remaining changes: (LP: #190004)
+    - Change maintainer address.
+    - Change the default font from helvetica to fixed.
+  * Drop Pepper/Q1 patch, upstream has a slightly different fix
+  * Upstream includes fix for running on amd64 (LP: #155880)
+	
+ -- Steve Magoun <steve.magoun@canonical.com>  Thu, 07 Feb 2008 14:09:00 -0500
+
+xf86-input-evtouch (0.8.7-3) unstable; urgency=low
+
+  * work(!!!!) with xserver-xorg-core 1.4
+  * added xf86-input-evtouch-0.8.7-misc.patch from 
+    http://www.postnuklear.de/xorg-patches/ (Closes: #443726)
+  * bump Standards-Version to 3.7.3
+  * use Vcs and Homepage headers in debian/control
+
+ -- Mattia Dongili <malattia@debian.org>  Sat, 02 Feb 2008 21:32:15 +0900
+
+xf86-input-evtouch (0.8.7-2ubuntu1) hardy; urgency=low
+
+  * Merge from debian unstable, remaining changes:
+    - Change maintainer address.
+    - Add patch from Pepper to handle the touch screen on the Samsung Q1
+      Ultra correctly.
+    - Change the default font from helvetica to fixed.
+ 
+ -- Timo Aaltonen <tepsipakki@ubuntu.com>  Tue, 13 Nov 2007 10:53:54 +0200
+
+xf86-input-evtouch (0.8.7-2) unstable; urgency=low
+
+  * build with xserver-xorg-core 1.4
+
+ -- Mattia Dongili <malattia@debian.org>  Mon, 17 Sep 2007 16:52:54 +0900
+
+xf86-input-evtouch (0.8.7-1) unstable; urgency=low
+
+  * New upstream release:
+    - Added "fix" for AMD64-crashes on touch (Closes: #431925)
+  * updated xsfbs
+  * removed 03_fix_compile_warns.patch applied upstream
+
+ -- Mattia Dongili <malattia@debian.org>  Tue, 11 Sep 2007 22:42:32 +0900
+
+xf86-input-evtouch (0.8.6-1ubuntu1) gutsy; urgency=low
+
+  * Add patch from Pepper to handle the touch screen on the Samsung Q1
+    Ultra correctly.
+  * Change the default font from helvetica to fixed.
+
+ -- Tollef Fog Heen <tfheen@ubuntu.com>  Wed, 11 Jul 2007 18:52:09 +0200
+
+xf86-input-evtouch (0.8.6-1) unstable; urgency=low
+
+  * New upstream release:
+    - Fixed classic rotation (Closes: #417546)
+  * removed 04_fix_segv_on_device_off.patch, applied upstream
+  * updated evtouch.html
+
+ -- Mattia Dongili <malattia@debian.org>  Sat, 16 Jun 2007 14:31:58 +0900
+
+xf86-input-evtouch (0.8.5-3) unstable; urgency=low
+
+  * Use xsfbs to get xserver dependencies automatically.
+
+ -- Mattia Dongili <malattia@debian.org>  Sun, 10 Jun 2007 10:44:51 +0900
+
+xf86-input-evtouch (0.8.5-2) unstable; urgency=low
+
+  * Fix SEGV on vt switch (DeviceClose actually).
+
+ -- Mattia Dongili <malattia@debian.org>  Wed, 30 May 2007 15:55:59 +0900
+
+xf86-input-evtouch (0.8.5-1) unstable; urgency=low
+
+  * New upstream release.
+
+ -- Mattia Dongili <malattia@debian.org>  Fri, 11 May 2007 18:28:41 +0900
+
+xf86-input-evtouch (0.8.3-1) unstable; urgency=low
+
+  * New upstream release.
+
+ -- Mattia Dongili <malattia@debian.org>  Mon, 19 Feb 2007 12:34:26 +0100
+
+xf86-input-evtouch (0.8.2-1) unstable; urgency=low
+
+  * New upstream release.
+
+ -- Mattia Dongili <malattia@debian.org>  Sat, 03 Feb 2007 20:14:40 +0100
+
+xf86-input-evtouch (0.8.1-1) unstable; urgency=low
+
+  * Initial release. (Closes: #404932)
+
+ -- Mattia Dongili <malattia@debian.org>  Fri, 29 Dec 2006 15:01:18 +0100
+
--- xf86-input-evtouch-0.8.8.orig/debian/xserver-xorg-input-evtouch.links
+++ xf86-input-evtouch-0.8.8/debian/xserver-xorg-input-evtouch.links
@@ -0,0 +1,2 @@
+usr/lib/xf86-input-evtouch/ev_calibrate usr/bin/ev_calibrate
+/usr/lib/xf86-input-evtouch/calibrate.sh usr/bin/calibrate_touchscreen
--- xf86-input-evtouch-0.8.8.orig/debian/copyright
+++ xf86-input-evtouch-0.8.8/debian/copyright
@@ -0,0 +1,34 @@
+This package was debianized Mattia Dongili <malattia@debian.org> based on the work
+by Rex Tsai <chihchun@debian.org.tw> on Sun, 03 Dec 2006 18:53:48 +0100.
+
+It was downloaded from http://www.stz-softwaretechnik.com/~ke/touchscreen/evtouch.html
+
+Upstream Author:  Kenan Esau <kenan.esau@conan.de>
+
+Copyright: 2004-2006 Kenan Esau <kenan.esau@conan.de>, Baltmannsweiler, Germany.
+
+License:
+
+ Permission to use, copy, modify, distribute, and sell this software and its
+ documentation for any purpose is hereby granted without fee, provided that
+ the above copyright notice appear in all copies and that both that
+ copyright notice and this permission notice appear in supporting
+ documentation, and that the names of copyright holders not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.  The copyright holders
+ make no representations about the suitability of this
+ software for any purpose.  It is provided "as is" without express or
+ implied warranty.
+ 
+ THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+
+The Debian packaging is (C) 2006, Mattia Dongili <malattia@debian.org> and
+is licensed under the GPL, see `/usr/share/common-licenses/GPL'.
+
--- xf86-input-evtouch-0.8.8.orig/debian/calibrate.desktop
+++ xf86-input-evtouch-0.8.8/debian/calibrate.desktop
@@ -0,0 +1,12 @@
+[Desktop Entry]
+Name=Calibrate Touchscreen
+Name[de]=Touchscreen Kalibrieren
+Comment=Run the touchscreen calibration tool
+Encoding=UTF-8
+Exec=gksu /usr/bin/calibrate_touchscreen
+Terminal=false
+Type=Application
+Icon=calibrate.png
+StartupNotify=true
+Categories=GTK;System;Settings;
+X-Ubuntu-Gettext-Domain=evtouch
--- xf86-input-evtouch-0.8.8.orig/debian/calibrate.uuencode
+++ xf86-input-evtouch-0.8.8/debian/calibrate.uuencode
@@ -0,0 +1,50 @@
+begin 644 calibrate.uunecode
+MB5!.1PT*&@H````-24A$4@```"0````D"`8```#A`)B8`````7-21T(`KLX<
+MZ0````9B2T=$`/\`_P#_H+VGDP````EP2%ES```-UP``#=<!0BB;>`````=T
+M24U%!]@)&!(8$5T-YE8```>]241!5%C#[9AMC%Q5&<=_YYX[.UOF95^Z[Z7;
+M+K2496'9I=)`1&RD#29H\04,B5\$/_C!^(&HI89$HX&LA*CPP=<0$WQ!H@E&
+M_62,"9(B+QL+0FB`LD5IR]ANNVQG=F;NO>>>\_CASLS.6Y<:$S]YDY-S9^:<
+M\_S/\_R?Y_S/P/^?C1\%\.V''D@KS[NWKZ]OO_9T^G\)P#H7%(OGGW'.?>?0
+MP?O+:N&A!U5O;^_//_ZQ`Y^]=,M6E/KO#(C(?SQ^966%W_W^MW\X?[YTNZ\4
+M4]?.7GO7^-@8E<K:?VE8Z(Y':G.Z?Y_-9KCFFMG;GOWKX9T^,-'?/Z#C..;8
+MB16^^\OGT9ZW08`;ZUP,[-H\U39'ZN'B2Y^YGNFI8?*YO`=L\5$-,Y3*$9G,
+M)CYZTZ[N>+K$TSF'B`,4GN=U'7,A&OSQ\!N4*E'S(.UWVY-UR0Z>?^9/W'#S
+M_LX=-X$Y<^IM@FJ%@>$),MD\VO>[@NI*:)':FHUU50>@.+:4*P&GWCG.3Q]]
+M@,&1+6R=VMEUP=@8",\ST7\)KRT=8V+R,K*Y/KP+A;S#ENO@5L=,8QTGWODG
+M3S[V"-5*F2<?>X1"H4`E,"VM7(U8JP3TYS+LVC'%/XZ]SKFSYU@K!QUC+]1,
+M[#KXZ".MH$SLR`R.<??!A_G>U^[F[H,/`U`)30N/1(0X,N0&,UQ^V10KRP7>
+M6WV/=&Z0E)4+<JYU\[8C/_SUU$DX8F)+)4B,?^$;/Z$:&%`*I11*4>L5(H(Q
+M%G%"?W\_FICE,P7\=(;T)1E2J32>]O&TCU+)GBM!Q.I:0+$<4`X,[Q96VSF$
+MWUY78NNH-GG#\Q1*>0T@":@Z>(=U#JTUD^-#[)Z;8F1D,X\_\6MT;S^YD6WX
+MV2%*D<?98LA:$.&<X%S"G6IMX\U/)X=B2S6,"8TEC!VA<43Q>C-6,-81Q99J
+MI80)R@#TY;-\ZO;;.'#;K6P=SO&CA^_G^JD,B\\]S=+2,<KE(EJ!KS6^K_&:
+MPKDAJ:T3PC@!$\6.R$H3$#!6B&*A&D3TE$\0U*K[Y.1D([M&1T?)Y7+LOV4O
+M5PU4N66'3_7T$BXJHSV%[_MHWT]`R88>$F(KB5>:/6.%R$H-5#*F>.8$G[CU
+MPVBM$1%&1D8(PQ`1H:^O#VLM0T-#7#TSPS?O_PHCJ2)1Z2Q(G(#2&N5UEGZO
+M_1RRSC7"E8`23+TYP3@(8X<+2URY:[T^34]/8ZU%1.CM[<48@]::OKX^E%+L
+MVC9"M'8.92,\3Z.UQE->1['UVN-H71*BR"2>,34/&2?$%HQ-2D"V5Y//YS$F
+M(>;,S`SCX^.("/OW[R>52N'[/G-S<SCGN.+R[=BPC(LCM*?P=/=CIK-26R&(
+M+%J#+Z`U>`Z4!:4$4(AS#$NYD?[U+*VWT='1QM$R/S^/<XZ)\5&\N(R+0Q32
+MR%QI([7?13`1&HLO"BL*[12^K]`(OM9XVD-PC3.Y;KQ=FM1;_<ED,E0K:^3%
+MKA=-19=*W7&T*IJ+I5(*A6JJ0TESM=\/'#C0XJ5ZC6D'%<=Q(T1)KYJ%1G<.
+M)7.E#7;KNU(*Y6E.GX\(P["K8&L&4P?Y;N%?I-)9/-U3`]1=5'6$K%J)6#E[
+MOJ9M/#POT3EUK9/4&@<EG[\=>9D;;]C3XJ$Z=XPQ&&,(PY`P#'GSK>-4C$>J
+M%!)($92F6@D[-MT":.?D((_>^Y$-%:%(8K"\=AE_?^55;KQA3X/<(D(410T0
+M01`011%!$'#JY`GNW'<M<[OW,#"X&:TU".RX=.!"I!:RFU+,7S'678:V94,8
+M#O#TRMNLKJXVTC\(`H(@:("I`SMY\B1*8JZ;F>(#5T^2R^5J!ZYT"YF4PC"@
+MM[<7:^T%O=(.,)U.,SL[R^'#A]F[=V\+D&9@QA@6%Q?9O'DSHZ-CY//];-K4
+MVU*#/$_7^;CF@WKEQ<47GR@4"G=JK5,;Z>?VU(["B-=>.\K<W!S66L(PI%JM
+MMG@G#$..'U\BE\]Q[*TW*96+I%*IUK6<N).G3OP9>.E]Q>_"PH(&>''Q^0>G
+MIZ^ZK[^O/RG[GH>(4"P6V;9M.[.SLX@(U6JU`:P.:&%AH7#TZ-&#F4SF+WOV
+M[#F];]\^VW9YD$.'#CF`B[X6WO/YS_WJ0S?=?%<VFVG*.@]K+>?.G:-0*+"Z
+MNHKOITBGTPV2ETHECKQTY-5G#S][#_`&L+;11<K?X(JM=N^>[YG?/3\P/#QT
+MQ_C8Q*=G9F9J@FV]%'B>PMK+,2:B7"Y3K08-+BH%J52*;=NW7CDW/_O!(T=>
+M/O7"<R\8YYP%;)>BU^$A70.9^NI]7]ZW96+BA]EL;G!L;*QG^LKIFM3H?E.L
+M>Z0.QKEU76UMS.MOO,Z9,Z>K:^7RJ>-+2U_\P?=_O`@8(`+BI+BM>TC5WGN`
+M'J54S_C8V-=O/_#)L;H>WOC2)XWOM>[F]#37S>\&V.1$=CSUU&^^!=Q1`^/7
+M>@,8O^T848":F!COR>5RVS.92][_FGQ1_P.T?L[G\SN'AX=ZEI?/QC6[#=M^
+MT^JF;B6.8[V\O/SRSW[Q>%X$!:)$1+6^"P@UN=^P6#MSE:C$[Z)00DUE**5$
+MH20R45$I%0!A6]BD6P#JB/TZGYK>=5/SVG;7[#K7U.H$CIMZ4^OC)G)SL6FO
+GFHRV@U`=>F4]<^K`V@'*1O'^-VN3A-O<,!`M`````$E%3D2N0F""
+`
+end
--- xf86-input-evtouch-0.8.8.orig/debian/xserver-xorg-input-evtouch.dirs
+++ xf86-input-evtouch-0.8.8/debian/xserver-xorg-input-evtouch.dirs
@@ -0,0 +1 @@
+etc/evtouch
--- xf86-input-evtouch-0.8.8.orig/debian/xserver-xorg-input-evtouch.init
+++ xf86-input-evtouch-0.8.8/debian/xserver-xorg-input-evtouch.init
@@ -0,0 +1,59 @@
+#!/bin/sh
+
+[ -x /usr/bin/hal-set-property ] || exit 0
+[ -x /usr/bin/hal-find-by-property ] || exit 0
+
+. /etc/evtouch/config > /dev/null 2>&1 || exit 0
+
+do_start() {
+    UDI=$(/usr/bin/hal-find-by-property --key input.x11_driver --string evtouch)
+
+    hal_set () {
+        if [ -n "$2" ]; then
+     /usr/bin/hal-set-property --udi "$UDI" --key input.x11_options.$1 --string "$2" >/dev/null 2>&1
+        else
+     /usr/bin/hal-set-property --udi "$UDI" --key input.x11_options.$1 --remove >/dev/null 2>&1
+        fi
+    }
+
+    hal_set minx $MINX
+    hal_set miny $MINY
+    hal_set maxx $MAXX
+    hal_set maxy $MAXY
+    hal_set x0 $X0
+    hal_set y0 $Y0
+    hal_set x1 $X1
+    hal_set y1 $Y1
+    hal_set x2 $X2
+    hal_set y2 $Y2
+    hal_set x3 $X3
+    hal_set y3 $Y3
+    hal_set x4 $X4
+    hal_set y4 $Y4
+    hal_set x5 $X5
+    hal_set y5 $Y5
+    hal_set x6 $X6
+    hal_set y6 $Y6
+    hal_set x7 $X7
+    hal_set y7 $Y7
+    hal_set x8 $X8
+    hal_set y8 $Y8
+}
+
+case "$1" in
+  start|"")
+        do_start
+        ;;
+  restart|reload|force-reload)
+        echo "Error: argument '$1' not supported" >&2
+        exit 3
+        ;;
+  stop)
+        # No-op
+        ;;
+  *)
+        echo "Usage: evtouch [start|stop]" >&2
+        exit 3
+        ;;
+esac
+
--- xf86-input-evtouch-0.8.8.orig/debian/rules
+++ xf86-input-evtouch-0.8.8/debian/rules
@@ -0,0 +1,85 @@
+#!/usr/bin/make -f
+# -*- makefile -*-
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+include debian/xsfbs/xsfbs.mk
+
+PACKAGE=xserver-xorg-input-evtouch
+
+CFLAGS = -Wall -g
+
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+	CFLAGS += -O0
+else
+	CFLAGS += -O2
+endif
+
+configure: configure-stamp
+configure-stamp: patch
+	dh_testdir
+	# Add here commands to configure the package.
+
+	CURSORDIR=/usr/share/xf86-input-evtouch ./configure --prefix=/usr --enable-evcalibrate
+	touch configure-stamp
+
+build: build-stamp
+
+build-stamp: configure-stamp 
+	dh_testdir
+
+	# Add here commands to compile the package.
+	$(MAKE) CFLAGS="$(CFLAGS)"
+	#docbook-to-man debian/evtouch.sgml > evtouch.1
+
+	touch $@
+
+clean: xsfclean clean-patched unpatch
+clean-patched:
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp configure-stamp
+
+	# Add here commands to clean up after the build process.
+	[ ! -f Makefile ] || $(MAKE) distclean
+
+	dh_clean 
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k 
+	dh_installdirs
+
+	# Add here commands to install the package into debian/tmp
+	$(MAKE) install DESTDIR=$(CURDIR)/debian/tmp
+
+
+# Build architecture-independent files here.
+binary-indep: build install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: build install serverabi
+	dh_testdir
+	dh_testroot
+	dh_install --sourcedir=debian/tmp --list-missing --exclude=.la --exclude=.a
+	dh_installchangelogs ChangeLog
+	dh_installdocs
+	dh_installexamples
+	dh_installman
+	mkdir -p debian/xserver-xorg-input-evtouch/usr/share/pixmaps
+	uudecode -o debian/xserver-xorg-input-evtouch/usr/share/pixmaps/calibrate.png debian/calibrate.uuencode
+	dh_installinit -a --no-start -u"start 25 2 3 4 5 ."
+	dh_link
+	dh_strip
+	dh_compress
+	dh_fixperms
+	dh_installdeb
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure
--- xf86-input-evtouch-0.8.8.orig/debian/control
+++ xf86-input-evtouch-0.8.8/debian/control
@@ -0,0 +1,23 @@
+Source: xf86-input-evtouch
+Section: x11
+Priority: optional
+Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
+XSBC-Original-Maintainer: Debian X Strike Force <debian-x@lists.debian.org>
+Uploaders: Mattia Dongili <malattia@debian.org>
+Build-Depends: debhelper (>= 5), pkg-config, xserver-xorg-dev (>= 2:1.4), x11proto-randr-dev, libxrender-dev, libx11-dev, quilt, sharutils
+Standards-Version: 3.7.3
+Vcs-Git: git://git.debian.org/git/pkg-xorg/driver/xserver-xorg-input-evtouch
+Vcs-Browser: http://git.debian.org/?p=pkg-xorg/driver/xserver-xorg-input-evtouch.git
+Homepage: http://stz-softwaretechnik.com/~ke/touchscreen/evtouch.html
+
+Package: xserver-xorg-input-evtouch
+Architecture: any
+Depends: ${shlibs:Depends}, ${xserver:Depends}, hal, ttf-freefont, x-ttcidfont-conf
+Provides: ${xinpdriver:Provides}
+Recommends: zenity | kdebase-bin | xidalog
+Description: Touchscreen-Driver for X.Org/XFree86 server
+ This XFree/X.Org driver provides support for touchscreens input devices.
+ The driver is actually an evdev-driver which supports events for moving
+ in absolute coordinates, relative coordinates and mouse-buttons.
+ .
+
--- xf86-input-evtouch-0.8.8.orig/debian/README.Debian
+++ xf86-input-evtouch-0.8.8/debian/README.Debian
@@ -0,0 +1,16 @@
+xf86-input-evtouch for Debian
+-----------------------------
+
+Evtouch is a Touchscreen-Driver for X.
+
+Be sure to calibrate the device and set correct parameters in your
+xorg.conf, see README.calibrate and find the necessary helpers
+in /usr/lib/xf86-input-evtouch.
+
+A complete reference can be found on-line at
+http://www.stz-softwaretechnik.com/~ke/touchscreen/evtouch.html
+or in /usr/share/doc/xserver-xorg-input-evtouch on your system.
+
+Check /proc/bus/input/devices to find out your touchscreen device.
+
+ -- Mattia Dongili <malattia@debian.org>, Sat, 09 Dec 2006 18:26:37 +0100
--- xf86-input-evtouch-0.8.8.orig/debian/xserver-xorg-input-evtouch.install
+++ xf86-input-evtouch-0.8.8/debian/xserver-xorg-input-evtouch.install
@@ -0,0 +1,4 @@
+usr/lib/*
+usr/share/*
+../fdi/* usr/share/hal/fdi/policy/20thirdparty
+../calibrate.desktop usr/share/applications/
--- xf86-input-evtouch-0.8.8.orig/debian/docs
+++ xf86-input-evtouch-0.8.8/debian/docs
@@ -0,0 +1,4 @@
+README
+README.calibration
+TODO
+debian/evtouch.html
--- xf86-input-evtouch-0.8.8.orig/debian/compat
+++ xf86-input-evtouch-0.8.8/debian/compat
@@ -0,0 +1 @@
+5
--- xf86-input-evtouch-0.8.8.orig/debian/evtouch.html
+++ xf86-input-evtouch-0.8.8/debian/evtouch.html
@@ -0,0 +1,248 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
+"http://www.w3.org/TR/html4/loose.dtd"><html>
+<head>
+<meta NAME="allow-search" content="YES">
+<meta NAME="searchtitle"  content="Conan's Homepage/X touchscreen
+driver">
+<meta NAME="keywords" CONTENT="conan touchscreen driver Xorg XFree">
+<meta NAME="description" CONTENT="Xorg/XFree touchscreen driver">
+<meta NAME="page-type" CONTENT=""><meta NAME="revisit-after" CONTENT="14 days">
+<meta NAME="ROBOTS" CONTENT="ALL">
+<meta NAME="audience" CONTENT="All">
+<meta NAME="content-language" CONTENT="en">
+<meta NAME="author" content="kenan.esau@conan.de">
+<link rel="StyleSheet" type="text/css" href="../style.css">
+<title>Xorg Touchscreen Driver</title>
+</head>
+<body>
+<div class="header">
+Last updated: 09.06.2007
+</div>
+<h1>Linux-Touchscreen Driver for X</h1>
+<div>
+Evtouch is a Touchscreen-Driver for X. This site contains the <a
+href=#config">configuration and installation</a> description as well as the
+possibility to <a href="#download">download</a> the driver.
+</div>
+<h2><a name="config">Installation/Configuration</a></h2>
+<ol><li>
+<div>
+<a href="#download">Download</a> the tarball and extract it to some
+temporary directory.
+</div>
+<div class="shell">tar xzvf evtouch-xx.yy.tar.gz</div>
+<div>
+Copy the file &quot;evtouch_drv.so&quot; to the appropriate location
+(Some distributions use &quot;/usr/X11R6/lib/modules/input&quot; or
+&quot;/usr/lib/xorg/modules/input/&quot; (for Ubuntu)). 
+</div>
+<div>
+Insert the lines below to the file &quot;/etc/X11/XF86Config-4&quot; or
+&quot;/etc/X11/xorg.conf&quot;.
+</div>
+<div class="code">
+<a name="config"></a>
+Section "InputDevice"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Identifier "touchscreen"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Driver "evtouch"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "Device" "/dev/input/event1"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "DeviceName" "touchscreen"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "MinX" "98"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "MinY" "43"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "MaxX" "940"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "MaxY" "925"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "ReportingMode" "Raw"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "Emulate3Buttons"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "Emulate3Timeout" "50"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "SendCoreEvents" "On"<br>
+EndSection<br>
+</div>
+<li>Beware that some distributions use other names for the device. Some use
+"/dev/input/evdevX" and others use "/dev/input/eventX". </li>
+<li>Add the line below to the file "/etc/X11/XF86Config-4" or
+"/etc/X11/xorg.conf" to the section "ServerLayout".<br>
+<div class="code">InputDevice "touchscreen" "CorePointer"</div>
+</li>
+<li>
+If your Y-axis is interchanged you might have used the wrong
+event-device. Maybe you should try the next few event-devices
+(/dev/event[1-9]).
+</li>
+</ol>
+
+<div class="warning">Since Xorg 7.2 there is always a default-mouse-pointer which will run simultaneously with evtouch if you do not prevent it from loading. It is extremely important that you add the following to your configuration. Otherwise you will get double click events and all kind of strange things.</div>
+
+<ol>
+<li>
+<div>Add the following new input-device to your xorg.conf:</div>
+<div class="code">
+Section "InputDevice"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Identifier "dummy"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Driver "void"<br>
+&nbsp;&nbsp;&nbsp;&nbsp;Option "Device" "/dev/input/mice"<br>
+EndSection<br>
+</div>
+</li>
+<li>
+<div>Add the following line your your &quot;ServerLayout&quot;-section:</div>
+<div class="code">InputDevice "dummy"</div>
+</li>
+</ol>
+
+<div>
+Calibration is also supported since V0.6.0. You can also reuse your
+settings from the old driver for the 2.6 driver. Actually you only
+have to exchange the driver name in the "Inputdevice"-section from
+"lbtouch" to "evtouch" and change the "Device".
+</div>
+
+<h2>Button-Events</h2>
+
+<div>
+With the state-machine based code you can have the three types of button actions (button up, down, click) which are issued in different states of the state-machine. So the complete behaviour is configurable.
+</div>
+
+<div>
+Have a look at <a href="libtouch.html">Libtouch</a> to see which default-actions are hard-coded in the driver and what you have to do to change the default-behaviour.
+</div>
+<br>
+
+<h2><a name="advanced">Advanced Configuration</a></h2>
+
+<h3>Changing Timers</h3>
+
+<div>
+If you are not confident with the default behaviour of your touchpanel you
+can configure certain timers which change its behaviour.
+</div>
+
+<table class="options" align="center" cellpadding="5" cellspacing="0">
+  <tr>
+    <th class="even"> Option </th>
+    <th class="even"> Description </th>
+    <th class="even"> Default-Value </td>
+  </tr>
+  <tr>
+    <td class="odd"> TapTimer </td>
+    <td class="odd"> This timer starts when the state MAYBETAPPED is
+entered. When this timer expires a tap-event is issued and the state
+changes to UNTOUCHED.</td>
+    <td class="odd"> 200 ms </td>
+  </tr>
+  <tr>
+    <td class="even"> LongTouchTimer </td>
+    <td class="even"> This timer is always started when the state TOUCHED
+is entered. When the timer expires before you untouch the screen again the
+state moves to LONGTOUCHED and on entering that state a longtouch-event is
+issued.</td>
+    <td class="even"> 400 ms </td>
+  </tr>
+  <tr>
+    <td class="odd"> Emulate3Buttons </td>
+    <td class="odd"> Enable emulation of three button support </td>
+    <td class="odd"> true -- enabled </td>
+  <tr>
+    <td class="even"> Emulate3Timeout </td>
+    <td class="even"> If both buttons are pressed/released before this timer
+expires a
+"middle press/release"-event is generated. This timer starts to run as soon as
+a button is pressed. </td>
+    <td class="even"> 50 ms </td>
+  </tr>
+  <tr>
+    <td class="odd"> MoveLimit </td>
+    <td class="odd"> If the pen moves out of this radius a "mouse-press"-event
+becomes impossible. </td>
+    <td class="odd"> 30 Pixels </td>
+  </tr>
+  <tr>
+    <td class="even"> Rotate </td>
+    <td class="even"> There are two valid values:<br> 
+      <code class="even">CW</code> -- Rotate the screen clockwise<br>
+      <code class="even">CCW</code> -- Rotate the screen counter-clockwise<br>
+      Everything else will be treated as "no rotation".
+    </td>
+    <td class="even"> no rotation </td>
+  </tr>
+  <tr>
+    <td class="odd"> SwapX </td>
+    <td class="odd"> This option is in the driver since V0.61. When set to 1
+the X-axis is
+    swapped. This option is applied BEFORE the rotation-option.
+    </td>
+    <td class="odd"> false -- no swapping </td>
+  </tr>
+  <tr>  
+    <td class="even"> SwapY</td>
+    <td class="even"> This option is in the driver since V0.61. When set to 1
+the Y-axis is
+    swapped. This option is applied BEFORE the rotation-option.
+    </td>
+    <td class="even"> false -- no swapping </td>
+  </tr>
+</table>
+
+<br>
+If you find bugs or if you have comment/wishes please send mail to <a
+href="mailto:lifebook@conan.de" target="Inhalt">lifebook@conan.de</a><br>
+
+<h2>Download<a name="download"></a></h2>
+<div align="center"><h3>Touchscreen-Driver for X</h3></div>
+This driver should work for XFree 4.x and Xorg 6.8.x.<br>
+Have a look at the <a href="CHANGELOG.evtouch">CHANGELOG</a>.<br>
+V0.8.2 was removed since it was broken -- sorry for the inconvenience.<br><br>
+V0.8.4 contains udev-rules for dynamically creating a softlink to the &quot;correct&quot; device. Please feel free to add your rules to this file and send the patches to me.<br>
+<table align="center">
+  <tr>
+    <td>Precompiled driver for X V0.8.6</td>
+    <td><a href="evtouch-0.8.6.tar.gz">evtouch-0.8.6.tar.gz</a></td>
+  </tr>
+  <tr>
+    <td>Precompiled driver for X V0.8.5</td>
+    <td><a href="evtouch-0.8.5.tar.gz">evtouch-0.8.5.tar.gz</a></td>
+  </tr>
+  <tr>
+    <td>Precompiled driver for X V0.8.4</td>
+    <td><a href="evtouch-0.8.4.tar.gz">evtouch-0.8.4.tar.gz</a></td>
+  </tr>
+  <tr>
+    <td>Precompiled driver for X V0.8.3</td>
+    <td><a href="evtouch-0.8.3.tar.gz">evtouch-0.8.3.tar.gz</a></td>
+  </tr>
+  <tr>
+    <td>Precompiled driver for X V0.8.1</td>
+    <td><a href="evtouch-0.8.1.tar.gz">evtouch-0.8.1.tar.gz</a></td>
+  </tr>
+  <tr>
+    <td>Precompiled driver for X V0.8.0</td>
+    <td><a href="evtouch-0.8.0.tar.gz">evtouch-0.8.0.tar.gz</a></td>
+  </tr>
+  <tr>
+    <td>X driver sources V0.8.6</td>
+    <td><a href="xf86-input-evtouch-0.8.6.tar.bz2">xf86-input-evtouch-0.8.6.tar.bz2</a></td>
+  </tr>
+  <tr>
+    <td>X driver sources V0.8.5</td>
+    <td><a href="xf86-input-evtouch-0.8.5.tar.bz2">xf86-input-evtouch-0.8.5.tar.bz2</a></td>
+  </tr>
+  <tr>
+    <td>X driver sources V0.8.4</td>
+    <td><a href="xf86-input-evtouch-0.8.4.tar.bz2">xf86-input-evtouch-0.8.4.tar.bz2</a></td>
+  </tr>
+  <tr>
+    <td>X driver sources V0.8.3</td>
+    <td><a href="xf86-input-evtouch-0.8.3.tar.bz2">xf86-input-evtouch-0.8.3.tar.bz2</a></td>
+  </tr>
+  <tr>
+    <td>X driver sources V0.8.1</td>
+    <td><a href="xf86-input-evtouch-0.8.1.tar.bz2">xf86-input-evtouch-0.8.1.tar.bz2</a></td>
+  </tr>
+  <tr>
+    <td>X driver sources V0.8.0</td>
+    <td><a href="evtouch-0.8.0-src.tar.gz">evtouch-0.8.0-src.tar.gz</a></td>
+  </tr>
+</table>
+<a href="evtouch_old.html">Older (obsolete) versions</a> of the evtouch-driver
+can be downloaded <a href="./evtouch_old.html#download">here</a>
+</body>
+</html>
--- xf86-input-evtouch-0.8.8.orig/debian/patches/02-buttonless-device.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/02-buttonless-device.patch
@@ -0,0 +1,86 @@
+Index: xf86-input-evtouch-0.8.3.dirty/evtouch.c
+===================================================================
+--- xf86-input-evtouch-0.8.3.dirty.orig/evtouch.c	2007-02-19 18:28:41.749371445 +0100
++++ xf86-input-evtouch-0.8.3.dirty/evtouch.c	2007-02-19 20:14:50.612312260 +0100
+@@ -364,9 +364,15 @@ void EVTouchLBRBEvent(EVTouchPrivatePtr 
+ void EVTouchProcessKey(EVTouchPrivatePtr priv)
+ {
+         struct input_event *ev; /* packet being/just read */
++        ev = &priv->ev;
+ 
+         DBGOUT(2, "EVTouch: %s\n", __FUNCTION__);
+-        ev = &priv->ev;
++
++	/* for buttonless devices no emulate3 is available,
++	   only go through the SM */
++	if (priv->buttonless)
++		return;
++
+         if ( (ev->code == BTN_LEFT) || 
+              (ev->code == BTN_RIGHT) ||
+              (ev->code == BTN_MIDDLE) ) {
+@@ -688,6 +694,8 @@ static void ReadInput (LocalDevicePtr lo
+         while (EVTouchGetPacket (priv) == Success)
+         {
+                 ev = &priv->ev;
++		DBGOUT(2, "EVTouch: %s type:%0.2x code: 0x%0.4x value:%d\n",
++				__FUNCTION__, ev->type, ev->code, ev->value);
+ 
+                 xf86XInputSetScreen(local, 
+                                     priv->screen_num, 
+@@ -708,7 +716,8 @@ static void ReadInput (LocalDevicePtr lo
+                         EVTouchProcessRel(priv);
+                         break;
+ 		case EV_KEY:
+-			if (priv->ev.code == BTN_TOUCH) {
++			if (priv->ev.code == BTN_TOUCH
++					|| priv->buttonless) {
+ 				if (priv->ev.value == 1) {
+ 					priv->touch_flags |= TOUCHED;
+ 					DBGOUT(2, "EVTouch: TOUCHED\n");
+Index: xf86-input-evtouch-0.8.3.dirty/libtouch.c
+===================================================================
+--- xf86-input-evtouch-0.8.3.dirty.orig/libtouch.c	2007-02-19 18:28:41.749371445 +0100
++++ xf86-input-evtouch-0.8.3.dirty/libtouch.c	2007-02-19 20:02:36.070453105 +0100
+@@ -320,6 +320,14 @@ static int handle_touched(LibTouchRecPtr
+ static void enter_moving(LibTouchRecPtr priv)
+ {
+         disable_timers(priv);
++	if (priv->pen == PEN_TOUCHED) {
++		DBG(4, ErrorF("LibTouch: Issuing Button-press 1\n"));
++		xf86PostButtonEvent(priv->local->dev, TRUE,
++				1, 1, 0, 2,
++				priv->cur_x,
++				priv->cur_y);
++		priv->pressed_btn_stat |= 1 << 1;
++	}
+ }
+ 
+ 
+@@ -336,13 +344,13 @@ static void enter_longtouched(LibTouchRe
+ {
+         disable_timers(priv);
+         /* FIXME: Make Longtouch-Event configurable*/
+-        /* for now issue an LB down */
+-        DBG(4, ErrorF("LibTouch: Issuing Button-press 1\n"));
++        /* for now issue an RB down */
++        DBG(4, ErrorF("LibTouch: Issuing Button-press 3\n"));
+         xf86PostButtonEvent(priv->local->dev, TRUE,
+-                            1, 1, 0, 2,
++                            3, 1, 0, 2,
+                             priv->cur_x, 
+                             priv->cur_y);
+-        priv->pressed_btn_stat |= 1 << 1;
++        priv->pressed_btn_stat |= 1 << 3;
+ }
+ 
+ 
+@@ -515,7 +523,7 @@ static int handle_oneandahalftap(LibTouc
+ 
+                 /* FIXME: Make OneAndHalf-Event configurable */
+                 /* for now RB down */
+-                DBG(4, ErrorF("LibTouch: Issuing Button-press 1\n"));
++                DBG(4, ErrorF("LibTouch: Issuing Button-press 3\n"));
+                 xf86PostButtonEvent (priv->local->dev, TRUE,
+                                      3, 1, 0, 2, 
+                                      priv->cur_x, 
--- xf86-input-evtouch-0.8.8.orig/debian/patches/20_fix_calibrate_submission_directions.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/20_fix_calibrate_submission_directions.patch
@@ -0,0 +1,13 @@
+Index: xf86-input-evtouch-0.8.8/calibrate.sh
+===================================================================
+--- xf86-input-evtouch-0.8.8.orig/calibrate.sh	2009-01-14 14:14:10.000000000 +0100
++++ xf86-input-evtouch-0.8.8/calibrate.sh	2009-01-14 14:14:51.000000000 +0100
+@@ -25,7 +25,7 @@
+ FAILINFO="No evtouch capable device found, if you are sure you have \n\
+ an evtouch capable touchscreen, please mail the \
+ resulting file of the command \"lshal > evtouch_hal.out\" to the\n\
+-ubuntu-mobile@lists.ubuntu.com mailing list, so support for your \
++bug url https://bugs.launchpad.net/bugs/317094, so support for your \
+ device can be added."
+ 
+ if [ -z "$UDI" ];then
--- xf86-input-evtouch-0.8.8.orig/debian/patches/05_build_with_1_4.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/05_build_with_1_4.patch
@@ -0,0 +1,22 @@
+Index: xserver-xorg-input-evtouch/evtouch.c
+===================================================================
+--- xserver-xorg-input-evtouch.orig/evtouch.c	2007-09-17 17:20:21.736761738 +0900
++++ xserver-xorg-input-evtouch/evtouch.c	2007-09-17 17:31:22.274403633 +0900
+@@ -492,9 +492,6 @@ DeviceOn (DeviceIntPtr dev)
+ 
+         priv->buffer = XisbNew(local->fd, 64);
+ 
+-        DBG (9, XisbTrace (priv->buffer, 1));
+-
+-
+         if (!priv->buffer) 
+         {
+                 xf86CloseSerial(local->fd);
+@@ -1207,7 +1204,6 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+                     priv->diff[i][0], priv->diff[i][1]);
+         }
+         
+-        xf86AlwaysCore(local, TRUE);
+         priv->touch_flags = 0;
+ 
+         local->history_size = xf86SetIntOption( local->options, "HistorySize", 0 );
--- xf86-input-evtouch-0.8.8.orig/debian/patches/10_ev_calibrate_fixups.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/10_ev_calibrate_fixups.patch
@@ -0,0 +1,55 @@
+Index: xf86-input-evtouch-0.8.7/ev_calibrate.c
+===================================================================
+--- xf86-input-evtouch-0.8.7.orig/ev_calibrate.c	2008-09-25 01:13:32.000000000 +0200
++++ xf86-input-evtouch-0.8.7/ev_calibrate.c	2008-09-25 01:13:43.000000000 +0200
+@@ -198,7 +198,7 @@
+         Pixmap cursor_pic;
+         XColor cursor_fg, cursor_bg;
+         XFontStruct* font_info;
+-        char* font_name = "*fixed*";
++        char* font_name = "*freemono*";
+         char str[256];   
+         unsigned int cursor_width, cursor_height;
+         int hotspot_x, hotspot_y;
+@@ -234,7 +234,7 @@
+         unsigned long black_pixel;
+ 
+ 
+-        display = XOpenDisplay(":0");
++        display = XOpenDisplay(getenv("DISPLAY"));
+         if (display == NULL) {
+                 fprintf(stderr, "Cannot connect to X server %s\n", ":0");
+                 exit(-1);
+@@ -553,7 +553,7 @@
+         /*
+           Put results to file and screen
+         */
+-        out_file = fopen("out.txt", "w");
++        out_file = fopen("/etc/evtouch/config", "w");
+         
+ 
+         /* 
+@@ -566,10 +566,10 @@
+                min_max.max_x, 
+                min_max.max_y);
+ 
+-        fprintf(out_file, "        Option        \"MinX\"        \"%d\"\n", min_max.min_x);
+-        fprintf(out_file, "        Option        \"MinY\"        \"%d\"\n", min_max.min_y);
+-        fprintf(out_file, "        Option        \"MaxX\"        \"%d\"\n", min_max.max_x);
+-        fprintf(out_file, "        Option        \"MaxY\"        \"%d\"\n", min_max.max_y);
++        fprintf(out_file, "MINX=\"%d\"\n", min_max.min_x);
++        fprintf(out_file, "MINY=\"%d\"\n", min_max.min_y);
++        fprintf(out_file, "MAXX=\"%d\"\n", min_max.max_x);
++        fprintf(out_file, "MAXY=\"%d\"\n", min_max.max_y);
+ 
+ 
+         for (i=0; i<9; i++) {
+@@ -602,7 +602,7 @@
+                        i, marker_coordinates[i][1]-click_coordinates[i][1]);
+ 
+ 
+-                fprintf(out_file, "        Option        \"x%d\"        \"%d\"\n        Option        \"y%d\"        \"%d\"\n",
++                fprintf(out_file, "X%d=\"%d\"\nY%d=\"%d\"\n",
+                         i, marker_coordinates[i][0]-click_coordinates[i][0],
+                         i, marker_coordinates[i][1]-click_coordinates[i][1]);
+         }
--- xf86-input-evtouch-0.8.8.orig/debian/patches/series
+++ xf86-input-evtouch-0.8.8/debian/patches/series
@@ -0,0 +1,11 @@
+#02-buttonless-device.patch
+#03_fix_compile_warns.patch
+#04_include_xf86_ansic_h.patch
+#05_build_with_1_4.patch
+#06_xf86-input-evtouch-0.8.7-misc.patch
+#07_random_fixes_for_06.patch
+#08_fix_xf86memset.patch
+#09_calibrate-script-halification.patch
+#10_ev_calibrate_fixups.patch
+20_fix_calibrate_submission_directions.patch
+21_more_calibration_fixups.patch
--- xf86-input-evtouch-0.8.8.orig/debian/patches/06_xf86-input-evtouch-0.8.7-misc.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/06_xf86-input-evtouch-0.8.7-misc.patch
@@ -0,0 +1,770 @@
+#
+# This patch is from http://www.postnuklear.de/xorg-patches/
+#
+# Description: This is a patch for the evtouch input driver (
+#              http://stz-softwaretechnik.com/~ke/touchscreen/evtouch.html).
+# Changes (for full description see ChangeLog file after patching (-: ):
+#   o Changed code to compile a working driver for both XInput ABI 0.x and 2.0 (Xorg 1.4.0)
+#   o changed rotation (due to segfault on xorg + fbdev)
+#   o drag support
+#   o tap "tolerance"
+#   o added generic ts-adc touchscreen device to udev rules file
+#
+# Feel free to send comments, critics, suggestions to harryrat@postnuklear.de
+# To apply simply change into the toplevel directory of the source to be modified and enter:
+# patch -p1 < <PATH_TO_PATCH>
+# 
+# All patches are available under the GNU GPL, I hope they might be useful for you (-:
+# - Harald Radke  
+#
+Index: xserver-xorg-input-evtouch/69-touchscreen.rules
+===================================================================
+--- xserver-xorg-input-evtouch.orig/69-touchscreen.rules	2008-02-02 21:49:20.783972805 +0900
++++ xserver-xorg-input-evtouch/69-touchscreen.rules	2008-02-02 21:49:39.730979724 +0900
+@@ -7,8 +7,11 @@
+ # Name can be found in /proc/bus/input/devices ('cat /proc/bus/input/devices')
+ #
+ 
+-# These are the touchscreens supported by kernel's "usbtouchscreen" module
++# Generic ts-adc touchscreen modules
++KERNEL=="event*", SUBSYSTEM=="input", ATTRS{name}=="ts-adc", SYMLINK+="input/evtouch_event"
++
+ 
++# These are the touchscreens supported by kernel's "usbtouchscreen" module
+ # eGalax Inc. USB TouchController)
+ KERNEL=="event*", SUBSYSTEM=="input", ATTRS{idVendor}=="3823", ATTRS{idProduct}=="0001", SYMLINK+="input/evtouch_event"
+ # eGalax Inc. USB TouchController)
+Index: xserver-xorg-input-evtouch/ChangeLog
+===================================================================
+--- xserver-xorg-input-evtouch.orig/ChangeLog	2008-02-02 21:49:20.795972782 +0900
++++ xserver-xorg-input-evtouch/ChangeLog	2008-02-02 21:49:39.730979724 +0900
+@@ -1,3 +1,61 @@
++0.8.7-HR *** Note this is not an official release but an "unauthorized
++	 *** fix version by me (Harald Radke - harryrat@postnuklear.de)
++	-> Changed code to compile a working driver for  both 
++	  XInput ABI 0.x and 2.0 (Xorg 1.4.0)
++	  (test compile for 0.x still needs to be done)
++	  - evtouch.c: 
++            * capsulated xf86Post*Events and xf86InputSetScreen 
++	      in functions where depending on the XINPUT ABI conversion
++	      is done or xf86 functions are directly called
++	    * xf86InitValuatorAxisStruct and xf86AlwaysCore() depending
++	      on ABI done
++	  - libtouch.h: passing xf86PostButtonEvent capsulation function
++	    to init function (same as in evtouch.c) to do proper button
++	    triggering
++	-> Rotation:
++	  - added support for Option "Rotate" "UD" (upside down) 
++	     in evtouch input section of xorg.conf
++	  - due to Segfault with (at least) fbdev video device, only
++	    evtouch "Rotate" option is taken into calculations for coords,
++	    meaning to get proper touchscreen behaviour on rotated X screens.
++	    same Rotate option as in video device section of xorg.conf has
++            to be set in the evtouch section
++	-> Drag support:
++	  Option "<STATE>_drag" "<BUTTON_ID>" has been added. When set,
++	  the handle_<STATE>() function triggers BUTTON_DOWN for Button <BUTTON_ID>
++	  before changing into S_MOVE state. Note that actually only
++	  Option "touched_drag" "<BUTTON_ID>" is implemented, rest is dummy
++	  (and doesn't make too much sense I guess) (-;
++	-> tap "tolerance":
++	   introduce move_limit to evtouch.c as it is in libtouch.c, using it
++	   to discard ABS_X/Y position changes if they are inside move_limit
++	   around cur_x/y. this way pointer hopping can be avoided as well as
++           proper touched_drag established
++         - changes of cur_x/y are reported on EV_SYN in evtouch.c ReadInput() instead
++           on EV_ABS
++	-> added generic ts-adc touchscreen device to udev rules file	   
++
++	=>  Example for a Loox720 PDA setup in input section of xorg.conf:
++		Section "InputDevice"
++		 Identifier "touchscreen"
++		 Driver "evtouch"
++		 Option "Device" "/dev/input/evtouch_event"
++		 Option "MinX" "434"
++		 Option "MinY" "333"
++		 Option "MaxX" "3643"
++		 Option "MaxY" "3804"
++		 Option "SwapX" "true"
++		 Option "longtouched_action" "down"
++		 Option "longtouched_button" "3"
++		 Option "maybetapped_action" "click"
++		 Option "maybetapped_button" "1"
++		 Option "touched_drag" "1"
++		 Option "oneandahalftap_button" "0"
++		 Option "TapTimer" "30"
++		 Option "LongtouchTimer"  "500"
++		 Option "MoveLimit"  "18"
++		EndSection
++
+ 0.8.7
+ 	- Added Elo Touchscreen to udev-rules (Stephen Webb)
+ 	- Added "fix" for AMD64-crashes on touch (Martin Letenay)
+Index: xserver-xorg-input-evtouch/evtouch.c
+===================================================================
+--- xserver-xorg-input-evtouch.orig/evtouch.c	2008-02-02 21:49:20.811973497 +0900
++++ xserver-xorg-input-evtouch/evtouch.c	2008-02-02 21:49:39.734971242 +0900
+@@ -182,6 +182,20 @@ static const char *default_options[] =
+ static int
+ ControlProc(LocalDevicePtr device, xDeviceCtl *ctrl);
+ 
++static void 
++PostMotionEvent(LocalDevicePtr local);
++
++static void 
++PostProximityEvent(LocalDevicePtr local,int is_in);
++
++static void 
++PostButtonEvent(LocalDevicePtr local, int button,
++		    	 int is_down, int x,int y);
++
++static void 
++InputSetScreen(LocalDevicePtr local);
++
++
+ /*****************************************************************************
+  *        Function Definitions
+  ****************************************************************************/
+@@ -197,11 +211,10 @@ emulate3Timer(OsTimerPtr timer, CARD32 n
+         LocalDevicePtr local = (LocalDevicePtr)_local;
+         EVTouchPrivatePtr priv = (EVTouchPrivatePtr) local->private;
+ 
++
+         sigstate = xf86BlockSIGIO();
+ 
+-        xf86PostMotionEvent(local->dev, TRUE, 0, 2, 
+-                            priv->cur_x, 
+-                            priv->cur_y);
++        PostMotionEvent(local);
+ 
+         /* 
+          * Emit a button press -- release is handled in EVTouchLBRBEvent
+@@ -209,31 +222,21 @@ emulate3Timer(OsTimerPtr timer, CARD32 n
+         if ( ( priv->touch_flags & LB_STAT ) &&
+              !( priv->touch_flags & RB_STAT ) ) {
+                 DBGOUT(2, "EVTouch: Left Press\n");
+-                xf86PostButtonEvent (local->dev, TRUE,
+-                                     1, 1, 0, 2, 
+-                                     priv->cur_x, 
+-                                     priv->cur_y);
++                PostButtonEvent (local, 1, 1,priv->cur_x,priv->cur_y);
+         }
+ 
+         if ( ( priv->touch_flags & RB_STAT ) &&
+              !( priv->touch_flags & LB_STAT ) ) {
+                 DBGOUT(2, "EVTouch: Right Press\n");
+-                xf86PostButtonEvent (local->dev, TRUE,
+-                                     3, 1, 0, 2, 
+-                                     priv->cur_x, 
+-                                     priv->cur_y);
+-        }
+-
++                PostButtonEvent (local, 3, 1,priv->cur_x,priv->cur_y);
++	}
+         /*
+           Handling "middle" button press
+         */
+         if ( ( priv->touch_flags & RB_STAT ) &&
+              ( priv->touch_flags & LB_STAT ) ) {
+                 DBGOUT(2, "EVTouch: Middle Press\n");
+-                xf86PostButtonEvent (local->dev, TRUE,
+-                                     2, 1, 0, 2, 
+-                                     priv->cur_x, 
+-                                     priv->cur_y);
++                PostButtonEvent (local, 2, 1,priv->cur_x,priv->cur_y);
+         }
+ 
+         priv->emulate3_timer_expired = TRUE;
+@@ -246,6 +249,7 @@ static void DoBtnAction(EVTouchPrivatePt
+ {
+         int btn = 0;
+         LocalDevicePtr local = priv->local;
++
+         DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__, priv->btn_count);
+ 
+         for (btn = 0; btn < priv->btn_count; btn++) {
+@@ -262,12 +266,7 @@ static void DoBtnAction(EVTouchPrivatePt
+                         DBGOUT(2, "EVTouch: %s btn = %d action = %d\n", 
+                                __FUNCTION__, btn, 
+                                priv->btn_actions[btn].action);
+-
+-                        xf86PostButtonEvent (local->dev, TRUE, btn, 
+-                                             priv->btn_actions[btn].action, 
+-                                             0, 2,
+-                                             priv->cur_x,
+-                                             priv->cur_y);
++			PostButtonEvent (local, btn, priv->btn_actions[btn].action,priv->cur_x,priv->cur_y);                        
+ 
+                         priv->btn_actions[btn].do_it  = 0;
+                         priv->btn_actions[btn].action = 0;
+@@ -292,39 +291,32 @@ void EVTouchProcessAbs(EVTouchPrivatePtr
+         ev = &priv->ev;
+ 
+         if ( (ev->code == ABS_X) || (ev->code == ABS_Z) ) {
++ 		if ((priv->cur_x - ev->value < priv->move_limit)
++                        && (priv->cur_x - ev->value > -priv->move_limit))
++                        return;
+                 priv->cur_x = ev->value;
+-		libtouchSetXPos(priv->libtouch, priv->cur_x);
++//		libtouchSetXPos(priv->libtouch, priv->cur_x);
+ 	}
+ 
+         if ( (ev->code == ABS_Y) || (ev->code == ABS_RX) ) {
++		if ((priv->cur_y - ev->value < priv->move_limit)
++                        && (priv->cur_y - ev->value > -priv->move_limit))
++                        return;
+                 priv->cur_y = ev->value;
+-		libtouchSetYPos(priv->libtouch, priv->cur_y);
++//		libtouchSetYPos(priv->libtouch, priv->cur_y);
+ 	}
+ 
+ 	if (ev->code == ABS_WHEEL) {
+ 		LocalDevicePtr local = priv->local;
+-
+ 		if (ev->value > 0) {
+ 			for (; ev->value > 0; ev->value--) {
+-				xf86PostButtonEvent (local->dev, TRUE,
+-						     4, 1, 0, 2, 
+-						     priv->cur_x, 
+-						     priv->cur_y);
+-				xf86PostButtonEvent (local->dev, TRUE,
+-						     4, 0, 0, 2, 
+-						     priv->cur_x, 
+-						     priv->cur_y);
++				PostButtonEvent (local, 4,1,priv->cur_x,priv->cur_y);
++				PostButtonEvent (local, 4,0,priv->cur_x,priv->cur_y);
+ 			}
+ 		} else if (ev->value < 0) {
+ 			for (ev->value = -ev->value; ev->value > 0; ev->value--) {
+-				xf86PostButtonEvent (local->dev, TRUE,
+-						     5, 1, 0, 2, 
+-						     priv->cur_x, 
+-						     priv->cur_y);
+-				xf86PostButtonEvent (local->dev, TRUE,
+-						     5, 0, 0, 2, 
+-						     priv->cur_x, 
+-						     priv->cur_y);
++				PostButtonEvent (local, 5,1,priv->cur_x,priv->cur_y);
++				PostButtonEvent (local, 5,0,priv->cur_x,priv->cur_y);
+ 			}
+ 		}			
+ 	}
+@@ -451,10 +443,7 @@ void EVTouchProcessKey(EVTouchPrivatePtr
+         default:
+                 return;
+         }
+-        xf86PostButtonEvent(local->dev, TRUE,
+-                            btn, ev->value, 0, 2, 
+-                            priv->cur_x, 
+-                            priv->cur_y);
++	PostButtonEvent (local, btn, ev->value,priv->cur_x,priv->cur_y);
+ #endif
+ 
+         return;
+@@ -492,8 +481,8 @@ DeviceOn (DeviceIntPtr dev)
+ 
+         priv->buffer = XisbNew(local->fd, 64);
+ 
+-        DBG (9, XisbTrace (priv->buffer, 1));
+-
++// breaks compilation
++//        DBG (9, XisbTrace (priv->buffer, 1));
+ 
+         if (!priv->buffer) 
+         {
+@@ -637,8 +626,19 @@ DeviceInit (DeviceIntPtr dev)
+                 ErrorF ("Unable to allocate EVTouch touchscreen ValuatorClassDeviceStruct\n");
+                 return !Success;
+         }
+-
+-        xf86InitValuatorAxisStruct(dev, 0, priv->min_x, priv->max_x,
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
++        xf86InitValuatorAxisStruct(dev, 0, 0, priv->screen_width,
++                                   1024,
++                                   EV_AXIS_MIN_RES /* min_res */ ,
++                                   EV_AXIS_MAX_RES /* max_res */ );
++        xf86InitValuatorDefaults(dev, 0);
++        xf86InitValuatorAxisStruct(dev, 1, 0, priv->screen_height,
++                                   1024,
++                                   EV_AXIS_MIN_RES /* min_res */ ,
++                                   EV_AXIS_MAX_RES /* max_res */ );
++        xf86InitValuatorDefaults(dev, 1);
++#else
++	xf86InitValuatorAxisStruct(dev, 0, priv->min_x, priv->max_x,
+                                    1024,
+                                    EV_AXIS_MIN_RES /* min_res */ ,
+                                    EV_AXIS_MAX_RES /* max_res */ );
+@@ -648,7 +648,7 @@ DeviceInit (DeviceIntPtr dev)
+                                    EV_AXIS_MIN_RES /* min_res */ ,
+                                    EV_AXIS_MAX_RES /* max_res */ );
+         xf86InitValuatorDefaults(dev, 1);
+-
++#endif
+         /* Initial position of pointer on screen: Centered */
+         priv->cur_x=(priv->max_x - priv->min_x)/2;
+         priv->cur_y=(priv->max_y - priv->min_y)/2;
+@@ -777,14 +777,8 @@ static void ReadInput (LocalDevicePtr lo
+ 		DBGOUT(2, "EVTouch: %s type:%0.2x code: 0x%0.4x value:%d\n",
+ 			__FUNCTION__, ev->type, ev->code, ev->value);
+ 
+-                xf86XInputSetScreen(local, 
+-                                    priv->screen_num, 
+-                                    priv->cur_x, 
+-                                    priv->cur_y);
+-                        
+-                xf86PostProximityEvent(local->dev, 1, 0, 2,
+-                                       priv->cur_x,
+-                                       priv->cur_y);
++		InputSetScreen(local);
++		PostProximityEvent (local,1);
+ 
+                 switch (ev->type) {
+                 case EV_ABS:
+@@ -794,9 +788,7 @@ static void ReadInput (LocalDevicePtr lo
+                         EVTouchProcessRel(priv);
+                         break;
+ 		case EV_KEY:
+-                        xf86PostMotionEvent (local->dev, TRUE, 0, 2, 
+-                                             priv->cur_x,
+-                                             priv->cur_y);
++			PostMotionEvent (local);
+ 
+ 			if (priv->ev.code == BTN_TOUCH) {
+ 				if (priv->ev.value == 1) {
+@@ -811,9 +803,8 @@ static void ReadInput (LocalDevicePtr lo
+                         EVTouchProcessKey(priv);
+ 			break;
+ 		case EV_SYN:
+-                        xf86PostMotionEvent (local->dev, TRUE, 0, 2, 
+-                                             priv->cur_x,
+-                                             priv->cur_y);
++			libtouchSetPos(priv->libtouch, priv->cur_x,priv->cur_y);
++			PostMotionEvent (local);
+ 
+ 			if ( priv->touch_flags & TOUCHED )
+ 				libtouchTriggerSM(priv->libtouch, PEN_TOUCHED);
+@@ -902,7 +893,9 @@ ConvertProc ( LocalDevicePtr local,
+ 
+         EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);  
+ 	ScrnInfoPtr pScrn = xf86Screens[priv->screen_num];
+-	Rotation rotation = RRGetRotation(pScrn->pScreen);
++
++// X Segfaults
++//	Rotation rotation = RRGetRotation(pScrn->pScreen);
+ 
+         DBGOUT(2, "EVTouch: FIRST: v0=%d   v1=%d\n", v0, v1);
+ 
+@@ -921,15 +914,17 @@ ConvertProc ( LocalDevicePtr local,
+                 max_x = priv->max_x - priv->min_x;
+                 max_y = priv->max_y - priv->min_y;
+ 
+-                if (priv->rotate == EV_ROTATE_NONE) {
++
++//                if (priv->rotate == EV_ROTATE_NONE) {
+                         screen_width  = pScrn->currentMode->HDisplay;
+                         screen_height = pScrn->currentMode->VDisplay;
++/* Swapping is done below in Coords! Leave those to be able to calc correct mapping
+                 } else {
+                         screen_width  = pScrn->currentMode->VDisplay;
+                         screen_height = pScrn->currentMode->HDisplay;
+                 }
+ 
+-
++*/
+                 if (xc < (max_x / 2)) {
+                         /*
+                           left
+@@ -1042,45 +1037,57 @@ ConvertProc ( LocalDevicePtr local,
+ 
+                 int tmp = 0;
+                 /* rotation mixes x and y up a bit */
+-                if (priv->rotate == EV_ROTATE_CW) {
++		switch(priv->rotate) {
++		case EV_ROTATE_CW:
+                         tmp = xc;
+                         xc = yc;
+                         yc = screen_width - tmp;
+-                } else if (priv->rotate == EV_ROTATE_CCW) {
++		break;
++                case EV_ROTATE_CCW:
+                         tmp = xc;
+                         xc = screen_height - yc;
+                         yc = tmp;
++		break;
++		case EV_ROTATE_UD:
++			xc = screen_width - xc;
++			yc = screen_height - yc;
++		break;
++		default:
++		break;
+                 }
+ 
+-		switch (rotation) {
+-			case RR_Rotate_0:
++/* X Segfaults on rotation setting
++                switch (rotation) {
++                        case RR_Rotate_0:
+                                 v0 = xc;
+                                 v1 = yc;
+-				break;
+-			case RR_Rotate_180:
+-				v0 = screen_width - xc;
+-				v1 = screen_height - yc;
+-				break;
+-			case RR_Rotate_90:
++                                break;
++                        case RR_Rotate_180:
++                                v0 = screen_width - xc;
++                                v1 = screen_height - yc;
++                                break;
++                        case RR_Rotate_90:
+                                 tmp = xc;
+-				v0  = screen_height - yc;
++                                v0  = screen_height - yc;
+                                 v1  = tmp;
+-				break;
+-			case RR_Rotate_270:
++                                break;
++                        case RR_Rotate_270:
+                                 tmp = xc;
+-				v0 = yc;
+-				v1 = screen_width - tmp;
+-				break;
+-			default:
+-				break;
+-		}
++                                v0 = yc;
++                                v1 = screen_width - tmp;
++                                break;
++                        default:
++                                break;
++                }
++
++
++*/
+         }
+ 
+         DBGOUT(2, "EVTouch: FINAL: v0=%d   v1=%d\n", v0, v1);
+ 
+-        *x = v0;
+-        *y = v1;
+-
++        *x = xc;
++        *y = yc;
+         return (TRUE);
+ }
+ 
+@@ -1133,8 +1140,9 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+ 
+         xf86OptionListReport(local->options);
+ 
++
+ 	priv->libtouch = xcalloc(1, sizeof(LibTouchRec));
+-	libtouchInit(priv->libtouch, local);
++	libtouchInit(priv->libtouch, local,PostButtonEvent);
+ 
+         priv->screen_num    = xf86SetIntOption(local->options, "ScreenNumber", 0 );
+ 
+@@ -1164,9 +1172,9 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+         timeo = xf86SetIntOption(local->options, "LongtouchTimer", 160);
+         libtouchSetLongtouchTimeo(priv->libtouch, timeo);
+ 
+-        libtouchSetMoveLimit(priv->libtouch, 
+-                             xf86SetIntOption( local->options, 
+-                                               "MoveLimit", 180 ));
++	priv->move_limit = xf86SetIntOption( local->options,
++                                               "MoveLimit", 180 );
++        libtouchSetMoveLimit(priv->libtouch, priv->move_limit);
+ 
+         priv->rotate     = EV_ROTATE_NONE;
+         s = xf86FindOptionValue(local->options, "Rotate");
+@@ -1175,7 +1183,11 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+                         priv->rotate = EV_ROTATE_CW;                           
+                 } else if (xf86NameCmp(s, "CCW") == 0 ) {
+                         priv->rotate = EV_ROTATE_CCW;
+-                } 
++                }  else if (xf86NameCmp(s, "UD") == 0 ) {
++                        priv->rotate = EV_ROTATE_UD;
++                }
++
++ 
+         }
+ 
+         if (priv->rotate == EV_ROTATE_NONE) {
+@@ -1207,9 +1219,10 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+                     priv->diff[i][0], priv->diff[i][1]);
+         }
+         
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
+         xf86AlwaysCore(local, TRUE);
++#endif
+         priv->touch_flags = 0;
+-
+         local->history_size = xf86SetIntOption( local->options, "HistorySize", 0 );
+ 
+         /* prepare to process touch packets */
+@@ -1232,6 +1245,7 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+ 
+         xf86CloseSerial(local->fd);
+         local->fd = -1;
++
+         return (local);
+ }
+ 
+@@ -1243,3 +1257,58 @@ EVTouchPtrCtrl(DeviceIntPtr device, PtrC
+      Ho Hum.
+   */
+ }
++
++
++static void
++PostMotionEvent(LocalDevicePtr local) {
++int cur_x, cur_y;
++EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);
++
++ cur_x = priv->cur_x;
++ cur_y = priv->cur_y;
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
++ ConvertProc(local,0,2,priv->cur_x,priv->cur_y,0,0,0,0,&cur_x,&cur_y);
++#endif
++
++xf86PostMotionEvent (local->dev, TRUE, 0, 2, cur_x, cur_y);
++}
++
++static void
++PostProximityEvent(LocalDevicePtr local, int is_in) {
++int cur_x, cur_y;
++EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);
++
++ cur_x = priv->cur_x;
++ cur_y = priv->cur_y;
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
++ ConvertProc(local,0,2,priv->cur_x,priv->cur_y,0,0,0,0,&cur_x,&cur_y);
++#endif
++
++xf86PostProximityEvent(local->dev, is_in, 0, 2, cur_x,cur_y);
++}
++
++static void
++PostButtonEvent(LocalDevicePtr local, int button, int is_down,int x, int y) {
++EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);
++
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
++ ConvertProc(local,0,2,x,y,0,0,0,0,&x,&y);
++#endif
++
++xf86PostButtonEvent (local->dev, TRUE, button, is_down, 0, 2, x, y);
++}
++
++
++static void InputSetScreen(LocalDevicePtr local) {
++int cur_x, cur_y;
++EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);
++
++ cur_x = priv->cur_x;
++ cur_y = priv->cur_y;
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
++ ConvertProc(local,0,2,priv->cur_x,priv->cur_y,0,0,0,0,&cur_x,&cur_y);
++#endif
++
++xf86XInputSetScreen(local,priv->screen_num,cur_x,cur_y);
++}
++
+Index: xserver-xorg-input-evtouch/evtouch.h
+===================================================================
+--- xserver-xorg-input-evtouch.orig/evtouch.h	2008-02-02 21:49:20.823984091 +0900
++++ xserver-xorg-input-evtouch/evtouch.h	2008-02-02 21:49:39.734971242 +0900
+@@ -42,6 +42,7 @@
+ #define EV_ROTATE_NONE 0
+ #define EV_ROTATE_CW   1
+ #define EV_ROTATE_CCW  2
++#define EV_ROTATE_UD  3
+ 
+ #define EV_AXIS_MIN_RES       0
+ #define EV_AXIS_MAX_RES       1024
+@@ -80,6 +81,7 @@ typedef struct _EVTouchPrivateRec
+         int max_rel_y;  /* Maximum y                    */
+ 
+         int drag_timer;
++	int move_limit;
+         Bool emulate3;
+         int emulate3_timeout;
+         OsTimerPtr emulate3_timer;
+@@ -138,6 +140,7 @@ typedef struct _EVTouchPrivateRec
+ 
+         LibTouchRecPtr libtouch;
+         LocalDevicePtr local;
++
+ } EVTouchPrivateRec, *EVTouchPrivatePtr;
+ 
+ 
+Index: xserver-xorg-input-evtouch/libtouch.c
+===================================================================
+--- xserver-xorg-input-evtouch.orig/libtouch.c	2008-02-02 21:49:36.899983517 +0900
++++ xserver-xorg-input-evtouch/libtouch.c	2008-02-02 21:49:39.734971242 +0900
+@@ -52,6 +52,7 @@ typedef struct state {
+         int  (*handle_state)(LibTouchRecPtr priv);
+         void (*action)(LibTouchRecPtr priv, int btn, int x, int y);
+         int btn;
++	int drag_btn;
+ } state_t;
+ 
+ 
+@@ -68,16 +69,14 @@ typedef enum states {
+ static void btn_down_action(LibTouchRecPtr priv, int btn, int x, int y)
+ {
+         DBG(4, ErrorF("LibTouch: Issuing Button %d down\n", btn));
+-        xf86PostButtonEvent(priv->local->dev, TRUE,
+-                            btn, 1, 0, 2, x, y);
++        priv->post_button_proc(priv->local,btn, 1,x,y);
+         priv->pressed_btn_stat |= 1 << btn;
+ }
+ 
+ static void btn_up_action(LibTouchRecPtr priv, int btn, int x, int y)
+ {
+         DBG(4, ErrorF("LibTouch: Issuing Button %d up\n", btn));
+-        xf86PostButtonEvent(priv->local->dev, TRUE,
+-                            btn, 0, 0, 2, x, y);
++        priv->post_button_proc(priv->local,btn, 0,x,y);
+         priv->pressed_btn_stat &= ~(1 << btn);
+ }
+ 
+@@ -103,13 +102,13 @@ static int handle_oneandahalftap(LibTouc
+ static void dump_configuration();
+ 
+ state_t state_ar[] = {
+-        {enter_untouched, handle_untouched, NULL, 0},
+-        {enter_touched, handle_touched, NULL, 0},
+-        {enter_longtouched, handle_longtouched, btn_down_action, 1},
+-        {enter_moving, handle_moving, NULL, 0},
+-        {enter_maybetap, handle_maybetap, btn_click_action, 1},
+-        {enter_oneandahalftap, handle_oneandahalftap, btn_down_action, 3},
+-        {NULL, NULL, NULL, -1},
++        {enter_untouched, handle_untouched, NULL, 0,-1},
++        {enter_touched, handle_touched, NULL, 0,-1},
++        {enter_longtouched, handle_longtouched, btn_down_action, 1,-1},
++        {enter_moving, handle_moving, NULL, 0,-1},
++        {enter_maybetap, handle_maybetap, btn_click_action, 1,-1},
++        {enter_oneandahalftap, handle_oneandahalftap, btn_down_action, 3,-1},
++        {NULL, NULL, NULL, -1,-1},
+ };
+ 
+ char *state_str[] = {
+@@ -142,6 +141,16 @@ char *state_button_str[] = {
+           NULL,
+ };
+ 
++char *state_drag_str[] = {
++          "untouched_drag",
++          "touched_drag",
++          "longtouched_drag",
++          "moving_drag",
++          "maybetapped_drag",
++          "oneandahalftap_drag",
++          NULL,
++};
++
+ char *action_str[] = {
+         "down",
+         "up",
+@@ -177,13 +186,13 @@ void libtouchSetMoveLimit(LibTouchRecPtr
+ }
+ 
+ 
+-void libtouchInit(LibTouchRecPtr libtouch, LocalDevicePtr local)
++void libtouchInit(LibTouchRecPtr libtouch, LocalDevicePtr local,pointer post_button_proc)
+ {
+         int state_action_idx = 0;
+         int state_button_idx = 0;
++        int state_drag_idx = 0;
+         int action_idx = 0;
+         int btn;
+-
+         char *str;
+ 
+         xf86memset(libtouch, 0, sizeof(LibTouchRec));
+@@ -193,6 +202,7 @@ void libtouchInit(LibTouchRecPtr libtouc
+         libtouch->local = local;
+         libtouch->move_limit = 30;
+ 
++	libtouch->post_button_proc = post_button_proc;
+         /*
+           Actions: up, down, click
+ 
+@@ -228,6 +238,11 @@ void libtouchInit(LibTouchRecPtr libtouc
+                 }
+         }
+ 
++	/* parse dragging for the states, that is which button sent to be as down, when in state and about to change to MOVING state */
++        for (state_drag_idx = 0; state_drag_str[state_drag_idx] != NULL; state_drag_idx++) {
++                btn = xf86SetIntOption(local->options, state_drag_str[state_drag_idx], -1);
++                if (btn != -1) state_ar[state_drag_idx].drag_btn = btn;
++        }
+ 
+         dump_configuration();
+ }
+@@ -359,10 +374,7 @@ static void enter_untouched(LibTouchRecP
+         for (i = 0; i < bit_size; i++)
+                 if (priv->pressed_btn_stat & (1 << i)) {
+                         DBG(4, ErrorF("LibTouch: Issuing Button-release %d\n", i));
+-                        xf86PostButtonEvent(priv->local->dev, TRUE,
+-                                            i, 0, 0, 2,
+-                                            priv->cur_x, 
+-                                            priv->cur_y);
++			priv->post_button_proc(priv->local,i, 0,priv->cur_x,priv->cur_y);
+                 }
+ 
+         priv->pressed_btn_stat = 0;
+@@ -445,6 +457,10 @@ static int handle_touched(LibTouchRecPtr
+                 if (priv->cur_x != priv->old_x) {
+                         dx = delta(priv->touch_x, priv->cur_x);
+                         if (dx > priv->move_limit) {
++				if((state_ar[S_TOUCHED].drag_btn != -1) && (priv->touch_time != priv->now)){
++					libtouchSetTime(priv, GetTimeInMillis());
++					btn_down_action(priv, state_ar[S_TOUCHED].drag_btn, priv->cur_x,priv->cur_y);
++				}
+                                 return S_MOVING;
+                         }
+                 }
+@@ -454,7 +470,10 @@ static int handle_touched(LibTouchRecPtr
+                 if (priv->cur_y != priv->old_y) {
+                         dy = delta(priv->touch_y, priv->cur_y);
+                         if (dy > priv->move_limit) {
+-                                return S_MOVING;
++				if((state_ar[S_TOUCHED].drag_btn != -1) && (priv->touch_time != priv->now)){
++					libtouchSetTime(priv, GetTimeInMillis());
++					btn_down_action(priv, state_ar[S_TOUCHED].drag_btn, priv->cur_x,priv->cur_y);
++}                                return S_MOVING;
+                         }
+                 }
+         }
+@@ -500,7 +519,7 @@ static int handle_longtouched(LibTouchRe
+         } else  {
+                 if (priv->cur_x != priv->old_x) {
+                         dx = delta(priv->touch_x, priv->cur_x);
+-                        if (dx > priv->move_limit) 
++                        if (dx > priv->move_limit)
+                                 rc = S_MOVING;
+                 }
+ 
+Index: xserver-xorg-input-evtouch/libtouch.h
+===================================================================
+--- xserver-xorg-input-evtouch.orig/libtouch.h	2008-02-02 21:49:36.899983517 +0900
++++ xserver-xorg-input-evtouch/libtouch.h	2008-02-02 21:49:39.734971242 +0900
+@@ -50,6 +50,7 @@ typedef struct _libtouch {
+         CARD32 past;
+         CARD32 now;
+         LocalDevicePtr local;
++        void                (*post_button_proc)(LocalDevicePtr local,int button, int is_down,int x,int y);
+ } LibTouchRec, *LibTouchRecPtr;
+ 
+ void libtouchSetDebugLevel(int level);
+@@ -59,7 +60,7 @@ void libtouchSetOneandahalftapTimeo(LibT
+ void libtouchSetTime(LibTouchRecPtr libtouch, CARD32 now);
+ void libtouchSetMoveLimit(LibTouchRecPtr libtouch, int move_limit);
+ 
+-void libtouchInit(LibTouchRecPtr libtouch, LocalDevicePtr local);
++void libtouchInit(LibTouchRecPtr libtouch, LocalDevicePtr local,pointer post_button_proc);
+ 
+ void libtouchSetPos(LibTouchRecPtr libtouch, int x, int y);
+ void libtouchTriggerSM(LibTouchRecPtr libtouch, LibTouchState_t touch);
--- xf86-input-evtouch-0.8.8.orig/debian/patches/04_include_xf86_ansic_h.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/04_include_xf86_ansic_h.patch
@@ -0,0 +1,23 @@
+Index: xserver-xorg-input-evtouch/libtouch.c
+===================================================================
+--- xserver-xorg-input-evtouch.orig/libtouch.c	2007-09-11 23:00:20.762131559 +0900
++++ xserver-xorg-input-evtouch/libtouch.c	2007-09-11 23:00:43.263413833 +0900
+@@ -34,7 +34,6 @@
+ #ifndef NEED_XF86_TYPES
+ #define NEED_XF86_TYPES
+ #endif
+-#include <xf86_ansic.h>
+ #include <xf86_OSproc.h>
+ #include <xf86Xinput.h>
+ #include <exevents.h>
+Index: xserver-xorg-input-evtouch/libtouch.h
+===================================================================
+--- xserver-xorg-input-evtouch.orig/libtouch.h	2007-09-11 23:00:20.762131559 +0900
++++ xserver-xorg-input-evtouch/libtouch.h	2007-09-11 23:00:51.263869754 +0900
+@@ -1,5 +1,6 @@
+ #ifndef _libtouch_H_
+ #define _libtouch_H_
++#include <xf86_ansic.h>
+ #include <os.h>
+ 
+ #define TOUCHED 0x01
--- xf86-input-evtouch-0.8.8.orig/debian/patches/07_random_fixes_for_06.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/07_random_fixes_for_06.patch
@@ -0,0 +1,523 @@
+# Description:
+#   o Random whitespace fixes
+#   o uninitialized variables warning fix
+#
+Index: xserver-xorg-input-evtouch/evtouch.c
+===================================================================
+--- xserver-xorg-input-evtouch.orig/evtouch.c	2008-02-03 11:51:32.082972688 +0900
++++ xserver-xorg-input-evtouch/evtouch.c	2008-02-03 11:51:32.106981862 +0900
+@@ -1,6 +1,6 @@
+ /*
+  *
+- * Copyright 2004 by Kenan Esau <kenan.esau@conan.de>, Baltmannsweiler, 
++ * Copyright 2004 by Kenan Esau <kenan.esau@conan.de>, Baltmannsweiler,
+  * Germany.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and its
+@@ -182,17 +182,17 @@ static const char *default_options[] =
+ static int
+ ControlProc(LocalDevicePtr device, xDeviceCtl *ctrl);
+ 
+-static void 
++static void
+ PostMotionEvent(LocalDevicePtr local);
+ 
+-static void 
++static void
+ PostProximityEvent(LocalDevicePtr local,int is_in);
+ 
+-static void 
++static void
+ PostButtonEvent(LocalDevicePtr local, int button,
+ 		    	 int is_down, int x,int y);
+ 
+-static void 
++static void
+ InputSetScreen(LocalDevicePtr local);
+ 
+ 
+@@ -216,7 +216,7 @@ emulate3Timer(OsTimerPtr timer, CARD32 n
+ 
+         PostMotionEvent(local);
+ 
+-        /* 
++        /*
+          * Emit a button press -- release is handled in EVTouchLBRBEvent
+          */
+         if ( ( priv->touch_flags & LB_STAT ) &&
+@@ -241,11 +241,11 @@ emulate3Timer(OsTimerPtr timer, CARD32 n
+ 
+         priv->emulate3_timer_expired = TRUE;
+         xf86UnblockSIGIO(sigstate);
+-             
++
+         return 0;
+ }
+ 
+-static void DoBtnAction(EVTouchPrivatePtr priv) 
++static void DoBtnAction(EVTouchPrivatePtr priv)
+ {
+         int btn = 0;
+         LocalDevicePtr local = priv->local;
+@@ -253,7 +253,7 @@ static void DoBtnAction(EVTouchPrivatePt
+         DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__, priv->btn_count);
+ 
+         for (btn = 0; btn < priv->btn_count; btn++) {
+-                DBGOUT(9, "EVTouch: %s do_it = %d \n", 
++                DBGOUT(9, "EVTouch: %s do_it = %d \n",
+                        __FUNCTION__, priv->btn_actions[btn].do_it);
+                 if (priv->btn_actions[btn].do_it != 0) {
+                         if (priv->emulate3_timer != NULL)
+@@ -263,10 +263,10 @@ static void DoBtnAction(EVTouchPrivatePt
+                                 priv->emulate3_timer_expired = FALSE;
+                         }
+ 
+-                        DBGOUT(2, "EVTouch: %s btn = %d action = %d\n", 
+-                               __FUNCTION__, btn, 
++                        DBGOUT(2, "EVTouch: %s btn = %d action = %d\n",
++                               __FUNCTION__, btn,
+                                priv->btn_actions[btn].action);
+-			PostButtonEvent (local, btn, priv->btn_actions[btn].action,priv->cur_x,priv->cur_y);                        
++			PostButtonEvent (local, btn, priv->btn_actions[btn].action,priv->cur_x,priv->cur_y);
+ 
+                         priv->btn_actions[btn].do_it  = 0;
+                         priv->btn_actions[btn].action = 0;
+@@ -318,7 +318,7 @@ void EVTouchProcessAbs(EVTouchPrivatePtr
+ 				PostButtonEvent (local, 5,1,priv->cur_x,priv->cur_y);
+ 				PostButtonEvent (local, 5,0,priv->cur_x,priv->cur_y);
+ 			}
+-		}			
++		}
+ 	}
+ }
+ 
+@@ -337,7 +337,7 @@ void EVTouchProcessRel(EVTouchPrivatePtr
+                 if (priv->cur_x < priv->min_x)
+                         priv->cur_x = priv->min_x;
+                 return;
+-        } 
++        }
+         if ( ev->code == REL_Y ) {
+                 priv->cur_y += ev->value;
+                 if (priv->cur_y > priv->max_y)
+@@ -346,7 +346,7 @@ void EVTouchProcessRel(EVTouchPrivatePtr
+                         priv->cur_y = priv->min_y;
+                 return;
+         }
+-	
++
+         libtouchSetPos(priv->libtouch, priv->cur_x, priv->cur_y);
+ }
+ 
+@@ -363,12 +363,12 @@ void EVTouchLBRBEvent(EVTouchPrivatePtr 
+ 
+         if (priv->emulate3) {
+                 if ( (ev->value==1) && (priv->emulate3_timer==NULL) )
+-                        priv->emulate3_timer = TimerSet(priv->emulate3_timer, 
++                        priv->emulate3_timer = TimerSet(priv->emulate3_timer,
+                                                         0,
+                                                         priv->emulate3_timeout,
+                                                         emulate3Timer,
+                                                         local);
+-                
++
+                 if ( (ev->value == 1) && (ev->code == BTN_LEFT) ) {
+                         priv->touch_flags |= LB_STAT;
+                 }
+@@ -376,8 +376,8 @@ void EVTouchLBRBEvent(EVTouchPrivatePtr 
+                         priv->touch_flags |= RB_STAT;
+                 }
+ 
+-                if ( (ev->value == 0) && 
+-                     (priv->touch_flags & RB_STAT) && 
++                if ( (ev->value == 0) &&
++                     (priv->touch_flags & RB_STAT) &&
+                      (priv->touch_flags & LB_STAT) ) {
+                         DBGOUT(2, "EVTouch: Middle Release\n");
+                         priv->touch_flags &= ~LB_STAT;
+@@ -393,7 +393,7 @@ void EVTouchLBRBEvent(EVTouchPrivatePtr 
+                         DBGOUT(2, "EVTouch: Right Release\n");
+                         priv->touch_flags &= ~RB_STAT;
+                         SetBtnAction(priv, 3, BTN_RELEASE);
+-                }                                
++                }
+         } else {
+                 if (ev->code == BTN_LEFT) {
+                         SetBtnAction(priv, 1, ev->value);
+@@ -418,11 +418,11 @@ void EVTouchProcessKey(EVTouchPrivatePtr
+ 
+         DBGOUT(2, "EVTouch: %s\n", __FUNCTION__);
+         ev = &priv->ev;
+-        if ( (ev->code == BTN_LEFT) || 
++        if ( (ev->code == BTN_LEFT) ||
+              (ev->code == BTN_RIGHT) ||
+              (ev->code == BTN_MIDDLE) ) {
+ 
+-                /* give lb and rb-events some special treatment 
++                /* give lb and rb-events some special treatment
+                    (emulate3 or not, ...) */
+                 EVTouchLBRBEvent(priv);
+                 return;
+@@ -468,7 +468,7 @@ DeviceOn (DeviceIntPtr dev)
+ {
+         LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
+         EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);
+-        
++
+         local->fd = xf86OpenSerial(local->options);
+ 
+         DBGOUT(2, "EVTouch: %s\n", __FUNCTION__ );
+@@ -484,7 +484,7 @@ DeviceOn (DeviceIntPtr dev)
+ // breaks compilation
+ //        DBG (9, XisbTrace (priv->buffer, 1));
+ 
+-        if (!priv->buffer) 
++        if (!priv->buffer)
+         {
+                 xf86CloseSerial(local->fd);
+                 local->fd = -1;
+@@ -526,7 +526,7 @@ DeviceOff (DeviceIntPtr dev)
+         DBGOUT(2, "EVTouch: %s\n", __FUNCTION__ );
+ 
+         if (local->fd != -1)
+-        { 
++        {
+                 ioctl(local->fd, EVIOCGRAB, (void *)0);
+                 xf86RemoveEnabledDevice (local);
+                 if (priv->buffer)
+@@ -564,7 +564,7 @@ DeviceInit (DeviceIntPtr dev)
+ 
+         priv->btn_count = EV_MAX_BUTTONS;
+ 
+-        /* 
++        /*
+          * these have to be here instead of in the SetupProc, because when the
+          * SetupProc is run at server startup, screenInfo is not setup yet
+          */
+@@ -574,9 +574,9 @@ DeviceInit (DeviceIntPtr dev)
+         priv->screen_height = pScrn->virtualY;
+         priv->pViewPort_X0  = &(pScrn->frameX0);   /* initialize the pointers to the viewport coords */
+         if ( (priv->screen_width != priv->phys_width) ||
+-             (priv->screen_height != priv->phys_height) ) 
++             (priv->screen_height != priv->phys_height) )
+               priv->virtual = 1;
+-        else  
++        else
+                 priv->virtual = 0;
+ 
+         priv->pViewPort_Y0  = &(pScrn->frameY0);
+@@ -591,24 +591,24 @@ DeviceInit (DeviceIntPtr dev)
+         DBGOUT(2, "EVTouch: MaxValue H,V: %d %d\n", pScrn->maxHValue, pScrn->maxVValue);
+ 
+         priv->screen_width = screenInfo.screens[priv->screen_num]->width;
+-        priv->screen_height = screenInfo.screens[priv->screen_num]->height;        
++        priv->screen_height = screenInfo.screens[priv->screen_num]->height;
+ 
+-        /* 
++        /*
+          * Device reports button press for 5 buttons.
+          */
+         if (InitButtonClassDeviceStruct (dev, EV_MAX_BUTTONS, map) == FALSE)
+         {
+                 ErrorF("Unable to allocate EVTouch touchscreen ButtonClassDeviceStruct\n");
+                 return BadAlloc;
+-        } 
++        }
+ 
+-        DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__, 
++        DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__,
+                priv->btn_count);
+         priv->btn_actions = xcalloc(priv->btn_count, sizeof(BtnAction));
+-        xf86memset(priv->btn_actions, 0, 
++        xf86memset(priv->btn_actions, 0,
+                    priv->btn_count * sizeof(BtnAction));
+-        
+-        DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__, 
++
++        DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__,
+                priv->btn_count);
+ 
+         if (InitFocusClassDeviceStruct(dev) == FALSE) {
+@@ -616,7 +616,7 @@ DeviceInit (DeviceIntPtr dev)
+                 return !Success;
+         }
+ 
+-        /* 
++        /*
+          * Device reports motions on 2 axes in absolute coordinates.
+          * Axes min and max values are reported in raw coordinates.
+          */
+@@ -654,7 +654,7 @@ DeviceInit (DeviceIntPtr dev)
+         priv->cur_y=(priv->max_y - priv->min_y)/2;
+         libtouchSetPos(priv->libtouch, priv->cur_x, priv->cur_y);
+ 
+-        
++
+         if (InitProximityClassDeviceStruct (dev) == FALSE)
+         {
+                 ErrorF ("Unable to allocate EVTouch touchscreen ProximityClassDeviceStruct\n");
+@@ -667,7 +667,7 @@ DeviceInit (DeviceIntPtr dev)
+                 return !Success;
+         }
+ 
+-        /* 
++        /*
+          * Allocate the motion events buffer.
+          */
+         xf86MotionHistoryAllocate (local);
+@@ -748,7 +748,7 @@ EVTouchGetPacket (EVTouchPrivatePtr priv
+                 if (sizeof(priv->ev) == count) {
+                         count = 0;
+                         EVTouchDumpPacketToLog(priv);
+-                        
++
+                         return Success;
+                 }
+         }
+@@ -764,7 +764,7 @@ static void ReadInput (LocalDevicePtr lo
+ 
+         EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);
+ 
+-        /* 
++        /*
+          * set blocking to -1 on the first call because we know there is data to
+          * read. Xisb automatically clears it after one successful read so that
+          * succeeding reads are preceeded buy a select with a 0 timeout to prevent
+@@ -815,7 +815,7 @@ static void ReadInput (LocalDevicePtr lo
+                         break;
+                 }
+ 
+-                DBGOUT( 2, "EVTouch: setting (x/y)=(%d/%d)\n", 
++                DBGOUT( 2, "EVTouch: setting (x/y)=(%d/%d)\n",
+                         priv->cur_x, priv->cur_y);
+ 
+         }
+@@ -855,7 +855,7 @@ static int
+ SwitchMode (ClientPtr client, DeviceIntPtr dev, int mode)
+ {
+         DBGOUT(2, "EVTouch: %s\n", __FUNCTION__);
+-        
++
+         return (!Success);
+ }
+ 
+@@ -884,19 +884,20 @@ ConvertProc ( LocalDevicePtr local,
+         float dx = 0, dy = 0;
+ 
+         int max_x, max_y;
+-        int xc, yc;
++        int xc = 0, yc = 0;
+         int screen_width  = 0;
+         int screen_height = 0;
+ #ifdef EVDBG
+         int i = 0;
+ #endif
+ 
+-        EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);  
++        EVTouchPrivatePtr priv = (EVTouchPrivatePtr) (local->private);
+ 	ScrnInfoPtr pScrn = xf86Screens[priv->screen_num];
+ 
+ // X Segfaults
+-//	Rotation rotation = RRGetRotation(pScrn->pScreen);
++	Rotation rotation = RRGetRotation(pScrn->pScreen);
+ 
++        DBGOUT(2, "EVTouch: RRRotation=%d\n", rotation);
+         DBGOUT(2, "EVTouch: FIRST: v0=%d   v1=%d\n", v0, v1);
+ 
+         /*correction of raw coordinates*/
+@@ -910,21 +911,20 @@ ConvertProc ( LocalDevicePtr local,
+                 DBGOUT(2, "EVTouch: Scaling coordinates\n");
+                 xc = v0 - priv->min_x;
+                 yc = v1 - priv->min_y;
+-        
++
+                 max_x = priv->max_x - priv->min_x;
+                 max_y = priv->max_y - priv->min_y;
+ 
+ 
+-//                if (priv->rotate == EV_ROTATE_NONE) {
++                if (priv->rotate == EV_ROTATE_NONE) {
+                         screen_width  = pScrn->currentMode->HDisplay;
+                         screen_height = pScrn->currentMode->VDisplay;
+-/* Swapping is done below in Coords! Leave those to be able to calc correct mapping
++/* Swapping is done below in Coords! Leave those to be able to calc correct mapping */
+                 } else {
+                         screen_width  = pScrn->currentMode->VDisplay;
+                         screen_height = pScrn->currentMode->HDisplay;
+                 }
+ 
+-*/
+                 if (xc < (max_x / 2)) {
+                         /*
+                           left
+@@ -942,7 +942,7 @@ ConvertProc ( LocalDevicePtr local,
+                                       (float)(cx[0] * cy[0] * priv->diff[0][0]) +
+                                       (float)(cx[1] * cy[1] * priv->diff[4][0]) +
+                                       (float)(cx[0] * cy[1] * priv->diff[3][0]));
+-                                
++
+                                 dy = ((float) (cx[1] * cy[0] * priv->diff[1][1]) +
+                                       (float)(cx[0] * cy[0] * priv->diff[0][1]) +
+                                       (float)(cx[1] * cy[1] * priv->diff[4][1]) +
+@@ -961,7 +961,7 @@ ConvertProc ( LocalDevicePtr local,
+                                       (float)(cx[0] * cy[0] * priv->diff[3][0]) +
+                                       (float)(cx[1] * cy[1] * priv->diff[7][0]) +
+                                       (float)(cx[0] * cy[1] * priv->diff[6][0]));
+-                                
++
+                                 dy = ((float) (cx[1] * cy[0] * priv->diff[4][1]) +
+                                       (float)(cx[0] * cy[0] * priv->diff[3][1]) +
+                                       (float)(cx[1] * cy[1] * priv->diff[7][1]) +
+@@ -985,7 +985,7 @@ ConvertProc ( LocalDevicePtr local,
+ 				      (float)(cx[0] * cy[0] * priv->diff[1][0]) +
+ 				      (float)(cx[1] * cy[1] * priv->diff[5][0]) +
+ 				      (float)(cx[0] * cy[1] * priv->diff[4][0]));
+-                        
++
+                                 dy = ((float) (cx[1] * cy[0] * priv->diff[2][1]) +
+ 				      (float)(cx[0] * cy[0] * priv->diff[1][1]) +
+                                       (float)(cx[1] * cy[1] * priv->diff[5][1]) +
+@@ -1004,7 +1004,7 @@ ConvertProc ( LocalDevicePtr local,
+                                       (float)(cx[0] * cy[0] * priv->diff[4][0]) +
+                                       (float)(cx[1] * cy[1] * priv->diff[8][0]) +
+                                       (float)(cx[0] * cy[1] * priv->diff[7][0]));
+-                                
++
+                                 dy = ((float) (cx[1] * cy[0] * priv->diff[5][1]) +
+                                       (float)(cx[0] * cy[0] * priv->diff[4][1]) +
+                                       (float)(cx[1] * cy[1] * priv->diff[8][1]) +
+@@ -1014,12 +1014,12 @@ ConvertProc ( LocalDevicePtr local,
+ 
+ 
+ #ifdef EVDBG
+-                for (i=0; i<3; i++) 
++                for (i=0; i<3; i++)
+                         xf86ErrorFVerb(2, "cx[%d]=%f   cy[%d]=%f\n", i, cx[i]
+                                        ,i, cy[i]);
+-                
+-                DBGOUT(2, "EVTouch: ViewPort_X0=%d   ViewPort_Y0=%d\n", 
+-                    *(priv->pViewPort_X0), 
++
++                DBGOUT(2, "EVTouch: ViewPort_X0=%d   ViewPort_Y0=%d\n",
++                    *(priv->pViewPort_X0),
+                     *(priv->pViewPort_Y0));
+                 DBGOUT(2, "EVTouch: dx=%f   dy=%f\n", dx, dy);
+ #endif
+@@ -1030,7 +1030,7 @@ ConvertProc ( LocalDevicePtr local,
+                 if (priv->swap_y == TRUE)
+                         yc = screen_height - yc;
+ 
+-                /* ususally we DON'T swap x -- but if swap_x is 1 
++                /* ususally we DON'T swap x -- but if swap_x is 1
+                    => go on and swap */
+                 if (priv->swap_x == TRUE)
+                         xc = screen_width - xc;
+@@ -1056,7 +1056,7 @@ ConvertProc ( LocalDevicePtr local,
+ 		break;
+                 }
+ 
+-/* X Segfaults on rotation setting
++/* X Segfaults on rotation setting */
+                 switch (rotation) {
+                         case RR_Rotate_0:
+                                 v0 = xc;
+@@ -1080,14 +1080,12 @@ ConvertProc ( LocalDevicePtr local,
+                                 break;
+                 }
+ 
+-
+-*/
+         }
+ 
+         DBGOUT(2, "EVTouch: FINAL: v0=%d   v1=%d\n", v0, v1);
+ 
+-        *x = xc;
+-        *y = yc;
++        *x = v0;
++        *y = v1;
+         return (TRUE);
+ }
+ 
+@@ -1160,7 +1158,7 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+         priv->button_number = xf86SetIntOption(local->options, "ButtonNumber", 2 );
+ 
+         priv->emulate3      = xf86SetBoolOption(local->options, "Emulate3Buttons", TRUE);
+-        priv->emulate3_timeout = xf86SetIntOption(local->options, 
++        priv->emulate3_timeout = xf86SetIntOption(local->options,
+                                                   "Emulate3Timeout", 50);
+ 
+         debug_level = xf86SetIntOption(local->options, "DebugLevel", 0);
+@@ -1180,33 +1178,33 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+         s = xf86FindOptionValue(local->options, "Rotate");
+         if (s) {
+                 if (xf86NameCmp(s, "CW") == 0) {
+-                        priv->rotate = EV_ROTATE_CW;                           
++                        priv->rotate = EV_ROTATE_CW;
+                 } else if (xf86NameCmp(s, "CCW") == 0 ) {
+                         priv->rotate = EV_ROTATE_CCW;
+                 }  else if (xf86NameCmp(s, "UD") == 0 ) {
+                         priv->rotate = EV_ROTATE_UD;
+                 }
+ 
+- 
++
+         }
+ 
+         if (priv->rotate == EV_ROTATE_NONE) {
+                 priv->max_rel_x = priv->max_x;
+                 priv->max_rel_y = priv->max_y;
+                 priv->min_rel_x = priv->min_x;
+-                priv->min_rel_y = priv->min_y;             
++                priv->min_rel_y = priv->min_y;
+         } else {
+                 priv->max_rel_x = priv->max_y;
+                 priv->max_rel_y = priv->max_x;
+                 priv->min_rel_x = priv->min_y;
+-                priv->min_rel_y = priv->min_x;             
++                priv->min_rel_y = priv->min_x;
+         }
+ 
+         priv->swap_y = xf86SetBoolOption(local->options, "SwapY", FALSE);
+         priv->swap_x = xf86SetBoolOption(local->options, "SwapX", FALSE);
+ 
+-        /* 
+-           get calibration parameters from XF86Config 
++        /*
++           get calibration parameters from XF86Config
+         */
+         for (i = 0; i < 9; i++){
+                 sprintf(tmp_str, "x%d", i);
+@@ -1215,10 +1213,10 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+                 sprintf(tmp_str, "y%d", i);
+                 priv->diff[i][1] = xf86SetIntOption( local->options,
+                                                      tmp_str, 0 );
+-                DBGOUT(2, "(diff[%d][0]/diff[%d][1])=(%d/%d)\n", i, i, 
++                DBGOUT(2, "(diff[%d][0]/diff[%d][1])=(%d/%d)\n", i, i,
+                     priv->diff[i][0], priv->diff[i][1]);
+         }
+-        
++
+ #if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
+         xf86AlwaysCore(local, TRUE);
+ #endif
+@@ -1228,9 +1226,9 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+         /* prepare to process touch packets */
+         EVTouchNewPacket (priv);
+ 
+-        /* 
++        /*
+            if started in calibration-mode:
+-           - open named pipe 
++           - open named pipe
+         */
+         if (priv->calibrate) {
+                 priv->fifo = open("/tmp/ev_calibrate", O_RDWR, 0);
+@@ -1252,7 +1250,7 @@ EVTouchPreInit(InputDriverPtr drv, IDevP
+ static void
+ EVTouchPtrCtrl(DeviceIntPtr device, PtrCtrl *ctrl)
+ {
+-  /* I have no clue what this does, except that registering it stops the 
++  /* I have no clue what this does, except that registering it stops the
+      X server segfaulting in ProcGetPointerMapping()
+      Ho Hum.
+   */
--- xf86-input-evtouch-0.8.8.orig/debian/patches/21_more_calibration_fixups.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/21_more_calibration_fixups.patch
@@ -0,0 +1,33 @@
+diff -u xf86-input-evtouch-0.8.8/evtouch.c xf86-input-evtouch-0.8.8/evtouch.c
+--- xf86-input-evtouch-0.8.8/evtouch.c
++++ xf86-input-evtouch-0.8.8/evtouch.c
+@@ -305,7 +305,7 @@
+ 	}
+ 
+         if (pos_changed == 1) {
+-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 2
+                 ConvertProc(priv->local, 0, 2, 
+                             priv->raw_x, priv->raw_y,
+                             0, 0, 0, 0, 
+@@ -369,7 +369,7 @@
+                         priv->raw_y = priv->min_y;
+         }
+ 
+-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 2
++#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 2
+         ConvertProc(priv->local, 0, 2,
+                     priv->raw_x, priv->raw_y,
+                     0, 0, 0, 0,
+diff -u xf86-input-evtouch-0.8.8/debian/changelog xf86-input-evtouch-0.8.8/debian/changelog
+--- xf86-input-evtouch-0.8.8.orig/ev_calibrate.c
++++ xf86-input-evtouch-0.8.8/ev_calibrate.c
+@@ -218,7 +218,7 @@
+         int cap_style = CapButt;        /* style of the line's edje and */
+         int join_style = JoinBevel;        /*  joined lines.                */
+ 
+-        int event_mask = ExposureMask | ButtonReleaseMask | PointerMotionMask | KeyPressMask;
++        int event_mask = ExposureMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask | KeyPressMask;
+ 
+         int depth;
+         int screen_num;
--- xf86-input-evtouch-0.8.8.orig/debian/patches/08_fix_xf86memset.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/08_fix_xf86memset.patch
@@ -0,0 +1,35 @@
+Index: xf86-input-evtouch-0.8.7/evtouch.c
+===================================================================
+--- xf86-input-evtouch-0.8.7.orig/evtouch.c	2008-08-07 11:33:52.000000000 +0300
++++ xf86-input-evtouch-0.8.7/evtouch.c	2008-08-07 11:33:52.000000000 +0300
+@@ -605,7 +605,7 @@
+         DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__,
+                priv->btn_count);
+         priv->btn_actions = xcalloc(priv->btn_count, sizeof(BtnAction));
+-        xf86memset(priv->btn_actions, 0,
++        memset(priv->btn_actions, 0,
+                    priv->btn_count * sizeof(BtnAction));
+ 
+         DBGOUT(2, "EVTouch: %s btn_count=%d\n", __FUNCTION__,
+@@ -708,7 +708,7 @@
+ static void
+ EVTouchNewPacket (EVTouchPrivatePtr priv)
+ {
+-        xf86memset(&priv->ev, 0, sizeof(struct input_event));
++        memset(&priv->ev, 0, sizeof(struct input_event));
+         priv->packeti = 0;
+         priv->binary_pkt = FALSE;
+ }
+Index: xf86-input-evtouch-0.8.7/libtouch.c
+===================================================================
+--- xf86-input-evtouch-0.8.7.orig/libtouch.c	2008-08-07 11:34:37.000000000 +0300
++++ xf86-input-evtouch-0.8.7/libtouch.c	2008-08-07 11:35:05.000000000 +0300
+@@ -195,7 +195,7 @@
+         int btn;
+         char *str;
+ 
+-        xf86memset(libtouch, 0, sizeof(LibTouchRec));
++        memset(libtouch, 0, sizeof(LibTouchRec));
+ 
+         libtouch->now = GetTimeInMillis();
+         libtouch->past = libtouch->now;
--- xf86-input-evtouch-0.8.8.orig/debian/patches/09_calibrate-script-halification.patch
+++ xf86-input-evtouch-0.8.8/debian/patches/09_calibrate-script-halification.patch
@@ -0,0 +1,87 @@
+Index: xf86-input-evtouch-0.8.7/calibrate.sh
+===================================================================
+--- xf86-input-evtouch-0.8.7.orig/calibrate.sh	2008-09-26 00:58:00.000000000 +0200
++++ xf86-input-evtouch-0.8.7/calibrate.sh	2008-09-26 00:59:37.000000000 +0200
+@@ -2,9 +2,58 @@
+ XINIT=`which xinit`
+ XSERVER=`which X`
+ EVCALIBRATE=`which ev_calibrate || echo ./ev_calibrate`
++UDI=$(hal-find-by-property --key input.x11_driver --string evtouch)
++MYDPY=":1.0"
++ZENITY=`which zenity`
++KDIALOG=`which kdialog`
++XDIALOG=`which Xdialog`
++
++INFO="You have selected to (re)calibrate your touchscreen.\n\n\
++Move your pen around all edges on the following screen.\n\n\
++If you are done and touched all edges, hit the enter key and wait until \
++the top left crosshair turns red.\nOnce you tap the red crosshair, \
++the next one will turn red going from the top left to the \
++bottom right.\nIf you miss a tap, the right mouse button will \
++take you back one step.\n\n\
++If you tapped the last (bottom right) crosshair, the program will \
++return to your session. Note that changes only take effect after \
++restarting the session."
++
++RESTARTINFO="Touchscreen calibration done\nPlease restart your \
++session to \nmake the changes take effect"
++
++FAILINFO="No evtouch capable device found, if you are sure you have \n\
++an evtouch capable touchscreen, please mail the \
++resulting file of the command \"lshal > evtouch_hal.out\" to the\n\
++ubuntu-mobile@lists.ubuntu.com mailing list, so support for your \
++device can be added."
++
++if [ -z "$UDI" ];then
++    if [ -x "${ZENITY}" ]; then
++        $ZENITY --info --text="${FAILINFO}"
++    elif [ -x "${XDIALOG}" ]; then
++        $XDIALOG --fill --msgbox "${FAILINFO}" 20 40
++    elif [ -x "${KDIALOG}" ]; then
++        $KDIALOG --msgbox "${FAILINFO}"
++    fi
++    exit 0
++fi
++
++if [ -x "${ZENITY}" ]; then
++    $ZENITY --info --text="${INFO}"
++elif [ -x "${XDIALOG}" ]; then
++    $XDIALOG --fill --msgbox "${INFO}" 30 40
++elif [ -x "${KDIALOG}" ]; then
++    $KDIALOG --msgbox "${INFO}"
++fi
+ 
+ echo $EVCALIBRATE
+ 
++if [ -n "$DISPLAY" ]; then
++    DPY=$(echo $DISPLAY|sed -e 's/[a-z:]*//g'|cut -d'.' -f1)
++    MYDPY=":$(($DPY+1)).0"
++fi
++
+ if ! [ -x "$EVCALIBRATE" ] ; then
+ 	echo "ev_calibrate not found exiting ..."
+ 	exit 1;
+@@ -32,6 +81,22 @@
+ #xinit /usr/bin/ddd ev_calibrate -- /usr/X11R6/bin/X
+ echo "Starting calibration program..."
+ sleep 2
++hal-set-property --udi $UDI --key input.x11_options.calibrate --string "1"
++
++$XINIT $EVCALIBRATE -- $XSERVER $MYDPY -auth /dev/null
++
++hal-set-property --remove --udi $UDI --key input.x11_options.calibrate
++
++invoke-rc.d --quiet xserver-xorg-input-evtouch start
++
++rm /tmp/ev_calibrate
++
++if [ -x "${ZENITY}" ]; then
++    $ZENITY --info --text="${RESTARTINFO}"
++elif [ -x "${XDIALOG}" ]; then
++    $XDIALOG --fill --msgbox "${RESTARTINFO}" 10 40
++elif [ -x "${KDIALOG}" ]; then
++    $KDIALOG --msgbox "${RESTARTINFO}"
++fi
+ 
+-$XINIT $EVCALIBRATE -- $XSERVER
+ exit 0
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-eGalax.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-eGalax.fdi
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+<deviceinfo version="0.2">
+  <device>
+    <match key="info.product" contains="eGalax">
+      <match key="info.capabilities" contains="input">
+        <merge key="input.x11_driver" type="string">evtouch</merge>
+        <merge key="input.x11_options.minx" type="string">130</merge>
+        <merge key="input.x11_options.miny" type="string">197</merge>
+        <merge key="input.x11_options.maxx" type="string">3945</merge>
+        <merge key="input.x11_options.maxy" type="string">3894</merge>
+        <merge key="input.x11_options.taptimer" type="string">30</merge>
+        <merge key="input.x11_options.longtouchtimer" type="string">750</merge>
+        <merge key="input.x11_options.longtouched_action" type="string">click</merge>
+        <merge key="input.x11_options.longtouched_button" type="string">3</merge>
+        <merge key="input.x11_options.oneandhalftap_button" type="string">2</merge>
+        <merge key="input.x11_options.movelimit" type="string">10</merge>
+        <merge key="input.x11_options.touched_drag" type="string">1</merge>
+        <merge key="input.x11_options.maybetapped_action" type="string">click</merge>
+        <merge key="input.x11_options.maybetapped_button" type="string">1</merge>
+      </match>
+    </match>
+  </device>
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-gunze.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-gunze.fdi
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="ISO-8859-1" ?>
+
+<deviceinfo version="0.2">
+  <device>
+    <match key="info.product" contains="GUNZE USB Touch Panel">
+      <merge key="input.x11_driver" type="string">evtouch</merge>
+      <merge key="input.x11_options.ReportingMode" type="string">Raw</merge>
+      <merge key="input.x11_options.Emulate3Buttons" type="string">false</merge>
+      <merge key="input.x11_options.Emulate3Timeout" type="string">1</merge>
+      <merge key="input.x11_options.MinX" type="string">35</merge>
+      <merge key="input.x11_options.MinY" type="string">37</merge>
+      <merge key="input.x11_options.MaxX" type="string">990</merge>
+      <merge key="input.x11_options.MaxY" type="string">986</merge>
+    </match>
+  </device>
+</deviceinfo>
\ No newline at end of file
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-ideaco.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-ideaco.fdi
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+
+<deviceinfo version="0.2">
+  <device>
+    <match key="info.product" contains="IDEACO">
+      <match key="info.product" contains="IDC 6680">
+        <match key="info.capabilities" contains="input.touchpad">
+	      <merge key="input.x11_driver" type="string">evtouch</merge>
+	      <merge key="input.x11_options.reportingmode" type="string">raw</merge>
+	      <merge key="input.x11_options.taptimer" type="string">50</merge>
+	      <merge key="input.x11_options.longtouchtimer" type="string">30</merge>
+	      <merge key="input.x11_options.movelimit" type="string">15</merge>
+	      <merge key="input.x11_options.emulate3buttons" type="string">true</merge>
+	      <merge key="input.x11_options.emulate3timeout" type="string">50</merge>
+          <merge key="input.x11_options.maxx" type="string">7948</merge>
+          <merge key="input.x11_options.maxy" type="string">7834</merge>
+          <merge key="input.x11_options.minx" type="string">112</merge>
+          <merge key="input.x11_options.miny" type="string">254</merge>
+        </match>
+      </match>
+    </match>
+  </device>
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-elo-2700.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-elo-2700.fdi
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+<deviceinfo version="0.2">
+  <device>
+    <match key="info.product" contains="Elo TouchSystems, Inc. Elo TouchSystems 2700 IntelliTouch(r) USB Touchmonitor Interface">
+      <match key="info.capabilities" contains="input">
+        <merge key="input.x11_driver" type="string">evtouch</merge>
+        <merge key="input.x11_options.minx" type="string">130</merge>
+        <merge key="input.x11_options.miny" type="string">197</merge>
+        <merge key="input.x11_options.maxx" type="string">3945</merge>
+        <merge key="input.x11_options.maxy" type="string">3894</merge>
+        <merge key="input.x11_options.swapx" type="string">1</merge>
+        <merge key="input.x11_options.swapy" type="string">1</merge>
+      </match>
+    </match>
+  </device>
+</deviceinfo>
+
+</deviceinfo>
\ No newline at end of file
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-touchpack.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-touchpack.fdi
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+<deviceinfo version="0.2">
+  <device>
+      <match key="info.product" contains="HID TOUCH HID Touch Panel">
+        <match key="info.capabilities" contains="input.touchpad">
+          <merge key="input.x11_driver" type="string">evtouch</merge>
+          <merge key="input.x11_options.reportingmode" type="string">raw</merge>
+          <merge key="input.x11_options.emulate3buttons" type="string">false</merge>
+          <merge key="input.x11_options.emulate3timeout" type="string">50</merge>
+          <merge key="input.x11_options.sendcoreevents" type="string">true</merge>
+	  <merge key="input.x11_options.maxx" type="string">4095</merge>
+	  <merge key="input.x11_options.maxy" type="string">4095</merge>
+	  <merge key="input.x11_options.minx" type="string">21</merge>
+	  <merge key="input.x11_options.miny" type="string">0</merge>
+	  <merge key="input.x11_options.Rotate" type="string">false</merge>
+	  <merge key="input.x11_options.Swapx" type="string">false</merge>
+	  <merge key="input.x11_options.Swapy" type="string">false</merge>
+          <merge key="input.x11_options.taptimer" type="string">30</merge>
+          <merge key="input.x11_options.longtouchtimer" type="string">750</merge>
+          <merge key="input.x11_options.longtouched_action" type="string">click</merge>
+          <merge key="input.x11_options.longtouched_button" type="string">3</merge>
+          <merge key="input.x11_options.oneandhalftap_button" type="string">2</merge>
+          <merge key="input.x11_options.movelimit" type="string">10</merge>
+          <merge key="input.x11_options.touched_drag" type="string">1</merge>
+          <merge key="input.x11_options.maybetapped_action" type="string">click</merge>
+          <merge key="input.x11_options.maybetapped_button" type="string">1</merge>
+        </match>
+    </match>
+  </device>
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-Fujitsu.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-Fujitsu.fdi
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+
+<deviceinfo version="0.2">
+
+  <device>
+    <match key="info.product" contains="Fujitsu Component USB Touch Panel">
+      <match key="info.capabilities" contains="input">
+         <merge key="input.x11_driver" type="string">evtouch</merge>
+         <merge key="input.x11_options.reportingmode" type="string">raw</merge>
+         <merge key="input.x11_options.emulate3buttons" type="string">true</merge>
+         <merge key="input.x11_options.emulate3timeout" type="string">50</merge>
+         <merge key="input.x11_options.sendcoreevents" type="string">on</merge>
+         <merge key="input.x11_options.minx" type="string">76</merge>
+         <merge key="input.x11_options.miny" type="string">104</merge>
+         <merge key="input.x11_options.maxx" type="string">957</merge>
+         <merge key="input.x11_options.maxy" type="string">976</merge>
+      </match>
+    </match>
+  </device>
+
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-Panasonic.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-Panasonic.fdi
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+
+<deviceinfo version="0.2">
+
+  <device>
+    <match key="info.product" contains="Fujitsu Takamisawa USB Touch Panel">
+      <match key="info.capabilities" contains="input">
+         <merge key="input.x11_driver" type="string">evtouch</merge>
+         <merge key="input.x11_options.reportingmode" type="string">raw</merge>
+         <merge key="input.x11_options.emulate3buttons" type="string">true</merge>
+         <merge key="input.x11_options.emulate3timeout" type="string">50</merge>
+         <merge key="input.x11_options.sendcoreevents" type="string">on</merge>
+         <merge key="input.x11_options.minx" type="string">76</merge>
+         <merge key="input.x11_options.miny" type="string">104</merge>
+         <merge key="input.x11_options.maxx" type="string">957</merge>
+         <merge key="input.x11_options.maxy" type="string">976</merge>
+      </match>
+    </match>
+  </device>
+
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-ideaco-idc6681.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-ideaco-idc6681.fdi
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+
+<deviceinfo version="0.2">
+  <device>
+    <match key="info.product" contains="IDEACO"> 
+      <match key="info.product" contains="IDC 6681"> 
+        <match key="info.capabilities" contains="input.touchpad">
+          <merge key="input.x11_driver" type="string">evtouch</merge>
+          <merge key="input.x11_options.reportingmode" type="string">raw</merge>
+          <merge key="input.x11_options.taptimer" type="string">50</merge>
+          <merge key="input.x11_options.longtouchtimer" type="string">30</merge>
+          <merge key="input.x11_options.movelimit" type="string">15</merge>
+          <merge key="input.x11_options.emulate3buttons" type="string">true</merge>
+          <merge key="input.x11_options.emulate3timeout" type="string">50</merge>
+          <merge key="input.x11_options.maxx" type="string">1100</merge>
+          <merge key="input.x11_options.maxy" type="string">1650</merge>
+          <merge key="input.x11_options.minx" type="string">7220</merge>
+          <merge key="input.x11_options.miny" type="string">6560</merge>
+        </match>
+      </match> 
+    </match>
+  </device>
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-touchkit.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-touchkit.fdi
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+<deviceinfo version="0.2">
+  <device>
+    <match key="info.product" contains="Touchkit Touch">
+      <match key="info.capabilities" contains="input">
+        <merge key="input.x11_driver" type="string">evtouch</merge>
+        <merge key="input.x11_options.minx" type="string">130</merge>
+        <merge key="input.x11_options.miny" type="string">197</merge>
+        <merge key="input.x11_options.maxx" type="string">3945</merge>
+        <merge key="input.x11_options.maxy" type="string">3894</merge>
+        <merge key="input.x11_options.taptimer" type="string">30</merge>
+        <merge key="input.x11_options.longtouchtimer" type="string">750</merge>
+        <merge key="input.x11_options.longtouched_action" type="string">click</merge>
+        <merge key="input.x11_options.longtouched_button" type="string">3</merge>
+        <merge key="input.x11_options.oneandhalftap_button" type="string">2</merge>
+        <merge key="input.x11_options.movelimit" type="string">10</merge>
+        <merge key="input.x11_options.touched_drag" type="string">1</merge>
+        <merge key="input.x11_options.maybetapped_action" type="string">click</merge>
+        <merge key="input.x11_options.maybetapped_button" type="string">1</merge>
+      </match>
+    </match>
+  </device>
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/fdi/50-itm.fdi
+++ xf86-input-evtouch-0.8.8/debian/fdi/50-itm.fdi
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?> <!-- -*- SGML -*- -->
+
+<deviceinfo version="0.2">
+  <device>
+      <match key="info.product" contains="ITM Inc USB Touch Panel">
+        <match key="info.capabilities" contains="input.touchpad">
+          <merge key="input.x11_driver" type="string">evtouch</merge>
+          <merge key="input.x11_options.reportingmode" type="string">raw</merge>
+          <merge key="input.x11_options.emulate3buttons" type="string">true</merge>
+          <merge key="input.x11_options.emulate3timeout" type="string">50</merge>
+          <merge key="input.x11_options.sendcoreevents" type="string">on</merge>
+              <merge key="input.x11_options.maxx" type="string">3815</merge>
+              <merge key="input.x11_options.maxy" type="string">3948</merge>
+              <merge key="input.x11_options.minx" type="string">295</merge>
+              <merge key="input.x11_options.miny" type="string">200</merge>
+          <merge key="input.x11_options.Swapx" type="string">1</merge>
+          <merge key="input.x11_options.Rotate" type="string">CW</merge>
+        </match>
+    </match>
+  </device>
+</deviceinfo>
--- xf86-input-evtouch-0.8.8.orig/debian/xsfbs/xsfbs-autoreconf.mk
+++ xf86-input-evtouch-0.8.8/debian/xsfbs/xsfbs-autoreconf.mk
@@ -0,0 +1,150 @@
+#!/usr/bin/make -f
+# $Id$
+
+# Automagical conversion of autoreconf results into quilt patches.
+
+# Copyright 2006 Eugene Konev
+#
+# Licensed under the GNU General Public License, version 2.  See the file
+# /usr/share/common-licenses/GPL or <http://www.gnu.org/copyleft/gpl.txt>.
+
+# The idea behind this is storing changes produced by autoreconf as a 
+# separate patch on quilt stack (on top of stack actually).
+# The only usable target here is 'autoreconf`. Other targets are not
+# supposed to be called directly. DO NOT invoke them, unless you know what
+# you are doing.
+# The autoreconf target will check if files with names in $(RECONF_CHECKFILES)
+# were changed during patching (from upstream version or from previously
+# autoreconfed version) and call actual autoreconfing if they were.
+# The actual autoreconfing target (doautoreconf) WILL FAIL after 
+# calling autoreconf and pushing changes into quilt stack by design. It
+# should never be invoked by automatic build process.
+# The proposed use is adding autoreconf into clean's prerequisites before
+# xsfclean like:
+# - clean: xsfclean
+# + clean: autoreconf xsfclean
+# This will ensure it is called when you build package with dpkg-buildpackage.
+
+# This dir will be used for producing diff of autoreconfed tree
+RECONF_DIR := xsfautoreconf
+
+# This files will be checked for changes
+RECONF_CHECKFILES += configure.ac Makefile.am
+
+# This files will not be hardlinked but copied
+RECONF_NOLINKFILES += aclocal.m4
+
+# This files/dirs will be pruned after autoreconf run
+RECONF_PRUNEFILES += autom4te.cache config.h.in~ aclocal.m4~
+
+# Internal target. Never invoke directly.
+stampdir_target+=check.md5sum
+$(STAMP_DIR)/check.md5sum:
+	dh_testdir
+	$(MAKE) -f debian/rules prepare
+	for F in $(RECONF_CHECKFILES); do \
+	  find . -wholename ./$(STAMP_DIR) -prune -o -name $$F -print | \
+	    LC_ALL=C sort | xargs --no-run-if-empty md5sum >>$@; \
+	done
+
+# Internal target. Never invoke directly.
+$(STAMP_DIR)/clean.md5sum:
+	dh_testdir
+	$(MAKE) -f debian/rules unpatch
+	rm -f $(STAMP_DIR)/check.md5sum
+	$(MAKE) -f debian/rules $(STAMP_DIR)/check.md5sum
+	mv $(STAMP_DIR)/check.md5sum $@
+
+# Internal target. Never invoke directly.
+debian/patches/patched.md5sum:
+	dh_testdir
+	[ -f $(STAMP_DIR)/clean.md5sum ] || \
+	  $(MAKE) -f debian/rules $(STAMP_DIR)/clean.md5sum
+
+	$(MAKE) -f debian/rules patch
+	rm -f $(STAMP_DIR)/check.md5sum
+	$(MAKE) -f debian/rules $(STAMP_DIR)/check.md5sum
+	if ! diff $(STAMP_DIR)/clean.md5sum \
+	          $(STAMP_DIR)/check.md5sum > /dev/null; then \
+	  $(MAKE) -f debian/rules doautoreconf; \
+	else \
+	  mv $(STAMP_DIR)/check.md5sum $@; \
+	fi
+
+# Internal target. Never invoke directly.
+,PHONY: doautoreconf
+doautoreconf: patch
+	quilt push -a >>$(STAMP_DIR)/log/autoreconf 2>&1 || true
+	if quilt applied | grep ^autoreconf.diff$$ > /dev/null; then \
+	  quilt pop -a >>$(STAMP_DIR)/log/autoreconf 2>&1; \
+	  quilt rename -p autoreconf.diff autoreconf-old.diff \
+	       >>$(STAMP_DIR)/log/autoreconf 2>&1; \
+	  quilt delete autoreconf-old.diff >>$(STAMP_DIR)/log/autoreconf 2>&1; \
+	  quilt push -a >>$(STAMP_DIR)/log/autoreconf 2>&1; \
+	fi
+
+	if [ -e $(RECONF_DIR) ]; then \
+	  echo "ERROR: $(RECONF_DIR) already exists. Cleanup by hand"; \
+	  exit 1; \
+	fi
+
+	mkdir -p $(RECONF_DIR)/before
+	find . -maxdepth 1 -mindepth 1 ! -wholename ./$(RECONF_DIR) \
+	     -a ! -wholename ./debian -a ! -wholename ./patches \
+	     -a ! -wholename ./.pc -a ! -wholename ./$(STAMP_DIR) | \
+	  xargs -i{} cp -al {} $(RECONF_DIR)/before/
+
+	for F in $(RECONF_PRUNEFILES); do \
+	  find $(RECONF_DIR)/before -name $$F -print | \
+	    xargs --no-run-if-empty rm -r; \
+	done
+
+	cp -al $(RECONF_DIR)/before $(RECONF_DIR)/after
+
+	for F in $(RECONF_NOLINKFILES); do \
+	  find . -wholename ./$(RECONF_DIR) -prune -o -wholename ./debian \
+	       -prune -o -wholename ./$(STAMP_DIR) -prune -o -name $$F \
+	       -print | \
+	    xargs --no-run-if-empty -i{} cp --remove-destination {} \
+	      $(RECONF_DIR)/after/{}; \
+	done
+
+	cd $(RECONF_DIR)/after && autoreconf -v --install && \
+	  for F in $(RECONF_PRUNEFILES); do \
+	    find . -name $$F -print | \
+	      xargs --no-run-if-empty rm -r; \
+	  done
+
+	cd $(RECONF_DIR) && diff -Nru before after > autoreconf.diff || true
+
+	quilt import $(RECONF_DIR)/autoreconf.diff \
+	      >>$(STAMP_DIR)/log/autoreconf 2>&1
+
+	mv $(STAMP_DIR)/check.md5sum debian/patches/patched.md5sum
+
+	rm -r $(RECONF_DIR) && rm -f patches/autoreconf-old.diff
+
+	@echo 
+	@echo "****************************************************************"
+	@echo "  This target is made to fail INTENTIONALLY. It should NEVER    "
+	@echo "  be invoked during automatic builds.                           "
+	@echo 
+	@echo "  This target was invoked because you added/removed/changed     "
+	@echo "  patches which modify either configure.ac or Makefile.am and,  "
+	@echo "  thus, require autoreconf run. And all autoreconfing should    "
+	@echo "  happen before uploading.                                      "
+	@echo 
+	@echo "  (See also debian/xsfbs/xsfbs-autoreconf.mk)                   "
+	@echo 
+	@echo "  If you see this message, autoreconfing actually SUCCEEDED,    "
+	@echo "  and your build should finish successfully, when rerun.        "
+	@echo "****************************************************************"
+	@echo 
+	exit 1;
+
+.PHONY: autoreconf
+autoreconf: debian/patches/patched.md5sum patch $(STAMP_DIR)/check.md5sum
+	if ! diff $(STAMP_DIR)/check.md5sum \
+	          debian/patches/patched.md5sum > /dev/null; then \
+	  $(MAKE) -f debian/rules doautoreconf; \
+	fi
--- xf86-input-evtouch-0.8.8.orig/debian/xsfbs/xsfbs.mk
+++ xf86-input-evtouch-0.8.8/debian/xsfbs/xsfbs.mk
@@ -0,0 +1,312 @@
+#!/usr/bin/make -f
+
+# Debian X Strike Force Build System (XSFBS): Make portion
+
+# Copyright 1996 Stephen Early
+# Copyright 1997 Mark Eichin
+# Copyright 1998-2005, 2007 Branden Robinson
+# Copyright 2005 David Nusinow
+#
+# Licensed under the GNU General Public License, version 2.  See the file
+# /usr/share/common-licenses/GPL or <http://www.gnu.org/copyleft/gpl.txt>.
+
+# Originally by Stephen Early <sde1000@debian.org>
+# Modified by Mark W. Eichin <eichin@kitten.gen.ma.us>
+# Modified by Adam Heath <doogie@debian.org>
+# Modified by Branden Robinson <branden@debian.org>
+# Modified by Fabio Massimo Di Nitto <fabbione@fabbione.net>
+# Modified by David Nusinow <dnusinow@debian.org>
+# Acknowledgements to Manoj Srivastava.
+
+# Pass $(DH_OPTIONS) into the environment for debhelper's benefit.
+export DH_OPTIONS
+
+# force quilt to not use ~/.quiltrc
+QUILT = quilt --quiltrc /dev/null
+# force QUILT_PATCHES to the default in case it is exported in the environment
+QUILT_PATCHES = patches/
+
+# Set up parameters for the upstream build environment.
+
+# Determine (source) package name from Debian changelog.
+SOURCE_NAME:=$(shell dpkg-parsechangelog -ldebian/changelog \
+                        | grep '^Source:' | awk '{print $$2}')
+
+# Determine package version from Debian changelog.
+SOURCE_VERSION:=$(shell dpkg-parsechangelog -ldebian/changelog \
+                        | grep '^Version:' | awk '{print $$2}')
+
+# Determine upstream version number.
+UPSTREAM_VERSION:=$(shell echo $(SOURCE_VERSION) | sed 's/-.*//')
+
+# Determine the source version without the epoch for make-orig-tar-gz
+NO_EPOCH_VER:=$(shell echo $(UPSTREAM_VERSION) | sed 's/^.://')
+
+# Figure out who's building this package.
+BUILDER:=$(shell echo $${DEBEMAIL:-$${EMAIL:-$$(echo $$LOGNAME@$$(cat /etc/mailname 2>/dev/null))}})
+
+# Find out if this is an official build; an official build has nothing but
+# digits, dots, and/or the strings "woody" or "sarge" in the Debian part of the
+# version number.  Anything else indicates an unofficial build.
+OFFICIAL_BUILD:=$(shell VERSION=$(SOURCE_VERSION); if ! expr "$$(echo $${VERSION\#\#*-} | sed 's/\(woody\|sarge\)//g')" : ".*[^0-9.].*" >/dev/null 2>&1; then echo yes; fi)
+
+# Set up parameters for the Debian build environment.
+
+# Determine our architecture.
+BUILD_ARCH:=$(shell dpkg-architecture -qDEB_BUILD_ARCH)
+# Work around some old-time dpkg braindamage.
+BUILD_ARCH:=$(subst i486,i386,$(BUILD_ARCH))
+# The DEB_HOST_ARCH variable may be set per the Debian cross-compilation policy.
+ifdef DEB_HOST_ARCH
+ ARCH:=$(DEB_HOST_ARCH)
+else
+ # dpkg-cross sets the ARCH environment variable; if set, use it.
+ ifdef ARCH
+  ARCH:=$(ARCH)
+ else
+  ARCH:=$(BUILD_ARCH)
+ endif
+endif
+
+# $(STAMP_DIR) houses stamp files for complex targets.
+STAMP_DIR:=stampdir
+
+# $(SOURCE_DIR) houses one or more source trees.
+SOURCE_DIR:=build-tree
+
+# $(SOURCE_TREE) is the location of the source tree to be compiled.  If there
+# is more than one, others are found using this name plus a suffix to indicate
+# the purpose of the additional tree (e.g., $(SOURCE_TREE)-custom).  The
+# "setup" target is responsible for creating such trees.
+#SOURCE_TREE:=$(SOURCE_DIR)/xc
+#FIXME We need to define this in our debian/rules file
+
+# $(DEBTREEDIR) is where all install rules are told (via $(DESTDIR)) to place
+# their files.
+DEBTREEDIR:=$(CURDIR)/debian/tmp
+
+# All "important" targets have four lines:
+#   1) A target name that is invoked by a package-building tool or the user.
+#      This consists of a dependency on a "$(STAMP_DIR)/"-prefixed counterpart.
+#   2) A line delcaring 1) as a phony target (".PHONY:").
+#   3) A "$(STAMP_DIR)/"-prefixed target which does the actual work, and may
+#   depend on other targets.
+#   4) A line declaring 3) as a member of the $(stampdir_targets) variable; the
+#   "$(STAMP_DIR)/" prefix is omitted.
+#
+# This indirection is needed so that the "stamp" files that signify when a rule
+# is done can be located in a separate "stampdir".  Recall that make has no way
+# to know when a goal has been met for a phony target (like "build" or
+# "install").
+#
+# At the end of each "$(STAMP_DIR)/" target, be sure to run the command ">$@"
+# so that the target will not be run again.  Removing the file will make Make
+# run the target over.
+
+# All phony targets should be declared as dependencies of .PHONY, even if they
+# do not have "($STAMP_DIR)/"-prefixed counterparts.
+
+# Define a harmless default rule to keep things from going nuts by accident.
+.PHONY: default
+default:
+
+# Set up the $(STAMP_DIR) directory.
+.PHONY: stampdir
+stampdir_targets+=stampdir
+stampdir: $(STAMP_DIR)/stampdir
+$(STAMP_DIR)/stampdir:
+	mkdir $(STAMP_DIR)
+	>$@
+
+# Set up the package build directory as quilt expects to find it.
+.PHONY: prepare
+stampdir_targets+=prepare
+prepare: $(STAMP_DIR)/genscripts $(STAMP_DIR)/prepare $(STAMP_DIR)/patches $(STAMP_DIR)/log
+$(STAMP_DIR)/prepare: $(STAMP_DIR)/stampdir
+	if [ ! -e $(STAMP_DIR)/patches ]; then \
+		mkdir $(STAMP_DIR)/patches; \
+		ln -s $(STAMP_DIR)/patches .pc; \
+		echo 2 >$(STAMP_DIR)/patches/.version; \
+	fi; \
+	if [ ! -e $(STAMP_DIR)/log ]; then \
+		mkdir $(STAMP_DIR)/log; \
+	fi; \
+	if [ -e debian/patches ] && [ ! -e patches ]; then \
+		ln -s debian/patches patches; \
+	fi; \
+	>$@
+
+# Apply all patches to the upstream source.
+.PHONY: patch
+stampdir_targets+=patch
+patch: $(STAMP_DIR)/patch
+$(STAMP_DIR)/patch: $(STAMP_DIR)/prepare
+	if ! [ `which quilt` ]; then \
+		echo "Couldn't find quilt. Please install it or add it to the build-depends for this package."; \
+		exit 1; \
+	fi; \
+	if $(QUILT) next >/dev/null 2>&1; then \
+	  echo -n "Applying patches..."; \
+	  if $(QUILT) push -a -v >$(STAMP_DIR)/log/patch 2>&1; then \
+	    cat $(STAMP_DIR)/log/patch; \
+	    echo "successful."; \
+	  else \
+	    cat $(STAMP_DIR)/log/patch; \
+	    echo "failed! (check $(STAMP_DIR)/log/patch for details)"; \
+	    exit 1; \
+	  fi; \
+	else \
+	  echo "No patches to apply"; \
+	fi; \
+	>$@
+
+# Revert all patches to the upstream source.
+.PHONY: unpatch
+unpatch:
+	rm -f $(STAMP_DIR)/patch
+	@echo -n "Unapplying patches..."; \
+	if [ -e $(STAMP_DIR)/patches/applied-patches ]; then \
+	  if $(QUILT) pop -a -v >$(STAMP_DIR)/log/unpatch 2>&1; then \
+	    cat $(STAMP_DIR)/log/unpatch; \
+	    echo "successful."; \
+	  else \
+	    cat $(STAMP_DIR)/log/unpatch; \
+	    echo "failed! (check $(STAMP_DIR)/log/unpatch for details)"; \
+	    exit 1; \
+	  fi; \
+	else \
+	  echo "nothing to do."; \
+	fi
+
+# Clean the generated maintainer scripts.
+.PHONY: cleanscripts
+cleanscripts:
+	rm -f $(STAMP_DIR)/genscripts
+	rm -f debian/*.config \
+	      debian/*.postinst \
+	      debian/*.postrm \
+	      debian/*.preinst \
+	      debian/*.prerm
+
+# Clean the package build tree.
+.PHONY: xsfclean
+xsfclean: cleanscripts unpatch
+	dh_testdir
+	rm -f .pc patches
+	rm -rf $(STAMP_DIR) $(SOURCE_DIR)
+	rm -rf imports
+	dh_clean debian/shlibs.local \
+	         debian/po/pothead
+
+# Generate the debconf templates POT file header.
+debian/po/pothead: debian/po/pothead.in
+	sed -e 's/SOURCE_VERSION/$(SOURCE_VERSION)/' \
+	  -e 's/DATE/$(shell date "+%F %X%z"/)' <$< >$@
+
+# Update POT and PO files.
+.PHONY: updatepo
+updatepo: debian/po/pothead
+	debian/scripts/debconf-updatepo --pot-header=pothead --verbose
+
+# Remove files from the upstream source tree that we don't need, or which have
+# licensing problems.  It must be run before creating the .orig.tar.gz.
+#
+# Note: This rule is for Debian package maintainers' convenience, and is not
+# needed for conventional build scenarios.
+.PHONY: prune-upstream-tree
+prune-upstream-tree:
+	# Ensure we're in the correct directory.
+	dh_testdir
+	grep -rvh '^#' debian/prune/ | xargs --no-run-if-empty rm -rf
+
+# Verify that there are no offsets or fuzz in the patches we apply.
+#
+# Note: This rule is for Debian package maintainers' convenience, and is not
+# needed for conventional build scenarios.
+.PHONY: patch-audit
+patch-audit: prepare unpatch
+	@echo -n "Auditing patches..."; \
+	>$(STAMP_DIR)/log/patch; \
+	FUZZY=; \
+	while [ -n "$$($(QUILT) next)" ]; do \
+	  RESULT=$$($(QUILT) push -v | tee -a $(STAMP_DIR)/log/patch | grep ^Hunk | sed 's/^Hunk.*\(succeeded\|FAILED\).*/\1/');\
+	  case "$$RESULT" in \
+	    succeeded) \
+	      echo "fuzzy patch: $$($(QUILT) top)" \
+	        | tee -a $(STAMP_DIR)/log/$$($(QUILT) top); \
+	      FUZZY=yes; \
+	      ;; \
+	    FAILED) \
+	      echo "broken patch: $$($(QUILT) next)" \
+	        | tee -a $(STAMP_DIR)/log/$$($(QUILT) next); \
+	      exit 1; \
+	      ;; \
+	  esac; \
+	done; \
+	if [ -n "$$FUZZY" ]; then \
+	  echo "there were fuzzy patches; please fix."; \
+	  exit 1; \
+	else \
+	  echo "done."; \
+	fi
+
+# Generate the maintainer scripts.
+.PHONY: genscripts
+stampdir_targets+=genscripts
+genscripts: $(STAMP_DIR)/genscripts
+$(STAMP_DIR)/genscripts: $(STAMP_DIR)/stampdir
+	for FILE in debian/*.config.in \
+	            debian/*.postinst.in \
+	            debian/*.postrm.in \
+	            debian/*.preinst.in \
+	            debian/*.prerm.in; do \
+	  if [ -e "$$FILE" ]; then \
+	    MAINTSCRIPT=$$(echo $$FILE | sed 's/.in$$//'); \
+	    sed -n '1,/^#INCLUDE_SHELL_LIB#$$/p' <$$FILE \
+	      | sed -e '/^#INCLUDE_SHELL_LIB#$$/d' >$$MAINTSCRIPT.tmp; \
+	    cat debian/xsfbs/xsfbs.sh >>$$MAINTSCRIPT.tmp; \
+	    sed -n '/^#INCLUDE_SHELL_LIB#$$/,$$p' <$$FILE \
+	      | sed -e '/^#INCLUDE_SHELL_LIB#$$/d' >>$$MAINTSCRIPT.tmp; \
+	    sed -e 's/@SOURCE_VERSION@/$(SOURCE_VERSION)/' \
+	        -e 's/@OFFICIAL_BUILD@/$(OFFICIAL_BUILD)/' \
+	        -e 's/@DEFAULT_DCRESOLUTIONS@/$(DEFAULT_DCRESOLUTIONS)/' \
+	      <$$MAINTSCRIPT.tmp >$$MAINTSCRIPT; \
+	    rm $$MAINTSCRIPT.tmp; \
+	  fi; \
+	done
+	# Validate syntax of generated shell scripts.
+	#sh debian/scripts/validate-posix-sh debian/*.config \
+	#                                    debian/*.postinst \
+	#                                    debian/*.postrm \
+	#                                    debian/*.preinst \
+	#                                    debian/*.prerm
+	>$@
+
+# Generate the shlibs.local file.
+debian/shlibs.local:
+	cat debian/*.shlibs >$@
+
+SERVERMINVERS = $(shell cat /usr/share/xserver-xorg/serverminver 2>/dev/null)
+VIDEOABI = $(shell cat /usr/share/xserver-xorg/videoabiver 2>/dev/null)
+INPUTABI = $(shell cat /usr/share/xserver-xorg/inputabiver 2>/dev/null)
+SERVER_DEPENDS = xserver-xorg-core (>= $(SERVERMINVERS))
+VIDDRIVER_PROVIDES = xserver-xorg-video-$(VIDEOABI)
+INPDRIVER_PROVIDES = xserver-xorg-input-$(INPUTABI)
+ifeq ($(PACKAGE),)
+PACKAGE=$(shell awk '/^Package:/ { print $$2; exit }' < debian/control)
+endif
+
+.PHONY: serverabi
+serverabi:
+ifeq ($(SERVERMINVERS),)
+	@echo error: xserver-xorg-dev needs to be installed
+	@exit 1
+else
+	echo "xserver:Depends=$(SERVER_DEPENDS)" >> debian/$(PACKAGE).substvars
+	echo "xviddriver:Provides=$(VIDDRIVER_PROVIDES)" >> debian/$(PACKAGE).substvars
+	echo "xinpdriver:Provides=$(INPDRIVER_PROVIDES)" >> debian/$(PACKAGE).substvars
+endif
+
+include debian/xsfbs/xsfbs-autoreconf.mk
+
+# vim:set noet ai sts=8 sw=8 tw=0:
--- xf86-input-evtouch-0.8.8.orig/debian/xsfbs/xsfbs.sh
+++ xf86-input-evtouch-0.8.8/debian/xsfbs/xsfbs.sh
@@ -0,0 +1,900 @@
+# $Id$
+
+# This is the X Strike Force shell library for X Window System package
+# maintainer scripts.  It serves to define shell functions commonly used by
+# such packages, and performs some error checking necessary for proper operation
+# of those functions.  By itself, it does not "do" much; the maintainer scripts
+# invoke the functions defined here to accomplish package installation and
+# removal tasks.
+
+# If you are reading this within a Debian package maintainer script (e.g.,
+# /var/lib/dpkg)info/PACKAGE.{config,preinst,postinst,prerm,postrm}), you can
+# skip past this library by scanning forward in this file to the string
+# "GOBSTOPPER".
+
+SOURCE_VERSION=@SOURCE_VERSION@
+OFFICIAL_BUILD=@OFFICIAL_BUILD@
+
+# Use special abnormal exit codes so that problems with this library are more
+# easily tracked down.
+SHELL_LIB_INTERNAL_ERROR=86
+SHELL_LIB_THROWN_ERROR=74
+SHELL_LIB_USAGE_ERROR=99
+
+# old -> new variable names
+if [ -z "$DEBUG_XORG_PACKAGE" ] && [ -n "$DEBUG_XFREE86_PACKAGE" ]; then
+  DEBUG_XORG_PACKAGE="$DEBUG_XFREE86_PACKAGE"
+fi
+if [ -z "$DEBUG_XORG_DEBCONF" ] && [ -n "$DEBUG_XFREE86_DEBCONF" ]; then
+  DEBUG_XORG_DEBCONF="$DEBUG_XFREE86_DEBCONF"
+fi
+
+# initial sanity checks
+if [ -z "$THIS_PACKAGE" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_PACKAGE shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of this package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ -z "$THIS_SCRIPT" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_SCRIPT shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of the
+"$THIS_PACKAGE" package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+ARCHITECTURE="$(dpkg --print-installation-architecture)"
+
+if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
+  RECONFIGURE="true"
+else
+  RECONFIGURE=
+fi
+
+if ([ "$1" = "install" ] || [ "$1" = "configure" ]) && [ -z "$2" ]; then
+  FIRSTINST="yes"
+fi
+
+if [ -z "$RECONFIGURE" ] && [ -z "$FIRSTINST" ]; then
+  UPGRADE="yes"
+fi
+
+trap "message;\
+      message \"Received signal.  Aborting $THIS_PACKAGE package $THIS_SCRIPT script.\";\
+      message;\
+      exit 1" HUP INT QUIT TERM
+
+reject_nondigits () {
+  # syntax: reject_nondigits [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters other than decimal digits and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain anything but digits?
+    if ! expr "$1" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+      # can't use die(), because it wraps message() which wraps this function
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_nondigits() encountered" \
+           "possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+reject_whitespace () {
+  # syntax: reject_whitespace [ operand ]
+  #
+  # scan operand (typically a shell variable whose value cannot be trusted) for
+  # whitespace characters and barf if any are found
+  if [ -n "$1" ]; then
+    # does the operand contain any whitespace?
+    if expr "$1" : "[[:space:]]" > /dev/null 2>&1; then
+      # can't use die(), because I want to avoid forward references
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_whitespace() encountered" \
+           "possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+  fi
+}
+
+reject_unlikely_path_chars () {
+  # syntax: reject_unlikely_path_chars [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters unlikely to be seen in a path and which the shell might
+  # interpret and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain any funny characters?
+    if expr "$1" : '.*[!$&()*;<>?|].*' > /dev/null 2>&1; then
+      # can't use die(), because I want to avoid forward references
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_unlikely_path_chars()" \
+           "encountered possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+# Query the terminal to establish a default number of columns to use for
+# displaying messages to the user.  This is used only as a fallback in the
+# event the COLUMNS variable is not set.  ($COLUMNS can react to SIGWINCH while
+# the script is running, and this cannot, only being calculated once.)
+DEFCOLUMNS=$(stty size 2> /dev/null | awk '{print $2}') || true
+if ! expr "$DEFCOLUMNS" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+  DEFCOLUMNS=80
+fi
+
+message () {
+  # pretty-print messages of arbitrary length
+  reject_nondigits "$COLUMNS"
+  echo "$*" | fmt -t -w ${COLUMNS:-$DEFCOLUMNS} >&2
+}
+
+observe () {
+  # syntax: observe message ...
+  #
+  # issue observational message suitable for logging someday when support for
+  # it exists in dpkg
+  if [ -n "$DEBUG_XORG_PACKAGE" ]; then
+    message "$THIS_PACKAGE $THIS_SCRIPT note: $*"
+  fi
+}
+
+warn () {
+  # syntax: warn message ...
+  #
+  # issue warning message suitable for logging someday when support for
+  # it exists in dpkg; also send to standard error
+  message "$THIS_PACKAGE $THIS_SCRIPT warning: $*"
+}
+
+die () {
+  # syntax: die message ...
+  #
+  # exit script with error message
+  message "$THIS_PACKAGE $THIS_SCRIPT error: $*"
+  exit $SHELL_LIB_THROWN_ERROR
+}
+
+internal_error () {
+  # exit script with error; essentially a "THIS SHOULD NEVER HAPPEN" message
+  message "internal error: $*"
+  if [ -n "$OFFICIAL_BUILD" ]; then
+    message "Please report a bug in the $THIS_SCRIPT script of the" \
+            "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+            "Tracking System.  Include all messages above that mention the" \
+            "$THIS_PACKAGE package.  Visit " \
+            "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+            "instructions, read the file" \
+            "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+            "package, or install the reportbug package and use the command of" \
+            "the same name to file a report."
+  fi
+  exit $SHELL_LIB_INTERNAL_ERROR
+}
+
+usage_error () {
+  message "usage error: $*"
+  message "Please report a bug in the $THIS_SCRIPT script of the" \
+          "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+          "Tracking System.  Include all messages above that mention the" \
+          "$THIS_PACKAGE package.  Visit " \
+          "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+          "instructions, read the file" \
+          "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+          "package, or install the reportbug package and use the command of" \
+          "the same name to file a report."
+  exit $SHELL_LIB_USAGE_ERROR
+}
+
+
+maplink () {
+  # returns what symlink should point to; i.e., what the "sane" answer is
+  # Keep this in sync with the debian/*.links files.
+  # This is only needed for symlinks to directories.
+  #
+  # XXX: Most of these look wrong in the X11R7 world and need to be fixed.
+  # If we've stopped using this function, fixing it might enable us to re-enable
+  # it again and catch more errors.
+  case "$1" in
+    /etc/X11/xkb/compiled) echo /var/lib/xkb ;;
+    /etc/X11/xkb/xkbcomp) echo /usr/X11R6/bin/xkbcomp ;;
+    /usr/X11R6/lib/X11/app-defaults) echo /etc/X11/app-defaults ;;
+    /usr/X11R6/lib/X11/fs) echo /etc/X11/fs ;;
+    /usr/X11R6/lib/X11/lbxproxy) echo /etc/X11/lbxproxy ;;
+    /usr/X11R6/lib/X11/proxymngr) echo /etc/X11/proxymngr ;;
+    /usr/X11R6/lib/X11/rstart) echo /etc/X11/rstart ;;
+    /usr/X11R6/lib/X11/twm) echo /etc/X11/twm ;;
+    /usr/X11R6/lib/X11/xdm) echo /etc/X11/xdm ;;
+    /usr/X11R6/lib/X11/xinit) echo /etc/X11/xinit ;;
+    /usr/X11R6/lib/X11/xkb) echo /etc/X11/xkb ;;
+    /usr/X11R6/lib/X11/xserver) echo /etc/X11/xserver ;;
+    /usr/X11R6/lib/X11/xsm) echo /etc/X11/xsm ;;
+    /usr/bin/X11) echo ../X11R6/bin ;;
+    /usr/bin/rstartd) echo ../X11R6/bin/rstartd ;;
+    /usr/include/X11) echo ../X11R6/include/X11 ;;
+    /usr/lib/X11) echo ../X11R6/lib/X11 ;;
+    *) internal_error "maplink() called with unknown path \"$1\"" ;;
+  esac
+}
+
+analyze_path () {
+  # given a supplied set of pathnames, break each one up by directory and do an
+  # ls -dl on each component, cumulatively; i.e.
+  # analyze_path /usr/X11R6/bin -> ls -dl /usr /usr/X11R6 /usr/X11R6/bin
+  # Thanks to Randolph Chung for this clever hack.
+
+  #local f g
+
+  while [ -n "$1" ]; do
+    reject_whitespace "$1"
+    _g=
+    message "Analyzing $1:"
+    for _f in $(echo "$1" | tr / \  ); do
+      if [ -e /$_g$_f ]; then
+        ls -dl /$_g$_f /$_g$_f.dpkg-* 2> /dev/null || true
+        _g=$_g$_f/
+      else
+        message "/$_g$_f: nonexistent; directory contents of /$_g:"
+        ls -l /$_g
+        break
+      fi
+    done
+    shift
+  done
+}
+
+find_culprits () {
+  #local f p dpkg_info_dir possible_culprits smoking_guns bad_packages package \
+  #  msg
+
+  reject_whitespace "$1"
+  message "Searching for overlapping packages..."
+  _dpkg_info_dir=/var/lib/dpkg/info
+  if [ -d $_dpkg_info_dir ]; then
+    if [ "$(echo $_dpkg_info_dir/*.list)" != "$_dpkg_info_dir/*.list" ]; then
+      _possible_culprits=$(ls -1 $_dpkg_info_dir/*.list | egrep -v \
+        "(xbase-clients|x11-common|xfs|xlibs)")
+      if [ -n "$_possible_culprits" ]; then
+        _smoking_guns=$(grep -l "$1" $_possible_culprits || true)
+        if [ -n "$_smoking_guns" ]; then
+          _bad_packages=$(printf "\\n")
+          for f in $_smoking_guns; do
+            # too bad you can't nest parameter expansion voodoo
+            p=${f%*.list}      # strip off the trailing ".list"
+            _package=${p##*/}   # strip off the directories
+            _bad_packages=$(printf "%s\n%s" "$_bad_packages" "$_package")
+          done
+          _msg=$(cat <<EOF
+The following packages appear to have file overlaps with the X.Org packages;
+these packages are either very old, or in violation of Debian Policy.  Try
+upgrading each of these packages to the latest available version if possible:
+for example, with the command "apt-get install".  If no newer version of a
+package is available, you will have to remove it; for example, with the command
+"apt-get remove".  If even the latest available version of the package has
+this file overlap, please file a bug against that package with the Debian Bug
+Tracking System.  You may want to refer the package maintainer to section 12.8
+of the Debian Policy manual.
+EOF
+)
+          message "$_msg"
+          message "The overlapping packages are: $_bad_packages"
+        else
+          message "no overlaps found."
+        fi
+      fi
+    else
+      message "cannot search; no matches for $_dpkg_info_dir/*.list."
+    fi
+  else
+    message "cannot search; $_dpkg_info_dir does not exist."
+  fi
+}
+
+# we require a readlink command or shell function
+if ! which readlink > /dev/null 2>&1; then
+  message "The readlink command was not found.  Please install version" \
+          "1.13.1 or later of the debianutils package."
+  readlink () {
+    # returns what symlink in $1 actually points to
+    perl -e '$l = shift; exit 1 unless -l $l; $r = readlink $l; exit 1 unless $r; print "$r\n"' "$1"
+  }
+fi
+
+check_symlink () {
+  # syntax: check_symlink symlink
+  #
+  # See if specified symlink points where it is supposed to.  Return 0 if it
+  # does, and 1 if it does not.
+  #
+  # Primarily used by check_symlinks_and_warn() and check_symlinks_and_bomb().
+
+  #local symlink
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "check_symlink() called with wrong number of arguments;" \
+                "expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  _symlink="$1"
+
+  if [ "$(maplink "$_symlink")" = "$(readlink "$_symlink")" ]; then
+    return 0
+  else
+    return 1
+  fi
+}
+
+check_symlinks_and_warn () {
+  # syntax: check_symlinks_and_warn symlink ...
+  #
+  # For each argument, check for symlink sanity, and warn if it isn't sane.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install".
+
+  #local errmsg symlink
+
+  # validate arguments
+  if [ $# -lt 1 ]; then
+    usage_error "check_symlinks_and_warn() called with wrong number of" \
+                "arguments; expected at least 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  while [ -n "$1" ]; do
+    _symlink="$1"
+    if [ -L "$_symlink" ]; then
+      if ! check_symlink "$_symlink"; then
+        observe "$_symlink symbolic link points to wrong location" \
+                "$(readlink "$_symlink"); removing"
+        rm "$_symlink"
+      fi
+    elif [ -e "$_symlink" ]; then
+      _errmsg="$_symlink exists and is not a symbolic link; this package cannot"
+      _errmsg="$_errmsg be installed until this"
+      if [ -f "$_symlink" ]; then
+        _errmsg="$_errmsg file"
+      elif [ -d "$_symlink" ]; then
+        _errmsg="$_errmsg directory"
+      else
+        _errmsg="$_errmsg thing"
+      fi
+      _errmsg="$_errmsg is removed"
+      die "$_errmsg"
+    fi
+    shift
+  done
+}
+
+check_symlinks_and_bomb () {
+  # syntax: check_symlinks_and_bomb symlink ...
+  #
+  # For each argument, check for symlink sanity, and bomb if it isn't sane.
+  #
+  # Call this function from a postinst script.
+
+  #local problem symlink
+
+  # validate arguments
+  if [ $# -lt 1 ]; then
+    usage_error "check_symlinks_and_bomb() called with wrong number of"
+                "arguments; expected at least 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  while [ -n "$1" ]; do
+    _problem=
+    _symlink="$1"
+    if [ -L "$_symlink" ]; then
+      if ! check_symlink "$_symlink"; then
+        _problem=yes
+        warn "$_symlink symbolic link points to wrong location" \
+             "$(readlink "$_symlink")"
+      fi
+    elif [ -e "$_symlink" ]; then
+      _problem=yes
+      warn "$_symlink is not a symbolic link"
+    else
+      _problem=yes
+      warn "$_symlink symbolic link does not exist"
+    fi
+    if [ -n "$_problem" ]; then
+      analyze_path "$_symlink" "$(readlink "$_symlink")"
+      find_culprits "$_symlink"
+      die "bad symbolic links on system"
+    fi
+    shift
+  done
+}
+
+font_update () {
+  # run $UPDATECMDS in $FONTDIRS
+
+  #local dir cmd shortcmd x_font_dir_prefix
+
+  _x_font_dir_prefix="/usr/share/fonts/X11"
+
+  if [ -z "$UPDATECMDS" ]; then
+    usage_error "font_update() called but \$UPDATECMDS not set"
+  fi
+  if [ -z "$FONTDIRS" ]; then
+    usage_error "font_update() called but \$FONTDIRS not set"
+  fi
+
+  reject_unlikely_path_chars "$UPDATECMDS"
+  reject_unlikely_path_chars "$FONTDIRS"
+
+  for _dir in $FONTDIRS; do
+    if [ -d "$_x_font_dir_prefix/$_dir" ]; then
+      for _cmd in $UPDATECMDS; do
+        if which "$_cmd" > /dev/null 2>&1; then
+          _shortcmd=${_cmd##*/}
+          observe "running $_shortcmd in $_dir font directory"
+	  _cmd_opts=
+          if [ "$_shortcmd" = "update-fonts-alias" ]; then
+            _cmd_opts=--x11r7-layout
+          fi
+          if [ "$_shortcmd" = "update-fonts-dir" ]; then
+            _cmd_opts=--x11r7-layout
+          fi
+          if [ "$_shortcmd" = "update-fonts-scale" ]; then
+            _cmd_opts=--x11r7-layout
+          fi
+          $_cmd $_cmd_opts $_dir || warn "$_cmd $_cmd_opts $_dir" \
+                              "failed; font directory data may not" \
+                              "be up to date"
+        else
+          warn "$_cmd not found; not updating corresponding $_dir font" \
+               "directory data"
+        fi
+      done
+    else
+      warn "$_dir is not a directory; not updating font directory data"
+    fi
+  done
+}
+
+remove_conffile_prepare () {
+  # syntax: remove_conffile_prepare filename official_md5sum ...
+  #
+  # Check a conffile "filename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  #local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 2 ]; then
+    usage_error "remove_conffile_prepare() called with wrong number of" \
+                "arguments; expected at least 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  _conffile="$1"
+  shift
+
+  # does the _conffile even exist?
+  if [ -e "$_conffile" ]; then
+    # calculate its checksum
+    _current_checksum=$(md5sum < "$_conffile" | sed 's/[[:space:]].*//')
+    # compare it to each supplied checksum
+    while [ -n "$1" ]; do
+      if [ "$_current_checksum" = "$1" ]; then
+        # we found a match; move the confffile and stop looking
+        observe "preparing obsolete conffile $_conffile for removal"
+        mv "$_conffile" "$_conffile.$THIS_PACKAGE-tmp"
+        break
+      fi
+      shift
+    done
+  fi
+}
+
+remove_conffile_commit () {
+  # syntax: remove_conffile_commit filename
+  #
+  # Complete the removal of a conffile "filename" that has become obsolete.
+  #
+  # Call this function from a postinst script after having used
+  # remove_conffile_prepare() in the preinst.
+
+  #local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_commit() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  _conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, remove it
+  if [ -e "$_conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "committing removal of obsolete conffile $_conffile"
+    rm "$_conffile.$THIS_PACKAGE-tmp"
+  fi
+}
+
+remove_conffile_rollback () {
+  # syntax: remove_conffile_rollback filename
+  #
+  # Roll back the removal of a conffile "filename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" is  after having used remove_conffile_prepare() in the
+  # preinst.
+
+  #local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_rollback() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  _conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, move it
+  # back
+  if [ -e "$_conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "rolling back removal of obsolete conffile $_conffile"
+    mv "$_conffile.$THIS_PACKAGE-tmp" "$_conffile"
+  fi
+}
+
+replace_conffile_with_symlink_prepare () {
+  # syntax: replace_conffile_with_symlink_prepare oldfilename newfilename \
+  # official_md5sum ...
+  #
+  # Check a conffile "oldfilename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails. Otherwise copy it
+  # to newfilename and let dpkg handle it through conffiles mechanism.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  #local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 3 ]; then
+    usage_error "replace_conffile_with_symlink_prepare() called with wrong" \
+                " number of arguments; expected at least 3, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  _oldconffile="$1"
+  shift
+  _newconffile="$1"
+  shift
+
+  remove_conffile_prepare "$_oldconffile" "$@"
+  # If $_oldconffile still exists, then md5sums didn't match.
+  # Copy it to new one.
+  if [ -f "$_oldconffile" ]; then
+    cp "$_oldconffile" "$_newconffile"
+  fi
+
+}
+
+replace_conffile_with_symlink_commit () {
+  # syntax: replace_conffile_with_symlink_commit oldfilename
+  #
+  # Complete the removal of a conffile "oldfilename" that has been
+  # replaced by a symlink.
+  #
+  # Call this function from a postinst script after having used
+  # replace_conffile_with_symlink_prepare() in the preinst.
+
+  #local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "replace_conffile_with_symlink_commit() called with wrong" \
+                "number of arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  _conffile="$1"
+
+  remove_conffile_commit "$_conffile"
+}
+
+replace_conffile_with_symlink_rollback () {
+  # syntax: replace_conffile_with_symlink_rollback oldfilename newfilename
+  #
+  # Roll back the replacing of a conffile "oldfilename" with symlink to
+  # "newfilename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" and verify $2 to ensure the package failed to upgrade
+  # from a version (or install over a version removed-but-not-purged) prior
+  # to the one in which the conffile was obsoleted.
+  # You should have  used replace_conffile_with_symlink_prepare() in the
+  # preinst.
+
+  #local conffile
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "replace_conffile_with_symlink_rollback() called with wrong" \
+                "number of arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  _oldconffile="$1"
+  _newconffile="$2"
+
+  remove_conffile_rollback "$_oldconffile"
+  if [ -f "$_newconffile" ]; then
+    rm "$_newconffile"
+  fi
+}
+
+run () {
+  # syntax: run command [ argument ... ]
+  #
+  # Run specified command with optional arguments and report its exit status.
+  # Useful for commands whose exit status may be nonzero, but still acceptable,
+  # or commands whose failure is not fatal to us.
+  #
+  # NOTE: Do *not* use this function with db_get or db_metaget commands; in
+  # those cases the return value of the debconf command *must* be checked
+  # before the string returned by debconf is used for anything.
+
+  #local retval
+
+  # validate arguments
+  if [ $# -lt 1 ]; then
+    usage_error "run() called with wrong number of arguments; expected at" \
+                "least 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  "$@" || _retval=$?
+
+  if [ ${_retval:-0} -ne 0 ]; then
+    observe "command \"$*\" exited with status $_retval"
+  fi
+}
+
+register_x_lib_dir_with_ld_so () {
+  # syntax: register_x_lib_dir_with_ld_so
+  #
+  # Configure the dynamic loader ld.so to search /usr/X11R6/lib for shared
+  # libraries.
+  #
+  # Call this function from the postinst script of a package that places a
+  # shared library in /usr/X11R6/lib, before invoking ldconfig.
+
+  #local dir ldsoconf
+
+  _dir="/usr/X11R6/lib"
+  _ldsoconf="/etc/ld.so.conf"
+
+  # is the line not already present?
+  if ! fgrep -qsx "$_dir" "$_ldsoconf"; then
+    observe "adding $_dir directory to $_ldsoconf"
+    echo "$_dir" >> "$_ldsoconf"
+  fi
+}
+
+deregister_x_lib_dir_with_ld_so () {
+  # syntax: deregister_x_lib_dir_with_ld_so
+  #
+  # Configure dynamic loader ld.so to not search /usr/X11R6/lib for shared
+  # libraries, if and only if no shared libaries remain there.
+  #
+  # Call this function from the postrm script of a package that places a shared
+  # library in /usr/X11R6/lib, in the event "$1" is "remove", and before
+  # invoking ldconfig.
+
+  #local dir ldsoconf fgrep_status cmp_status
+
+  _dir="/usr/X11R6/lib"
+  _ldsoconf="/etc/ld.so.conf"
+
+  # is the line present?
+  if fgrep -qsx "$_dir" "$_ldsoconf"; then
+    # are there any shared objects in the directory?
+    if [ "$(echo "$_dir"/lib*.so.*.*)" = "$_dir/lib*.so.*.*" ]; then
+      # glob expansion produced nothing, so no shared libraries are present
+      observe "removing $_dir directory from $_ldsoconf"
+      # rewrite the file (very carefully)
+      set +e
+      fgrep -svx "$_dir" "$_ldsoconf" > "$_ldsoconf.dpkg-tmp"
+      _fgrep_status=$?
+      set -e
+      case $_fgrep_status in
+        0|1) ;; # we don't actually care if any lines matched or not
+        *) die "error reading \"$_ldsoconf\"; fgrep exited with status" \
+          "$_fgrep_status" ;;
+      esac
+      set +e
+      cmp -s "$_ldsoconf.dpkg-tmp" "$_ldsoconf"
+      _cmp_status=$?
+      set -e
+      case $_cmp_status in
+        0) rm "$_ldsoconf.dpkg-tmp" ;; # files are identical
+        1) mv "$_ldsoconf.dpkg-tmp" "$_ldsoconf" ;; # files differ
+        *) die "error comparing \"$_ldsoconf.dpkg-tmp\" to \"$_ldsoconf\";" \
+          "cmp exited with status $_cmp_status" ;;
+      esac
+    fi
+  fi
+}
+
+make_symlink_sane () {
+  # syntax: make_symlink_sane symlink target
+  #
+  # Ensure that the symbolic link symlink exists, and points to target.
+  #
+  # If symlink does not exist, create it and point it at target.
+  #
+  # If symlink exists but is not a symbolic link, back it up.
+  #
+  # If symlink exists, is a symbolic link, but points to the wrong location, fix
+  # it.
+  #
+  # If symlink exists, is a symbolic link, and already points to target, do
+  # nothing.
+  #
+  # This function wouldn't be needed if ln had an -I, --idempotent option.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "make_symlink_sane() called with wrong number of arguments;" \
+      "expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  #local symlink target
+
+  _symlink="$1"
+  _target="$2"
+
+  if [ -L "$_symlink" ] && [ "$(readlink "$_symlink")" = "$_target" ]; then
+      observe "link from $_symlink to $_target already exists"
+  else
+    observe "creating symbolic link from $_symlink to $_target"
+    mkdir -p "${_target%/*}" "${_symlink%/*}"
+    ln -s -b -S ".dpkg-old" "$_target" "$_symlink"
+  fi
+}
+
+migrate_dir_to_symlink () {
+  # syntax: migrate_dir_to_symlink old_location new_location
+  #
+  # Per Debian Policy section 6.5.4, "A directory will never be replaced by a
+  # symbolic link to a directory or vice versa; instead, the existing state
+  # (symlink or not) will be left alone and dpkg will follow the symlink if
+  # there is one."
+  #
+  # We have to do it ourselves.
+  #
+  # This function moves the contents of old_location, a directory, into
+  # new_location, a directory, then makes old_location a symbolic link to
+  # new_location.
+  #
+  # old_location need not exist, but if it does, it must be a directory (or a
+  # symlink to a directory).  If it is not, it is backed up.  If new_location
+  # exists already and is not a directory, it is backed up.
+  #
+  # This function should be called from a package's preinst so that other
+  # packages unpacked after this one --- but before this package's postinst runs
+  # --- are unpacked into new_location even if their payloads contain
+  # old_location filespecs.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "migrate_dir_to_symlink() called with wrong number of"
+                "arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local _new _old
+
+  _old="$1"
+  _new="$2"
+
+  # Is old location a symlink?
+  if [ -L "$_old" ]; then
+    # Does it already point to new location?
+    if [ "$(readlink "$_old")" = "$_new" ]; then
+      # Nothing to do; migration has already been done.
+      observe "migration of $_old to $_new already done"
+      return 0
+    else
+      # Back it up.
+      warn "backing up symbolic link $_old as $_old.dpkg-old"
+      mv -b "$_old" "$_old.dpkg-old"
+    fi
+  fi
+
+  # Does old location exist, but is not a directory?
+  if [ -e "$_old" ] && ! [ -d "$_old" ]; then
+      # Back it up.
+      warn "backing up non-directory $_old as $_old.dpkg-old"
+      mv -b "$_old" "$_old.dpkg-old"
+  fi
+
+  observe "migrating $_old to $_new"
+
+  # Is new location a symlink?
+  if [ -L "$_new" ]; then
+    # Does it point the wrong way, i.e., back to where we're migrating from?
+    if [ "$(readlink "$_new")" = "$_old" ]; then
+      # Get rid of it.
+      observe "removing symbolic link $_new which points to $_old"
+      rm "$_new"
+    else
+      # Back it up.
+      warn "backing up symbolic link $_new as $_new.dpkg-old"
+      mv -b "$_new" "$_new.dpkg-old"
+    fi
+  fi
+
+  # Does new location exist, but is not a directory?
+  if [ -e "$_new" ] && ! [ -d "$_new" ]; then
+    warn "backing up non-directory $_new as $_new.dpkg-old"
+    mv -b "$_new" "$_new.dpkg-old"
+  fi
+
+  # Create new directory if it does not yet exist.
+  if ! [ -e "$_new" ]; then
+    observe "creating $_new"
+    mkdir -p "$_new"
+  fi
+
+  # Copy files in old location to new location.  Back up any filenames that
+  # already exist in the new location with the extension ".dpkg-old".
+  observe "copying files from $_old to $_new"
+  if ! (cd "$_old" && cp -a -b -S ".dpkg-old" . "$_new"); then
+    die "error(s) encountered while copying files from $_old to $_new"
+  fi
+
+  # Remove files at old location.
+  observe "removing $_old"
+  rm -r "$_old"
+
+  # Create symlink from old location to new location.
+  make_symlink_sane "$_old" "$_new"
+}
+
+# vim:set ai et sw=2 ts=2 tw=80:
+
+# GOBSTOPPER: The X Strike Force shell library ends here.
