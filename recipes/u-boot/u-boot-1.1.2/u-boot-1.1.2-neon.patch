diff -u -r --new-file u-boot-1.1.2/board/bd2003/bd2003.c u-boot-1.1.2-neon/board/bd2003/bd2003.c
--- u-boot-1.1.2/board/bd2003/bd2003.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/bd2003.c	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+ * (C) Copyright 2002
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <common.h>
+#include <version.h>
+#include <stdarg.h>
+#include <linux/types.h>
+#include <devices.h>
+#include <lcd.h>
+#include <lcd_panels.h>
+
+/* ------------------------------------------------------------------------- */
+/*
+ * LCD panel declarations
+ */
+
+vidinfo_t panel_info = {
+	vl_col:		1024,		//this is corrected in SetPanelInfo
+	vl_row:		768,
+	vl_bpix:    LCD_BPP,
+	vl_lcd_line_length: (320 * NBITS(LCD_BPP) ) >> 3
+};
+
+void disable_lcd_panel( void )
+{
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	/* memory and cpu-speed are setup before relocation */
+	/* so we do _nothing_ here */
+
+	/* arch number of Neon Board */
+	gd->bd->bi_arch_number = MACH_TYPE_BD2003 ;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0xa0000100;
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	setenv("stdout", "serial");
+	setenv("stderr", "serial");
+	return 0;
+}
+
+
+int dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
diff -u -r --new-file u-boot-1.1.2/board/bd2003/config.mk u-boot-1.1.2-neon/board/bd2003/config.mk
--- u-boot-1.1.2/board/bd2003/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/config.mk	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,4 @@
+#TEXT_BASE = 0xa1700000
+TEXT_BASE = 0xA1F00000
+#TEXT_BASE = 0
+PXALCD = 1
diff -u -r --new-file u-boot-1.1.2/board/bd2003/.cvsignore u-boot-1.1.2-neon/board/bd2003/.cvsignore
--- u-boot-1.1.2/board/bd2003/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/.cvsignore	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,2 @@
+.depend
+
diff -u -r --new-file u-boot-1.1.2/board/bd2003/flash.c u-boot-1.1.2-neon/board/bd2003/flash.c
--- u-boot-1.1.2/board/bd2003/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/flash.c	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,477 @@
+/*
+ * (C) Copyright 2001
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2001
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include <asm/arch/pxa250Base.h>
+#include <asm/arch/pxaHardware.h>
+#include "lcd.h"
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips    */
+
+/* Board support for 1 or 2 flash devices */
+#define FLASH_PORT_WIDTH32
+#undef FLASH_PORT_WIDTH16
+
+#ifdef FLASH_PORT_WIDTH16
+#define FLASH_PORT_WIDTH		ushort
+#define FLASH_PORT_WIDTHV		vu_short
+#define SWAP(x)               __swab16(x)
+#else
+#define FLASH_PORT_WIDTH		ulong
+#define FLASH_PORT_WIDTHV		vu_long
+#define SWAP(x)               __swab32(x)
+#endif
+
+#define FPW	   FLASH_PORT_WIDTH
+#define FPWV   FLASH_PORT_WIDTHV
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (FPW *addr, flash_info_t *info);
+static int write_data (flash_info_t *info, ulong dest, FPW data);
+static void flash_get_offsets (ulong base, flash_info_t *info);
+void inline spin_wheel_init(ulong addr, ulong cnt);
+void inline spin_wheel_done( int worked );
+void inline spin_wheel (ulong numleft);
+
+/*-----------------------------------------------------------------------
+ */
+ulong bases[] = {PHYS_FLASH_1,PHYS_FLASH_2,1};
+unsigned long flash_init (void)
+{
+	int i=0;
+	int j=0;
+	ulong size = 0;
+	ulong base;
+
+   while (i < CFG_MAX_FLASH_BANKS) {
+		base = bases[j++];
+		flash_info[i].start[0] = 0;
+		if (base & 1) break;
+		if (flash_get_size ((FPW *) base, &flash_info[i])) {
+			flash_get_offsets (base, &flash_info[i]);
+			size += flash_info[i].size;
+			i++;
+		}
+      else {
+printf( "error reading flash size\n" );
+      }
+	}
+	if (size>0) {
+		base = flash_info[0].start[0];
+		// Protect monitor and environment sectors
+		flash_protect ( FLAG_PROTECT_SET,
+			base,
+			base + monitor_flash_len - 1,
+			&flash_info[0] );
+
+		flash_protect ( FLAG_PROTECT_SET,
+			base+CFG_ENV_OFFSET,
+			base+CFG_ENV_OFFSET + CFG_ENV_SIZE - 1, &flash_info[0] );
+	}
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
+		for (i = 0; i < info->sector_count; i++) {
+			info->start[i] = base + (i * PHYS_FLASH_SECT_SIZE);
+			info->protect[i] = 0;
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+		printf ("INTEL ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F128J3A:
+		printf ("28F128J3A\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (FPW *addr, flash_info_t *info)
+{
+	volatile FPW value;
+	volatile unsigned long *mc = (unsigned long *)MEMORY_CONTROL_BASE;
+	unsigned long val = 1<<3;
+
+   info->flash_id = FLASH_UNKNOWN;
+	info->sector_count = 0;
+	info->size = 0;
+
+	if (((ulong)addr) > 0x14000000) return 0;
+	val = mc[(MSC0>>2) +(((ulong)addr)>>27)];
+	if (((ulong)addr) & 0x04000000) val = val>>16;
+	if ( val & (1<<3)) return 0;	//if 16 bit bus then return
+	
+	/* Write auto select command: read Manufacturer ID */
+	addr[0x5555] = (FPW) 0x00AA00AA;
+	addr[0x2AAA] = (FPW) 0x00550055;
+	addr[0x5555] = (FPW) 0x00900090;
+
+	mb ();
+	value = addr[0];
+
+	switch (value) {
+
+	case (FPW) 0:
+	case (FPW) INTEL_MANUFACT & 0xFF0000 :
+	case (FPW) INTEL_MANUFACT & 0x0000FF :
+	case (FPW) INTEL_MANUFACT:
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+printf( "Invalid flash manufacturer %x\n", value );
+		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+		return (0);			/* no or unknown flash  */
+	}
+
+	mb ();
+	value = addr[1];			/* device ID        */
+
+	switch (value) {
+
+	case (FPW) 0:
+	case (FPW) INTEL_ID_28F128J3A & 0xFF0000 :
+	case (FPW) INTEL_ID_28F128J3A & 0x0000FF :
+	case (FPW) INTEL_ID_28F128J3A:
+		info->flash_id += FLASH_28F128J3A;
+		info->sector_count = 128;
+		info->size = 0x02000000;
+		break;				/* => 16 MB     */
+
+	default:
+printf( "Unknown flash device %x\n", value );
+		info->flash_id = FLASH_UNKNOWN;
+		break;
+	}
+
+	if (info->sector_count > CFG_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+			info->sector_count, CFG_MAX_FLASH_SECT);
+		info->sector_count = CFG_MAX_FLASH_SECT;
+	}
+
+	addr[0] = (FPW) 0x00FF00FF;		/* restore read mode */
+
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong type, start, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	type = (info->flash_id & FLASH_VENDMASK);
+	if ((type != FLASH_MAN_INTEL)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	start = get_timer (0);
+	last = start;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+         char temp[80];
+			FPWV *addr = (FPWV *) (info->start[sect]);
+			FPW status;
+
+			sprintf (temp, "Erasing sector %2d ... \r", sect);
+         lcd_puts( temp );
+
+			/* arm simple, non interrupt dependent timer */
+			reset_timer_masked ();
+
+			*addr = (FPW) 0x00500050;	/* clear status register */
+			*addr = (FPW) 0x00200020;	/* erase setup */
+			*addr = (FPW) 0x00D000D0;	/* erase confirm */
+
+			while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+				if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+					printf ("Timeout\n");
+					*addr = (FPW) 0x00B000B0;	/* suspend erase     */
+					*addr = (FPW) 0x00FF00FF;	/* reset to read mode */
+					rcode = 1;
+					break;
+				}
+			}
+
+			*addr = 0x00500050;	/* clear status register cmd.   */
+			*addr = 0x00FF00FF;	/* resest to read mode          */
+		}
+	}
+   lcd_puts( "\r\n" );
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	FPW data;
+	int count, i, l, rc, port_width;
+
+   rc = 0 ;
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+/* get lower word aligned address */
+#ifdef FLASH_PORT_WIDTH16
+	wp = (addr & ~1);
+	port_width = 2;
+#else
+	wp = (addr & ~3);
+	port_width = 4;
+#endif
+
+   spin_wheel_init(addr,cnt);
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+         goto out;
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+         goto out;
+		}
+		wp += port_width;
+		cnt -= port_width;
+		if (count++ > 0x800) {
+			spin_wheel (cnt);
+			count = 0;
+		}
+	}
+
+	if (cnt) {
+   	/*
+   	 * handle unaligned tail bytes
+   	 */
+   	data = 0;
+   	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+   		data = (data << 8) | *src++;
+   		--cnt;
+   	}
+   	for (; i < port_width; ++i, ++cp) {
+   		data = (data << 8) | (*(uchar *) cp);
+   	}
+   
+   	rc = write_data (info, wp, SWAP (data));
+	}
+
+out:
+   spin_wheel_done(0 == rc);
+   return rc ;
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word or halfword to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_data (flash_info_t *info, ulong dest, FPW data)
+{
+	FPWV *addr = (FPWV *) dest;
+   FPW old = *addr ;
+	ulong status;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((old & data) != data) {
+		printf ("not erased at %08lx (%lx)\n", (ulong) addr, old);
+		return (2);
+	}
+
+   if( old != data )
+   {
+   	/* Disable interrupts which might cause a timeout here */
+   	flag = disable_interrupts ();
+
+   	*addr = (FPW) 0x00400040;	/* write setup */
+   	*addr = data;
+   
+   	/* arm simple, non interrupt dependent timer */
+   	reset_timer_masked ();
+   
+   	/* wait while polling the status register */
+   	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+   		if (get_timer_masked () > CFG_FLASH_WRITE_TOUT) {
+   			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+   			return (1);
+   		}
+   	}
+   	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+   } /* need to program? */
+
+
+	return (0);
+}
+
+void inline spin_wheel_init(ulong addr, ulong cnt)
+{
+   char temp[80];
+   sprintf( temp, 
+            "\nprogramming flash\n"
+            "%08lx->%08lx\n"
+            " ", addr, cnt );
+   lcd_puts( temp );
+}
+
+void inline spin_wheel_done( int worked )
+{
+   if( worked )
+      spin_wheel(0);
+   lcd_puts( worked ? "\ncompleted.\n" : "\nfailed!\n" );
+}
+
+void inline spin_wheel( ulong numleft )
+{
+   char temp[40];
+   sprintf( temp, "\r          %08lx", numleft );
+   lcd_puts( temp );
+}
diff -u -r --new-file u-boot-1.1.2/board/bd2003/init.script u-boot-1.1.2-neon/board/bd2003/init.script
--- u-boot-1.1.2/board/bd2003/init.script	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/init.script	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,42 @@
+if fatload mmc 0 a0000000 logo.bmp ; then
+   bmp info a0000000 ;
+   bmp display a0000000 ;
+else
+   lecho "No logo present" ;
+fi
+
+if fatload mmc 0 a2000000 uimage ; then
+   lecho 'load Linux'
+   if fatload mmc 0 a2200000 mmcinitrd.u-boot ; then
+      echo 'using initrd' ;
+      lecho "Booting Linux"
+      set bootargs root=/dev/ram0 console=ttyS0,115200 debug=7 mtdparts=phys_mapped_flash:1024k(armboot),256k(params),-(rootfs1)
+      bootm a2000000 a2200000
+   else
+      echo 'testing cramfs img' ;
+      if fatload mmc 0 a2200000 cramfs.img ; then
+         if cmp.b 00140000 a2200000 $filesize ; then
+            echo 'cramfs images match' ;
+         else
+            lecho 'filesystems differ...' ;
+            protect off all ;
+            erase 00140000 01ffffff ;
+            cp.b a2200000 00140000 $filesize ;
+         fi
+
+         set bootargs console=ttyS0,115200 debug=7 mtdparts=phys_mapped_flash:1024k(armboot),256k(params),-(rootfs1) root=/dev/mtdblock3 rootfstype=cramfs
+         lecho "Booting Linux"
+         bootm a2000000
+      fi
+   fi
+else
+   echo "No Linux kernel" ;
+fi
+
+lecho 'No Linux, try CE'
+
+if fatload mmc 0 A0030000 nk.nb0 ; then
+   g A0030000 ;
+else
+   echo "No WinCE image" ;
+fi
diff -u -r --new-file u-boot-1.1.2/board/bd2003/Makefile u-boot-1.1.2-neon/board/bd2003/Makefile
--- u-boot-1.1.2/board/bd2003/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/Makefile	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,48 @@
+
+#
+# (C) Copyright 2000
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= bd2003.o flash.o
+SOBJS	:= memsetup.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -u -r --new-file u-boot-1.1.2/board/bd2003/memsetup.S u-boot-1.1.2-neon/board/bd2003/memsetup.S
--- u-boot-1.1.2/board/bd2003/memsetup.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/memsetup.S	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * Most of this taken from Redboot hal_platform_setup.h with cleanup
+ *
+ * NOTE: I haven't clean this up considerably, just enough to get it
+ * running. See hal_platform_setup.h for the source. See
+ * board/cradle/memsetup.S for another PXA250 setup that is
+ * much cleaner.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#define BAUDRATE 115200
+#include <asm/arch/platformTypes.h>
+#include <configs/select.h>
+#include <asm/arch/pxaGpio.h>
+#include <asm/arch/pxaMacro3.h>
+
+DRAM_SIZE:  .long   CFG_DRAM_SIZE
+
+/* wait for coprocessor write complete */
+   .macro CPWAIT reg
+   mrc  p15,0,\reg,c2,c0,0
+   mov  \reg,\reg
+   sub  pc,pc,#4
+   .endm
+
+
+/*
+ * 	Memory setup
+ */
+
+.globl memsetup
+memsetup:
+
+    mov      r10, lr
+
+    InitCS0_CS1	r0,sp
+    InitGPIO	r0,sp
+    InitIC_Clocks	r0,sp
+    InitUART	r0,sp,UART_BASE,BAUDRATE
+    InitUART	r0,sp,UART_BASE+0x600000,9600
+    InitChangeCPUSpeed r0
+    InitMemory	r0,sp,r1
+
+    mov     pc, lr
diff -u -r --new-file u-boot-1.1.2/board/bd2003/u-boot.lds u-boot-1.1.2-neon/board/bd2003/u-boot.lds
--- u-boot-1.1.2/board/bd2003/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/u-boot.lds	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/start.o	(.text)
+	  cpu/pxa/ministart.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -u -r --new-file u-boot-1.1.2/board/bd2003/u-bootmini.lds u-boot-1.1.2-neon/board/bd2003/u-bootmini.lds
--- u-boot-1.1.2/board/bd2003/u-bootmini.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/bd2003/u-bootmini.lds	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(StartUp)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/minidebug.o	(.text)
+	  cpu/pxa/ministart.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -u -r --new-file u-boot-1.1.2/board/halogen/config.mk u-boot-1.1.2-neon/board/halogen/config.mk
--- u-boot-1.1.2/board/halogen/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/config.mk	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,4 @@
+#TEXT_BASE = 0xa1700000
+TEXT_BASE = 0xA1F00000
+#TEXT_BASE = 0
+PXALCD = 1
diff -u -r --new-file u-boot-1.1.2/board/halogen/.cvsignore u-boot-1.1.2-neon/board/halogen/.cvsignore
--- u-boot-1.1.2/board/halogen/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/.cvsignore	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,2 @@
+.depend
+
diff -u -r --new-file u-boot-1.1.2/board/halogen/flash.c u-boot-1.1.2-neon/board/halogen/flash.c
--- u-boot-1.1.2/board/halogen/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/flash.c	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,482 @@
+/*
+ * (C) Copyright 2001
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2001
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include <asm/arch/pxa250Base.h>
+#include <asm/arch/pxaHardware.h>
+#include "lcd.h"
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips    */
+
+/* Board support for 1 or 2 flash devices */
+#define FLASH_PORT_WIDTH32
+#undef FLASH_PORT_WIDTH16
+
+#ifdef FLASH_PORT_WIDTH16
+#define FLASH_PORT_WIDTH		ushort
+#define FLASH_PORT_WIDTHV		vu_short
+#define SWAP(x)               __swab16(x)
+#else
+#define FLASH_PORT_WIDTH		ulong
+#define FLASH_PORT_WIDTHV		vu_long
+#define SWAP(x)               __swab32(x)
+#endif
+
+#define FPW	   FLASH_PORT_WIDTH
+#define FPWV   FLASH_PORT_WIDTHV
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (FPW *addr, flash_info_t *info);
+static int write_data (flash_info_t *info, ulong dest, FPW data);
+static void flash_get_offsets (ulong base, flash_info_t *info);
+void inline spin_wheel_init(ulong addr, ulong cnt);
+void inline spin_wheel_done( int worked );
+void inline spin_wheel (ulong numleft);
+
+/*-----------------------------------------------------------------------
+ */
+ulong bases[] = {PHYS_FLASH_1,PHYS_FLASH_2,1};
+unsigned long flash_init (void)
+{
+	int i=0;
+	int j=0;
+	ulong size = 0;
+	ulong base;
+
+   while (i < CFG_MAX_FLASH_BANKS) {
+		base = bases[j++];
+		flash_info[i].start[0] = 0;
+		if (base & 1) break;
+		if (flash_get_size ((FPW *) base, &flash_info[i])) {
+			flash_get_offsets (base, &flash_info[i]);
+			size += flash_info[i].size;
+			i++;
+		}
+      else {
+printf( "error reading flash size\n" );
+      }
+	}
+	if (size>0) {
+		base = flash_info[0].start[0];
+		// Protect monitor and environment sectors
+		flash_protect ( FLAG_PROTECT_SET,
+			base,
+			base + monitor_flash_len - 1,
+			&flash_info[0] );
+
+		flash_protect ( FLAG_PROTECT_SET,
+			base+CFG_ENV_OFFSET,
+			base+CFG_ENV_OFFSET + CFG_ENV_SIZE - 1, &flash_info[0] );
+	}
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
+		for (i = 0; i < info->sector_count; i++) {
+			info->start[i] = base + (i * PHYS_FLASH_SECT_SIZE);
+			info->protect[i] = 0;
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+		printf ("INTEL ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F128J3A:
+		printf ("28F128J3A\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (FPW *addr, flash_info_t *info)
+{
+	volatile FPW value;
+	volatile unsigned long *mc = (unsigned long *)MEMORY_CONTROL_BASE;
+	unsigned long val = 1<<3;
+
+   info->flash_id = FLASH_UNKNOWN;
+	info->sector_count = 0;
+	info->size = 0;
+
+	if (((ulong)addr) > 0x14000000) return 0;
+	val = mc[(MSC0>>2) +(((ulong)addr)>>27)];
+	if (((ulong)addr) & 0x04000000) val = val>>16;
+	if ( val & (1<<3)) return 0;	//if 16 bit bus then return
+	
+	/* Write auto select command: read Manufacturer ID */
+	addr[0x5555] = (FPW) 0x00AA00AA;
+	addr[0x2AAA] = (FPW) 0x00550055;
+	addr[0x5555] = (FPW) 0x00900090;
+
+	mb ();
+	value = addr[0];
+
+	switch (value) {
+
+	case (FPW) 0:
+   case (FPW) STM_MANUFACT:
+	case (FPW) INTEL_MANUFACT & 0xFF0000 :
+	case (FPW) INTEL_MANUFACT & 0x0000FF :
+	case (FPW) INTEL_MANUFACT:
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+printf( "Invalid flash manufacturer %x\n", value );
+		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+		return (0);			/* no or unknown flash  */
+	}
+
+	mb ();
+	value = addr[1];			/* device ID        */
+
+	switch (value) {
+
+	case (FPW) 0:
+	case (FPW) INTEL_ID_28F128J3A & 0xFF0000 :
+	case (FPW) INTEL_ID_28F128J3A & 0x0000FF :
+	case (FPW) INTEL_ID_28F128J3A:
+		info->flash_id += FLASH_28F128J3A;
+		info->sector_count = 128;
+		info->size = 0x01000000;
+		break;				/* => 16 MB x 1  */
+   case (FPW) INTEL_ID_28F320J3A:
+      info->flash_id += FLASH_28F320J3A;
+		info->sector_count = 32 ;
+		info->size = 0x400000 ;
+		break;				/* => 4 MB x 1 */
+	default:
+printf( "Unknown flash device %x\n", value );
+		info->flash_id = FLASH_UNKNOWN;
+		break;
+	}
+
+	if (info->sector_count > CFG_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+			info->sector_count, CFG_MAX_FLASH_SECT);
+		info->sector_count = CFG_MAX_FLASH_SECT;
+	}
+
+	addr[0] = (FPW) 0x00FF00FF;		/* restore read mode */
+
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong type, start, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	type = (info->flash_id & FLASH_VENDMASK);
+	if ((type != FLASH_MAN_INTEL)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	start = get_timer (0);
+	last = start;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+         char temp[80];
+			FPWV *addr = (FPWV *) (info->start[sect]);
+			FPW status;
+
+			sprintf (temp, "Erasing sector %2d ... \r", sect);
+         lcd_puts( temp );
+
+			/* arm simple, non interrupt dependent timer */
+			reset_timer_masked ();
+
+			*addr = (FPW) 0x00500050;	/* clear status register */
+			*addr = (FPW) 0x00200020;	/* erase setup */
+			*addr = (FPW) 0x00D000D0;	/* erase confirm */
+
+			while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+				if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+					printf ("Timeout\n");
+					*addr = (FPW) 0x00B000B0;	/* suspend erase     */
+					*addr = (FPW) 0x00FF00FF;	/* reset to read mode */
+					rcode = 1;
+					break;
+				}
+			}
+
+			*addr = 0x00500050;	/* clear status register cmd.   */
+			*addr = 0x00FF00FF;	/* resest to read mode          */
+		}
+	}
+   lcd_puts( "\r\n" );
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	FPW data;
+	int count, i, l, rc, port_width;
+
+   rc = 0 ;
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+/* get lower word aligned address */
+#ifdef FLASH_PORT_WIDTH16
+	wp = (addr & ~1);
+	port_width = 2;
+#else
+	wp = (addr & ~3);
+	port_width = 4;
+#endif
+
+   spin_wheel_init(addr,cnt);
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+         goto out;
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+         goto out;
+		}
+		wp += port_width;
+		cnt -= port_width;
+		if (count++ > 0x800) {
+			spin_wheel (cnt);
+			count = 0;
+		}
+	}
+
+	if (cnt) {
+   	/*
+   	 * handle unaligned tail bytes
+   	 */
+   	data = 0;
+   	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+   		data = (data << 8) | *src++;
+   		--cnt;
+   	}
+   	for (; i < port_width; ++i, ++cp) {
+   		data = (data << 8) | (*(uchar *) cp);
+   	}
+   
+   	rc = write_data (info, wp, SWAP (data));
+	}
+
+out:
+   spin_wheel_done(0 == rc);
+   return rc ;
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word or halfword to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_data (flash_info_t *info, ulong dest, FPW data)
+{
+	FPWV *addr = (FPWV *) dest;
+   FPW old = *addr ;
+	ulong status;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((old & data) != data) {
+		printf ("not erased at %08lx (%lx)\n", (ulong) addr, old);
+		return (2);
+	}
+
+   if( old != data )
+   {
+   	/* Disable interrupts which might cause a timeout here */
+   	flag = disable_interrupts ();
+
+   	*addr = (FPW) 0x00400040;	/* write setup */
+   	*addr = data;
+   
+   	/* arm simple, non interrupt dependent timer */
+   	reset_timer_masked ();
+   
+   	/* wait while polling the status register */
+   	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+   		if (get_timer_masked () > CFG_FLASH_WRITE_TOUT) {
+   			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+   			return (1);
+   		}
+   	}
+   	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+   } /* need to program? */
+
+
+	return (0);
+}
+
+void inline spin_wheel_init(ulong addr, ulong cnt)
+{
+   char temp[80];
+   sprintf( temp, 
+            "\nprogramming flash\n"
+            "%08lx->%08lx\n"
+            " ", addr, cnt );
+   lcd_puts( temp );
+}
+
+void inline spin_wheel_done( int worked )
+{
+   if( worked )
+      spin_wheel(0);
+   lcd_puts( worked ? "\ncompleted.\n" : "\nfailed!\n" );
+}
+
+void inline spin_wheel( ulong numleft )
+{
+   char temp[40];
+   sprintf( temp, "\r          %08lx", numleft );
+   lcd_puts( temp );
+}
diff -u -r --new-file u-boot-1.1.2/board/halogen/halogen.c u-boot-1.1.2-neon/board/halogen/halogen.c
--- u-boot-1.1.2/board/halogen/halogen.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/halogen.c	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+ * (C) Copyright 2002
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <common.h>
+#include <version.h>
+#include <stdarg.h>
+#include <linux/types.h>
+#include <devices.h>
+#include <lcd.h>
+#include <lcd_panels.h>
+
+/* ------------------------------------------------------------------------- */
+/*
+ * LCD panel declarations
+ */
+
+vidinfo_t panel_info = {
+	vl_col:		1024,		//this is corrected in SetPanelInfo
+	vl_row:		768,
+	vl_bpix:    LCD_BPP,
+	vl_lcd_line_length: (320 * NBITS(LCD_BPP) ) >> 3
+};
+
+void disable_lcd_panel( void )
+{
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	/* memory and cpu-speed are setup before relocation */
+	/* so we do _nothing_ here */
+
+	/* arch number of Neon Board */
+	gd->bd->bi_arch_number = MACH_TYPE_HALOGEN ;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0xa0000100;
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	setenv("stdout", "serial");
+	setenv("stderr", "serial");
+	return 0;
+}
+
+
+int dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
diff -u -r --new-file u-boot-1.1.2/board/halogen/init.script u-boot-1.1.2-neon/board/halogen/init.script
--- u-boot-1.1.2/board/halogen/init.script	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/init.script	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,42 @@
+if fatload mmc 0 a0008000 logo*.bmp ; then
+   bmp info a0008000 ;
+   bmp display a0008000 ;
+else
+   lecho "No logo present" ;
+fi
+
+if fatload mmc 0 a2000000 uim* ; then
+   lecho 'load Linux'
+   if fatload mmc 0 a2200000 mmcinitrd* ; then
+      echo 'using initrd' ;
+      lecho "Booting Linux"
+      set bootargs root=/dev/ram0 console=ttyS0,115200 debug=7 mtdparts=phys_mapped_flash:1024k(armboot),256k(params),-(rootfs1)
+      bootm a2000000 a2200000
+   else
+      echo 'testing cramfs img' ;
+      if fatload mmc 0 a2200000 cramfs* ; then
+         if cmp.b 00140000 a2200000 $filesize ; then
+            echo 'cramfs images match' ;
+         else
+            lecho 'filesystems differ...' ;
+            protect off all ;
+            erase 00140000 01ffffff ;
+            cp.b a2200000 00140000 $filesize ;
+         fi
+
+         set bootargs console=ttyS0,115200 debug=7 mtdparts=phys_mapped_flash:1024k(armboot),256k(params),-(rootfs1) root=/dev/mtdblock3 rootfstype=cramfs
+         lecho "Booting Linux"
+         bootm a2000000
+      fi
+   fi
+else
+   echo "No Linux kernel" ;
+fi
+
+lecho 'No Linux, try CE'
+
+if fatload mmc 0 A0030000 nk*.nb0 ; then
+   g A0030000 ;
+else
+   echo "No WinCE image" ;
+fi
diff -u -r --new-file u-boot-1.1.2/board/halogen/Makefile u-boot-1.1.2-neon/board/halogen/Makefile
--- u-boot-1.1.2/board/halogen/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/Makefile	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,48 @@
+
+#
+# (C) Copyright 2000
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= halogen.o flash.o
+SOBJS	:= memsetup.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -u -r --new-file u-boot-1.1.2/board/halogen/memsetup.S u-boot-1.1.2-neon/board/halogen/memsetup.S
--- u-boot-1.1.2/board/halogen/memsetup.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/memsetup.S	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * Most of this taken from Redboot hal_platform_setup.h with cleanup
+ *
+ * NOTE: I haven't clean this up considerably, just enough to get it
+ * running. See hal_platform_setup.h for the source. See
+ * board/cradle/memsetup.S for another PXA250 setup that is
+ * much cleaner.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#define BAUDRATE 115200
+#include <asm/arch/platformTypes.h>
+#include <configs/select.h>
+#include <asm/arch/pxaGpio.h>
+#include <asm/arch/pxaMacro3.h>
+
+DRAM_SIZE:  .long   CFG_DRAM_SIZE
+
+/* wait for coprocessor write complete */
+   .macro CPWAIT reg
+   mrc  p15,0,\reg,c2,c0,0
+   mov  \reg,\reg
+   sub  pc,pc,#4
+   .endm
+
+
+/*
+ * 	Memory setup
+ */
+
+.globl memsetup
+memsetup:
+
+    mov      r10, lr
+
+    InitCS0_CS1	r0,sp
+    InitGPIO	r0,sp
+    InitIC_Clocks	r0,sp
+    InitUART	r0,sp,UART_BASE,BAUDRATE
+    InitUART	r0,sp,UART_BASE+0x600000,9600
+    InitChangeCPUSpeed r0
+    InitMemory	r0,sp,r1
+
+    mov     pc, lr
diff -u -r --new-file u-boot-1.1.2/board/halogen/u-boot.lds u-boot-1.1.2-neon/board/halogen/u-boot.lds
--- u-boot-1.1.2/board/halogen/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/u-boot.lds	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/start.o	(.text)
+	  cpu/pxa/ministart.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -u -r --new-file u-boot-1.1.2/board/halogen/u-bootmini.lds u-boot-1.1.2-neon/board/halogen/u-bootmini.lds
--- u-boot-1.1.2/board/halogen/u-bootmini.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/halogen/u-bootmini.lds	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(StartUp)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/minidebug.o	(.text)
+	  cpu/pxa/ministart.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -u -r --new-file u-boot-1.1.2/board/neon/config.mk u-boot-1.1.2-neon/board/neon/config.mk
--- u-boot-1.1.2/board/neon/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/config.mk	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,4 @@
+#TEXT_BASE = 0xa1700000
+TEXT_BASE = 0xA1F00000
+#TEXT_BASE = 0
+#PXALCD = 1
diff -u -r --new-file u-boot-1.1.2/board/neon/.cvsignore u-boot-1.1.2-neon/board/neon/.cvsignore
--- u-boot-1.1.2/board/neon/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/.cvsignore	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,2 @@
+.depend
+
diff -u -r --new-file u-boot-1.1.2/board/neon/flash.c u-boot-1.1.2-neon/board/neon/flash.c
--- u-boot-1.1.2/board/neon/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/flash.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,482 @@
+/*
+ * (C) Copyright 2001
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2001
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include <asm/arch/pxa250Base.h>
+#include <asm/arch/pxaHardware.h>
+#include "lcd.h"
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips    */
+
+/* Board support for 1 or 2 flash devices */
+#define FLASH_PORT_WIDTH32
+#undef FLASH_PORT_WIDTH16
+
+#ifdef FLASH_PORT_WIDTH16
+#define FLASH_PORT_WIDTH		ushort
+#define FLASH_PORT_WIDTHV		vu_short
+#define SWAP(x)               __swab16(x)
+#else
+#define FLASH_PORT_WIDTH		ulong
+#define FLASH_PORT_WIDTHV		vu_long
+#define SWAP(x)               __swab32(x)
+#endif
+
+#define FPW	   FLASH_PORT_WIDTH
+#define FPWV   FLASH_PORT_WIDTHV
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (FPW *addr, flash_info_t *info);
+static int write_data (flash_info_t *info, ulong dest, FPW data);
+static void flash_get_offsets (ulong base, flash_info_t *info);
+void inline spin_wheel_init(ulong addr, ulong cnt);
+void inline spin_wheel_done( int worked );
+void inline spin_wheel (ulong numleft);
+
+/*-----------------------------------------------------------------------
+ */
+ulong bases[] = {PHYS_FLASH_1,PHYS_FLASH_2,1};
+unsigned long flash_init (void)
+{
+	int i=0;
+	int j=0;
+	ulong size = 0;
+	ulong base;
+
+   while (i < CFG_MAX_FLASH_BANKS) {
+		base = bases[j++];
+		flash_info[i].start[0] = 0;
+		if (base & 1) break;
+		if (flash_get_size ((FPW *) base, &flash_info[i])) {
+			flash_get_offsets (base, &flash_info[i]);
+			size += flash_info[i].size;
+			i++;
+		}
+      else {
+printf( "error reading flash size\n" );
+      }
+	}
+	if (size>0) {
+		base = flash_info[0].start[0];
+		// Protect monitor and environment sectors
+		flash_protect ( FLAG_PROTECT_SET,
+			base,
+			base + monitor_flash_len - 1,
+			&flash_info[0] );
+
+		flash_protect ( FLAG_PROTECT_SET,
+			base+CFG_ENV_OFFSET,
+			base+CFG_ENV_OFFSET + CFG_ENV_SIZE - 1, &flash_info[0] );
+	}
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
+		for (i = 0; i < info->sector_count; i++) {
+			info->start[i] = base + (i * PHYS_FLASH_SECT_SIZE);
+			info->protect[i] = 0;
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+		printf ("INTEL ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F128J3A:
+		printf ("28F128J3A\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (FPW *addr, flash_info_t *info)
+{
+	volatile FPW value;
+	volatile unsigned long *mc = (unsigned long *)MEMORY_CONTROL_BASE;
+	unsigned long val = 1<<3;
+
+   info->flash_id = FLASH_UNKNOWN;
+	info->sector_count = 0;
+	info->size = 0;
+
+	if (((ulong)addr) > 0x14000000) return 0;
+	val = mc[(MSC0>>2) +(((ulong)addr)>>27)];
+	if (((ulong)addr) & 0x04000000) val = val>>16;
+	if ( val & (1<<3)) return 0;	//if 16 bit bus then return
+	
+	/* Write auto select command: read Manufacturer ID */
+	addr[0x5555] = (FPW) 0x00AA00AA;
+	addr[0x2AAA] = (FPW) 0x00550055;
+	addr[0x5555] = (FPW) 0x00900090;
+
+	mb ();
+	value = addr[0];
+
+	switch (value) {
+
+	case (FPW) 0:
+   case (FPW) STM_MANUFACT:
+	case (FPW) INTEL_MANUFACT & 0xFF0000 :
+	case (FPW) INTEL_MANUFACT & 0x0000FF :
+	case (FPW) INTEL_MANUFACT:
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+printf( "Invalid flash manufacturer %x\n", value );
+		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+		return (0);			/* no or unknown flash  */
+	}
+
+	mb ();
+	value = addr[1];			/* device ID        */
+
+	switch (value) {
+
+	case (FPW) 0:
+	case (FPW) INTEL_ID_28F128J3A & 0xFF0000 :
+	case (FPW) INTEL_ID_28F128J3A & 0x0000FF :
+	case (FPW) INTEL_ID_28F128J3A:
+		info->flash_id += FLASH_28F128J3A;
+		info->sector_count = 128;
+		info->size = 0x02000000;
+		break;				/* => 16 MB x 2  */
+   case (FPW) INTEL_ID_28F320J3A:
+      info->flash_id += FLASH_28F320J3A;
+		info->sector_count = 32 ;
+		info->size = 0x800000 ;
+		break;				/* => 4 MB x 2 */
+	default:
+printf( "Unknown flash device %x\n", value );
+		info->flash_id = FLASH_UNKNOWN;
+		break;
+	}
+
+	if (info->sector_count > CFG_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+			info->sector_count, CFG_MAX_FLASH_SECT);
+		info->sector_count = CFG_MAX_FLASH_SECT;
+	}
+
+	addr[0] = (FPW) 0x00FF00FF;		/* restore read mode */
+
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong type, start, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	type = (info->flash_id & FLASH_VENDMASK);
+	if ((type != FLASH_MAN_INTEL)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	start = get_timer (0);
+	last = start;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+         char temp[80];
+			FPWV *addr = (FPWV *) (info->start[sect]);
+			FPW status;
+
+			sprintf (temp, "Erasing sector %2d ... \r", sect);
+         lcd_puts( temp );
+
+			/* arm simple, non interrupt dependent timer */
+			reset_timer_masked ();
+
+			*addr = (FPW) 0x00500050;	/* clear status register */
+			*addr = (FPW) 0x00200020;	/* erase setup */
+			*addr = (FPW) 0x00D000D0;	/* erase confirm */
+
+			while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+				if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+					printf ("Timeout\n");
+					*addr = (FPW) 0x00B000B0;	/* suspend erase     */
+					*addr = (FPW) 0x00FF00FF;	/* reset to read mode */
+					rcode = 1;
+					break;
+				}
+			}
+
+			*addr = 0x00500050;	/* clear status register cmd.   */
+			*addr = 0x00FF00FF;	/* resest to read mode          */
+		}
+	}
+   lcd_puts( "\r\n" );
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	FPW data;
+	int count, i, l, rc, port_width;
+
+   rc = 0 ;
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+/* get lower word aligned address */
+#ifdef FLASH_PORT_WIDTH16
+	wp = (addr & ~1);
+	port_width = 2;
+#else
+	wp = (addr & ~3);
+	port_width = 4;
+#endif
+
+   spin_wheel_init(addr,cnt);
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+         goto out;
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+         goto out;
+		}
+		wp += port_width;
+		cnt -= port_width;
+		if (count++ > 0x800) {
+			spin_wheel (cnt);
+			count = 0;
+		}
+	}
+
+	if (cnt) {
+   	/*
+   	 * handle unaligned tail bytes
+   	 */
+   	data = 0;
+   	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+   		data = (data << 8) | *src++;
+   		--cnt;
+   	}
+   	for (; i < port_width; ++i, ++cp) {
+   		data = (data << 8) | (*(uchar *) cp);
+   	}
+   
+   	rc = write_data (info, wp, SWAP (data));
+	}
+
+out:
+   spin_wheel_done(0 == rc);
+   return rc ;
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word or halfword to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_data (flash_info_t *info, ulong dest, FPW data)
+{
+	FPWV *addr = (FPWV *) dest;
+   FPW old = *addr ;
+	ulong status;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((old & data) != data) {
+		printf ("not erased at %08lx (%lx)\n", (ulong) addr, old);
+		return (2);
+	}
+
+   if( old != data )
+   {
+   	/* Disable interrupts which might cause a timeout here */
+   	flag = disable_interrupts ();
+
+   	*addr = (FPW) 0x00400040;	/* write setup */
+   	*addr = data;
+   
+   	/* arm simple, non interrupt dependent timer */
+   	reset_timer_masked ();
+   
+   	/* wait while polling the status register */
+   	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+   		if (get_timer_masked () > CFG_FLASH_WRITE_TOUT) {
+   			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+   			return (1);
+   		}
+   	}
+   	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+   } /* need to program? */
+
+
+	return (0);
+}
+
+void inline spin_wheel_init(ulong addr, ulong cnt)
+{
+   char temp[80];
+   sprintf( temp, 
+            "\nprogramming flash\n"
+            "%08lx->%08lx\n"
+            " ", addr, cnt );
+   lcd_puts( temp );
+}
+
+void inline spin_wheel_done( int worked )
+{
+   if( worked )
+      spin_wheel(0);
+   lcd_puts( worked ? "\ncompleted.\n" : "\nfailed!\n" );
+}
+
+void inline spin_wheel( ulong numleft )
+{
+   char temp[40];
+   sprintf( temp, "\r          %08lx", numleft );
+   lcd_puts( temp );
+}
diff -u -r --new-file u-boot-1.1.2/board/neon/init.script u-boot-1.1.2-neon/board/neon/init.script
--- u-boot-1.1.2/board/neon/init.script	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/init.script	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,42 @@
+if fatload mmc 0 a0008000 logo*.bmp ; then
+   bmp info a0008000 ;
+   bmp display a0008000 ;
+else
+   lecho "No logo present" ;
+fi
+
+if fatload mmc 0 a2000000 uim* ; then
+   lecho 'load Linux'
+   if fatload mmc 0 a2200000 mmcinitrd* ; then
+      echo 'using initrd' ;
+      lecho "Booting Linux"
+      set bootargs root=/dev/ram0 console=ttyS0,115200 debug=7 mtdparts=phys_mapped_flash:1024k(armboot),256k(params),-(rootfs1)
+      bootm a2000000 a2200000
+   else
+      echo 'testing cramfs img' ;
+      if fatload mmc 0 a2200000 cramfs* ; then
+         if cmp.b 00140000 a2200000 $filesize ; then
+            echo 'cramfs images match' ;
+         else
+            lecho 'filesystems differ...' ;
+            protect off all ;
+            erase 00140000 01ffffff ;
+            cp.b a2200000 00140000 $filesize ;
+         fi
+
+         set bootargs console=ttyS0,115200 debug=7 mtdparts=phys_mapped_flash:1024k(armboot),256k(params),-(rootfs1) root=/dev/mtdblock3 rootfstype=cramfs
+         lecho "Booting Linux"
+         bootm a2000000
+      fi
+   fi
+else
+   echo "No Linux kernel" ;
+fi
+
+lecho 'No Linux, try CE'
+
+if fatload mmc 0 A0030000 nk*.nb0 ; then
+   g A0030000 ;
+else
+   echo "No WinCE image" ;
+fi
diff -u -r --new-file u-boot-1.1.2/board/neon/Makefile u-boot-1.1.2-neon/board/neon/Makefile
--- u-boot-1.1.2/board/neon/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/Makefile	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,48 @@
+
+#
+# (C) Copyright 2000
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= neon.o flash.o rtc_M41T81S.o
+SOBJS	:= memsetup.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -u -r --new-file u-boot-1.1.2/board/neon/memsetup.S u-boot-1.1.2-neon/board/neon/memsetup.S
--- u-boot-1.1.2/board/neon/memsetup.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/memsetup.S	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * Most of this taken from Redboot hal_platform_setup.h with cleanup
+ *
+ * NOTE: I haven't clean this up considerably, just enough to get it
+ * running. See hal_platform_setup.h for the source. See
+ * board/cradle/memsetup.S for another PXA250 setup that is
+ * much cleaner.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#define BAUDRATE 115200
+#include <asm/arch/platformTypes.h>
+#include <configs/select.h>
+#include <asm/arch/pxaGpio.h>
+#include <asm/arch/pxaMacro3.h>
+
+DRAM_SIZE:  .long   CFG_DRAM_SIZE
+
+/* wait for coprocessor write complete */
+   .macro CPWAIT reg
+   mrc  p15,0,\reg,c2,c0,0
+   mov  \reg,\reg
+   sub  pc,pc,#4
+   .endm
+
+
+/*
+ * 	Memory setup
+ */
+
+.globl memsetup
+memsetup:
+
+    mov      r10, lr
+
+    InitCS0_CS1	r0,sp
+    InitGPIO	r0,sp
+    InitIC_Clocks	r0,sp
+    InitUART	r0,sp,UART_BASE,BAUDRATE
+    InitUART	r0,sp,UART_BASE+0x600000,9600
+    InitChangeCPUSpeed r0
+    InitMemory	r0,sp,r1
+
+    mov     pc, lr
diff -u -r --new-file u-boot-1.1.2/board/neon/neon.c u-boot-1.1.2-neon/board/neon/neon.c
--- u-boot-1.1.2/board/neon/neon.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/neon.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,615 @@
+/*
+ * (C) Copyright 2002
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <common.h>
+#include <version.h>
+#include <stdarg.h>
+#include <linux/types.h>
+#include <devices.h>
+#include <lcd.h>
+#include <lcd_panels.h>
+
+#define FASTCLOCK1 0x291A0201		//faster pixel clock:     P2S = 1, P2 =  9  (/6)      ( panel source 1, divide by 6)
+                                 //                        V2S = 1, V2 = 10 (/12)      ( crt source 1, divide by 12)
+                                 //                        M2S = 0, MR =  2  (/4)      (sdram source 1, divide by 4)
+                                 //                        M1S = 0, MR =  1  (/2)
+                                 // miscTimReg[5:4] == 0 (336 MHz)
+                                 //                   / 6 == 56 MHz
+                                 //
+#define FASTCLOCK2 0x291A0201
+#define FASTCLOCK3 0x00080800
+
+#define SLOWCLOCK1 0x0A1A0201        //slow pixel clock:       P2S = 0, P2 = 10 (/12)      ( panel source 0, divide by 12)  
+                                     //                        V2S = 1, V2 = 10 (/12)      ( crt source 1, divide by 12)   
+                                     //                        M2S = 0, MR =  2  (/4)      (sdram source 1, divide by 4)   
+                                     //                        M1S = 0, MR =  1  (/2)                                      
+                                     // miscTimReg[5:4] == 0 (288 MHz)                                                     
+                                     //                   / 12 == 24 MHz                                                    
+                                     //
+#define SLOWCLOCK2 0x0A1A0A09
+#define SLOWCLOCK3 0x00090900
+
+unsigned long const fbStart = 0x0C000000 ;
+unsigned long const fbMax   = 0x00800000 ;    //
+
+unsigned long const mmioStart  = 0xFE00000 ;
+unsigned long const mmioLength = 0x00200000 ;
+unsigned long const lcdPaletteRegs = 0xFE80400 ;
+unsigned long const crtPaletteRegs = 0xFE80C00 ;
+unsigned long paletteRegs = 0xFE80400 ;
+
+const unsigned int sm501_list1[]={
+   0x0FE00000,
+	0x00100000,0x00001002,0x00000000,0x00000000,0x07F127C0,0x05146732,0x40715128,0x00000000,
+	0x00000000,0x00180002,0x00000002,0x00000002,0x00000000,0x00000000,0x0000001F,0x291A0201,
+	0x0000001F,0x291A0201,0x00000007,0x291A0201,0x00018000,0x00000000,0x00000000,0x00000000,
+	0x050100A0,0x00000000,0x00080800};
+
+const unsigned int sm501_list2[]={ 0x0fe80000,
+/* 80000 dispctrl  */ 	0x0F013100,             // 0f0d0105
+/* 80004 pan       */   0x00000000,
+/* 80008 colorkey  */   0x00000000,
+/* 8000C fbaddr    */   0x00000000,
+/* 80010 offsetww  */   0x00000000, // ((LCD_XRES)<<16)+(LCD_XRES),
+/* 80014 fbwidth   */   0x00000000, // (LCD_XRES<<16),
+/* 80018 fbheight  */   0x00000000, // (LCD_YRES<<16),
+/* 8001C tllocate  */   0x00000000,
+/* 80020 brlocate  */ 	0x00000000, // ((LCD_YRES-1)<<16)+(LCD_XRES-1),
+/* 80024 htotal    */ 	0x00000000, // ((LCD_BEGIN_OF_LINE_WAIT_COUNT+
+/*                 */               //   LCD_XRES+
+/*                 */               //   LCD_END_OF_LINE_WAIT_COUNT+
+/*                 */               //   LCD_HORIZONTAL_SYNC_PULSE_WIDTH-1)<<16)
+/*                 */               // +(LCD_XRES-1),
+/* 80028 hsync     */ 	0x00000000, // (LCD_HORIZONTAL_SYNC_PULSE_WIDTH<<16)
+/*                 */               // +(LCD_XRES+LCD_BEGIN_OF_LINE_WAIT_COUNT-1),
+/* 8002C vtotal    */ 	0x00000000, // ((LCD_BEGIN_FRAME_WAIT_COUNT+
+/*                 */               //   LCD_YRES+
+/*                 */               //   LCD_END_OF_FRAME_WAIT_COUNT+
+/*                 */               //   LCD_VERTICAL_SYNC_PULSE_WIDTH-1)<<16)
+/*                 */               // +(LCD_YRES-1),
+/* 80030 vsync     */ 	0x00000000, // (LCD_VERTICAL_SYNC_PULSE_WIDTH<<16)
+/*                 */               // +(LCD_YRES+LCD_BEGIN_FRAME_WAIT_COUNT-1)
+};
+
+static unsigned const miscCtrl       = 0x00000004 ;
+static unsigned const curClockReg    = 0x0000003C ;
+static unsigned const pm0ClockReg    = 0x00000044 ;
+static unsigned const pm1ClockReg    = 0x0000004C ;
+static unsigned const miscTimReg     = 0x00000068 ;
+
+static unsigned const dispctrlReg    = 0x00080000 ;
+static unsigned const offsetReg      = 0x00080010 ;  // ((xres)<<16)+(xres),
+static unsigned const fbWidthReg     = 0x00080014 ;  // (xres<<16), 
+static unsigned const fbHeightReg    = 0x00080018 ;  // (yres<<16), 
+static unsigned const brLocateReg    = 0x00080020 ;  // ((yres-1)<<16)+(xres-1),
+static unsigned const hTotalReg      = 0x00080024 ;  // (left_margin+xres+right_margin+hsync_len-1) << 16
+                                                     // + xres
+static unsigned const hSyncReg       = 0x00080028 ;  //  (hsync_len<<16)  + (xres+left_margin-1)
+static unsigned const vTotalReg      = 0x0008002c ;  // (top_margin+yres+lower_margin+vsync_len-1) << 16
+                                                     // + yres-1
+static unsigned const vSyncReg       = 0x00080030 ;  // (vsync_len<<16) + yres+top_margin-1
+
+/*
+ * CRT regs
+ */
+static unsigned const crtctrlReg     = 0x00080200 ;
+static unsigned const crtFbAddrReg   = 0x00080204 ;
+static unsigned const crtFbOffsReg   = 0x00080208 ;
+static unsigned const crtFbHTotReg   = 0x0008020C ;
+static unsigned const crtFbHSynReg   = 0x00080210 ;
+static unsigned const crtFbVTotReg   = 0x00080214 ;
+static unsigned const crtFbVSynReg   = 0x00080218 ;
+
+#define DISPCRTL_ENABLE 4
+
+#define CLOCK_ACTIVEHIGH 0
+#define CLOCK_ACTIVELOW  (1<<14)
+#define CLOCK_ACTIVEMASK (1<<14)
+
+#define LCDTYPE_TFT    0
+#define LCDTYPE_STN12  (3<<18)
+#define LCDTYPE_MASK   (3<<18)
+
+#define READREG( addr ) *( (unsigned long volatile *)((addr)+mmioStart) )
+#define STUFFREG( addr, value ) *( (unsigned long volatile *)((addr)+mmioStart) ) = (value)
+
+const unsigned int sm501_list3[]={0x0fe80040,
+	0x00010000,0x0703E360,0x00200400,0x00A81330,0x0385009C,0x02200240,0x00000000,0x00000000,
+	0x00EDEDED,0x089C4040,0x0031E3B0};
+ 
+const unsigned int sm501_list4[]={0x0fe80080,
+	0x00010000,0x05121880,0x28800C00,0x00108030,0x02090040,0x00840050,0x00000000,0x00000000,
+	0x0141A200,0x020A0802,0x0088D109,0x20820040,0x10800000,0x30029200,0x00080821,0x01010400,
+	0x44000120,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+	0x00000000,0x00000000,0x00000000,0x00000000};
+
+const unsigned int sm501_list5[]={0x0fe800f0,
+	0x0070F800,0x00780140,0x00000000,0x0000FFFF,0x00010000};
+
+struct itemEntry {
+	const int cnt;
+	const unsigned int* p;
+};
+
+const struct itemEntry lists[] = {
+	{sizeof(sm501_list1)>>2,sm501_list1},
+	{sizeof(sm501_list2)>>2,sm501_list2},
+	{sizeof(sm501_list3)>>2,sm501_list3},
+	{sizeof(sm501_list4)>>2,sm501_list4},
+	{sizeof(sm501_list5)>>2,sm501_list5}
+};
+
+int lcd_color_fg;
+int lcd_color_bg;
+
+void *lcd_base;			/* Start of framebuffer memory	*/
+void *lcd_console_address;		/* Start of console buffer	*/
+
+short console_col;
+short console_row;
+
+
+ulong calc_fbsize (void)
+{
+   if( cur_lcd_panel )
+   {
+   	int line_length = (cur_lcd_panel->xres * NBITS (LCD_BPP)) / 8;
+      return ( cur_lcd_panel->yres * line_length ) + PAGE_SIZE ;
+   }
+   else
+      return 0 ;
+}
+
+void lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue)
+{
+   unsigned long *const palette = (unsigned long *)paletteRegs ;
+   unsigned long const rgb = ((unsigned long)red ) << 16
+                           | ((unsigned long)green ) << 8 
+                           | blue ;
+   palette[regno] = rgb ;
+}
+
+void lcd_ctrl_init	(void *lcdbase)
+{
+	unsigned short *fbMem;
+   char *panelName ;
+
+	unsigned long val=0;
+	const struct itemEntry* l = lists;
+	int count = sizeof(lists)/sizeof(struct itemEntry);
+	printf( "sm501 init start\n");
+	
+	while (count) {
+		int cnt = l->cnt-1;
+		const unsigned long* p = (unsigned long*)l->p;
+		volatile unsigned int* reg = (unsigned int*)(*p++);
+//		printf( "set regs: %p, cnt:%x, from %p, l:%p\n", reg, cnt, p,l );
+//		while (reg==0) {
+//		}
+		
+		while (cnt) {
+			val = *p++;
+//			printf( "set reg: %p = %x from %p\n", reg, val, p );
+			*reg++ = val;
+			cnt--;
+		}
+		count--;
+		l++;
+	}
+//	printf( "sm501 init middle\n");
+
+   panelName = getenv( "panel" );
+//	printf( "after getenv\n");
+   if( panelName )
+   {
+      struct lcd_panel_info_t const *panel ;
+      panel = find_lcd_panel( panelName );
+      if( panel )
+      {
+         printf( "panel %s found: %u x %u\n", panelName, panel->xres, panel->yres );
+//	printf( "before set_lcd_panel\n");
+         set_lcd_panel( panel ); 
+//	printf( "after set_lcd_panel\n");
+      }
+      else
+         printf( "panel %s not found\n", panelName );
+   }
+
+   fbMem = (unsigned short *)fbStart ;
+   lcd_base = fbMem ;
+
+/*
+Settings for Hitachi 5.7
+		PANEL_HORIZONTAL_TOTAL, 01c00160);
+		PANEL_HORIZONTAL_SYNC, 00400161);
+		PANEL_VERTICAL_TOTAL, 0x010800f0);
+		PANEL_VERTICAL_SYNC, 0x00020104);
+      
+In bdlogo.bmp - offset 436 is pixel data      
+   STUFFREG( hTotalReg,      0x01800140 );
+   STUFFREG( hSyncReg,       0x0008014f );
+   STUFFREG( vTotalReg,      0x010700F0 );
+   STUFFREG( vSyncReg,       0x00020100 );
+*/
+	printf( "lcd_ctrl_init exit\n");
+}
+
+void lcd_enable	(void)
+{
+}
+
+#define BIT29 (1<<29)
+
+static void setClockReg( unsigned reg, unsigned long value )
+{
+   unsigned oldValue = READREG( reg );
+   if( (oldValue & BIT29) != (value&BIT29) )
+   {
+      oldValue = (oldValue & (~BIT29))
+               | (value & BIT29);
+      STUFFREG( reg, oldValue );
+      udelay(16000);
+   }
+   
+   if( oldValue != value )
+      STUFFREG( reg, value );
+}
+
+vidinfo_t panel_info = {
+	vl_col:		320,		//this is corrected in SetPanelInfo
+	vl_row:		240,
+	vl_bpix:    LCD_BPP,
+	vl_lcd_line_length: (320 * NBITS(LCD_BPP) ) >> 3
+};
+
+static void SetPanelInfo(struct lcd_panel_info_t const *panel)
+{
+   panel_info.vl_col = panel->xres;
+   panel_info.vl_row = panel->yres;
+   panel_info.vl_bpix = LCD_BPP;
+   panel_info.vl_lcd_line_length = (panel_info.vl_col * NBITS (panel_info.vl_bpix)) >> 3;
+   printf("panel: %ix%ix%i\n",panel_info.vl_col,panel_info.vl_row,(1<<panel_info.vl_bpix));
+}
+
+static unsigned long clockRegs[] = {
+   SLOWCLOCK1, SLOWCLOCK2,
+   FASTCLOCK1, FASTCLOCK2
+};
+
+static unsigned const numClockRegs = sizeof(clockRegs)/sizeof(clockRegs[0])/2 ;
+
+/*
+ * The following tables were built by screen-scraping and sorting
+ * the tables in the SM501 manual:
+ *
+ * Fields are:
+ *    frequency in Hz
+ *    clock source (0 == 288MHz, 1 == 366 MHz)
+ *    select bits (5 bits for panels, 4 bits for CRTs)
+ */ 
+#define ENTRIESPERFREQ 3
+unsigned long const panelFrequencies[] = {
+      450000/2, 0<<29, 0x17<<24, 
+      525000/2, 1<<29, 0x17<<24, 
+      750000/2, 0<<29, 0x0f<<24, 
+      875000/2, 1<<29, 0x0f<<24, 
+      900000/2, 0<<29, 0x16<<24, 
+     1050000/2, 1<<29, 0x16<<24, 
+     1500000/2, 0<<29, 0x0e<<24, 
+     1750000/2, 1<<29, 0x0e<<24, 
+     1800000/2, 0<<29, 0x15<<24, 
+     2100000/2, 1<<29, 0x15<<24, 
+     2250000/2, 0<<29, 0x07<<24, 
+     2625000/2, 1<<29, 0x07<<24, 
+     3000000/2, 0<<29, 0x0d<<24, 
+     3500000/2, 1<<29, 0x0d<<24, 
+     3600000/2, 0<<29, 0x14<<24, 
+     4200000/2, 1<<29, 0x14<<24, 
+     4500000/2, 0<<29, 0x06<<24, 
+     5250000/2, 1<<29, 0x06<<24, 
+     6000000/2, 0<<29, 0x0c<<24, 
+     7000000/2, 1<<29, 0x0c<<24, 
+     7200000/2, 0<<29, 0x13<<24, 
+     8400000/2, 1<<29, 0x13<<24, 
+     9000000/2, 0<<29, 0x05<<24, 
+    10500000/2, 1<<29, 0x05<<24, 
+    12000000/2, 0<<29, 0x0b<<24, 
+    14000000/2, 1<<29, 0x0b<<24, 
+    14400000/2, 0<<29, 0x12<<24, 
+    16800000/2, 1<<29, 0x12<<24, 
+    18000000/2, 0<<29, 0x04<<24, 
+    21000000/2, 1<<29, 0x04<<24, 
+    24000000/2, 0<<29, 0x0a<<24, 
+    28000000/2, 1<<29, 0x0a<<24, 
+    28800000/2, 0<<29, 0x11<<24, 
+    33600000/2, 1<<29, 0x11<<24, 
+    36000000/2, 0<<29, 0x03<<24, 
+    42000000/2, 1<<29, 0x03<<24, 
+    48000000/2, 0<<29, 0x09<<24, 
+    56000000/2, 1<<29, 0x09<<24, 
+    57600000/2, 0<<29, 0x10<<24, 
+    67200000/2, 1<<29, 0x10<<24, 
+    72000000/2, 0<<29, 0x02<<24, 
+    84000000/2, 1<<29, 0x02<<24, 
+    96000000/2, 0<<29, 0x08<<24, 
+   112000000/2, 1<<29, 0x08<<24, 
+   144000000/2, 0<<29, 0x01<<24, 
+   168000000/2, 1<<29, 0x01<<24, 
+   288000000/2, 0<<29, 0x00<<24, 
+   336000000/2, 1<<29, 0x00<<24 
+};
+#define numPanelFrequencies (sizeof(panelFrequencies)/sizeof(panelFrequencies[0])/ENTRIESPERFREQ)
+
+unsigned long const crtFrequencies[] = {
+      750000/2, 0<<20, 0x0f<<16, 
+      875000/2, 1<<20, 0x0f<<16, 
+     1500000/2, 0<<20, 0x0e<<16, 
+     1750000/2, 1<<20, 0x0e<<16, 
+     2250000/2, 0<<20, 0x07<<16, 
+     2625000/2, 1<<20, 0x07<<16, 
+     3000000/2, 0<<20, 0x0d<<16, 
+     3500000/2, 1<<20, 0x0d<<16, 
+     4500000/2, 0<<20, 0x06<<16, 
+     5250000/2, 1<<20, 0x06<<16, 
+     6000000/2, 0<<20, 0x0c<<16, 
+     7000000/2, 1<<20, 0x0c<<16, 
+     9000000/2, 0<<20, 0x05<<16, 
+    10500000/2, 1<<20, 0x05<<16, 
+    12000000/2, 0<<20, 0x0b<<16, 
+    14000000/2, 1<<20, 0x0b<<16, 
+    18000000/2, 0<<20, 0x04<<16, 
+    21000000/2, 1<<20, 0x04<<16, 
+    24000000/2, 0<<20, 0x0a<<16, 
+    28000000/2, 1<<20, 0x0a<<16, 
+    36000000/2, 0<<20, 0x03<<16, 
+    42000000/2, 1<<20, 0x03<<16, 
+    48000000/2, 0<<20, 0x09<<16, 
+    56000000/2, 1<<20, 0x09<<16, 
+    72000000/2, 0<<20, 0x02<<16, 
+    84000000/2, 1<<20, 0x02<<16, 
+    96000000/2, 0<<20, 0x08<<16, 
+   112000000/2, 1<<20, 0x08<<16, 
+   144000000/2, 0<<20, 0x01<<16, 
+   168000000/2, 1<<20, 0x01<<16, 
+   288000000/2, 0<<20, 0x00<<16, 
+   336000000/2, 1<<20, 0x00<<16
+};
+#define numCrtFrequencies (sizeof(crtFrequencies)/sizeof(crtFrequencies[0])/ENTRIESPERFREQ)
+
+unsigned long const * const frequencies[] = {
+   panelFrequencies,
+   crtFrequencies
+};
+
+unsigned const numFrequencies[] = {
+   numPanelFrequencies,
+   numCrtFrequencies
+};
+
+static unsigned long const clockMasks[] = {
+   0x3F<<24,
+   0x1F<<16
+};
+
+static void updateCRT( unsigned long const           *freq,
+                       struct lcd_panel_info_t const *panel )
+{
+   unsigned long reg ;
+   unsigned long crtCtrl = 0x00010304 ; // FIFO 3 or more, CRT Timing, CRT data, enable 8-bit
+   if( panel->act_high )
+      crtCtrl |= (3<<14);     // horizontal and vertical phase
+   STUFFREG( crtFbAddrReg, 0 );
+   STUFFREG( crtFbOffsReg, ((panel->xres)<<16)+(panel->xres) );
+   STUFFREG( crtFbHTotReg, (( panel->left_margin
+                            +panel->xres
+                            +panel->right_margin
+                            +panel->hsync_len - 1) << 16 )
+                          + panel->xres-1 );
+   STUFFREG( crtFbHSynReg, (panel->hsync_len<<16)+ (panel->xres+panel->left_margin-1) );
+   STUFFREG( crtFbVTotReg, (( panel->upper_margin
+                            +panel->yres
+                            +panel->lower_margin
+                            +panel->vsync_len-1 ) << 16 )
+                          + panel->yres-1 );
+   STUFFREG( crtFbVSynReg,(panel->vsync_len<<16) 
+                          + panel->yres+panel->upper_margin-1 );
+   STUFFREG( crtctrlReg, crtCtrl );    // enable
+
+   reg = READREG( miscCtrl ) & ~0x1000 ;
+   STUFFREG( miscCtrl, reg );
+}
+
+void set_lcd_panel( struct lcd_panel_info_t const *panel )
+{
+   unsigned long dispctrl = READREG( dispctrlReg );
+   dispctrl &= ~(CLOCK_ACTIVEMASK|LCDTYPE_MASK);
+   if( !panel->act_high )
+      dispctrl |= CLOCK_ACTIVELOW ;
+   else
+      dispctrl &= ~CLOCK_ACTIVEMASK ;
+
+   if( !panel->active )
+      dispctrl |= LCDTYPE_STN12 ;
+   else
+      dispctrl &= ~LCDTYPE_MASK ;
+
+   if (panel->crt==0) dispctrl |= 4;
+
+   STUFFREG( offsetReg,   ((panel->xres)<<16)+(panel->xres) );
+   STUFFREG( fbWidthReg,  (panel->xres<<16) );
+   STUFFREG( fbHeightReg, (panel->yres<<16) ); 
+   STUFFREG( brLocateReg, ((panel->yres-1)<<16)+(panel->xres-1) );
+   STUFFREG( hTotalReg,   (( panel->left_margin
+                            +panel->xres
+                            +panel->right_margin
+                            +panel->hsync_len - 1) << 16 )
+                          + panel->xres-1 );
+   STUFFREG( hSyncReg,    (panel->hsync_len<<16)+ (panel->xres+panel->left_margin-1) );
+   STUFFREG( vTotalReg,   (( panel->upper_margin
+                            +panel->yres
+                            +panel->lower_margin
+                            +panel->vsync_len-1 ) << 16 )
+                          + panel->yres-1 );
+   STUFFREG( vSyncReg,    (panel->vsync_len<<16) 
+                          + panel->yres+panel->upper_margin-1 );
+
+   if( panel->pixclock < numClockRegs )
+   {
+      unsigned long const *clk = clockRegs+(panel->pixclock*2);
+      setClockReg( curClockReg, *clk );
+      setClockReg( pm0ClockReg, *clk++ );
+      setClockReg( pm1ClockReg, *clk );
+   }
+   else
+   {
+      int const isCRT = (0 != panel->crt);
+      int crt ;
+
+      for( crt = 0 ; crt < 2 ; crt++ )
+      {
+         unsigned long reg ;
+         unsigned long const *freq = frequencies[crt];
+         unsigned const count = numFrequencies[crt];
+         
+         unsigned long f, diffl, diffh ;
+         int i ;
+         unsigned long low, high ;
+
+         //
+         // linear scan for closest frequency
+         //
+         for( i = 0 ; i < count ; i++, freq += ENTRIESPERFREQ )
+         {
+            if( *freq > panel->pixclock )
+               break;
+         }
+         
+         low  = (i > 0) 
+                ? freq[0-ENTRIESPERFREQ]
+                : 0 ;
+         diffl = panel->pixclock - low ;
+   
+         high = (i < count ) 
+                ? *freq
+                : 0xFFFFFFFF ;
+         diffh = high - panel->pixclock ;
+   
+         if( diffh < diffl )
+         {
+            f = high ;
+         }
+         else
+         {
+            f = low ;
+            freq-- ;
+         }
+   
+         printf( "pixclock == %lu, frequency %u/%u -> %lu\n",
+                 panel->pixclock, low, high, f );
+         
+         reg = READREG( curClockReg ) & ~(clockMasks[crt]);
+
+         // Clock source
+         printf( "source %u, divisor %u\n", freq[1], freq[2] );
+         reg |= freq[1];
+         reg |= freq[2];
+
+         setClockReg( curClockReg, reg );
+         setClockReg( pm0ClockReg, reg );
+         setClockReg( pm1ClockReg, reg );
+      
+         if( isCRT )
+         {
+            paletteRegs = crtPaletteRegs ;
+            updateCRT( freq, panel );
+         }
+         else
+            paletteRegs = lcdPaletteRegs ;
+      }
+   }
+   STUFFREG( dispctrlReg, dispctrl );
+   cur_lcd_panel = panel ;
+   SetPanelInfo(panel);
+}
+
+void disable_lcd_panel( void )
+{
+   unsigned long dispctrl = READREG( dispctrlReg );
+   unsigned long crtctrl = READREG( crtctrlReg );
+
+   dispctrl &= ~(DISPCRTL_ENABLE);
+   STUFFREG( dispctrlReg, dispctrl );
+   
+   crtctrl  &= ~(DISPCRTL_ENABLE);
+   STUFFREG( crtctrlReg, crtctrl );
+}
+
+/* ------------------------------------------------------------------------- */
+
+
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	/* memory and cpu-speed are setup before relocation */
+	/* so we do _nothing_ here */
+
+	/* arch number of Neon Board */
+	gd->bd->bi_arch_number = MACH_TYPE_BD2003 ;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0xa0000100;
+
+   /* address of frame buffer */
+	gd->fb_base = fbStart ;
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	setenv("stdout", "serial");
+	setenv("stderr", "serial");
+	return 0;
+}
+
+
+int dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
diff -u -r --new-file u-boot-1.1.2/board/neon/rtc_M41T81S.c u-boot-1.1.2-neon/board/neon/rtc_M41T81S.c
--- u-boot-1.1.2/board/neon/rtc_M41T81S.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/rtc_M41T81S.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,663 @@
+/*
+ * M41T81S: 
+ *
+ * This module defines a single 'rtc' command to read/write or
+ * test the ST Micro Real Time Clock attached to the SM-501
+ * I2C pins.
+ *
+ * If called with no parameters, it will display the current time
+ * to the console device and set the 'time' environment variable.
+ *
+ * If called with a single parameter of "test", it will read the 
+ * current time, wait a second and read the current time again.
+ * It will return success (zero) if the RTC time appears to tick
+ * by 1 second.
+ *
+ * If called with one or two parameters that appear to fit an 
+ * ISO 8601 time format (i.e. YYYY-MM-DD HH:MM:SS.00 ), it will
+ * set the date and time.
+ *
+ * Copyright (c) Boundary Devices, 2006
+ *
+ */
+#include "sm501.h" 
+#include <config.h>
+#include <common.h>
+#include <version.h>
+#include <stdarg.h>
+#include <command.h>
+
+int  WriteI2C(int bVal);
+int  ReadI2C(int ack);
+int  I2CStart(int bSlaveAddress);
+void I2CStop(void);
+void I2CInit(void);
+
+//////////////////////////////////////////////////////////
+
+#define SM501_GPIO_DATA 0x10000
+#define SM501_GPIO_DIR  0x10008
+
+#define INPUT  0
+#define OUTPUT 1
+
+#define I2C_CLK  46
+#define I2C_DATA 47
+#define GPBIT_MASK(bitnum) (1<<(bitnum&0x1f))
+#define GPBIT_TEST(bitnum) ( (ReadReg(SM501_GPIO_DATA + ((bitnum>>5)<<2))) & (1<<(bitnum&0x1f)) )
+#define GPBIT_TESTBIT(c,bitnum) ( c & (1<<(bitnum&0x1f)) )
+#define GPBIT_SET(x,bitnum,value) ( (value) ? ((x) | (1<<(bitnum&0x1f))) : ((x) & ~(1<<(bitnum&0x1f))) )
+
+//0.400 Mhz protocol  = 1/.4 uSec = 10/4 uSec = 2.5 uSec
+//4 should be safe
+#define I2CWait 4
+#define LongBusWait 8
+#define StartBusWait 12
+
+typedef struct {
+	unsigned short wYear;
+	unsigned short wMonth;
+	unsigned short wDayOfWeek;
+	unsigned short wDay;
+	unsigned short wHour;
+	unsigned short wMinute;
+	unsigned short wSecond;
+	unsigned short wMilliseconds;
+} SYSTEMTIME ;
+
+typedef SYSTEMTIME *LPSYSTEMTIME ;
+
+void I2CInit(void)
+{
+    int i;
+
+    for(i=0; i<9; i++)
+    {
+        I2CStop();  
+    }
+}
+
+
+#define ReadReg(reg) READ_SM501_REG(reg)
+#define WriteReg(reg,data) STUFF_SM501_REG((reg), (data))
+
+void SetVal_ClkData(int clk,int data)
+{
+#if (I2C_DATA>>5)==(I2C_CLK>>5)
+	ulong c = ReadReg( SM501_GPIO_DATA + ((I2C_DATA>>5)<<2) );
+	c = GPBIT_SET(c, I2C_DATA, data);
+	c = GPBIT_SET(c, I2C_CLK, clk);
+	WriteReg(SM501_GPIO_DATA + ((I2C_DATA>>5)<<2), c);
+#else
+	ulong c = ReadReg( SM501_GPIO_DATA + ((I2C_DATA>>5)<<2) );
+	c = GPBIT_SET(c, I2C_DATA, data);
+	WriteReg(SM501_GPIO_DATA + ((I2C_DATA>>5)<<2), c);
+
+	c = ReadReg( SM501_GPIO_DATA + ((I2C_CLK>>5)<<2) );
+	c = GPBIT_SET(c, I2C_CLK, clk);
+	WriteReg(SM501_GPIO_DATA + ((I2C_CLK>>5)<<2), c);
+#endif
+}
+
+void SetDir_ClkData(int clk,int data)
+{
+	ulong c,c1;
+#if (I2C_DATA>>5)==(I2C_CLK>>5)
+	c = ReadReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2) );
+	if (clk==OUTPUT) {
+		//will be low, and can then change data
+		c1 = GPBIT_SET(c, I2C_CLK, OUTPUT);
+		if (c!=c1) WriteReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2), c1);
+		c = GPBIT_SET(c1, I2C_DATA, data);
+	} else {
+		//clk might be low currently, so change data 1st
+		c1 = GPBIT_SET(c, I2C_DATA, data);
+		if (c!=c1) WriteReg( SM501_GPIO_DIR + ((I2C_DATA>>5)<<2), c1);
+		c = GPBIT_SET(c1, I2C_CLK, INPUT);
+	}
+	if (c!=c1) WriteReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2), c);
+#else
+	if (clk==OUTPUT) {
+		//will be low, and can then change data
+		c = ReadReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2) );
+		c1 = GPBIT_SET(c, I2C_CLK, OUTPUT);
+		if (c!=c1) WriteReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2), c1);
+
+		c1 = ReadReg( SM501_GPIO_DIR + ((I2C_DATA>>5)<<2) );
+		c = GPBIT_SET(c1, I2C_DATA, data);
+		if (c!=c1) WriteReg( SM501_GPIO_DIR + ((I2C_DATA>>5)<<2), c);
+	} else {
+		//clk might be low currently, so change data 1st
+		c = ReadReg( SM501_GPIO_DIR + ((I2C_DATA>>5)<<2) );
+		c1 = GPBIT_SET(c, I2C_DATA, data);
+		if (c!=c1) WriteReg( SM501_GPIO_DIR + ((I2C_DATA>>5)<<2), c1);
+
+		c1 = ReadReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2) );
+		c = GPBIT_SET(c1, I2C_CLK, INPUT);
+		if (c!=c1) c1WriteReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2), c);
+	}
+#endif
+}
+void SetDir_Clk(int clk)
+{
+	ulong c = ReadReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2) );
+	c = GPBIT_SET(c, I2C_CLK, clk);
+	WriteReg( SM501_GPIO_DIR + ((I2C_CLK>>5)<<2), c);
+}
+
+void I2CStop()
+{
+	SetDir_Clk(OUTPUT);		//low clock
+	udelay(I2CWait);
+	SetDir_ClkData(OUTPUT,OUTPUT);		//low clock, low data
+	udelay(I2CWait);
+
+	//Drive Write SCL High
+	SetDir_Clk(INPUT);					//high clock
+	udelay(I2CWait);
+
+	// Drive Write SDA High
+	SetDir_ClkData(INPUT,INPUT);		//transition on data from low to high while clock is high is a stop control signal
+	udelay(LongBusWait);
+
+}
+
+
+//return 0 for success
+int WriteI2C(int bVal) 
+{
+
+	int mask;
+	int i;
+
+	// Enable Write SDA and SCL, and Drv SCL low
+	SetDir_Clk(OUTPUT);			//clock low
+	udelay(I2CWait);					//hold time
+
+	for (mask=0x80; mask; mask>>=1)
+	{
+		SetDir_ClkData(OUTPUT, (bVal & mask) ? INPUT : OUTPUT);		// Write data bits to SDA
+		udelay(LongBusWait);
+
+		SetDir_Clk(INPUT);		// Drv CLK High
+		udelay(I2CWait);
+
+		SetDir_Clk(OUTPUT);		// Drv CLK Low
+		udelay(I2CWait);				//hold time after clock goes low
+	}
+
+
+	SetDir_ClkData(OUTPUT,INPUT);	// Disable Write SDA
+	udelay(LongBusWait);					//wait for acknowledge to be placed on SDA
+	SetDir_Clk(INPUT);				// Drive Clock High
+
+	// Read SDA, until SDA==0
+	for (i=0; i<255; i++) {
+		udelay(LongBusWait);
+		if (!GPBIT_TEST(I2C_DATA)) {
+			SetDir_Clk(OUTPUT);			// Drv Clk LOW
+			return 0;					//success
+		}
+	}
+
+	printf( "WriteI2C(%i) failed\n", bVal );
+	return -1;
+}
+
+int ReadI2C(int ack)
+{
+	int mask;
+	int byRet = 0;
+
+//	SetVal_ClkData(0,0);
+	SetDir_Clk(OUTPUT);			//clock low
+	udelay(I2CWait);			//hold time
+
+	SetDir_ClkData(OUTPUT,INPUT);		//clock low, data input
+	for (mask=0x80; mask; mask>>=1)
+	{
+		// Disable Write SDA, Drive SCL to LOW
+		SetDir_Clk(OUTPUT);				//clock low
+		udelay(LongBusWait);
+
+		// Enable Write SCL, Drive SCL to HIGH
+		SetDir_Clk(INPUT);				//clock high
+		udelay(I2CWait);
+
+		// Read data bits from SDA 
+		if (GPBIT_TEST(I2C_DATA)) byRet |= mask;	//sample data bit
+	}
+
+	SetDir_Clk(OUTPUT);					//clock low
+	udelay(I2CWait);					//let them stop driving data line
+
+	if (ack) {
+		SetDir_ClkData(OUTPUT,OUTPUT);		//clock low, data low for ack
+	}
+	udelay(I2CWait);
+	SetDir_Clk(INPUT);					//clock high
+	udelay(I2CWait);					//wait ack/noack phase
+	return byRet;
+
+}
+
+int I2CStart(int SlaveAddress)
+{
+	int ret;
+	udelay(I2CWait);
+	// Enable Write SDA and Write SCL, and drive them high
+	SetDir_ClkData(INPUT,INPUT);
+	SetVal_ClkData(0,0);			//they float high anyway
+	udelay(StartBusWait);
+
+	// Drive Data
+	SetDir_ClkData(INPUT,OUTPUT);	//drive data low, (high to low transition on data, while clock high is start signal)
+	udelay(StartBusWait);
+
+	ret = WriteI2C(SlaveAddress);
+	if (ret) {
+	    printf( "I2CStart failed write of device address\n" );
+	}
+	return ret;
+}
+
+#define M41T81S_SlaveAddrWrite   0xd0
+#define M41T81S_SlaveAddrRead    0xd1
+
+#define M_HUNDREDTHS	0		//00-99	BCD
+#define M_SECONDS		1		//00-59	BCD, bit 7 ST (oscillator is stopped bit)
+#define M_MINUTES		2		//00-59 BCD
+#define M_HOURS			3		//high 2 bits are CENTURY, low 6 BCD 00-23
+#define M_WEEKDAY		4		//01-07
+#define M_DAY			5		//01-31 BCD
+#define M_MONTH			6		//01-12 BCD
+#define M_YEAR			7		//00-99	BCD
+#define M_CALIBRATION	8
+#define M_WATCHDOG		9
+#define M_ALARM_MOTH	0x0a	//01-12 BCD, high 3 bits enable
+#define M_ALARM_DAY		0x0b	//01-31 BCD. high 2 bits RPT4, RPT5
+#define M_ALARM_HOUR	0x0c	//00-23 BCD, high 2 bits RPT3, HT
+#define M_ALARM_MINUTES 0x0d	//00-59 BCD, high bit RPT2
+#define M_ALARM_SECONDS 0x0e	//00-59 BCD, high bit RPT1
+#define M_FLAGS			0x0f	//bit 7(WDF), 6(AF), 4(BL), 2(OF)
+#define M_SQW			0x13	//bit 7(RS3), 6(RS2), 5(RS1), 4(RS0)
+
+//M_FLAGS bit mask definitions
+#define MF_WDF			0x80	//Watchdog flag
+#define MF_AF			0x40	//Alarm flag
+#define MF_BL			0x10	//Battery low
+#define MF_OF			0x04	//Oscillator fail
+static int bcd(int val,int low, int high)
+{
+	int tens = val>>4;
+	int ones = val & 0xf;
+	if ((tens > 9) || (ones > 9)) return -1;
+	val = (tens*10) + ones;
+	if ((val < low) || (val > high)) return -1;
+	return val;
+}
+static unsigned char toBcd(int val)
+{
+	int tens = val/10;
+	int rem = val - (tens*10);
+	if (tens >= 10) tens = tens % 10;
+	return (tens<<4) | rem;
+}
+
+static int GetTime(LPSYSTEMTIME lpst)
+{
+	unsigned char b[M_YEAR+1];
+	unsigned char * p = b;
+	unsigned char flags;
+	int i;
+	I2CInit();		//send a bunch of stops
+
+	if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+	if (WriteI2C(M_ALARM_HOUR)) return -1;
+	if (I2CStart(M41T81S_SlaveAddrRead)) return -1;
+
+	b[0] = (unsigned char)ReadI2C(0);	//read Halt bit
+	I2CStop();
+
+	if (b[0] & 0x40) {
+		//halted, restart it
+		if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+		if (WriteI2C(M_ALARM_HOUR)) return -1;
+		if (WriteI2C(b[0] & ~0x40)) return -1;	//clear Halt bit
+		I2CStop();
+	}
+
+	if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+	if (WriteI2C(M_HUNDREDTHS))	return -1;
+	if (I2CStart(M41T81S_SlaveAddrRead)) return -1;
+	for (i=0; i<M_YEAR; i++) *p++ = (unsigned char)ReadI2C(1);
+	*p++ = (unsigned char)ReadI2C(0);	//read year
+	I2CStop();
+
+	if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+	if (WriteI2C(M_FLAGS))	return -1;
+	if (I2CStart(M41T81S_SlaveAddrRead)) return -1;
+	flags = (unsigned char)ReadI2C(0);	//read flags
+	I2CStop();
+
+	if (flags & MF_BL) {
+		printf( "M41T81S_GetTime: Battery low\n" );
+	}
+	if (flags & MF_OF) {
+		printf( "M41T81S_GetTime: Oscillator failed\n" );
+
+		//stop oscillator
+		if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+		if (WriteI2C(M_SECONDS)) return -1;
+		if (WriteI2C(b[M_SECONDS] | 0x80)) return -1;			//set stop bit
+		I2CStop();
+
+		//start oscillator
+		if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+		if (WriteI2C(M_SECONDS)) return -1;
+		if (WriteI2C(b[M_SECONDS] & ~0x80)) return -1;			//clear stop bit
+		I2CStop();
+	}
+
+
+	lpst->wYear			= ( (b[M_YEAR] > 0x99) || ((b[M_YEAR]&0xf) > 0x9) ) ? 0 :
+								(bcd(b[M_YEAR],0,99) + ( (b[M_HOURS]&0x40) ? 2100 : 2000));
+	lpst->wMonth		= bcd(b[M_MONTH],1,12);
+	lpst->wDayOfWeek	= bcd(b[M_WEEKDAY],1,7);
+	lpst->wDay			= bcd(b[M_DAY],1,31);
+	lpst->wHour			= bcd(b[M_HOURS]&0x3f,0,23);
+	lpst->wMinute		= bcd(b[M_MINUTES],0,59);
+	lpst->wSecond		= bcd(b[M_SECONDS]&0x7f,0,59);
+	lpst->wMilliseconds = bcd(b[M_HUNDREDTHS],0,99)*10;
+
+	if (b[M_SECONDS] & 0x80) {
+		//oscillator is stopped, restart it
+		if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+		if (WriteI2C(M_SECONDS)) return -1;
+		if (WriteI2C(b[M_SECONDS] & ~0x80)) return -1;			//clear stop bit
+		I2CStop();
+	}
+
+/*
+	printf( "M41T81S_GetTime: Year:%u, Month:%u, Day:%u, Hour:%u, Minute:%u, second:%u, milli:%u\n",
+	        lpst->wYear, lpst->wMonth,lpst->wDay, lpst->wHour, lpst->wMinute, lpst->wSecond,lpst->wMilliseconds );
+*/
+	if (flags & MF_OF) {
+		if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+		if (WriteI2C(M_FLAGS)) return -1;
+		if (WriteI2C(flags & ~MF_OF)) return -1;			//clear oscillator failed bit
+		I2CStop();
+	}
+	return 0;
+}
+
+static int SetTime(LPSYSTEMTIME lpst)
+{
+	unsigned char b[M_YEAR+1];
+	unsigned char flags;
+	int i;
+	if (lpst->wYear < 2004) {
+		lpst->wYear = 2004;	//don't allow it to be set in the far past.
+		lpst->wMonth = 1;
+		lpst->wDay = 1;
+		lpst->wDayOfWeek = 4;	//Thursday Jan. 1, 2004
+	}
+
+/*	printf( "M41T81S_SetTime: Year:%u, Month:%u, Day:%u, Hour:%u, Minute:%u, second:%u, milli:%u\n",
+	        lpst->wYear, lpst->wMonth,lpst->wDay, lpst->wHour, lpst->wMinute, lpst->wSecond,lpst->wMilliseconds );
+*/
+	b[M_HUNDREDTHS] = 0;		//toBcd(lpst->wMilliseconds/10);
+	b[M_SECONDS]	= toBcd(lpst->wSecond);
+	b[M_MINUTES]	= toBcd(lpst->wMinute);
+	b[M_HOURS]	= toBcd(lpst->wHour) | ( ((lpst->wYear % 200) >= 100) ? 0xc0 : 0x80);
+	b[M_WEEKDAY]	= (unsigned char)lpst->wDayOfWeek;
+	b[M_DAY]	= toBcd(lpst->wDay);
+	b[M_MONTH]	= toBcd(lpst->wMonth);
+	b[M_YEAR]	= toBcd( lpst->wYear % 100); 
+
+	if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+	if (WriteI2C(M_HUNDREDTHS)) return -1;
+
+	for (i=M_HUNDREDTHS; i<=M_YEAR; i++) {
+		if (WriteI2C(b[i])) return -1;
+	}
+	I2CStop();
+
+	if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+	if (WriteI2C(M_FLAGS))	return -1;
+	if (I2CStart(M41T81S_SlaveAddrRead)) return -1;
+	flags = (unsigned char)ReadI2C(0);	//read flags
+	I2CStop();
+
+/*	printf( "M41T81S_SetTime: Year:%u, Month:%u, Day:%u, Weekday:%u, Hour:%u, Minute:%u, second:%u flags:%u\n",
+		lpst->wYear, lpst->wMonth, lpst->wDay, lpst->wDayOfWeek, lpst->wHour, lpst->wMinute, lpst->wSecond, flags );
+*/
+	
+	if (flags & MF_OF) {
+		if (I2CStart(M41T81S_SlaveAddrWrite)) return -1;
+		if (WriteI2C(M_FLAGS)) return -1;
+		if (WriteI2C(flags & ~MF_OF)) return -1;			//clear oscillator failed bit
+		I2CStop();
+	}
+	return 0;
+}
+
+int M41T81S_GetTime(LPSYSTEMTIME lpst)
+{
+	int ret;
+	int reg =  (READ_SM501_REG(SMIR_POWER_MODE_CONTROL) & 1) ? SMIR_PWRM1_GATE : SMIR_PWRM0_GATE;
+	int gate = READ_SM501_REG(reg);
+	if ((gate & 0x40)==0) STUFF_SM501_REG(reg, gate | 0x40);
+	STUFF_SM501_REG(SMIR_GPIO_32_63_CONTROL, 
+			READ_SM501_REG(SMIR_GPIO_32_63_CONTROL) 
+			& ~(GPBIT_MASK(I2C_CLK)|GPBIT_MASK(I2C_DATA)));	// set as gpio controlled
+	udelay(LongBusWait);
+	ret = GetTime(lpst);
+	udelay(I2CWait);
+	SetDir_ClkData(INPUT,INPUT);		//high clock, high data, just for safety, should be input already
+	if ((gate & 0x40)==0){
+		STUFF_SM501_REG( reg,
+                		 READ_SM501_REG( reg )
+                                 & ~0x40 );	//disable gpio if was originally
+	}
+
+        return ret;
+}
+int M41T81S_SetTime(LPSYSTEMTIME lpst)
+{
+	int ret;
+	int reg =  (READ_SM501_REG(SMIR_POWER_MODE_CONTROL) & 1) ? SMIR_PWRM1_GATE : SMIR_PWRM0_GATE;
+	int gate = READ_SM501_REG(reg);
+	if ((gate & 0x40)==0) STUFF_SM501_REG(reg, gate | 0x40);
+	STUFF_SM501_REG(SMIR_GPIO_32_63_CONTROL, 
+			READ_SM501_REG(SMIR_GPIO_32_63_CONTROL) 
+			& ~(GPBIT_MASK(I2C_CLK)|GPBIT_MASK(I2C_DATA)));	// set as gpio controlled
+	udelay(LongBusWait);
+	ret = SetTime(lpst);
+	udelay(I2CWait);
+	SetDir_ClkData(INPUT,INPUT);		//high clock, high data, just for safety, should be input already
+	if ((gate & 0x40)==0){
+		STUFF_SM501_REG( reg,
+                		 READ_SM501_REG( reg )
+                                 & ~0x40 );	//disable gpio if was originally
+	}
+
+	return ret;
+}
+
+static int badTime( LPSYSTEMTIME lpst )
+{
+   return ( 1 > lpst->wMonth)
+          ||
+          ( 12 < lpst->wMonth)
+          ||
+          ( 1 > lpst->wDay)
+          ||
+          ( 12 < lpst->wDay)
+          ||
+          ( 24 <= lpst->wHour)
+          ||
+          ( 60 <= lpst->wMinute)
+          ||
+          ( 60 <= lpst->wSecond)
+          ||
+          ( 1000 <= lpst->wMilliseconds );
+}
+
+static unsigned diffMs( LPSYSTEMTIME lpst1,
+                        LPSYSTEMTIME lpst2 )
+{
+   return ( (long)lpst2->wMilliseconds-(long)lpst1->wMilliseconds )
+        + ( (long)lpst2->wSecond-(long)lpst1->wSecond)*1000
+        + ( (long)lpst2->wMinute-(long)lpst1->wMinute)*60000
+        + ( (long)lpst2->wHour-(long)lpst1->wHour)*3600000 ;
+}
+
+static void printTime( LPSYSTEMTIME t )
+{
+   printf( "%04u-%02u-%02u %02u:%02u:%02u.%02u",
+           t->wYear, t->wMonth, t->wDay,
+           t->wHour, t->wMinute, t->wSecond, t->wMilliseconds/10 );
+}
+
+// returns zero for success
+static int parseTime( LPSYSTEMTIME t,
+                      char const  *dateString,
+                      char const  *timeString )
+{
+   int rval = 1 ;
+   char *nextIn ;
+   unsigned long inVal = simple_strtoul( dateString, &nextIn, 10 );
+   if( ( 0 == inVal ) || ( 2999 < inVal ) || ( '-' != *nextIn ) )
+      goto bail ;
+
+   nextIn++ ;
+   t->wYear = inVal ;
+
+   inVal = simple_strtoul( nextIn, &nextIn, 10 );
+   if( ( 0 == inVal ) || ( 12 < inVal ) || ( '-' != *nextIn ) )
+      goto bail ;
+
+   nextIn++ ;
+   t->wMonth = inVal ;
+
+   inVal = simple_strtoul( nextIn, &nextIn, 10 );
+   if( ( 0 == inVal ) || ( 31 < inVal ) || ( '\0' != *nextIn ) )
+      goto bail ;
+
+   nextIn++ ;
+   t->wDay = inVal ;
+
+   t->wHour = 0 ; t->wMinute = 0 ; t->wSecond = 0 ; t->wMilliseconds = 0 ;
+
+   if( 0 != timeString )
+   {
+      inVal = simple_strtoul( timeString, &nextIn, 10 );
+      if( ( 23 < inVal ) || ( ':' != *nextIn ) )
+         goto bail ;
+   
+      nextIn++ ;
+      t->wHour = inVal ;
+   
+      inVal = simple_strtoul( nextIn, &nextIn, 10 );
+      if( ( 59 < inVal ) || ( ':' != *nextIn ) )
+         goto bail ;
+   
+      nextIn++ ;
+      t->wMinute = inVal ;
+      
+      inVal = simple_strtoul( nextIn, &nextIn, 10 );
+      if( ( 59 < inVal ) || ( '.' != *nextIn ) )
+         goto bail ;
+   
+      nextIn++ ;
+      t->wSecond = inVal ;
+   
+      inVal = simple_strtoul( nextIn, &nextIn, 10 );
+      if( ( 99 < inVal ) || ( '\0' != *nextIn ) )
+         goto bail ;
+
+      nextIn++ ;
+      t->wMilliseconds = inVal*10 ;
+      rval = 0 ;
+   }
+   else
+      rval = 0 ;
+
+bail:
+   return rval ;
+}
+
+int do_rtc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+   int rval = 1 ;
+
+   if( 1 == argc )
+   {
+      SYSTEMTIME t ;
+      int rval = M41T81S_GetTime( &t );
+      if( 0 == rval )
+      {
+         printTime(&t);
+      }
+   }
+   else if( ( 2 == argc ) && ( 0 == strcmp( "test", argv[1] ) ) )
+   {
+      SYSTEMTIME t ;
+      int rval = M41T81S_GetTime( &t );
+      if( 0 == rval ){
+         if( badTime(&t) ){
+            printf( "time not initialized...initializing\n" );
+            t.wYear = 2006 ;
+            t.wMonth = 6 ;
+            t.wDay   = 3 ;
+            memset( &t, 0, sizeof(t) );
+            rval = M41T81S_SetTime(&t);
+         }
+      }
+      
+      if( 0 == rval )
+      {
+         SYSTEMTIME t2 ;
+         udelay( 1000000 ); // wait a sec
+         rval = M41T81S_GetTime( &t2 );
+         if( 0 == rval )
+         {
+            unsigned diff = diffMs(&t,&t2);
+            
+            if( ( diff < 800 ) || ( diff > 1200 ) )
+            {
+               rval = 1 ; // clock not moving or moving too fast (bad oscillator?)
+               if( 0 == diff )
+                  printf( "check RTC oscillator\n" );
+#ifdef DEBUG                  
+               printf( "rtc test failed!\n"
+                       "difftime: %u\n", diff );
+               printf( "t1: " ); printTime( &t ); printf( "\n" );
+               printf( "t2: " ); printTime( &t2 ); printf( "\n" );
+#endif
+            }
+         }
+      }
+   }
+   else if( ( 2 == argc ) || ( 3 == argc ) )
+   {
+      SYSTEMTIME t ;
+      if( 0 == parseTime( &t, argv[1], ( 3 == argc ) ? argv[2] : 0 ) )
+      {
+         rval = M41T81S_SetTime(&t);
+      }
+      else
+         printf( "Invalid time format: use YYYY-MM-DD HH:MM:SS\n" );
+   }
+   
+   return rval ;
+}
+
+U_BOOT_CMD(
+	rtc,	127,	0,	do_rtc,
+	"rtc      - get/set/test RTC\n",
+	NULL
+);
+
+
diff -u -r --new-file u-boot-1.1.2/board/neon/sm501.h u-boot-1.1.2-neon/board/neon/sm501.h
--- u-boot-1.1.2/board/neon/sm501.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/sm501.h	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,22 @@
+#ifndef __SM501_H__
+#define __SM501_H__
+
+/*
+ * sm501.h
+ *
+ * Defines constants and macros for the SM-501 Graphics Controller.
+ *
+ */
+
+extern unsigned long const mmioStart ;
+extern unsigned long const mmioLength ;
+
+#define SMIR_GPIO_32_63_CONTROL  0x0000c
+#define SMIR_PWRM0_GATE          0x00040
+#define SMIR_PWRM1_GATE          0x00048
+#define SMIR_POWER_MODE_CONTROL  0x00054
+
+#define READ_SM501_REG( addr ) *( (unsigned long volatile *)((addr)+mmioStart) )
+#define STUFF_SM501_REG( addr, value ) *( (unsigned long volatile *)((addr)+mmioStart) ) = (value)
+
+#endif
diff -u -r --new-file u-boot-1.1.2/board/neon/u-boot.lds u-boot-1.1.2-neon/board/neon/u-boot.lds
--- u-boot-1.1.2/board/neon/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/u-boot.lds	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/start.o	(.text)
+	  cpu/pxa/ministart.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -u -r --new-file u-boot-1.1.2/board/neon/u-bootmini.lds u-boot-1.1.2-neon/board/neon/u-bootmini.lds
--- u-boot-1.1.2/board/neon/u-bootmini.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/board/neon/u-bootmini.lds	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(StartUp)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/minidebug.o	(.text)
+	  cpu/pxa/ministart.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -u -r --new-file u-boot-1.1.2/common/cmd_boot.c u-boot-1.1.2-neon/common/cmd_boot.c
--- u-boot-1.1.2/common/cmd_boot.c	2003-10-09 01:26:14.000000000 +0200
+++ u-boot-1.1.2-neon/common/cmd_boot.c	2007-08-11 21:07:20.000000000 +0200
@@ -59,6 +59,7 @@
 	 */
 	argv[0] = (char *)gd;
 #endif
+	*((ulong*)0x40e00014) |= (1<<25);	//make gpio89 an output(ac97_reset)
 #if !defined(CONFIG_NIOS)
 	rc = ((ulong (*)(int, char *[]))addr) (--argc, &argv[1]);
 #else
diff -u -r --new-file u-boot-1.1.2/common/cmd_bootm.c u-boot-1.1.2-neon/common/cmd_bootm.c
--- u-boot-1.1.2/common/cmd_bootm.c	2004-11-21 01:06:34.000000000 +0100
+++ u-boot-1.1.2-neon/common/cmd_bootm.c	2007-08-11 21:07:20.000000000 +0200
@@ -29,8 +29,6 @@
 #include <command.h>
 #include <image.h>
 #include <malloc.h>
-#include <zlib.h>
-#include <bzlib.h>
 #include <environment.h>
 #include <asm/byteorder.h>
 
@@ -73,10 +71,12 @@
 # define CHUNKSZ (64 * 1024)
 #endif
 
+#ifdef CONFIG_GZIP
+#include <zlib.h>
 int  gunzip (void *, int, unsigned char *, unsigned long *);
-
 static void *zalloc(void *, unsigned, unsigned);
 static void zfree(void *, void *, unsigned);
+#endif 
 
 #if (CONFIG_COMMANDS & CFG_CMD_IMI)
 static int image_info (unsigned long addr);
@@ -327,12 +327,17 @@
 		break;
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
+#ifdef CONFIG_GZIP
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
 			    (uchar *)data, &len) != 0) {
 			puts ("GUNZIP ERROR - must RESET board to recover\n");
 			SHOW_BOOT_PROGRESS (-6);
 			do_reset (cmdtp, flag, argc, argv);
 		}
+#else
+      printf( "GUNZIP not supported\n" );
+#endif 
+
 		break;
 #ifdef CONFIG_BZIP2
 	case IH_COMP_BZIP2:
@@ -1221,6 +1226,8 @@
 	printf ("%s %s %s (%s)", arch, os, type, comp);
 }
 
+#ifdef CONFIG_GZIP
+
 #define	ZALLOC_ALIGNMENT	16
 
 static void *zalloc(void *x, unsigned items, unsigned size)
@@ -1302,6 +1309,8 @@
 
 	return (0);
 }
+#endif // CONFIG_GZIP
+
 
 #ifdef CONFIG_BZIP2
 void bz_internal_error(int errcode)
diff -u -r --new-file u-boot-1.1.2/common/cmd_fat.c u-boot-1.1.2-neon/common/cmd_fat.c
--- u-boot-1.1.2/common/cmd_fat.c	2004-08-28 23:09:15.000000000 +0200
+++ u-boot-1.1.2-neon/common/cmd_fat.c	2007-08-11 21:07:20.000000000 +0200
@@ -30,6 +30,13 @@
 #include <net.h>
 #include <ata.h>
 
+#define CONFIG_FATLOAD_TICKS
+#define CONFIG_FATLOAD_ADLER
+
+#ifdef CONFIG_FATLOAD_ADLER
+#include <zlib.h>
+#endif 
+
 #if (CONFIG_COMMANDS & CFG_CMD_FAT)
 
 #undef	DEBUG
@@ -83,6 +90,11 @@
 	int dev=0;
 	int part=1;
 	char *ep;
+#ifdef CONFIG_FATLOAD_TICKS
+   ulong ticks1 ;
+   ulong ticks2 ;
+   ulong ticks3 ;
+#endif 
 
 	if (argc < 5) {
 		printf ("usage: fatload <interface> <dev[:part]> <addr> <filename> [bytes]\n");
@@ -110,6 +122,10 @@
 		count = simple_strtoul (argv[5], NULL, 16);
 	else
 		count = 0;
+#ifdef CONFIG_FATLOAD_TICKS
+   ticks1 = get_timer( 0 );
+#endif 
+
 	size = file_fat_read (argv[4], (unsigned char *) offset, count);
 
 	if(size==-1) {
@@ -117,7 +133,21 @@
 		return 1;
 	}
 
-	printf ("\n%ld bytes read\n", size);
+	printf ("\n%ld bytes read", size);
+
+#ifdef CONFIG_FATLOAD_TICKS
+   ticks2 = get_timer( 0 );
+   printf( " in %lu ticks, (%lu ms)", (ticks2-ticks1), (ticks2-ticks1)/(CFG_HZ/1000) );
+#endif 
+
+#ifdef CONFIG_FATLOAD_ADLER
+   printf( ", adler == 0x" );
+   printf( "%08lx", adler32(0, (Bytef *)offset, size ) );
+   ticks3 = get_timer( 0 );
+   printf( " in %lu ticks, (%lu ms)", (ticks3-ticks2), (ticks3-ticks2)/(CFG_HZ/1000) );
+#endif 
+
+   printf( "\n" );
 
 	sprintf(buf, "%lX", size);
 	setenv("filesize", buf);
diff -u -r --new-file u-boot-1.1.2/common/cmd_flash.c u-boot-1.1.2-neon/common/cmd_flash.c
--- u-boot-1.1.2/common/cmd_flash.c	2004-12-31 10:32:50.000000000 +0100
+++ u-boot-1.1.2-neon/common/cmd_flash.c	2007-08-11 21:07:20.000000000 +0200
@@ -507,7 +507,7 @@
 );
 
 U_BOOT_CMD(
-	erase,   3,   1,  do_flerase,
+	erase,   3,   0,  do_flerase,
 	"erase   - erase FLASH memory\n",
 	"start end\n"
 	"    - erase FLASH from addr 'start' to addr 'end'\n"
diff -u -r --new-file u-boot-1.1.2/common/cmd_lcdpanel.c u-boot-1.1.2-neon/common/cmd_lcdpanel.c
--- u-boot-1.1.2/common/cmd_lcdpanel.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/common/cmd_lcdpanel.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,265 @@
+/*
+ * Module cmd_lcdpanel.cpp
+ *
+ * This module defines ...
+ *
+ *
+ * Change History : 
+ *
+ * $Log: cmd_lcdpanel.c,v $
+ * Revision 1.8  2005/09/19 13:15:59  ericn
+ * -allow zeros in most fields
+ *
+ * Revision 1.7  2005/08/22 16:30:32  ericn
+ * -update panel env var w/lcdp command
+ *
+ * Revision 1.6  2005/07/18 03:05:53  ericn
+ * -allow cmdline config of CRT
+ *
+ * Revision 1.5  2005/07/06 05:26:54  ericn
+ * -make lcdinfo command conditional on PXALCD
+ *
+ * Revision 1.4  2005/07/04 18:49:01  ericn
+ * -added lcdi command
+ *
+ * Revision 1.3  2005/06/02 04:01:30  ericn
+ * -allow zero value of pixclock (meaning slow one)
+ *
+ * Revision 1.2  2005/04/30 20:32:44  ericn
+ * -added disable cmd
+ *
+ * Revision 1.1  2005/04/09 17:49:15  ericn
+ * -Initial import
+ *
+ *
+ * Copyright Boundary Devices, Inc. 2005
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+#include <command.h>
+#if (CONFIG_COMMANDS & CFG_CMD_LCDPANEL)
+
+#include <malloc.h>
+#include <lcd_panels.h>
+
+extern char console_buffer[];		/* console I/O buffer	*/
+
+static void print_panel_info( struct lcd_panel_info_t const *panel )
+{
+   printf( "------------------------------------\n"
+           "name           : %s\n", panel->name );
+   printf( "pixclock       : %u\n", panel->pixclock );
+   printf( "xres           : %u\n", panel->xres );
+   printf( "yres           : %u\n", panel->yres );
+   printf( "act_high       : %u\n", panel->act_high );
+   printf( "hsync_len      : %u\n", panel->hsync_len );
+   printf( "left_margin    : %u\n", panel->left_margin );
+   printf( "right_margin   : %u\n", panel->right_margin );
+   printf( "vsync_len      : %u\n", panel->vsync_len );
+   printf( "upper_margin   : %u\n", panel->upper_margin );
+   printf( "lower_margin   : %u\n", panel->lower_margin );
+   printf( "active         : %u\n", panel->active );
+   printf( "CRT            ? %u\n", panel->crt );
+}
+
+static struct lcd_panel_info_t const *prompt_for_panel( void )
+{
+   struct lcd_panel_info_t *panel = (struct lcd_panel_info_t *)malloc(sizeof(struct lcd_panel_info_t));
+   int bytesRead ;
+
+   memset( panel, 0, sizeof(*panel));
+
+   bytesRead = readline( "name: " );
+   if( 0 < bytesRead )
+   {
+      panel->name = strdup( console_buffer );
+      bytesRead = readline( "pixclock: " );
+      if( 0 < bytesRead )
+      {
+         char *endp;
+         ulong value = simple_strtoul( console_buffer, &endp, 0 );
+         if( endp > console_buffer )
+         {
+            panel->pixclock = value ;
+            bytesRead = readline( "xres: " );
+            if( ( 0 < bytesRead ) 
+                && ( 0 != ( value = simple_strtoul( console_buffer, &endp, 0 ) ) ) 
+                && ( endp > console_buffer ) )
+            {
+               panel->xres = value ;
+               bytesRead = readline( "yres: " );
+               if( ( 0 < bytesRead ) 
+                   && ( 0 != ( value = simple_strtoul( console_buffer, &endp, 0 ) ) )
+                   && ( endp > console_buffer ) )
+               {
+                  panel->yres = value ;
+                  bytesRead = readline( "act_high: " );
+                  if( ( 0 < bytesRead ) 
+                      && ( 1 >= ( value = simple_strtoul( console_buffer, &endp, 0 ) ) )
+                      && ( endp > console_buffer ) )
+                  {
+                     panel->act_high = value ;
+                     bytesRead = readline( "hsync_len: " );
+                     if( ( 0 < bytesRead ) 
+                         && ( 0 != ( value = simple_strtoul( console_buffer, &endp, 0 ) ) )
+                         && ( endp > console_buffer ) )
+                     {
+                        panel->hsync_len = value ;
+                        bytesRead = readline( "left_margin: " );
+                        value = simple_strtoul( console_buffer, &endp, 0 );
+                        if( ( 0 < bytesRead ) 
+                            && ( endp > console_buffer ) )
+                        {
+                           panel->left_margin = value ;
+                           bytesRead = readline( "right_margin: " );
+                           value = simple_strtoul( console_buffer, &endp, 0 );
+                           if( ( 0 < bytesRead ) 
+                               && ( endp > console_buffer ) )
+                           {
+                              panel->right_margin = value ;
+                              bytesRead = readline( "vsync_len: " );
+                              value = simple_strtoul( console_buffer, &endp, 0 );
+                              if( ( 0 < bytesRead ) 
+                                  && ( endp > console_buffer ) )
+                              {
+                                 panel->vsync_len = value ;
+                                 bytesRead = readline( "upper_margin: " );
+                                 value = simple_strtoul( console_buffer, &endp, 0 );
+                                 if( ( 0 < bytesRead ) 
+                                     && ( endp > console_buffer ) )
+                                 {
+                                    panel->upper_margin = value ;
+                                    bytesRead = readline( "lower_margin: " );
+                                    value = simple_strtoul( console_buffer, &endp, 0 );
+                                    if( ( 0 < bytesRead ) 
+                                        && ( endp > console_buffer ) )
+                                    {
+                                       panel->lower_margin = value ;
+                                       bytesRead = readline( "active (0|1) : " );
+                          		         value = simple_strtoul( console_buffer, &endp, 0 );
+                                       if( ( 0 < bytesRead ) && ( endp > console_buffer ) )
+                                       {
+                                          panel->active = value ;
+                                          bytesRead = readline( "crt (0|1) : " );
+                                          value = simple_strtoul( console_buffer, &endp, 0 );
+                                          if( ( 0 < bytesRead ) 
+                                              && 
+                                              ( endp > console_buffer ) )
+                                          {
+                                             panel->crt = value ;
+                                             print_panel_info( panel );
+                                             return panel ;
+                                          }
+                                       }
+                                    }
+                                 }
+                              }
+                           }
+                        }
+                     }
+                  }
+               }
+            }
+         }
+      }
+   }
+
+   free( panel );
+
+   return 0 ;
+}
+
+static int lcdpanel(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	if ( 1 == argc ) {
+      if( cur_lcd_panel )
+         print_panel_info( cur_lcd_panel );
+      else
+         printf( "no panel defined\n" );
+	}
+   else {
+      struct lcd_panel_info_t const *panel = find_lcd_panel( argv[1] );
+      if( panel ) {
+         printf( "found panel %s\n", panel->name );
+         set_lcd_panel( panel );
+         setenv( "panel", panel->name );
+      }
+      else if( '+' == *argv[1] ) {
+         panel = prompt_for_panel();
+         if( panel )
+         {
+            print_panel_info( panel );
+            set_lcd_panel( panel );
+         }
+      }
+      else if( '?' == *argv[1] )
+      {
+         int i ; 
+         for( i = 0 ; i < num_lcd_panels ; i++ )
+            print_panel_info( lcd_panels+i );
+      }
+      else if( '-' == *argv[1] )
+      {
+         disable_lcd_panel();
+         printf( "panel disabled\n" );
+      }
+      else
+         printf( "panel %s not found\n", argv[1] );
+   }
+   
+	return 0;
+}
+
+
+U_BOOT_CMD(
+	lcdpanel,	2,	0,	lcdpanel,
+	"lcdpanel [panelName|?|+|-]\n"
+   "     init lcd panel with panel name\n"
+   "     ? will display the supported panels\n"
+   "     + will prompt for panel details\n"
+   "     - will disable the panel\n",
+	NULL
+);
+
+#ifdef PXALCD
+#include <lcd.h>
+
+static int lcdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	printf( "--> lcdinfo:\n"
+		"screen:    %08lx\n"
+		"palette:   %08lx/%u\n",
+		panel_info.pxa.screen,
+		panel_info.pxa.palette,
+		panel_info.pxa.palette_size );
+	return 0 ;
+}
+
+U_BOOT_CMD(
+	lcdinfo,	2,	0,	lcdinfo,
+	"lcdinfo\n",
+	NULL
+);
+#endif
+
+#endif	/* CFG_CMD_LCDPANEL */
+
+
+
+
diff -u -r --new-file u-boot-1.1.2/common/cmd_lcdpanel.h u-boot-1.1.2-neon/common/cmd_lcdpanel.h
--- u-boot-1.1.2/common/cmd_lcdpanel.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/common/cmd_lcdpanel.h	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,24 @@
+#ifndef __CMD_LCDPANEL_H__
+#define __CMD_LCDPANEL_H__ "$Id: cmd_lcdpanel.h,v 1.1 2005/04/09 17:49:16 ericn Exp $"
+
+/*
+ * cmd_lcdpanel.h
+ *
+ * This header file declares ...
+ *
+ *
+ * Change History : 
+ *
+ * $Log: cmd_lcdpanel.h,v $
+ * Revision 1.1  2005/04/09 17:49:16  ericn
+ * -Initial import
+ *
+ *
+ *
+ * Copyright Boundary Devices, Inc. 2005
+ */
+
+
+
+#endif
+
diff -u -r --new-file u-boot-1.1.2/common/cmd_mmc.c u-boot-1.1.2-neon/common/cmd_mmc.c
--- u-boot-1.1.2/common/cmd_mmc.c	2003-07-01 23:07:07.000000000 +0200
+++ u-boot-1.1.2-neon/common/cmd_mmc.c	2007-08-11 21:07:20.000000000 +0200
@@ -43,4 +43,71 @@
 	NULL
 );
 
+int do_mmc_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+   if( 5 == argc )
+   {
+      unsigned long args[4];
+      unsigned i ;
+      for( i = 1 ; i < 5 ; i++ )
+      {
+         char *endp ;
+         args[i-1] = simple_strtoul(argv[i], &endp, 16 );
+         if( 0 != *endp )
+         {
+            printf( "arg[%u] is not a valid hex number\n", i );
+            break;
+         }
+      }
+   
+      if( 5 == i )
+      {
+         uchar *resp = mmc_cmd( (ushort)args[0],
+                                (ushort)args[1],
+                                (ushort)args[2],
+                                (ushort)args[3] );
+         ushort numWords = 0 ;
+         switch( args[3] )
+         {
+            case MMC_CMDAT_R1:
+            case MMC_CMDAT_R3:
+               numWords = 3;
+               break;
+   
+            case MMC_CMDAT_R2:
+               numWords = 8;
+               break;
+   
+            default:
+               printf( "Invalid response type %lu, options are [1,2,3]\n", args[3] );
+               break;
+         }
+   
+         if( resp )
+         {
+            for( i = 0 ; i < numWords*2 ; i++ )
+            {
+               printf( "%02X ", resp[i] );
+            }
+            printf( "\n" );
+         }
+         else
+            printf( "no response\n" );
+      }
+   }
+   else
+      printf ("Usage:\n%s\n", cmdtp->usage);
+   
+   return 0;
+}
+
+extern uchar *
+mmc_cmd(ushort cmd, ushort argh, ushort argl, ushort cmdat);
+
+U_BOOT_CMD(
+	mmccmd,	5,	0,	do_mmc_cmd,
+	"mmccmd - issue mmc command\n",
+	"mmccmd cmd# argh(hex) argl(hex) rsptype\n"
+);
+
 #endif	/* CFG_CMD_MMC */
diff -u -r --new-file u-boot-1.1.2/common/cmd_net.c u-boot-1.1.2-neon/common/cmd_net.c
--- u-boot-1.1.2/common/cmd_net.c	2004-06-09 14:42:26.000000000 +0200
+++ u-boot-1.1.2-neon/common/cmd_net.c	2007-08-11 21:07:20.000000000 +0200
@@ -46,6 +46,104 @@
 	"[loadAddress] [bootfilename]\n"
 );
 
+extern int get_rom_mac (char *v_rom_mac);
+extern int set_rom_mac (char const *v_rom_mac);
+
+/*
+ * returns -1 if not valid hex
+ */
+static int hexValue( char c )
+{
+	if( ( '0' <= c ) && ( '9' >= c ) )
+	{
+		return c-'0' ;
+	}
+	else if( ( 'A' <= c ) && ( 'F' >= c ) )
+	{
+		return c-'A'+10 ;
+	}
+	else if( ( 'a' <= c ) && ( 'f' >= c ) )
+	{
+		return c-'a'+10 ;
+	}
+	else
+		return -1 ;
+}
+
+// returns non-zero to indicate success
+static int parse_mac( char const *macString, // input
+                      char       *macaddr )  // output: not NULL-terminated
+{
+	int i ;
+	for( i = 0 ; i < 6 ; i++ )
+	{
+		char high, low, term ;
+		int  highval, lowval ;
+		high = *macString++ ;
+		
+		if( ( 0 == high ) 
+		    || 
+		    ( 0 > ( highval = hexValue(high) ) ) )
+			break ;
+		low  = *macString++ ;
+		if( ( 0 == low ) 
+		    || 
+		    ( 0 > ( lowval = hexValue(low) ) ) )
+			break ;
+		
+		term = *macString++ ;
+		if( 5 > i )
+		{
+			if( ( '-' != term ) && ( ':' != term ) )
+				break ;
+		}
+		else if( '\0' != term )
+			break ;
+			
+		*macaddr++ = (highval<<4) | lowval ;
+	}
+
+	return ( 6 == i );
+}
+
+int do_mac (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	if( 2 == argc )
+	{
+		char mac[6];
+		if( parse_mac( argv[1], mac ) )
+		{
+			printf( "setting mac address to %02x:%02x:%02x:%02x:%02x:%02x\n",
+				mac[0],mac[1],mac[2],mac[3],mac[4],mac[5] );
+			if( set_rom_mac( mac ) )
+				printf( "done\n" );
+			else
+				printf( "Error setting mac address\n" );
+		}
+		else
+			printf( "Error parsing mac: use form NN:NN:NN:NN:NN:NN\n" );
+	}
+	else
+	{
+		char mac[6];
+		if( get_rom_mac( mac ) )
+			printf( "mac address %02x:%02x:%02x:%02x:%02x:%02x\n",
+				mac[0],mac[1],mac[2],mac[3],mac[4],mac[5] );
+		else if( 0xFF == mac[0] )
+			printf( "MAC has not been programmed\n" );
+		else
+			printf( "error reading mac\n" );
+	}
+   return 0 ;
+}
+
+U_BOOT_CMD(
+	mac,	3,	1,	do_mac,
+	"mac\t- read/write mac address\n",
+	"- supply a parameter of the form NN:NN:NN:NN:NN:NN to set"
+);
+
+
 int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	return netboot_common (TFTP, cmdtp, argc, argv);
diff -u -r --new-file u-boot-1.1.2/common/cmd_not.c u-boot-1.1.2-neon/common/cmd_not.c
--- u-boot-1.1.2/common/cmd_not.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/common/cmd_not.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,55 @@
+/*
+ * (C) Copyright 2006
+ * Eric Nelson, Boundary Devices
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <command.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NOT)
+
+int do_not (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+   int rval = 1 ;
+   if( 1 < argc )
+   {
+      cmd_tbl_t *cmd = find_cmd(argv[1]);
+      if( cmd )
+      {
+         rval = ( 0 == cmd->cmd(cmd, flag, argc-1, argv+1) );
+      }
+      else
+         printf( "command %s not found\n", argv[1] );
+   }
+   else
+      printf( "Usage not command [..params]\n" );
+   
+   return rval ;
+}
+
+U_BOOT_CMD(
+	not,	127,	0,	do_not,
+	"not      - negate a command\n",
+	NULL
+);
+
+#endif /* CONFIG_COMMANDS & CFG_CMD_NOT */
diff -u -r --new-file u-boot-1.1.2/common/cmd_nvedit.c u-boot-1.1.2-neon/common/cmd_nvedit.c
--- u-boot-1.1.2/common/cmd_nvedit.c	2004-09-30 00:55:14.000000000 +0200
+++ u-boot-1.1.2-neon/common/cmd_nvedit.c	2007-08-11 21:07:20.000000000 +0200
@@ -487,16 +487,21 @@
 {
 	int i, nxt;
 
+//	printf ("before WATCHDOG_RESET\n");
 	WATCHDOG_RESET();
+//	printf ("after WATCHDOG_RESET\n");
 
 	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
 		int val;
 
+//	printf ("i= %i\n", i);
 		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
 			if (nxt >= CFG_ENV_SIZE) {
 				return (NULL);
 			}
+//	putc(env_get_char(nxt));
 		}
+//	printf ("\n");
 		if ((val=envmatch(name, i)) < 0)
 			continue;
 		return (env_get_addr(val));
diff -u -r --new-file u-boot-1.1.2/common/command.c u-boot-1.1.2-neon/common/command.c
--- u-boot-1.1.2/common/command.c	2004-04-18 19:39:39.000000000 +0200
+++ u-boot-1.1.2-neon/common/command.c	2007-08-11 21:07:20.000000000 +0200
@@ -27,6 +27,9 @@
 
 #include <common.h>
 #include <command.h>
+#ifdef CONFIG_LCD
+#include "lcd.h"
+#endif 
 
 int
 do_version (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -74,6 +77,41 @@
 	"    - echo args to console; \\c suppresses newline\n"
 );
 
+#ifdef CONFIG_LCD
+
+int
+do_lecho (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int i, putnl = 1;
+
+	for (i = 1; i < argc; i++) {
+		char *p = argv[i], c;
+
+		if (i > 1)
+			putc(' ');
+		while ((c = *p++) != '\0') {
+			if (c == '\\' && *p == 'c') {
+				putnl = 0;
+				p++;
+			} else {
+				lcd_putc(c);
+			}
+		}
+	}
+
+	if (putnl)
+		lcd_putc('\n');
+	return 0;
+}
+
+U_BOOT_CMD(
+	lecho,	CFG_MAXARGS,	1,	do_lecho,
+ 	"lecho    - echo args to lcd\n",
+ 	"[args..]\n"
+	"    - echo args to lcd; \\c suppresses newline\n"
+);
+#endif 
+
 #ifdef CFG_HUSH_PARSER
 
 int
diff -u -r --new-file u-boot-1.1.2/common/env_flash.c u-boot-1.1.2-neon/common/env_flash.c
--- u-boot-1.1.2/common/env_flash.c	2004-03-14 02:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/common/env_flash.c	2007-08-11 21:07:20.000000000 +0200
@@ -83,6 +83,10 @@
 #define OBSOLETE_FLAG 0
 #endif /* CFG_ENV_ADDR_REDUND */
 
+#ifdef CFG_ENV_IS_IN_FLASH
+static env_t *flash_addr_new = (env_t *)CFG_ENV_ADDR ;
+#endif
+
 extern uchar default_environment[];
 extern int default_environment_size;
 
diff -u -r --new-file u-boot-1.1.2/common/fnmatch.c u-boot-1.1.2-neon/common/fnmatch.c
--- u-boot-1.1.2/common/fnmatch.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/common/fnmatch.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,166 @@
+/*
+ * (C) Copyright 2005
+ * Boundary Devices
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ *
+ */
+
+#include <common.h>
+#include <config.h>
+#include <part.h>
+
+/* Some file systems are case-insensitive.  If FOLD_FN_CHAR is
+   #defined, it maps the character C onto its "canonical" form.  In a
+   case-insensitive system, it would map all alphanumeric characters
+   to lower case.  Under Windows NT, / and \ are both path component
+   separators, so FOLD_FN_CHAR would map them both to /.  */
+#define FOLD_FN_CHAR(c) (c)
+
+
+int fnmatch(const char *pattern, const char *string, int flags)
+{
+  register const char *p = pattern, *n = string;
+  register char c;
+
+  while ((c = *p++) != '\0')
+    {
+      switch (c)
+        {
+        case '?':
+          if (*n == '\0')
+            return FNM_NOMATCH;
+          else if ((flags & FNM_PATHNAME) && *n == '/')
+            return FNM_NOMATCH;
+          else if ((flags & FNM_PERIOD) && *n == '.' &&
+                   (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+            return FNM_NOMATCH;
+          break;
+          
+        case '\\':
+          if (!(flags & FNM_NOESCAPE))
+            c = *p++;
+          if (FOLD_FN_CHAR (*n) != FOLD_FN_CHAR (c))
+            return FNM_NOMATCH;
+          break;
+          
+        case '*':
+          if ((flags & FNM_PERIOD) && *n == '.' &&
+              (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+            return FNM_NOMATCH;
+          
+          for (c = *p++; c == '?' || c == '*'; c = *p++, ++n)
+            if (((flags & FNM_PATHNAME) && *n == '/') ||
+                (c == '?' && *n == '\0'))
+              return FNM_NOMATCH;
+          
+          if (c == '\0')
+            return 0;
+          
+          {
+            char c1 = (!(flags & FNM_NOESCAPE) && c == '\\') ? *p : c;
+            for (--p; *n != '\0'; ++n)
+              if ((c == '[' || FOLD_FN_CHAR (*n) == FOLD_FN_CHAR (c1)) &&
+                  fnmatch(p, n, flags & ~FNM_PERIOD) == 0)
+                return 0;
+            return FNM_NOMATCH;
+          }
+          
+        case '[':
+          {
+            /* Nonzero if the sense of the character class is inverted.  */
+            register int not;
+            
+            if (*n == '\0')
+              return FNM_NOMATCH;
+            
+            if ((flags & FNM_PERIOD) && *n == '.' &&
+                (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+              return FNM_NOMATCH;
+            
+            not = (*p == '!' || *p == '^');
+            if (not)
+              ++p;
+            
+            c = *p++;
+            for (;;)
+              {
+                register char cstart = c, cend = c;
+                
+                if (!(flags & FNM_NOESCAPE) && c == '\\')
+                  cstart = cend = *p++;
+                
+                if (c == '\0')
+                  /* [ (unterminated) loses.  */
+                  return FNM_NOMATCH;
+                
+                c = *p++;
+                
+                if ((flags & FNM_PATHNAME) && c == '/')
+                  /* [/] can never match.  */
+                  return FNM_NOMATCH;
+                
+                if (c == '-' && *p != ']')
+                  {
+                    cend = *p++;
+                    if (!(flags & FNM_NOESCAPE) && cend == '\\')
+                      cend = *p++;
+                    if (cend == '\0')
+                      return FNM_NOMATCH;
+                    c = *p++;
+                  }
+                
+                if (*n >= cstart && *n <= cend)
+                  goto matched;
+                
+                if (c == ']')
+                  break;
+              }
+            if (!not)
+              return FNM_NOMATCH;
+            break;
+            
+          matched:;
+            /* Skip the rest of the [...] that already matched.  */
+            while (c != ']')
+              {
+                if (c == '\0')
+                  /* [... (unterminated) loses.  */
+                  return FNM_NOMATCH;
+                
+                c = *p++;
+                if (!(flags & FNM_NOESCAPE) && c == '\\')
+                  /* 1003.2d11 is unclear if this is right.  %%% */
+                  ++p;
+              }
+            if (not)
+              return FNM_NOMATCH;
+          }
+          break;
+          
+        default:
+          if (FOLD_FN_CHAR (c) != FOLD_FN_CHAR (*n))
+            return FNM_NOMATCH;
+        }
+      
+      ++n;
+    }
+
+  if (*n == '\0')
+    return 0;
+
+  return FNM_NOMATCH;
+}
+
diff -u -r --new-file u-boot-1.1.2/common/lcd.c u-boot-1.1.2-neon/common/lcd.c
--- u-boot-1.1.2/common/lcd.c	2004-12-10 12:40:50.000000000 +0100
+++ u-boot-1.1.2-neon/common/lcd.c	2007-08-11 21:07:20.000000000 +0200
@@ -41,7 +41,7 @@
 #endif
 #include <lcd.h>
 
-#if defined(CONFIG_PXA250)
+#if defined(CONFIG_PXA250) || defined(CONFIG_PXA270)
 #include <asm/byteorder.h>
 #endif
 
@@ -94,8 +94,46 @@
 static int lcd_getfgcolor (void);
 #endif	/* NOT_USED_SO_FAR */
 
-/************************************************************************/
+static int luminance( int red, int green, int blue )
+{
+   // 
+   // I've seen a couple of different algorithms here:
+   // (max+min)/2
+/*
+
+   int max = MAX( red, MAX( green, blue ) );
+   int min = MIN( red, MIN( green, blue ) );
+   return (max+min)/2 ;
+*/
+
+   // A more mathematically-correct version
+// return (int)(c.R*0.3 + c.G*0.59+ c.B*0.11);
+
+   // Just return 'green'
+   // return green;
+
+   // and one that uses shifts and adds to come close to the above
+   //
+   //    red   = 5/16= 0.3125    == 1/4 + 1/16
+   //    green = 9/16= 0.5625    == 1/2 + 1/16
+   //    blue  = 1/8 = 0.125
+   //
+   if( 0 < red )
+      red = (red>>2) + (red>>4);
+   else
+      red = 0 ;
+   if( 0 < green )
+      green = (green>>1) + (green>>4) ;
+   else
+      green = 0 ;
+   if( 0 < blue )
+      blue = blue >> 3 ;
+   else
+      blue = 0 ;
+   return red+green+blue ;
+}
 
+/************************************************************************/
 /*----------------------------------------------------------------------*/
 
 static void console_scrollup (void)
@@ -221,10 +259,10 @@
 	uchar *dest;
 	ushort off, row;
 
-	dest = (uchar *)(lcd_base + y * lcd_line_length + x * (1 << LCD_BPP) / 8);
+	dest = (uchar *)(lcd_base + y * panel_info.vl_lcd_line_length + x * (1 << LCD_BPP) / 8);
 	off  = x * (1 << LCD_BPP) % 8;
 
-	for (row=0;  row < VIDEO_FONT_HEIGHT;  ++row, dest += lcd_line_length)  {
+	for (row=0;  row < VIDEO_FONT_HEIGHT;  ++row, dest += panel_info.vl_lcd_line_length)  {
 		uchar *s = str;
 		uchar *d = dest;
 		int i;
@@ -337,8 +375,6 @@
 
 	lcd_base = (void *)(gd->fb_base);
 
-	lcd_line_length = (panel_info.vl_col * NBITS (panel_info.vl_bpix)) / 8;
-
 	lcd_init (lcd_base);		/* LCD initialization */
 
 	/* Device initialization */
@@ -389,7 +425,7 @@
 	/* set framebuffer to background color */
 	memset ((char *)lcd_base,
 		COLOR_MASK(lcd_getbgcolor()),
-		lcd_line_length*panel_info.vl_row);
+		panel_info.vl_lcd_line_length*panel_info.vl_row);
 #endif
 	/* Paint the logo and retrieve LCD base address */
 	debug ("[LCD] Drawing the logo...\n");
@@ -500,12 +536,13 @@
 #ifdef CONFIG_LCD_LOGO
 void bitmap_plot (int x, int y)
 {
-	ushort *cmap;
+	PALETTEVAL_TYPE *cmap;
 	ushort i, j;
 	uchar *bmap;
 	uchar *fb;
 	ushort *fb16;
-#if defined(CONFIG_PXA250)
+
+#if defined(PXALCD)
 	struct pxafb_info *fbi = &panel_info.pxa;
 #elif defined(CONFIG_MPC823)
 	volatile immap_t *immr = (immap_t *) CFG_IMMR;
@@ -514,17 +551,18 @@
 
 	debug ("Logo: width %d  height %d  colors %d  cmap %d\n",
 		BMP_LOGO_WIDTH, BMP_LOGO_HEIGHT, BMP_LOGO_COLORS,
-		sizeof(bmp_logo_palette)/(sizeof(ushort)));
+		sizeof(bmp_logo_palette)/(sizeof(PALETTEVAL_TYPE)));
 
 	bmap = &bmp_logo_bitmap[0];
-	fb   = (char *)(lcd_base + y * lcd_line_length + x);
+	fb   = (char *)(lcd_base + y * panel_info.vl_lcd_line_length + x);
 
 	if (NBITS(panel_info.vl_bpix) < 12) {
 		/* Leave room for default color map */
-#if defined(CONFIG_PXA250)
-		cmap = (ushort *)fbi->palette;
+#if defined(PXALCD)
+		cmap = (PALETTEVAL_TYPE *)fbi->palette;
 #elif defined(CONFIG_MPC823)
 		cmap = (ushort *)&(cp->lcd_cmap[BMP_LOGO_OFFSET*sizeof(ushort)]);
+#elif defined(CONFIG_SM501)
 #endif
 
 		WATCHDOG_RESET();
@@ -532,10 +570,13 @@
 		/* Set color map */
 		for (i=0; i<(sizeof(bmp_logo_palette)/(sizeof(ushort))); ++i) {
 			ushort colreg = bmp_logo_palette[i];
-#ifdef  CFG_INVERT_COLORS
-			*cmap++ = 0xffff - colreg;
+#if defined(CONFIG_SM501)
 #else
+   #ifdef  CFG_INVERT_COLORS
+   			*cmap++ = 0xffff - colreg;
+   #else
 			*cmap++ = colreg;
+   #endif
 #endif
 		}
 
@@ -548,7 +589,7 @@
 		}
 	}
 	else { /* true color mode */
-		fb16 = (ushort *)(lcd_base + y * lcd_line_length + x);
+		fb16 = (ushort *)(lcd_base + y * panel_info.vl_lcd_line_length + x);
 		for (i=0; i<BMP_LOGO_HEIGHT; ++i) {
 			for (j=0; j<BMP_LOGO_WIDTH; j++) {
 				fb16[j] = bmp_logo_palette[(bmap[j])];
@@ -570,7 +611,11 @@
  */
 int lcd_display_bitmap(ulong bmp_image, int x, int y)
 {
-	ushort *cmap;
+#if defined(CONFIG_SM501)
+   uchar  *cmap ;
+#else 
+	PALETTEVAL_TYPE *cmap;
+#endif 
 	ushort i, j;
 	uchar *fb;
 	bmp_image_t *bmp=(bmp_image_t *)bmp_image;
@@ -579,7 +624,12 @@
 	unsigned long width, height;
 	unsigned colors,bpix;
 	unsigned long compression;
-#if defined(CONFIG_PXA250)
+	int     maxLum = 0 ;
+	int     bgCol = 0 ;
+	int     minLum = 0xFFFF ;
+	int     fgCol = 0 ;
+
+#if defined(PXALCD)
 	struct pxafb_info *fbi = &panel_info.pxa;
 #elif defined(CONFIG_MPC823)
 	volatile immap_t *immr = (immap_t *) CFG_IMMR;
@@ -590,7 +640,7 @@
 		(bmp->header.signature[1]=='M'))) {
 		printf ("Error: no valid bmp image at %lx\n", bmp_image);
 		return 1;
-}
+	}
 
 	width = le32_to_cpu (bmp->header.width);
 	height = le32_to_cpu (bmp->header.height);
@@ -616,33 +666,64 @@
 		(int)width, (int)height, (int)colors);
 
 	if (bpix==8) {
-#if defined(CONFIG_PXA250)
-		cmap = (ushort *)fbi->palette;
+#if defined(PXALCD)
+		cmap = (PALETTEVAL_TYPE *)fbi->palette;
 #elif defined(CONFIG_MPC823)
 		cmap = (ushort *)&(cp->lcd_cmap[255*sizeof(ushort)]);
+#elif defined(CONFIG_SM501)
+      cmap = (uchar *)paletteRegs ;
 #else
 # error "Don't know location of color map"
 #endif
 
 		/* Set color map */
 		for (i=0; i<colors; ++i) {
+         int lum ;
 			bmp_color_table_entry_t cte = bmp->color_table[i];
+#if defined(CONFIG_SM501)
+         *cmap++ = cte.blue ;
+         *cmap++ = cte.green ;
+         *cmap++ = cte.red ;
+         *cmap++  = 0 ;
+#elif defined(CONFIG_PXA270) && defined(PXALCD)
+	 *cmap = 0xFF000000 ;
+	 *cmap |= cte.red << 16 ;
+	 *cmap |= cte.green << 8 ;
+	 *cmap |= cte.blue ;
+         *cmap++ ;
+#else 
 			ushort colreg =
 				( ((cte.red)   << 8) & 0xf800) |
 				( ((cte.green) << 4) & 0x07e0) |
 				( (cte.blue) & 0x001f) ;
-
-#ifdef CFG_INVERT_COLORS
+   #ifdef CFG_INVERT_COLORS
 			*cmap = 0xffff - colreg;
-#else
+   #else
 			*cmap = colreg;
-#endif
-#if defined(CONFIG_PXA250)
+   #endif
+   #if defined(PXALCD)
 			cmap++;
-#elif defined(CONFIG_MPC823)
+   #elif defined(CONFIG_MPC823)
 			cmap--;
+   #endif
 #endif
+          lum = luminance( cte.red, cte.green, cte.blue );
+          if( lum > maxLum )
+          {
+             maxLum = lum ;
+             bgCol = i ;
+          }
+          
+          if( lum < minLum )
+          {
+             minLum = lum ;
+             fgCol = i ;
+          }
 		}
+
+      printf( "bgcolor %u, fg %u\n", bgCol, fgCol );
+      lcd_color_fg = fgCol ;
+      lcd_color_bg = bgCol ;
 	}
 
 	padded_line = (width&0x3) ? ((width&~0x3)+4) : (width);
@@ -653,16 +734,16 @@
 
 	bmap = (uchar *)bmp + le32_to_cpu (bmp->header.data_offset);
 	fb   = (uchar *) (lcd_base +
-		(y + height - 1) * lcd_line_length + x);
+		(y + height - 1) * panel_info.vl_lcd_line_length + x);
 	for (i = 0; i < height; ++i) {
 		for (j = 0; j < width ; j++)
-#if defined(CONFIG_PXA250)
+#if defined(CONFIG_PXA250) || defined(CONFIG_PXA270)
 			*(fb++)=*(bmap++);
 #elif defined(CONFIG_MPC823)
 			*(fb++)=255-*(bmap++);
 #endif
-		bmap += (width - padded_line);
-		fb   -= (width + lcd_line_length);
+		bmap += (padded_line-width);
+		fb   -= (width + panel_info.vl_lcd_line_length);
 	}
 
 	return (0);
@@ -735,7 +816,7 @@
 #endif /* LCD_INFO */
 
 #if defined(CONFIG_LCD_LOGO) && !defined(LCD_INFO_BELOW_LOGO)
-	return ((void *)((ulong)lcd_base + BMP_LOGO_HEIGHT * lcd_line_length));
+	return ((void *)((ulong)lcd_base + BMP_LOGO_HEIGHT * panel_info.vl_lcd_line_length));
 #else
 	return ((void *)lcd_base);
 #endif /* CONFIG_LCD_LOGO */
diff -u -r --new-file u-boot-1.1.2/common/lcd_panels.c u-boot-1.1.2-neon/common/lcd_panels.c
--- u-boot-1.1.2/common/lcd_panels.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/common/lcd_panels.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,286 @@
+/*
+ * Module lcd_panels.cpp
+ *
+ * This module defines the num_lcd_panels and lcd_panels
+ * constants as declared in lcd_panels.h
+ *
+ * Change History : 
+ *
+ * $Log: lcd_panels.c,v $
+ * Revision 1.9  2006/05/23 18:46:39  ericn
+ * -added hitachi_wxga panel
+ *
+ * Revision 1.8  2005/09/19 13:15:43  ericn
+ * -updated sharp_qvga timing
+ *
+ * Revision 1.7  2005/07/18 03:05:35  ericn
+ * -update crt1024x768 timings
+ *
+ * Revision 1.6  2005/07/07 03:42:22  tkisky
+ * -make my CRT 1024x768 display work
+ *
+ * Revision 1.5  2005/06/02 04:02:39  ericn
+ * -added qvga_portrait
+ *
+ * Revision 1.4  2005/05/15 18:59:00  tkisky
+ * -change polarity of hitachi_wvga
+ *
+ * Revision 1.3  2005/05/03 15:32:11  ericn
+ * -fast pixclock for hvga, remove redundant 1024x768
+ *
+ * Revision 1.2  2005/04/30 20:33:22  ericn
+ * -added CRT support
+ *
+ * Revision 1.1  2005/04/09 17:49:17  ericn
+ * -Initial import
+ *
+ *
+ * Copyright Boundary Devices, Inc. 2005
+ */
+
+
+#include "lcd_panels.h"
+#include <common.h>
+
+/*
+Settings for Hitachi 5.7
+		PANEL_HORIZONTAL_TOTAL, 01c00160);    // should be 34+320+1+64-1= 418 = 0x1A2 (Hex) 
+                                               + 0x13f+16
+		PANEL_HORIZONTAL_SYNC, 00400161);            hsync_len == 64    lmargin=0x161-0x13f=34
+		PANEL_VERTICAL_TOTAL, 0x010800f0);
+		PANEL_VERTICAL_SYNC, 0x00020104);     vsync=2,  upper_margin=0x0104-0xf0-1= 19
+
+In bdlogo.bmp - offset 436 is pixel data
+
+Sharp 5.7 active
+
+   STUFFREG( hTotalReg,      0x01800140 );  // should be 16+320+1+8-1 == 0x158
+                                             + 0x13f (width-1)
+   STUFFREG( hSyncReg,       0x0008014f );         hsync_len == 8    lmargin=0x14f-0x13f=16
+   STUFFREG( vTotalReg,      0x010700F0 );
+   STUFFREG( vSyncReg,       0x00020100 );     vsync=2,  upper_margin=0x0100-0xf0+1= 17
+
+static unsigned const hTotalReg      = 0x00080024 ;  //  015F0140
+static unsigned const hSyncReg       = 0x00080028 ;  //  0008014f
+static unsigned const vTotalReg      = 0x0008002c ;  //  010700F0
+static unsigned const vSyncReg       = 0x00080030 ;  //  000200FE
+
+const unsigned int sm501_list2[]={0x0fe80000,
+dispctrl	  0x0F013104,             // 0f0d0105
+pan        0x00000000,
+colorkey   0x00000000,
+fbaddr     0x00000000,
+offsetww   ((LCD_XRES)<<16)+(LCD_XRES),
+fbwidth    (LCD_XRES<<16),
+fbheight   (LCD_YRES<<16),
+tllocate   0x00000000,
+brlocate   ((LCD_YRES-1)<<16)+(LCD_XRES-1),
+htotal     ((LCD_BEGIN_OF_LINE_WAIT_COUNT+
+             LCD_XRES+
+             LCD_END_OF_LINE_WAIT_COUNT+
+             LCD_HORIZONTAL_SYNC_PULSE_WIDTH-1)<<16)
+           +(LCD_XRES-1),
+hsync      (LCD_HORIZONTAL_SYNC_PULSE_WIDTH<<16)
+          +(LCD_XRES+LCD_BEGIN_OF_LINE_WAIT_COUNT-1),
+vtotal     ((LCD_BEGIN_FRAME_WAIT_COUNT+
+             LCD_YRES+
+             LCD_END_OF_FRAME_WAIT_COUNT+
+             LCD_VERTICAL_SYNC_PULSE_WIDTH-1)<<16)
+           +(LCD_YRES-1),
+vsync   	  (LCD_VERTICAL_SYNC_PULSE_WIDTH<<16)
+           +(LCD_YRES+LCD_BEGIN_FRAME_WAIT_COUNT-1)};
+*/
+
+static struct lcd_panel_info_t const lcd_panels_[] = {
+
+   /* char const       *name         */   { "hitachi_qvga"
+   /* unsigned long     pixclock     */    , 0
+   /* unsigned short    xres         */    , 320       
+   /* unsigned short    yres         */    , 240
+   /* unsigned char     act_high     */    , 1
+   /* unsigned char     hsync_len    */    , 64       
+   /* unsigned char     left_margin  */    ,  1
+   /* unsigned char     right_margin */    , 16       
+   /* unsigned char     vsync_len    */    , 20       
+   /* unsigned char     upper_margin */    , 8       
+   /* unsigned char     lower_margin */    , 3       
+   /* unsigned char     active       */    , 1
+   /* unsigned char     crt          */    , 0 }
+
+   /* char const       *name         */ , { "sharp_qvga"
+   /* unsigned long     pixclock     */    , 0          
+   /* unsigned short    xres         */    , 320        /* , 320  */
+   /* unsigned short    yres         */    , 240        /* , 240  */
+   /* unsigned char     act_high     */    , 1          /* , 1    */
+   /* unsigned char     hsync_len    */    , 20         /* , 8    */
+   /* unsigned char     left_margin  */    , 1          /* , 16   */
+   /* unsigned char     right_margin */    , 30         /* , 1    */
+   /* unsigned char     vsync_len    */    , 4          /* , 20   */
+   /* unsigned char     upper_margin */    , 17         /* , 17   */
+   /* unsigned char     lower_margin */    , 3          /* , 3    */
+   /* unsigned char     active       */    , 1          /* , 1    */
+   /* unsigned char     crt          */    , 0 }
+
+   /* char const       *name         */ , { "qvga_portrait"
+   /* unsigned long     pixclock     */    , 0
+   /* unsigned short    xres         */    , 240
+   /* unsigned short    yres         */    , 320
+   /* unsigned char     act_high     */    , 1
+   /* unsigned char     hsync_len    */    , 64       
+   /* unsigned char     left_margin  */    , 34
+   /* unsigned char     right_margin */    , 1       
+   /* unsigned char     vsync_len    */    , 20       
+   /* unsigned char     upper_margin */    , 8       
+   /* unsigned char     lower_margin */    , 3       
+   /* unsigned char     active       */    , 1
+   /* unsigned char     crt          */    , 0 
+   /* unsigned          rotation     */    , 90 }
+
+   /* char const       *name         */ , { "hitachi_hvga"
+   /* unsigned long     pixclock     */    , 1      
+   /* unsigned short    xres         */    , 640
+   /* unsigned short    yres         */    , 240
+   /* unsigned char     act_high     */    , 1
+   /* unsigned char     hsync_len    */    , 64       
+   /* unsigned char     left_margin  */    , 34       
+   /* unsigned char     right_margin */    , 1       
+   /* unsigned char     vsync_len    */    , 20       
+   /* unsigned char     upper_margin */    , 8       
+   /* unsigned char     lower_margin */    , 3       
+   /* unsigned char     active       */    , 1
+   /* unsigned char     crt          */    , 0 }
+
+   /* char const       *name         */ , { "sharp_vga"
+   /* unsigned long     pixclock     */    , 1      
+   /* unsigned short    xres         */    , 640
+   /* unsigned short    yres         */    , 480
+   /* unsigned char     act_high     */    , 1
+   /* unsigned char     hsync_len    */    , 64       
+   /* unsigned char     left_margin  */    , 60       
+   /* unsigned char     right_margin */    , 60       
+   /* unsigned char     vsync_len    */    , 20       
+   /* unsigned char     upper_margin */    , 34       
+   /* unsigned char     lower_margin */    , 3       
+   /* unsigned char     active       */    , 1
+   /* unsigned char     crt          */    , 0 }
+   
+   /* char const       *name         */ , { "hitachi_wvga"
+   /* unsigned long     pixclock     */    , 1      
+   /* unsigned short    xres         */    , 800
+   /* unsigned short    yres         */    , 480
+   /* unsigned char     act_high     */    , 1 
+   /* unsigned char     hsync_len    */    , 64
+   /* unsigned char     left_margin  */    , 1       
+   /* unsigned char     right_margin */    , 39       
+   /* unsigned char     vsync_len    */    , 20       
+   /* unsigned char     upper_margin */    , 8       
+   /* unsigned char     lower_margin */    , 3       
+   /* unsigned char     active       */    , 1
+   /* unsigned char     crt          */    , 0 }
+// Note that you can use the nifty tool at the 
+// following location to generate these values:
+//    http://www.tkk.fi/Misc/Electronics/faq/vga2rgb/calc.html
+, {
+    name: "crt1024x768",
+    pixclock: 65000000,
+    xres: 1024,
+    yres: 768,
+    act_high : 0,
+    hsync_len: 136,
+    left_margin: 24,
+    right_margin: 160,
+    vsync_len: 6,
+    upper_margin: 3,
+    lower_margin: 29,
+    active : 0,
+    crt : 1
+}
+, {
+    name: "hitachi_wxga",
+    pixclock: 1,
+    xres: 1024,
+    yres: 768,
+    act_high : 1,
+    hsync_len: 64,
+    left_margin: 1,
+    right_margin: 39,
+    vsync_len: 20,
+    upper_margin: 8,
+    lower_margin: 3,
+    active : 1,
+    crt : 0
+}
+};
+
+/*
+. e
+typedef enum _polarity_t
+{
+	POSITIVE,
+	NEGATIVE,
+}
+polarity_t;
+
+typedef struct _mode_table_t
+{
+	// Horizontal timing.
+	int horizontal_total;
+	int horizontal_display_end;
+	int horizontal_sync_start;
+	int horizontal_sync_width;
+	polarity_t horizontal_sync_polarity;
+
+	// Vertical timing.
+	int vertical_total;
+	int vertical_display_end;
+	int vertical_sync_start;
+	int vertical_sync_height;
+	polarity_t vertical_sync_polarity;
+
+	// Refresh timing.
+	long pixel_clock;
+	long horizontal_frequency;
+	long vertical_frequency;
+}
+mode_table_t;
+
+	// 1024 x 768
+ htotal dend hsstrt hsw  hpolar    vtot vdend vdstrt vsh vpolar    pixclk    hfreq vfreq
+{ 1344, 1024, 1048, 136, NEGATIVE, 806, 768,    771,  6, NEGATIVE, 65000000, 48363, 60 },
+{ 1328, 1024, 1048, 136, NEGATIVE, 806, 768,    771,  6, NEGATIVE, 75000000, 56476, 70 },
+{ 1312, 1024, 1040,  96, POSITIVE, 800, 768,    769,  3, POSITIVE, 78750000, 60023, 75 },
+{ 1376, 1024, 1072,  96, POSITIVE, 808, 768,    769,  3, POSITIVE, 94500000, 68677, 85 },
+
+0FE80200/00010000 +           CRT regs
+0FE80204/00180000 +
+0FE80208/08000800 +
+0FE8020C/05D003FF +
+0FE80210/00C80424 +
+0FE80214/032502FF +
+0FE80218/00060302 +
+0FE8021C/00000000 +
+0FE80220/00000000 +
+0FE80224/00400200 +
+0FE80228/00000000 +
+0FE8022C/00000000 +
+0FE80230/00000800 +
+0FE80234/00000000 +
+0FE80238/08000000 +
+0FE8023C/00000400 +
+*/
+
+struct lcd_panel_info_t const * const lcd_panels = lcd_panels_ ;
+unsigned const num_lcd_panels = sizeof(lcd_panels_)/sizeof(lcd_panels_[0]);
+
+struct lcd_panel_info_t const *find_lcd_panel( char const * name )
+{
+   unsigned i ;
+   for( i = 0 ; i < num_lcd_panels ; i++ )
+   {
+      if( 0 == strcmp( lcd_panels_[i].name, name ) ) 
+         return lcd_panels_+i ;
+   }
+   return 0 ;
+}
+
+struct lcd_panel_info_t const *cur_lcd_panel = 0 ;
diff -u -r --new-file u-boot-1.1.2/common/Makefile u-boot-1.1.2-neon/common/Makefile
--- u-boot-1.1.2/common/Makefile	2004-12-16 18:35:57.000000000 +0100
+++ u-boot-1.1.2-neon/common/Makefile	2007-08-11 21:07:20.000000000 +0200
@@ -35,16 +35,16 @@
 	  cmd_eeprom.o cmd_elf.o cmd_ext2.o \
 	  cmd_fat.o cmd_fdc.o cmd_fdos.o cmd_flash.o cmd_fpga.o \
 	  cmd_i2c.o cmd_ide.o cmd_immap.o cmd_itest.o cmd_jffs2.o \
-	  cmd_load.o cmd_log.o \
+	  cmd_lcdpanel.o cmd_load.o cmd_log.o \
 	  cmd_mem.o cmd_mii.o cmd_misc.o cmd_mmc.o \
-	  cmd_nand.o cmd_net.o cmd_nvedit.o \
+	  cmd_nand.o cmd_net.o cmd_not.o cmd_nvedit.o \
 	  cmd_pci.o cmd_pcmcia.o cmd_portio.o \
 	  cmd_reginfo.o cmd_reiser.o cmd_scsi.o cmd_spi.o cmd_universe.o cmd_usb.o cmd_vfd.o \
 	  command.o console.o devices.o dlmalloc.o docecc.o \
 	  environment.o env_common.o \
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o env_nvram.o env_nowhere.o exports.o \
-	  flash.o fpga.o \
-	  hush.o kgdb.o lcd.o lists.o lynxkdi.o \
+	  flash.o fnmatch.o fpga.o \
+	  hush.o kgdb.o lcd.o lcd_panels.o lists.o lynxkdi.o \
 	  memsize.o miiphybb.o miiphyutil.o \
 	  s_record.o serial.o soft_i2c.o soft_spi.o spartan2.o \
 	  usb.o usb_kbd.o usb_storage.o \
diff -u -r --new-file u-boot-1.1.2/config.mk u-boot-1.1.2-neon/config.mk
--- u-boot-1.1.2/config.mk	2004-10-10 00:21:30.000000000 +0200
+++ u-boot-1.1.2-neon/config.mk	2007-08-11 21:07:20.000000000 +0200
@@ -22,6 +22,7 @@
 #
 
 #########################################################################
+sinclude select.mk	# include DISPLAY_TYPE, HARDWARE_TYPE, SOFTWARE_TYPE, INCLUDE_MINIDEBUG
 
 # clean the slate ...
 PLATFORM_RELFLAGS =
@@ -106,11 +107,15 @@
 OPTFLAGS= -Os #-fomit-frame-pointer
 ifndef LDSCRIPT
 #LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug
+ifeq ($(INCLUDE_MINIDEBUG),y)
+LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-bootmini.lds
+else
 LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds
 endif
+endif
 OBJCFLAGS += --gap-fill=0xff
 
-gccincdir := $(shell $(CC) -print-file-name=include)
+gccincdir := "$(shell $(CC) -print-file-name=include)"
 
 CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)		\
 	-D__KERNEL__ -DTEXT_BASE=$(TEXT_BASE)		\
@@ -170,11 +175,19 @@
 
 #########################################################################
 
+ifdef LISTINGS
+%.s:	%.S
+	$(CPP) $(AFLAGS) -Wa,-alh=$(basename $<).lst -o $@ $(CURDIR)/$<
+%.o:	%.S
+	$(CC) $(AFLAGS) -c -Wa,-alh=$(basename $<).lst -o $@ $(CURDIR)/$<
+%.o:	%.c
+	$(CC) $(CFLAGS) -c -Wa,-alh=$(basename $<).lst -o $@ $<
+else
 %.s:	%.S
 	$(CPP) $(AFLAGS) -o $@ $(CURDIR)/$<
 %.o:	%.S
 	$(CC) $(AFLAGS) -c -o $@ $(CURDIR)/$<
 %.o:	%.c
 	$(CC) $(CFLAGS) -c -o $@ $<
-
+endif
 #########################################################################
diff -u -r --new-file u-boot-1.1.2/Configure u-boot-1.1.2-neon/Configure
--- u-boot-1.1.2/Configure	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/Configure	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,170 @@
+#!/bin/bash
+#=======================================================================
+DISPLAY_TYPE_CHOICES="DA640X240 DA320X240 DA800X480 DA640X480 DA240X320 DA800X600 DA1024X768 DP320X240 DP480X320 DL122X32"
+PLATFORM_TYPE_CHOICES="NEONB NEON HALOGEN BD2003 GAME_WITH_SMC GAME_CONTROLLER"
+# BOUNDARY_OLD_BOARD  #lcd pin reordering for rgb problem, don't use VLIO(gp18 is turnstile)
+# OLD_GAME_CONTROLLER GAME_CONTROLLER_PLAITED_A1 
+REVISION_CHOICES="1 2"
+
+SOFTWARE_TYPE_CHOICES="WINCE LINUX GAME"
+INCLUDE_MINIDEBUG_CHOICES="y n"
+CPU_CLOCK_CHOICES="100 200 300 400"
+CPU_CLOCK_PXA270_CHOICES="104 208 312 416 520 624"
+
+CONFIG_H=include/configs/select.h
+CONFIG_MK=select.mk
+CONFIG_LOG=select.log
+
+fail ()
+{
+    echo ""
+    echo "Configuration failed."
+    echo ""
+    exit 1
+}
+
+if [ -f $CONFIG_MK ] ; then
+. ./$CONFIG_LOG
+fi
+
+
+
+#=======================================================================
+
+
+arg () {
+    VALUE="`echo X"$2" | sed -e 's/^X--[a-zA-Z_]*=//'`"
+    eval $1=\"$VALUE\"
+	eval $1_P='y'
+}
+
+usage () {
+    echo "bad parameters"
+    exit 1
+}
+
+while [ $# -gt 0 ] ; do
+    case "$1" in
+    --DISPLAY_TYPE=*)		arg DISPLAY_TYPE $1 		;;
+    --PLATFORM_TYPE=*)		arg PLATFORM_TYPE $1		;;
+    --SOFTWARE_TYPE=*)		arg SOFTWARE_TYPE $1		;;
+    --INCLUDE_MINIDEBUG=*)	arg INCLUDE_MINIDEBUG $1	;;
+    --CPU_CLOCK=*)			arg CPU_CLOCK $1			;;
+    *)			usage			;;
+    esac
+    shift
+done
+
+#=======================================================================
+
+write_str () {
+    value=`eval echo '$'$1`
+    echo "$1=$value" >> $CONFIG_MK
+    echo "$1=\"$value\"" >> $CONFIG_LOG
+    if [ x$3 != x ] ; then
+		choices=`eval echo '$'$2`
+		str=""
+		for a in $choices ; do
+			if [ -n "$str" ] ; then str="$str && " ; fi
+			str="$str!defined($3$a)";
+		done
+    	echo "#if $str" >> $CONFIG_H
+	    echo "#define $3$value" >> $CONFIG_H
+		echo "#endif" >> $CONFIG_H
+	else
+		echo "#ifndef $1" >> $CONFIG_H
+	    echo "#define $1 $value" >> $CONFIG_H
+		echo "#endif" >> $CONFIG_H
+	fi
+}
+
+prompt () {
+    eval $3=\"$2\"
+	/bin/echo -e "$1 [$2]: \c"
+	read tmp
+	if [ -n "$tmp" ] ; then eval $3=\"$tmp\" ; fi
+	if [ ! -t 1 ] ; then echo $3 ; fi
+}
+noprompt () {
+    eval $3=\"$2\"
+	/bin/echo -e "$1 [$2]: "
+	if [ ! -t 1 ] ; then echo $3 ; fi
+}
+
+
+ask_str () {
+	choices=`eval echo '$'$3`
+	default=`eval echo '$'$2`
+	ppp=`eval echo '$'$2_P`
+	ans=""
+	stop="0"
+	if [ x$ppp = x"y" ] ; then
+		noprompt "$1 ($choices)" "$default" answer
+		for a in $choices ; do
+			if [ x$a = x$answer ] ; then ans=$a; stop="1"; break; fi;
+		done
+		if [ $stop != "1" ] ; then default=""; fi;
+	fi
+	while [ $stop != "1" ] ; do
+		prompt "$1 ($choices)" "$default" answer
+		for a in $choices ; do
+			if [ x$a = x$answer ] ; then ans=$a; stop="1"; break; fi;
+		done
+	done
+	eval $2=\"$ans\"
+}
+#=======================================================================
+
+echo ""
+echo "    -------- U-Boot Boundary Devices Specific Configuration Script --------"
+echo ""
+echo ""
+
+ask_str "Choose display type" DISPLAY_TYPE DISPLAY_TYPE_CHOICES
+ask_str "Choose hardware type" PLATFORM_TYPE PLATFORM_TYPE_CHOICES
+	if [ x$PLATFORM_TYPE = xHALOGEN ] ; then
+ask_str "Choose hardware revision" PLATFORM_REV REVISION_CHOICES
+	fi
+ask_str "Choose software type" SOFTWARE_TYPE SOFTWARE_TYPE_CHOICES
+ask_str "Include minidebug" INCLUDE_MINIDEBUG INCLUDE_MINIDEBUG_CHOICES
+
+	if [ x$PLATFORM_TYPE = xHALOGEN ] ; then
+ask_str "CPU clock" CPU_CLOCK CPU_CLOCK_PXA270_CHOICES
+	else
+ask_str "CPU clock" CPU_CLOCK CPU_CLOCK_CHOICES
+	fi
+
+rm -f $CONFIG_H $CONFIG_MK
+
+cat << 'EOF' > $CONFIG_H
+/*
+  Automatically generated by 'make xxx_config' -- don't edit!
+*/
+#include <asm/arch/platformTypes.h>
+EOF
+
+cat << 'EOF' > $CONFIG_MK
+#
+# Automatically generated by 'make xxx_config' -- don't edit!
+#
+EOF
+
+cat << 'EOF' > $CONFIG_LOG
+#!/bin/bash
+EOF
+
+chmod 777 $CONFIG_LOG
+
+write_str DISPLAY_TYPE DISPLAY_TYPE_CHOICES
+write_str PLATFORM_TYPE PLATFORM_TYPE_CHOICES
+	if [ x$PLATFORM_TYPE = xHALOGEN ] ; then
+write_str PLATFORM_REV REVISION_CHOICES
+	fi
+write_str SOFTWARE_TYPE SOFTWARE_TYPE_CHOICES
+write_str INCLUDE_MINIDEBUG INCLUDE_MINIDEBUG_CHOICES
+	if [ x$PLATFORM_TYPE = xHALOGEN ] ; then
+write_str CPU_CLOCK CPU_CLOCK_PXA270_CHOICES
+	else
+write_str CPU_CLOCK CPU_CLOCK_CHOICES
+	fi
+echo "Configuration successful."
diff -u -r --new-file u-boot-1.1.2/cpu/mpc8xx/lcd.c u-boot-1.1.2-neon/cpu/mpc8xx/lcd.c
--- u-boot-1.1.2/cpu/mpc8xx/lcd.c	2004-10-10 01:26:00.000000000 +0200
+++ u-boot-1.1.2-neon/cpu/mpc8xx/lcd.c	2007-08-11 21:07:20.000000000 +0200
@@ -255,7 +255,6 @@
 /*----------------------------------------------------------------------*/
 
 
-int lcd_line_length;
 
 int lcd_color_fg;
 int lcd_color_bg;
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/config.mk u-boot-1.1.2-neon/cpu/pxa/config.mk
--- u-boot-1.1.2/cpu/pxa/config.mk	2003-05-23 14:36:21.000000000 +0200
+++ u-boot-1.1.2-neon/cpu/pxa/config.mk	2007-08-11 21:15:47.000000000 +0200
@@ -21,8 +21,19 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 # MA 02111-1307 USA
 #
-
-PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
-	-mshort-load-bytes -msoft-float
-
-PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4 -mtune=strongarm1100
++sinclude ../../select.mk       # include DISPLAY_TYPE, HARDWARE_TYPE, SOFTWARE_TYPE, INCLUDE_MINIDEBUG
++
++PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8
++PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4
++GCC_MAJOR    := $(shell $(CC) -v 2>&1 | grep version | cut -d' ' -f3  | cut -d'.' -f1)
++GCC_MINOR    := $(shell $(CC) -v 2>&1 | grep version | cut -d' ' -f3  | cut -d'.' -f2)
++
++ifneq ($(GCC_MAJOR),3)
++   PLATFORM_CPPFLAGS += -mtune=strongarm1100
++   PLATFORM_RELFLAGS += -msoft-float
++else
++   PLATFORM_CPPFLAGS += -mtune=xscale
++   ifneq ($(GCC_MINOR),4)
++      PLATFORM_RELFLAGS += -msoft-float
++   endif
++endif
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/cpu.c u-boot-1.1.2-neon/cpu/pxa/cpu.c
--- u-boot-1.1.2/cpu/pxa/cpu.c	2004-02-08 20:38:44.000000000 +0100
+++ u-boot-1.1.2-neon/cpu/pxa/cpu.c	2007-08-11 21:07:20.000000000 +0200
@@ -33,6 +33,7 @@
 #include <common.h>
 #include <command.h>
 #include <asm/arch/pxa-regs.h>
+#include <asm/arch/mmc.h>
 
 int cpu_init (void)
 {
@@ -59,8 +60,12 @@
 
 	unsigned long i;
 
+   MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	
 	disable_interrupts ();
 
+   dcache_disable();
+	
 	/* turn off I-cache */
 	asm ("mrc p15, 0, %0, c1, c0, 0":"=r" (i));
 	i &= ~0x1000;
@@ -129,21 +134,6 @@
 	return (i & 0x1000);
 }
 
-/* we will never enable dcache, because we have to setup MMU first */
-void dcache_enable (void)
-{
-	return;
-}
-
-void dcache_disable (void)
-{
-	return;
-}
-
-int dcache_status (void)
-{
-	return 0;					/* always off */
-}
 
 void set_GPIO_mode(int gpio_mode)
 {
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/Makefile u-boot-1.1.2-neon/cpu/pxa/Makefile
--- u-boot-1.1.2/cpu/pxa/Makefile	2003-06-16 00:40:43.000000000 +0200
+++ u-boot-1.1.2-neon/cpu/pxa/Makefile	2007-08-11 21:07:20.000000000 +0200
@@ -23,10 +23,45 @@
 
 include $(TOPDIR)/config.mk
 
+CPU_TYPE=xscale
+
+ifeq ($(SOFTWARE_TYPE),WINCE)
+STACKS_VALID = -DCONFIG_STACKS_VALID
+else
+
+ifeq ($(SOFTWARE_TYPE),GAME)
+STACKS_VALID = -DCONFIG_STACKS_VALID
+else
+STACKS_VALID =
+endif
+endif
+ARM_ELF_GCC     ?= arm-elf-gcc
+
 LIB	= lib$(CPU).a
 
-START	= start.o
-OBJS	= serial.o interrupts.o cpu.o i2c.o pxafb.o mmc.o
+ifeq ($(INCLUDE_MINIDEBUG),y)
+START	= minidebug.o ministart.o
+else
+START	= start.o ministart.o
+endif
+OBJS	= serial.o interrupts.o cpu.o i2c.o mmc.o
+
+ifdef PXALCD
+   OBJS	+= pxafb.o
+endif
+
+ifeq ($(PLATFORM_TYPE),HALOGEN)
+   OBJS	+= usb_ohci.o
+else
+ifeq ($(PLATFORM_TYPE),NEON)
+   OBJS	+= usb_ohci.o
+else
+ifeq ($(PLATFORM_TYPE),NEONB)
+   OBJS	+= usb_ohci.o
+else
+endif
+endif
+endif
 
 all:	.depend $(START) $(LIB)
 
@@ -35,9 +70,13 @@
 
 #########################################################################
 
-.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+.depend:	Makefile $(START) $(OBJS)
+		$(CC) -M $(CFLAGS) -DUBOOT=1 $(START:.o=.S) $(OBJS:.o=.c) > $@
 
 sinclude .depend
 
+minidebug.o : minidebug.S Makefile
+	$(ARM_ELF_GCC) -c $(D_GNUC) -DUBOOT=1 -DDISPLAY_TYPE=$(DISPLAY_TYPE) -DPLATFORM_TYPE=$(PLATFORM_TYPE) -DPLATFORM_REV=$(PLATFORM_REV) -DSOFTWARE_TYPE=$(SOFTWARE_TYPE) $(STACKS_VALID) -DCPU_CLOCK=$(CPU_CLOCK) \
+		$(SOFT_FLOAT) -I$(TOPDIR)/include -mtune=$(CPU_TYPE) -mcpu=$(CPU_TYPE) -o $@ $<
+
 #########################################################################
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/minidebug.S u-boot-1.1.2-neon/cpu/pxa/minidebug.S
--- u-boot-1.1.2/cpu/pxa/minidebug.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/cpu/pxa/minidebug.S	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,3850 @@
+	.nolist
+	.ifdef __ARMASM
+UBOOT EQU 0
+CONFIG_UNSCRAMBLE_LCD EQU 0
+LCD_REORDER_BLUE EQU 1
+	.endif
+
+#ifdef UBOOT
+#include <asm/arch/platformTypes.h>
+#include <configs/select.h>
+#include <asm/arch/pxaGpio.h>
+#include <asm/arch/pxaMacro3.h>
+#include <asm/arch/miniMac.inc>
+#include <asm/arch/burn.inc>
+#else
+#include "platformTypes.h"
+#include "pxaGpio.h"
+#include "pxaMacro3.h"
+#include "miniMac.inc"
+#include "burn.inc"
+	.ifdef __ARMASM
+	STARTUPTEXT
+	EXTERN HeadStart
+	.endif
+#endif
+
+	.list
+	.global StartUp
+
+
+#define L1(a)          ((CH_##a))
+#define L2(a,b)     ((CH_##a)+(CH_##b<<8))
+#define L3(a,b,c)   ((CH_##a)+(CH_##b<<8)+(CH_##c<<16))
+#define L4(a,b,c,d) ((CH_##a)+(CH_##b<<8)+(CH_##c<<16)+(CH_##d<<24))
+
+#define C2(a,b)     ((CH_##a<<8)+(CH_##b))
+#define C3(a,b,c)   ((CH_##a<<16)+(CH_##b<<8)+(CH_##c))
+#define C4(a,b,c,d) ((CH_##a<<24)+(CH_##b<<16)+(CH_##c<<8)+(CH_##d))
+
+// *******************************************************************************************
+// *******************************************************************************************
+
+
+//.global _start
+//_start:
+StartUp:
+	b	V_Reset			//0
+	b	V_UndefinedInstr	//4
+	b	V_SWI			//8
+	b	V_PrefetchAbort		//0x0c
+	b	V_DataAbort		//0x10
+	b	V_Unused		//0x14, not used
+	b	V_IRQ			//0x18
+//	b	V_FIQ			//0x1c
+
+//In Linux, all modes switch almost immediately to the SVC mode
+//and it is the only one with a valid stack
+//FIQ & SWI stacks are always assumed valid
+V_FIQ:
+	V_VectorEntrance V_rWork,V_rBranch,SIG_FIQ
+
+join_fiq:
+	CheckBranch V_rWork,V_rBranch
+	V_VectorExitCC V_rWork,V_rBranch,eq,eqia
+	CheckLdr  V_rWork,V_rBranch
+	V_VectorExitCC1 V_rWork,V_rBranch,cc,ccia
+join_fiq2:
+	sub	sp,sp,#(DEBUG_SPACE-DBG_R0)		//the extra 12 bytes already on stack are needed for indirect return for SDS bug
+	stmia	sp,{r0,r1}
+	sub	r1,V_rBranch,#8		//restore to SIG_xxx value
+	add	r0,sp,#(DEBUG_SPACE-DBG_R0)
+	ldr	V_rWork,[r0],#4
+	ldr	V_rBranch,[r0],#8
+	str	r0,[sp,#DBG_HSP-DBG_R0]
+	sub	r0,sp,#DBG_R0
+join_fiq3:
+	mov	r1,r1,LSR #2
+	and	r1,r1,#0xf
+	b	SaveRest2
+V_Reset:
+//this is either a normal processor reset, or a debug exception in halt mode
+	mrs	sp,cpsr
+	and	sp,sp,#0x1f
+	cmp	sp,#0x15
+	bne	2f
+//this is a debug exception in halt mode
+	CP14_DCSR mrc,sp
+	and	sp,sp,#0x1c
+	cmp	sp,#0		//reset
+	cmpne	sp,#5<<2	//vector trap (reset vector)
+	bne	10f		//initialization already done
+
+	BigMov	sp,PWR_MANAGER_BASE
+	ldr	sp,[sp,#RCSR]
+	tst	sp,#2
+	tsteq	pc,#0xff000000
+	bne	2f		//br if watchdog reset or if not nCS0 address
+
+//signal debugger that he can download into main instruction cache now
+	CP14_TX mcr,sp
+1:
+	CP14_TXRXCTRL mrc,r15	//r15 means update condition codes
+	bpl	1b
+	CP14_RX mrc,sp		//just read and discard
+2:
+	CP14_DCSR mrc,sp
+	orr	sp,sp,#1<<31		//set global debug enable bit
+	CP14_DCSR mcr,sp
+
+//	InitGPIO r0,sp
+//	InitIC_Clocks r0,sp
+//	InitUART r0,sp,UART_BASE,BAUDRATE
+//	TransMacro L1(U)
+	b	MainInitializationCode	//this can be in the main instruction cache not locked
+					//because it is only executed upon reset
+
+10:
+	cmp	sp,#1<<2		//Instruction breakpoint
+	mov	sp,r0			//save r0
+	BigMov	r0,DEBUG_BASE
+	str	sp,[r0,#DBG_R0]
+	str	r1,[r0,#DBG_R1]
+	str	r2,[r0,#DBG_R2]
+SSDebug:
+	bne	11f
+//this is a breakpoint
+	ldr	r1,[r0,#DBG_TRACE]
+	tst	r1,#1
+	beq	11f
+	cmn	r1,#1
+	moveq	r1,#0
+	CP15_IBCR1 mrc,sp
+	sub	r2,lr,#3
+	cmp	sp,r2
+	CP15_IBCR1 mcreq,r1		//remove breakpoint if single-stepping
+	beq	11f
+	CP15_IBCR0 mrc,sp
+	cmp	sp,r2
+	CP15_IBCR0 mcreq,r1
+11:
+	mrs	r2,spsr
+	sub	lr,lr,#4
+
+	str	r3,[r0,#DBG_R3]
+	ldrb	r3,[r0,#DBG_Mode]
+SaveDebug:
+	CP14_DCSR mrc,sp
+//	str	sp,[r0,#DBG_Temp]	//the mcr CP14_DCSR instruction below will trash sp in SDS (special debug state)
+	and	r1,sp,#0x1c
+	orr	sp,sp,#0x1c
+	CP14_DCSR mcr,sp
+	mov	r1,r1,LSR #2
+	add	r1,r1,#SIG_DBG
+	b	SaveR4andUp
+
+V_UndefinedInstr:
+	VectorEntrance rWork,rBranch,SIG_UNDEFINED_INSTRUCTION
+	JOIN b
+V_IRQ:
+	VectorEntrance rWork,rBranch,SIG_IRQ
+
+	.if STACKS_VALID
+	JOIN b
+	.else
+join_irq:
+	CheckBranch I_rWork,I_rBranch
+	I_VectorExitCC I_rWork,I_rBranch,eq,eqia
+
+	CheckLdr  I_rWork,I_rBranch
+	I_VectorExitCC1 I_rWork,I_rBranch,cc,ccia
+join_irq2:
+	strd	r0,[I_rWork,#DBG_R0-DBG_MAGIC]
+	sub	r0,I_rWork,#DBG_MAGIC
+	sub	r1,I_rBranch,#8		//restore to SIG_xxx value
+	ldr	I_rWork,[r0,#DBG_TEMP]
+	add	sp,r0,#DBG_INDIRECT_R0+8	//sp is trashed, if stacks assumed invalid
+	str	sp,[r0,#DBG_HSP]
+	b	join_fiq3
+	.endif
+
+//sp is valid for this!!!!!, what a treat
+V_SWI:
+	V_VectorEntrance V_rWork,V_rBranch,SIG_SWI
+	b	join_fiq
+
+//monitor mode also has instruction breakpoint, bkpt instruction
+V_PrefetchAbort:
+	VectorEntrance rWork,rBranch,SIG_PREFETCH_ABORT
+	CP15_FSR mrc,rWork
+	tst	rWork,#1<<9
+	bne	DEBUG_EVENT		//br if a debug event, in monitor mode
+
+//the 1st instruction after exiting special debug state can cause an abort or possibly the wrong instruction to execute.
+//the Immu is not turned on until the 2nd instruction.
+	tst	rWork,#1<<10
+	JOIN beq
+	and	rWork,rWork,#0xf
+	cmp	rWork,#0x6
+	JOIN bne		//br if not an external abort
+
+	CP15_CONTROL mrc,rWork	//get the control register
+	tst	rWork,#1		//test MMU
+
+	BigMov	rWork,DEBUG_BASE+DBG_ABORT_PC
+	swpne	rWork,lr,[rWork]	//save lr as a flag so not infinite errors, if mmu on
+	cmpne	rWork,lr
+
+	.if STACKS_VALID
+	ldrne	rBranch,[sp,#4]
+	ldrne	rWork,[sp],#12
+	subnes	pc,lr,#4		//retry access
+	.else
+	BigMov	rWork,DEBUG_BASE+DBG_MAGIC
+	ldrne	rWork,[rWork,#DBG_TEMP-DBG_MAGIC]
+	subnes	pc,lr,#4		//retry access
+	.endif
+
+	add	rBranch,rBranch,#8
+	JOIN2 b
+
+//stacks aren't kept valid
+//monitor mode also has data breakpoint, external debug break, trace-buffer full break
+V_DataAbort:
+	VectorEntrance rWork,rBranch,SIG_DATA_ABORT
+	CP15_FSR mrc,rWork
+	tst	rWork,#1<<9
+	JOIN beq
+	sub	lr,lr,#4		//+8 of offending instruction for most data aborts instead of +4
+DEBUG_EVENT:
+	BigMov	rWork,DEBUG_BASE+DBG_MAGIC
+	strd	r0,[rWork,#DBG_R0-DBG_MAGIC]
+	sub	r0,rWork,#DBG_MAGIC
+
+	.if STACKS_VALID
+	ldr	rWork,[sp],#4
+	ldr	rBranch,[sp],#8
+	.else
+	ldr	rWork,[r0,#DBG_TEMP]
+	add	sp,r0,#DBG_INDIRECT_R0+8	//sp is trashed, if stacks assumed invalid
+	.endif
+	str	sp,[r0,#DBG_HSP]
+	CP14_DCSR mrc,sp
+	and	sp,sp,#0x1c
+	cmp	sp,#1<<2		//Instruction breakpoint
+	str	r2,[r0,#DBG_R2]
+	b	SSDebug
+
+V_Unused:
+	mov	sp,r0			//save r0
+	BigMov	r0,DEBUG_BASE
+	str	sp,[r0,#DBG_R0]
+	str	r1,[r0,#DBG_R1]
+	mov	r1,#SIG_UNUSED
+//	b	SaveRest2
+
+//r0 - debug storage
+//r1 - reason for getting here
+SaveRest2:
+	str	r2,[r0,#DBG_R2]
+	sub	lr,lr,#4
+	mrs	r2,spsr
+	str	r3,[r0,#DBG_R3]
+	ldrb	r3,[r0,#DBG_Mode]
+//r2 - spsr
+//r3 - DBG_MODE - don't assume that ram is working upon reset
+SaveR4andUp:
+	str	r4,[r0,#DBG_R4]
+	str	lr,[r0,#DBG_PC]	//return PC
+	str	r2,[r0,#DBG_CPSR]	//return CPSR
+	mrs	r4,cpsr
+	str	r4,[r0,#DBG_HCPSR]	//mode to return to before exception return
+
+	tst	r2,#0xf
+	orreq	r2,r2,#0xdf		//if user mode, switch to system mode to access user registers, set I, F
+	orrne	r2,r2,#0xc0		//set I, F
+	msr	cpsr_c,r2
+
+	add	r2,r0,#DBG_R5
+	stmia	r2,{r5,r6,r7,r8,r9,sl,fp,ip,sp,lr}
+// **********************************
+// **********************************
+
+	mov	rDBG,r0
+	mov	r6,r1			//reason
+	mov	r5,r3			//DBG_MODE
+	strb	r2,[rDBG,#DBG_LastSignal]
+	CP15_CONTROL mrc,r1		//get the control register
+	tst	r1,#1
+	BigMov	rUart,UART_BASE		//this is right if MMU is off
+	blne GetUartAddress			//if MMU is on
+	b	gdb_lastSignal1
+
+//r1 - CP15_CONTROL(r1)
+GetUartAddress:
+	tst	r1,#1<<13		//assume 1:1 mapping for TTBR if relocation vector is off
+// see if identity mapping is enabled
+	CP15_TTBR mrc,r1
+//  using Big will generate no instructions if Wince, throwing off my reloc vector
+//	BigAdd2Ne r1,(SDRAM_BASE_C_VIRTUAL-0xA0000000)
+	addne	r1,r1,#(SDRAM_BASE_C_VIRTUAL-0xA0000000)	//convert this physical address to a virtual address if relocation vector ON
+
+	ldr	r2,[r1,rUart,lsr #18]
+	sub	r2,r2,rUart
+	cmp	r2,#1<<20
+	movcc	pc,lr				//identity mapping on
+
+	mov	r3,rUart
+	BigMov	rUart,UART_VIRT_BASE
+1:	ldr	r2,[r1,rUart,lsr #18]
+	tst	r2,#3
+	beq	2f
+	sub	r2,r2,r3
+	cmp	r2,#1<<20
+	movcc	pc,lr				//br if found virtual address
+	adds	rUart,rUart,#1<<20
+	moveq	rUart,#0xE0000000
+	b	1b
+2:
+	BigOrr2	r3,0xc02
+	str	r3,[r1,rUart,lsr #18]	//steal this unused entry
+//	b	cache_clean_invalidate_all
+
+cache_clean_invalidate_all:
+//flush data cache, if data cache is enabled
+	CP15_CONTROL mrc,r0		//get the control register
+	tst	r0,#4
+	moveq	pc,lr				//return if disabled
+
+// Set baseaddress as the 1st virtual address of a 32k range used only
+// to flush the data cache. baseaddress should be aligned on a 32 byte(cache-line) boundary.
+// If the virtual range beginning with baseaddress is used for any purpos other than flushing
+// the data cache, then cachelinecount must be doubled from 1024  to 2048
+	mov	r1,#cachelinecount
+	ldr	r0,[rDBG,#DBG_PC]	//I hope my return address is mapped
+	BigBic2	r0,0xffff
+1:
+	CP15_CF_ALLOC_LINE mcr,r0	//allocate a cache line for r0
+	add	r0,r0,#cachelinesize
+	subs	r1,r1,#1
+	bne	1b
+
+//	teq	r2, #0			// if running only from cache, an invalidate could be fatal if not done from minicache
+						// and then, a return to caller would not be allowed, so invalidate is postponed
+//	CP15_CF_INVAL_I mcrne,r0
+	CP15_CF_DRAIN mcr,r0
+	CP15_CF_INVAL_D mcr,r0
+// The instruction cache is guaranteed to be invalidated at this point. The
+// next instruction sees the result of the invalidate command.
+	mov	pc,lr
+
+
+//r0 - value to printm r9 - chksum
+PrintHexEndian:
+#if LITTLE_ENDIAN
+	mov	r2,#8
+1:	mov	r4,r0
+	mov	r3,lr
+2:	tst	r2,#1
+	moveq	r0,r4,LSR #4
+	andne	r0,r4,#0xf
+	andeq	r0,r0,#0xf
+	movne	r4,r4,ROR #8
+	cmp	r0,#0xA
+	addcs	r0,r0,#L1(a)-0x0a
+	addcc	r0,r0,#L1(0)
+	add	r9,r9,r0
+	bl	Transmit
+	subs	r2,r2,#1
+	bne	2b
+	mov	pc,r3
+
+PrintHexByteEndian:
+	mov	r2,#2
+	b	1b
+#else
+	mov	r2,#8
+	mov	r4,r0
+1:	mov	r3,lr
+2:	mov	r4,r4,ROR #28
+	and	r0,r4,#0xf
+	cmp	r0,#0xA
+	addcs	r0,r0,#L1(a)-0x0a
+	addcc	r0,r0,#L1(0)
+	add	r9,r9,r0
+	bl	Transmit
+	subs	r2,r2,#1
+	bne	2b
+	mov	pc,r3
+PrintHexByteEndian:
+	mov	r4,r0,LSL #24
+	mov	r2,#2
+	b	1b
+#endif
+
+PrintHexByte:
+	mov	r4,r0,LSL #24
+	mov	r2,#2
+	b	PrintHex1
+
+TransmitCRLF:
+	BigMov	r0,L2(CR,LF)
+	b	Transmit
+
+
+	.if STACKS_VALID
+	.else
+// *******************************************************
+	RelocationVector 0
+// *******************************************************
+	.endif
+
+
+//IN: r0 - value to print
+//OUT: r0-r4 trashed
+PrintHex:
+	mov	r2,#8
+	mov	r4,r0
+PrintHex1:
+	mov	r3,lr
+1:	mov	r4,r4,ROR #28
+	and	r0,r4,#0xf
+	cmp	r0,#0xA
+	addcs	r0,r0,#L1(A)-0x0a
+	addcc	r0,r0,#L1(0)
+	bl	Transmit
+	subs	r2,r2,#1
+	bne	1b
+	mov	pc,r3
+
+
+TransmitSPACE:
+	mov	r0,#L1(SPACE)
+//	b Transmit
+
+//IN: r0 - character to transmit
+//OUT: r0 - last character transmitted, r1 - trashed
+Transmit1:
+Transmit:
+1:	ldr	r1,[rUart,#UART_LSR]
+	ands	r1,r1,#0x20
+	beq	1b
+	mov	r1,r0
+	and	r1,r1,#0xff
+	str	r1,[rUart,#UART_THR]
+	movs	r1,r0,LSR #8
+	movne	r0,r1
+	bne	1b
+	mov	pc,lr			//return
+
+TransmitChkSum:
+	add	r9,r9,r0
+	b	Transmit
+
+	.if STACKS_VALID
+// *******************************************************
+	RelocationVector 2
+// *******************************************************
+	.endif
+
+//OUT:
+//z-0 good data in r0
+//z-1 timeout, r0 is 0
+//r1 - loop cnt time remaining
+Receive:
+	mov	r1,#RECEIVE_LOOP_COUNT
+Receive1:
+1:	ldr	r0,[rUart,#UART_LSR]
+	ands	r0,r0,#0x1
+	ldrne	r0,[rUart,#UART_RBR]
+	movne	pc,lr			//return
+
+	subs	r1,r1,#1
+	bne	1b
+	mov	pc,lr			//return
+
+
+
+
+//IN: r2 - symbol #
+//OUT: r1:r0 - value,
+GetRegVal:
+	cmp	r2,#SYM_FP0
+	bcs	GetSpecialReg
+#if DBG_R0
+	add	r1,rDBG,#DBG_R0
+	ldr	r0,[r1,r2,LSL #2]
+#else
+	ldr	r0,[rDBG,r2,LSL #2]
+#endif
+	mov	r1,#0
+	mov	pc,lr
+
+// ********************************************************************
+// ********************************************************************
+// ********************************************************************
+
+
+gdb_lastSignal:
+	ldrb	r6,[rDBG,#DBG_LastSignal]
+	ldrb	r5,[rDBG,#DBG_Mode]
+gdb_lastSignal1:
+	ldr	r0,[rUart,#UART_LCR]
+	strb	r0,[rDBG,#DBG_FFUART_LCR]
+	bic	r0,r0,#0x80			//make sure DLAB is clear
+	str	r0,[rUart,#UART_LCR]
+
+
+1:	mov	r9,#0			//chksum
+	mov	r0,#L1(DOLLAR)
+	bl	Transmit
+//	mov	r0,#L1(T)
+	mov	r0,#L1(S)
+	bl	TransmitChkSum
+	mov	r0,r6
+	bl	PrintHexByteEndian
+//	mov	r0,#L1(F)
+//	bl	TransmitChkSum
+//	mov	r0,#L1(COLON)
+//	bl	TransmitChkSum
+//	mov	r2,#SYM_PC
+//	bl	GetRegVal
+//	bl	PrintHexEndian
+
+	mov	r0,#L1(POUND)
+	bl	Transmit
+	and	r0,r9,#0xff
+	bl	PrintHexByteEndian
+	mov	r3,#0
+	mov	r1,#RECEIVE_LOOP_COUNT
+10:
+	bl	Receive1		//z-0 good data in r0, z-1 timeout, r0 is 0
+	moveq rNum1,#0
+	beq	12f		//br if timeout
+	cmpne	r6,#SIG_RESET 		//disable cr abort on power up
+//	beq	10b		//uncomment to stop <cr> from stopping
+	
+	cmp	r0,#L1(PLUS)
+	beq	WaitForDollarSign
+	cmp	r0,#L1(DOLLAR)
+	beq	ReadGDB
+	
+	cmp	r0,#L1(MINUS)
+	beq	1b
+	tst	r5,#1
+	cmpeq	r0,#GDB_EXIT_CHAR
+	bne	10b		//br if in GDB mode or NOT <cr>
+	mov	rNum1,#1
+
+//r6 -SIG_xxx
+12:
+	bl	TransmitCRLF
+	cmp	r6,#SIG_DBG
+	BigMov	r0,L4(D,B,G,MINUS)
+	blcs	Transmit1
+
+	mov	r2,#0
+	mov	r3,#0
+	mov	r4,#0
+	cmp	r6,#SIG_RESET
+	cmpne	r6,#SIG_DBG_RESET
+	BigMovEq r0,L4(R,e,s,e)
+	BigMovEq r2,L1(t)
+	cmp	r6,#SIG_UNDEFINED_INSTRUCTION
+	BigMovEq r0,L4(U,n,d,e)
+	BigMovEq r2,L1(f)
+//	BigMovEq r3,L1(d)
+	cmp	r6,#SIG_SWI
+	BigMovEq r0,L3(S,w,i)
+	cmp	r6,#SIG_PREFETCH_ABORT
+	BigMovEq r0,L4(P,r,e,f)
+	BigMovEq r2,L4(e,t,c,h)
+	cmp	r6,#SIG_DATA_ABORT
+	BigMovEq r0,L4(D,a,t,a)
+	cmpne	r6,#SIG_PREFETCH_ABORT
+	BigMovEq r3,L4(SPACE,A,b,o)
+	BigMovEq r4,L2(r,t)
+	cmp	r6,#SIG_UNUSED
+	BigMovEq r0,L4(U,n,u,s)
+	BigMovEq r2,L2(e,d)
+	cmp	r6,#SIG_IRQ
+	BigMovEq r0,L3(I,r,q)
+	cmp	r6,#SIG_FIQ
+	BigMovEq r0,L3(F,i,q)
+	cmp	r6,#SIG_DBG_INSTRUCTION_BKPT
+	BigMovEq r0,L4(I,n,s,t)
+	BigMovEq r2,L4(SPACE,B,r,k)
+	cmp	r6,#SIG_DBG_DATA_BKPT
+	BigMovEq r0,L4(D,a,t,a)
+	BigMovEq r2,L4(SPACE,B,r,k)
+	cmp	r6,#SIG_DBG_BKPT_SOFTWARE
+	BigMovEq r0,L4(B,k,p,t)
+	cmp	r6,#SIG_DBG_EXTERNAL
+	BigMovEq r0,L4(E,x,t,e)
+	BigMovEq r2,L4(r,n,a,l)
+	cmp	r6,#SIG_DBG_VECTOR_TRAP
+	BigMovEq r0,L4(V,e,c,t)
+	BigMovEq r2,L4(o,r,SPACE,T)
+	BigMovEq r3,L3(r,a,p)
+	cmp	r6,#SIG_DBG_TRACE_BUFFER_FULL
+	BigMovEq r0,L4(T,r,a,c)
+	BigMovEq r2,L4(e,SPACE,F,u)
+	BigMovEq r3,L2(l,l)
+	cmp	r6,#SIG_DBG_RESERVED
+	BigMovEq r0,L4(R,e,s,e)
+	BigMovEq r2,L4(r,v,e,d)
+
+	bl	Transmit1
+	movs	r0,r2
+	blne	Transmit1
+	movs	r0,r3
+	blne	Transmit1
+	movs	r0,r4
+	blne	Transmit1
+
+	bl	TransmitSPACE
+	mov	r2,#SYM_PC
+	bl	GetRegVal
+	bl	PrintHex
+//	bl	TransmitSPACE
+	bl	TransmitCRLF
+
+	rsbs	r0,pc,#0x800
+	BigMov	r0,FLASH_READ_CMD
+
+#if (PLATFORM_TYPE==NEONB)
+	BigMov	r1,VIRTUAL_CS1	//remember, although instruction fetches are physical, data are still virtual
+#else
+	BigMov	r1,VIRTUAL_CS0	//remember, although instruction fetches are physical, data are still virtual
+#endif
+	cmphs	rUart,#0x41000000
+	strhs	r0,[r1]		//if (pc is in minicache) & (rUart is in virtual memory) then
+				//make sure flash is in read mode, we are almost off the minicache
+
+#if (PLATFORM_TYPE==NEONB)
+	adr		lr,AfterPCPrint
+	add		r1,r1,lr		//virtual address of AfterPCPrint if in Linux for data fetch
+	cmp		lr,#0x800
+	BigOrr2Eq lr,FLASH_BASE_ADDRESS 		//if in low part of CS0 flash, try CS1 flash
+	BigMov	r0,0xe3a00055		//instruction mov	r0,#55
+	cmp		rUart,#0x41000000
+	movlo	r1,lr			//use physical address of AfterPCPrint for data fetch
+	ldr		r2,[r1]
+	cmp		r2,r0
+	moveq	pc,lr		//br if CS1 valid
+	b		AfterPCPrint_error
+#else
+	b		AfterPCPrint1
+#endif
+
+// ******************************************************************************************
+//A MAIN goal is for all the code above this point to fit into the 2k mini instruction cache
+//So that if difficult errors occur and the flash isn't functioning properly, we can
+//at least get the PC printed out before a crash.
+// ******************************************************************************************
+
+
+//IN: r2 - symbol #, z-1 if SYM_FP0
+//OUT: r1:r0 - value,
+GetSpecialReg:
+	bne	2f
+//MRA{<cond>} <RdLo>,<RdHi>,acc0
+	mra	r0,r1,acc0
+	mov	pc,lr
+
+	.if STACKS_VALID
+	.else
+//Must keep this aligned at 0x800 if Bal
+	mac_AfterPCPrint 1
+	.endif
+
+2:	cmp	r2,#SYM_FSR
+	CP15_FSR mrceq,r0
+	cmp	r2,#SYM_FAR
+	CP15_FAR mrceq,r0
+	cmp	r2,#SYM_DCSR
+	CP14_DCSR mrceq,r0
+	cmp	r2,#SYM_TTBR
+	CP15_TTBR mrceq,r0
+	cmp	r2,#SYM_CTRL
+	CP15_CONTROL mrceq,r0
+	mov	r1,#0
+	mov	pc,lr
+
+//out: c-1 means hex char, r0 - character read, r1 - 0:15 if r0 is a hex character
+ReadHex:
+1:	ldr	r0,[rUart,#UART_LSR]
+	ands	r0,r0,#0x1
+	ldrne	r0,[rUart,#UART_RBR]
+	beq	1b			//br on timeout
+	rsbs	r1,r0,#L1(9)	//reverse subtract
+	subcss	r1,r0,#L1(0)
+	movcs	pc,lr
+
+	rsbs	r1,r0,#L1(f)	//reverse subtract
+	subcss	r1,r0,#L1(a)
+	addcs	r1,r1,#10
+
+	movcs	pc,lr
+
+	rsbs	r1,r0,#L1(F)	//reverse subtract
+	subcss	r1,r0,#L1(A)
+	addcs	r1,r1,#10
+	mov	pc,lr
+
+	.if STACKS_VALID
+//Must keep this aligned at 0x800 if Bal
+	mac_AfterPCPrint 0
+	.endif
+
+
+//r2:r1:r0 value to print, r9 - chksum
+PrintHexEndian12:
+	.if 1
+	orr	r3,r0,r1
+	orrs	r3,r3,r2
+	bne	1f
+	mov	r3,lr
+	mov	r0,#L1(0)
+	bl	TransmitChkSum
+	mov	r0,#L1(ASTERISK)
+	bl	TransmitChkSum
+	mov	r0,#29+24-1
+	mov	lr,r3
+	b	TransmitChkSum
+	.endif
+1:
+#if LITTLE_ENDIAN
+	mov	r7,lr
+	mov	r5,r1
+	mov	r6,r2
+	bl	PrintHexEndian	//r0
+	mov	r0,r5
+	bl	PrintHexEndian	//r1
+	mov	r0,r6
+	mov	lr,r7
+	b	PrintHexEndian	//r2
+
+#else
+	mov	r7,lr
+	mov	r5,r0
+	mov	r6,r1
+	mov	r0,r2
+	bl	PrintHexEndian	//r2
+	mov	r0,r6
+	bl	PrintHexEndian	//r1
+	mov	r0,r5
+	mov	lr,r7
+	b	PrintHexEndian	//r0
+#endif
+
+
+MainInitializationCode:
+	cmp		pc,#MEM_START
+	biclo	sp,pc,#FLASH_BASE_ADDRESS
+	rsblos	sp,sp,#0x4000
+	movlo	r1,#0
+	blo		InitializeCont2		//br if not ram and not from reset vector
+
+//pc - 0-0x4000, 0x04000000-0x04004000, 0xa000000-0xffffffff
+	InitCS0_CS1	r0,sp
+	InitGPIO	r0,sp
+
+#if (PLATFORM_TYPE==NEONB)
+	adr		lr,AfterPCPrint
+	cmp		lr,#0x800
+	bne		InitializeCont1
+	BigOrr2 lr,FLASH_BASE_ADDRESS 		//if in low part of CS0 flash, try CS1 flash
+	BigMov	r0,0xe3a00055		//instruction mov	r0,#55
+	ldr		r2,[lr]
+	cmp		r2,r0
+	addeq	pc,lr,#InitializeCont-AfterPCPrint		//br if CS1 valid
+#endif
+	b		InitializeCont1
+
+//OUT: r0,r2 value, r7 trashed
+ReadHexEndian:
+	mov	r3,lr
+	ReadHexE r2,r7
+	mov	r0,r2
+	mov	pc,r3
+
+
+//OUT: r2:r1:r0 value
+ReadHexEndian12:
+	mov	r3,lr
+
+#if LITTLE_ENDIAN
+	ReadHexE r4,r7
+	ReadHexE r5,r7
+	ReadHexE r2,r7
+	mov	r0,r4
+	mov	r1,r5
+#else
+	ReadHexE r2,r7
+	ReadHexE r5,r7
+	ReadHexE r4,r7
+	mov	r0,r4
+	mov	r1,r5
+#endif
+	mov	pc,r3
+
+
+
+ReadGDB:
+	mov	r8,#0
+	mov	r9,#0
+	mov	rGdbNum3,#0
+	mov	rGdbChkSum,#0
+1:	bl	Receive
+	beq	1b			//br on timeout
+	cmp	r0,#L1(G)
+	beq	gdb_G
+//	cmp	r0,#L1(q)
+//	beq	gdb_q
+	mov	rGdbCmd,r0			//r5 - command being requested
+	add	rGdbChkSum,rGdbChkSum,r0	//update checksum
+	bl	GetNumber
+	mov	r6,r2
+	mov	r7,r0
+	cmp	r0,#L1(POUND)
+	beq	2f
+	cmp	rGdbCmd,#L1(P)
+	beq	gdb_P
+//	cmp	r0,#L1(COMMA)
+//	cmpne	r0,#L1(SEMICOLON)
+//	cmpne	r0,#L1(COLON)
+//	cmpne	r0,#L1(EQUAL)
+	bl	GetNumber
+	mov	r8,r2
+	mov	r9,r0
+	cmp	r0,#L1(POUND)
+	beq	2f
+	cmp	rGdbCmd,#L1(M)
+	beq	gdb_M
+	cmp	rGdbCmd,#L1(X)
+	beq	gdb_X
+
+	bl	GetNumber
+	mov	rGdbNum3,r2
+	cmp	r0,#L1(POUND)
+	bne	WaitForPound
+
+//# found, check chksum
+2:	bl	ReadChksum
+	and	rGdbChkSum,rGdbChkSum,#0xff
+	cmp	rGdbChkSum,r2
+	bne	CheckSumError
+	mov	r0,#L1(PLUS)
+	bl	Transmit
+
+	cmp	rGdbCmd,#L1(g)
+	beq	gdb_g
+	cmp	rGdbCmd,#L1(p)
+	beq	gdb_p
+	cmp	rGdbCmd,#L1(m)
+	beq	gdb_m
+	cmp	rGdbCmd,#L1(c)
+	beq	gdb_c
+	cmp	rGdbCmd,#L1(C)
+	beq	gdb_C
+	cmp	rGdbCmd,#L1(s)
+	beq	gdb_s
+	cmp	rGdbCmd,#L1(S)
+	beq	gdb_S
+	cmp	rGdbCmd,#L1(z)
+	beq	gdb_z
+	cmp	rGdbCmd,#L1(Z)
+	beq	gdb_Z
+	cmp	rGdbCmd,#L1(t)
+	beq	gdb_t
+	cmp	rGdbCmd,#L1(QUESTION_MARK)
+	beq	gdb_lastSignal
+	cmp	rGdbCmd,#L1(D)
+	beq	gdb_D
+//this is an unimplemented command
+UnImplemented:
+	BigMov	r0,L4(DOLLAR,POUND,0,0)
+	bl	Transmit1
+	b	WaitForDollarSign
+
+
+SendError01:
+	mov	r9,#0			//chksum
+	mov	r0,#L1(DOLLAR)
+	bl	Transmit
+	mov	r0,#L1(E)
+	bl	TransmitChkSum
+	mov	r0,#L1(0)
+	bl	TransmitChkSum
+	mov	r0,#L1(1)
+	bl	TransmitChkSum
+	sub	r5,pc,#.+8-SendError01
+	b	FinishPacket
+
+
+SendOK:
+	mov	r9,#0			//chksum
+	mov	r0,#L1(DOLLAR)
+	bl	Transmit
+	mov	r0,#L1(O)
+	bl	TransmitChkSum
+	mov	r0,#L1(K)
+	bl	TransmitChkSum
+	sub	r5,pc,#.+8-SendOK
+	b	FinishPacket
+
+CheckSumError:
+	mov	r0,#L1(MINUS)
+	bl	Transmit
+WaitForDollarSign:
+11:	bl	GetNumber		//$ will branch to ReadGDB
+	b	11b
+WaitForPound:
+11:	bl	GetNumber
+	cmp	r0,#L1(POUND)
+	bne	11b
+	bl	ReadChksum
+	and	rGdbChkSum,rGdbChkSum,#0xff
+	cmp	rGdbChkSum,r2
+	bne	CheckSumError
+	mov	r0,#L1(PLUS)
+	bl	Transmit
+	b	UnImplemented
+
+
+
+FinishPacket:
+	mov	r0,#L1(POUND)
+	bl	Transmit
+	and	r0,r9,#0xff
+	bl	PrintHexByte
+10:	mov	r2,#5
+11:	bl	ReadHex
+	cmp	r0,#L1(DOLLAR)
+	beq	ReadGDB
+	cmp	r0,#L1(PLUS)
+	beq	WaitForDollarSign
+	cmp	r0,#L1(MINUS)
+	
+
+	moveq	pc,r5			//retransmit packet
+	cmp	r0,#GDB_EXIT_CHAR
+	bne	10b
+	subs	r2,r2,#1
+	beq	Prompt
+	b	11b
+
+	.if 0
+gdb_q:
+	mov	r2,#0
+	mov	r3,#0
+1:	bl	ReadHex
+	cmp	r0,#L1(DOLLAR)
+	beq	ReadGDB
+	cmp	r0,#GDB_EXIT_CHAR
+	beq	Prompt
+	cmp	r0,#L1(POUND)
+	beq	2f
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	mov	r1,r2,LSR #24
+	orr	r3,r1,r3,LSL #8
+	orr	r2,r0,r2,LSL #8
+	b	1b
+2:
+	bl	ReadChksum
+	and	rGdbChkSum,rGdbChkSum,#0xff
+	cmp	rGdbChkSum,r2
+	bne	CheckSumError
+	mov	r0,#L1(PLUS)
+	bl	Transmit
+	b	UnImplemented
+	.endif
+
+
+//Detach command - gdb is exiting
+gdb_D:
+//clear break/watch points
+	b	Prompt
+
+//r6 - addr, r8 - PP, rGdbNum3 - mm
+gdb_t:
+	b	UnImplemented
+
+
+//read general registers
+gdb_g:
+	mov	r9,#0			//chksum
+	mov	r0,#L1(DOLLAR)
+	bl	Transmit
+	mov	r8,#0
+1:	mov	r2,r8
+	bl	GetRegVal
+	bl	PrintHexEndian
+	add	r8,r8,#1
+	cmp	r8,#SYM_PC+1
+	bne	1b
+
+	mov	r2,#SYM_FP0
+	bl	GetRegVal
+	mov	r8,#0
+2:	mov	r2,#0
+	bl	PrintHexEndian12	//fp0-7
+	mov	r0,#0
+	mov	r1,#0
+	add	r8,r8,#1
+	cmp	r8,#8
+	bne	2b
+
+	bl	PrintHexEndian		//fps
+
+	mov	r2,#SYM_CPSR
+	bl	GetRegVal
+	bl	PrintHexEndian		//cpsr
+
+	sub	r5,pc,#.+8-gdb_g
+	b	FinishPacket
+
+
+//Read general register
+//r6 - reg #
+gdb_p:
+	mov	r9,#0			//chksum
+	mov	r0,#L1(DOLLAR)
+	bl	Transmit
+	mov	r2,r6
+	cmp	r6,#SYM_PC+1
+	bcs	2f
+
+1:	bl	GetRegVal
+3:	bl	PrintHexEndian
+4:	sub	r5,pc,#.+8-gdb_p
+	b	FinishPacket
+2:	cmp	r6,#25
+	mov	r2,#SYM_CPSR
+	beq	1b
+	cmp	r6,#24			//fps
+	mov	r0,#0
+	beq	3b
+	cmp	r6,#16			//fp0
+	mov	r0,#0
+	mov	r1,#0
+	mov	r2,#SYM_FP0
+	mov	rGdbNum3,r6
+	bleq	GetRegVal
+	mov	r2,#0
+	bl	PrintHexEndian12	//fp0-7
+	mov	r6,rGdbNum3
+	b	4b
+
+//read memory
+//r6 - addr, r8 - length
+gdb_m:
+	mov	r9,#0			//chksum
+	mov	r0,#L1(DOLLAR)
+	bl	Transmit
+	mov	r5,r6
+	movs	r7,r8
+	beq	4f
+1:
+	tst	r5,#3
+	bne	3f
+	cmp	r7,#4
+	bcc	3f
+	ldr	r0,[r5],#4
+	bl	PrintHexEndian
+	subs	r7,r7,#4
+	bne	1b
+	b	4f
+
+3:	ldrb	r0,[r5],#1
+	bl	PrintHexByteEndian
+	subs	r7,r7,#1
+	bne	1b
+4:	sub	r5,pc,#.+8-gdb_m
+	b	FinishPacket
+
+
+//continue
+//r6 - address, 0- current PC
+gdb_c:
+	mov	r8,r6
+//r8 - address, 0- current PC
+gdb_C:
+	movs	rNum1,r8
+	movne	rValidCnt,#F_NUM1_MASK
+	moveq	rValidCnt,#0
+	tst	rNum1,#3
+	bne	SendError01
+	mov	r4,#1
+	b	Go_Cmd1
+
+//step
+//r6 - address, 0- current PC
+gdb_s:
+	mov	r8,r6
+//r8 - address, 0- current PC
+gdb_S:
+	movs	rNum1,r8
+	movne	rValidCnt,#F_NUM1_MASK
+	moveq	rValidCnt,#0
+	tst	rNum1,#3
+	bne	SendError01
+	mov	r4,#1
+	b	Trace_Cmd1
+
+
+
+//watchpoints/breakpoints - remove
+//r6 - type, r8 - address
+gdb_z:
+	cmp	r6,#0		//software breakpoint
+	cmpne	r6,#1		//hardware breakpoint
+	bne	UnImplemented
+//	mov	rNum1,r8		//same reg
+	bl	BC_Do
+	b	SendOK
+
+
+
+//watchpoints/breakpoints - insert
+gdb_Z:
+	cmp	r6,#0		//software breakpoint
+	cmpne	r6,#1		//hardware breakpoint
+	bne	UnImplemented
+//	mov	rNum1,r8		//same reg
+	bl	BS_Do			//	z-0 if r0==rNum1, breakpoint was already set
+	cmpne	r0,rNum1
+	beq	SendOK
+	b	SendError01
+
+
+//gdb routines below have not done checksum yet
+//write general registers
+gdb_G:
+	mov	r8,#0
+1:	bl	ReadHexEndian
+	mov	r2,r8
+	mov	r1,#0
+	bl	StoreRegVal		//r2 - symbol #, r1:r0 - value
+	add	r8,r8,#1
+	cmp	r8,#SYM_PC+1
+	bne	1b
+
+	bl	ReadHexEndian12
+	mov	r2,#SYM_FP0
+	bl	StoreRegVal		//r2 - symbol #, r1:r0 - value
+
+	mov	r8,#1
+2:	bl	ReadHexEndian12
+	add	r8,r8,#1
+	cmp	r8,#8
+	bne	2b
+
+	bl	ReadHexEndian		//fps
+	bl	ReadHexEndian		//cpsr
+
+	mov	r2,#SYM_CPSR
+	bl	StoreRegVal		//r2 - symbol #, r1:r0 - value
+FinishWritePacket:
+	bl	FinishWriteP
+	b	SendOK
+FinishWriteP:
+	mov	r4,lr
+	bl	ReadHex
+	cmp	r0,#L1(POUND)
+	bne	CheckSumError
+	bl	ReadChksum
+	and	rGdbChkSum,rGdbChkSum,#0xff
+	cmp	rGdbChkSum,r2
+	bne	CheckSumError
+	mov	r0,#L1(PLUS)
+	bl	Transmit
+	mov	pc,r4
+
+
+
+
+//write general register
+//r6 - reg#
+gdb_P:
+	mov	r8,r6
+	cmp	r6,#SYM_PC+1
+	bcs	2f
+1:
+	bl	ReadHexEndian
+4:	mov	r6,r0
+	mov	r7,r1
+	bl	FinishWriteP
+	mov	r0,r6
+	mov	r1,r7
+	mov	r2,r8
+	bl	StoreRegVal		//r2 - symbol #, r1:r0 - value
+	b	SendOK
+
+3:	bl	ReadHexEndian
+	b	FinishWritePacket
+
+2:	cmp	r6,#25
+	mov	r8,#SYM_CPSR
+	beq	1b
+	cmp	r6,#24			//fps
+	beq	3b
+	bl	ReadHexEndian12
+	cmp	r6,#16			//fp0
+	bne	FinishWritePacket
+	mov	r8,#SYM_FP0
+	b	4b
+
+
+//write memory
+//r6 - addr, r8 - length
+gdb_M:
+	movs	r8,r8
+	beq	FinishWritePacket
+
+1:	tst	r6,#3
+	beq	3f
+2:	bl	ReadHexByteEndian
+	strb	r2,[r6],#1
+	subs	r8,r8,#1
+	bne	1b
+	b	FinishWritePacket
+3:	cmp	r8,#4
+	bcc	2b
+	bl	ReadHexEndian
+	str	r2,[r6],#4
+	subs	r8,r8,#4
+	bne	3b
+	b	FinishWritePacket
+
+
+//write memory binary with 0x7d, "$","#", escaped with 0x7d
+//r6 - addr, r8 - length
+gdb_X:
+	movs	r8,r8
+	beq	FinishWritePacket
+
+1:	tst	r6,#3
+	beq	3f
+2:	bl	ReadByteEndian
+	strb	r0,[r6],#1
+	subs	r8,r8,#1
+	bne	1b
+	b	FinishWritePacket
+3:	cmp	r8,#4
+	bcc	2b
+	bl	ReadEndian
+	str	r0,[r6],#4
+	subs	r8,r8,#4
+	bne	3b
+	b	FinishWritePacket
+
+	
+
+ReadEndian:
+	mov	r4,lr
+	mov	r5,#4
+1:	bl	ReadByteEndian
+
+#if LITTLE_ENDIAN
+	mov	r0,r0,LSL #24
+	orr	r2,r0,r2,LSR #8
+#else
+	orr	r2,r0,r2,LSL #8
+#endif
+
+	subs	r5,r5,#1
+	bne	1b
+	mov	r0,r2
+	mov	pc,r4
+
+
+ReadByteEndian:
+	mov	r3,lr
+	bl	ReadHex
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	cmp	r0,#0x7d
+	beq	1f
+	cmp	r0,#L1(DOLLAR)
+	cmpne	r0,#L1(POUND)
+	beq	CheckSumError
+	mov	pc,r3
+1:
+	bl	ReadHex
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	mov	pc,r3
+
+
+ReadHexByteEndian:
+	mov	r3,lr
+	bl	ReadHex
+	bcc	CheckSumError
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	mov	r2,r1
+	bl	ReadHex
+	bcc	CheckSumError
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	add	r2,r1,r2,LSL #4
+	mov	pc,r3
+
+//OUT: r2 - checksum
+ReadChksum:
+	mov	r3,lr
+	bl	ReadHex
+	movcs	r2,r1
+	blcs	ReadHex
+	addcs	r2,r1,r2,LSL #4
+	mvncc	r2,#0
+	mov	pc,r3
+
+//out: r0 exit character, r2 - number, rGdbChkSum - updated
+GetNumber:
+	mov	r2,#0
+	mov	r3,lr
+1:	bl	ReadHex
+	bcc	3f
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+2:	tst	r2,#0xf0000000
+	movne	pc,r3		//return on number overflow
+	add	r2,r1,r2,LSL #4
+	b	1b
+3:	cmp	r0,#L1(DOLLAR)
+	beq	ReadGDB
+	cmp	r0,#GDB_EXIT_CHAR
+	beq	Prompt
+	cmp	r0,#L1(POUND)
+	addne	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	mov	pc,r3
+
+// *****************************************************************
+#if (PLATFORM_TYPE==NEONB)
+AfterPCPrint_error:
+	bl	TransmitCRLF
+	BigMov	r0,L4(F,l,a,s)
+	bl	Transmit1
+	BigMov	r0,L4(h,SPACE,i,s)
+	bl	Transmit1
+	BigMov	r0,L4(SPACE,i,n,v)
+	bl	Transmit1
+	BigMov	r0,L4(a,l,i,d)
+	bl	Transmit1
+	bl	TransmitCRLF
+#endif
+AfterPCPrint1:
+	mov		rPrevNum1,#MEM_START
+	movs	rNum1,rNum1
+	tsteq	r6,#7		//make sure it's a SIG_RESET, or SIG_DBG_RESET, and timeout
+	bne		1f
+	BigBic	r0,pc,FLASH_BASE_ADDRESS
+	cmp		r0,#0x4000
+	blo		Gl_Cmd		//auto start program if running in flash
+1:
+	b		R_Cmd
+//	b		Prompt2
+
+
+Invalid:
+	bl	TransmitCRLF
+	BigMov	r0,L4(i,n,v,a)
+	bl	Transmit1
+	BigMov	r0,L3(l,i,d)
+	bl	Transmit1
+	b	Prompt
+Prompt1:
+	mov	rPrevNum1,#MEM_START
+Prompt:
+1:	bl	TransmitCRLF
+Prompt2:
+	mov	r0,#L1(PERIOD)
+	bl	Transmit
+	bl	TransmitSPACE
+	mov	rFieldStart,#1
+	bl	ReadCommand
+
+	mov	r2,r0			//save exit character
+	cmp	r0,#0x0d
+	blne	Transmit
+	bl	TransmitCRLF
+
+	cmp	rCommand,#0
+	bne	2f
+	cmp	r2,#0x0d
+	beq	1b
+	cmp	r2,#L1(PLUS)
+	addeq	rPrevNum1,rPrevNum1,#4
+	beq	Examine_Cmd
+	cmp	r2,#L1(MINUS)
+	subeq	rPrevNum1,rPrevNum1,#4
+	beq	Examine_Cmd
+	b	1b
+
+2:	tst	rSymbol,#F_NUM1_MASK
+	mov	r0,rNum1
+	blne	GetSymbolNumber
+	bne	Invalid
+	mov	rNum1,r0
+
+	tst	rSymbol,#F_NUM2_MASK
+	mov	r0,rNum2
+	blne	GetSymbolNumber
+	bne	Invalid
+	mov	rNum2,r0
+
+	cmp	rCommand,#L1(E)
+	beq	Examine_Cmd
+	cmp	rCommand,#L1(D)
+	beq	Deposit_Cmd
+	cmp	rCommand,#L1(G)
+	beq	Go_Cmd
+	cmp	rCommand,#L1(R)
+	beq	R_Cmd
+	cmp	rCommand,#L1(T)
+	beq	Trace_Cmd
+	BigMov	r0,C2(D,L)
+	cmp	rCommand,r0
+	beq	Download_Cmd
+	cmp	rCommand,#L1(QUESTION_MARK)
+	beq	Help_Cmd
+
+	mov	r0,r0,LSL #8
+	orr	r0,r0,#L1(W)
+	cmp	rCommand,r0
+	beq	Download_Wireless_Cmd
+
+	BigMov	r0,C4(S,S,I,D)
+	cmp	rCommand,r0
+	beq	SSID_Cmd
+
+	BigMov	r0,C3(M,A,C)
+	cmp	rCommand,r0
+	beq	MAC_Cmd
+
+	BigMov	r0,C4(B,U,R,N)
+	cmp	rCommand,r0
+	beq	Burn_Cmd
+
+	BigMov	r0,C2(B,B)
+	cmp	rCommand,r0
+	beq	Burn2_Cmd
+
+	BigMov	r0,C4(B,A,L,L)	//Burn all of flash, erase end.
+	cmp	rCommand,r0
+	beq	BurnAll_Cmd
+
+	cmp	rCommand,#L1(V)
+	beq	Verify_Cmd
+
+	BigMov	r0,C2(V,V)
+	cmp	rCommand,r0
+	beq	Verify2_Cmd
+
+	BigMov	r0,C2(G,L)
+	cmp	rCommand,r0
+	beq	Gl_Cmd			//go linux!!
+
+	BigEor2	r0,C2(G,L)^C2(G,G)
+	cmp	rCommand,r0
+	beq	GG_Cmd			//go without cache invalidate
+
+	BigMov	r0,C2(T,T)
+	cmp	rCommand,r0
+	beq	TT_Cmd			//Trace without cache invalidate
+
+	BigMov	r0,C2(B,S)
+	cmp	rCommand,r0
+	beq	BS_Cmd
+
+	BigEor2	r0,C2(B,S)^C2(B,E)
+	cmp	rCommand,r0
+	beq	BE_Cmd
+
+	BigEor2	r0,C2(B,E)^C2(B,C)
+	cmp	rCommand,r0
+	beq	BC_Cmd
+
+	BigEor2	r0,C2(B,C)^C2(W,C)
+	cmp	rCommand,r0
+	beq	WC_Cmd
+
+	BigEor2	r0,C2(W,C)^C2(W,W)
+	cmp	rCommand,r0
+	beq	WW_Cmd
+
+	BigEor2	r0,C2(W,W)^C2(W,R)
+	cmp	rCommand,r0
+	beq	WR_Cmd
+
+	mov	r0,r0,LSL #8
+	orr	r0,r0,#L1(W)
+	cmp	rCommand,r0
+	beq	WRW_Cmd
+
+	BigMov	r0,C3(M,M,U)
+	cmp	rCommand,r0
+	beq	MMU_Cmd
+//	mov	r0,rCommand
+//	bl	PrintHex
+	b	Invalid
+
+//IN: rFieldStart - starting field (this is a blank counting field)
+//OUT:
+ReadCommand:
+	mov	r3,lr
+	mov	rSymbol,#0
+	mov	rField,rFieldStart
+	mov	rValidCnt,#0		//low nibble: # of blanks before command
+					//next: # of chars in command
+					//next: # of blanks
+					//next: # of hex digits in num1
+					//next: # of blanks
+					//next: # of hex digits in num2
+	mov	rCommand,#0		//command
+	mov	rNum1,#0		//1st number
+	mov	rNum2,#0		//2nd number
+
+1:	bl	Receive
+	beq	1b			//br on timeout
+	cmp	r0,#L1(DOLLAR)
+	beq	ReadGDB
+	cmp	r0,#L1(PLUS)
+	cmpne	r0,#L1(MINUS)
+	cmpne	r0,#L1(AT_SIGN)
+	cmpeq	rValidCnt,#0
+	cmpne	r0,#0x0d
+	moveq	pc,r3			//return on -,+, 1st on line or <cr>
+
+	cmp	r0,#L1(SPACE)
+	bne	2f
+	bl	Transmit
+	tst	rValidCnt,#0x80000000
+	eorne	rValidCnt,rValidCnt,#0x80000000	//clear bit 31 to mark as blank field
+	movne	rField,rField,LSL #F_INC
+//now we are in a counting blanks field
+	rsb	r2,rField,rField,LSL #F_INC	//get a field mask
+	and	r1,rValidCnt,r2
+	cmp	r1,r2
+	beq	Invalid				//br if field is full
+	add	rValidCnt,rValidCnt,rField
+	b	1b
+2:
+	cmp	r0,#0x08		//Backspace
+	cmpne	r0,#0x7f		//del or Backspace
+	bne	4f
+	cmp	rValidCnt,#0
+	beq	1b			//br if nothing to remove
+	BigMov	r0,L3(BACKSPACE,SPACE,BACKSPACE)
+	bl	Transmit1
+	sub	rValidCnt,rValidCnt,rField
+	mov	r0,#4
+	tst	rSymbol,rField
+	movne	r0,#8
+	cmp	rField,#F_COMMAND
+	moveq	rCommand,rCommand,LSR #8
+	cmp	rField,#F_NUM1
+	moveq	rNum1,rNum1,LSR r0
+	cmp	rField,#F_NUM2
+	moveq	rNum2,rNum2,LSR r0
+
+3:	rsb	r0,rField,rField,LSL #F_INC	//get a field mask
+	tst	rValidCnt,r0
+	bne	1b				//br if still more in this field
+	bic	rSymbol,rSymbol,rField
+	cmp	rField,rFieldStart
+	beq	1b
+//move back to lower field
+	mov	rField,rField,LSR #F_INC
+	eors	rValidCnt,rValidCnt,#0x80000000
+	b	3b
+
+4:	bl	Transmit
+	tst	rValidCnt,#0x80000000
+	orreq	rValidCnt,rValidCnt,#0x80000000	//set bit 31 to mark as data field
+	moveq	rField,rField,LSL #F_INC
+	cmp	rField,#F_UNDEF
+	beq	Invalid
+//now we are in a data field
+	rsbs	r1,rField,#F_COMMAND
+	rsbges	r1,r0,#L1(9)		//reverse subtract
+	subges	r1,r0,#L1(0)
+	movge	rField,rField,LSL #F_INC+F_INC	//advance to number field if in range "0"-"9"
+
+	rsb	r2,rField,rField,LSL #F_INC	//get a field mask
+	and	r1,rValidCnt,r2
+	cmp	r1,r2
+	beq	Invalid				//field is full
+	add	rValidCnt,rValidCnt,rField
+
+	rsbs	r1,r0,#L1(z)	//reverse subtract
+	subges	r1,r0,#L1(a)
+	andge	r0,r0,#0xdf	//convert to uppercase if was "a"-"z"
+	cmp	rField,#F_COMMAND
+	bne	6f
+	tst	rCommand,#0xff000000
+	bne	Invalid
+	add	rCommand,r0,rCommand,LSL #8
+	b	1b
+
+6:	tst	rSymbol,rField
+	bne	15f
+	rsbs	r1,r0,#L1(9)	//reverse subtract
+	subges	r1,r0,#L1(0)
+	bge	5f
+	rsbs	r1,r0,#L1(F)	//reverse subtract
+	subges	r1,r0,#L1(A)
+	add	r1,r1,#10
+	bge	5f
+	orr	rSymbol,rSymbol,rField
+//now if number started with "A"-"F", convert back to ascii
+
+	cmp	rField,#F_NUM1
+	mov	r1,rValidCnt,LSR #F_NUM1_BIT	//# of nibbles +1 in rNum
+	movne	r1,rValidCnt,LSR #F_NUM2_BIT
+	and	r1,r1,#((1<<F_INC)-1)
+
+	subs	r1,r1,#1			//# of nibbles in rNum
+	beq	15f
+
+
+
+	cmp	r1,#3
+	bcs	Invalid			//br if too many leading hex characters
+	mov	r1,r1,LSL #2		//# of bits valid in rNum
+	cmp	rField,#F_NUM1
+	rsb	lr,r1,#24
+	moveq	r2,rNum1,ROR r1
+	movne	r2,rNum2,ROR r1
+	orr	r2,r2,r0,LSL lr		//save r0 character
+
+	mov	lr,#0
+26:	mov	r0,r2,LSR #28
+	cmp	r0,#10
+	addcs	r0,r0,#L1(A)-10
+	addcc	r0,r0,#L1(0)
+	orr	lr,r0,lr,LSL #8
+	mov	r2,r2,LSL #4
+	subs	r1,r1,#4
+	bne	26b
+
+	cmp	rField,#F_NUM1
+	mov	r0,r2,LSR #24		//restore r0
+	moveq	rNum1,lr
+	movne	rNum2,lr
+	b	15f
+
+5:
+	cmp	rField,#F_NUM1
+	bne	7f
+	tst	rNum1,#0xf0000000
+	bne	Invalid
+	add	rNum1,r1,rNum1,LSL #4
+	b	1b
+7:	tst	rNum2,#0xf0000000
+	bne	Invalid
+	add	rNum2,r1,rNum2,LSL #4
+	b	1b
+
+15:
+	cmp	rField,#F_NUM1
+	bne	17f
+	tst	rNum1,#0xff000000
+	bne	Invalid
+	add	rNum1,r0,rNum1,LSL #8
+	b	1b
+17:	tst	rNum2,#0xff000000
+	bne	Invalid
+	add	rNum2,r0,rNum2,LSL #8
+	b	1b
+
+//rNum1 - 0 off, 1 on
+MMU_Cmd:
+	bl	cache_clean_invalidate_all
+	tst	rNum1,#1
+//now enable/disable MMU, Data Cache
+	CP15_CONTROL mrc,r1		//get the control register
+	biceq	r1,r1,#0x5
+	orrne	r1,r1,#0x5
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+	BigMov	rUart,UART_BASE		//this is right if MMU is off
+	blne	GetUartAddress		//if mmu is on
+	b	Prompt
+	
+// ********************************************************************
+// ********************************************************************
+// ********************************************************************
+// r3 - -1 : Trace, 0 : Go
+// r4 - 0 : normal, 1 : mark gdb mode
+// rNum2 - 0 : invalidate cache, 1 : don't invalidate cache
+//go without cache invalidate
+GG_Cmd:
+	mov	r4,#0
+	mov	r3,#0
+	mov	rNum2,#1
+	b	Go2
+Go_Cmd:
+	mov	r4,#0
+Go_Cmd1:
+	mov	r3,#0
+Go1:
+	bl	cache_clean_invalidate_all
+	.if	0
+	mov	rNum2,#0
+	.else
+	mov	rNum2,#1
+	.endif
+Go2:
+
+	ldrb	r2,[rDBG,#DBG_Mode]
+	and	r2,r2,#0xfe
+	orr	r2,r2,r4
+	strb	r2,[rDBG,#DBG_Mode]	//mark gdb mode
+
+	tst	rValidCnt,#F_NUM1_MASK
+	strne	rNum1,[rDBG,#DBG_PC]	//return pc
+	ldreq	rNum1,[rDBG,#DBG_PC]	//return pc
+	orr	r0,rNum1,#1
+	CP15_IBCR0 mrc,rBCR0
+	CP15_IBCR1 mrc,rBCR1
+	cmp	r0,rBCR0
+	ldr	r7,[rDBG,#DBG_CPSR]
+	mov	r2,rBCR0				//save temporary
+	moveq	rBCR0,#0
+	cmp	r0,rBCR1
+	moveq	rBCR1,#0
+
+	cmpne	r0,r2
+	streq	r0,[rDBG,#DBG_TRACE]	//this is the current instruction breakpoint value
+	beq	4f				//br if a bkpt matches current instruction
+	cmp	r3,#0
+	str	r3,[rDBG,#DBG_TRACE]	//-1 : Trace, 0 : Go
+	beq	6f
+
+
+4:	bl	CalcNextPc			//IN: rNum1: current PC, r7- cpsr;    OUT: rNum1: next PC
+	tst	r0,#1
+	bne	Invalid
+	orr	r1,r0,#1
+
+	tst	rBCR0,#1
+	moveq	rBCR0,r1
+	beq	5f
+	tst	rBCR1,#1
+	moveq	rBCR1,r1
+	strne	rBCR0,[rDBG,#DBG_TRACE]	//need to steal this breakpoint momentarily
+	movne	rBCR0,r1
+5:
+	CP15_IBCR0 mcr,rBCR0
+	CP15_IBCR1 mcr,rBCR1
+
+6:
+	ldrb	r0,[rDBG,#DBG_FFUART_LCR]
+	str	r0,[rUart,#UART_LCR]	//restore value
+	add	r0,rDBG,#DBG_R2
+
+	bl	ClearStickyAbort
+	BigMov	r1,UART_BASE		//physical address
+	movs	rNum2,rNum2,LSR #1	//carry flag 1 : don't invalidate cache
+	teq	r1,rUart		//this lets me know if identity mapping is used, or MMU is off, C & V are not affected by instruction
+
+	ldmia	r0,{r2,r3,r4,r5,r6,r7,r8,r9,sl,fp,ip,sp,lr}
+//z-0 return indirect, setup stack to contain real return address
+	ldrne	r1,[r0,#DBG_PC-DBG_R2]
+	strne	r1,[sp,#-4]!
+
+	ldr	r1,[r0,#DBG_HCPSR-DBG_R2]
+	orr	r1,r1,#0xc0		//set I, F
+	msr	cpsr_c,r1
+//	ldr	r1,[r0,#DBG_CPSR-DBG_R2]	//don't allow changing return mode for now... to messy
+//	msr	spsr,r1
+	CP15_CF_DRAIN mcr,r1	//make sure data cache write buffers are drained
+	b	InvalidateAndReturn	//z-1 return direct, z-0 return indirect
+
+
+
+ClearStickyAbort:
+	CP14_DCSR mrc,r1
+	tst	r1,#1<<5
+	bic	r1,r1,#1<<5		//clear sticky abort bit
+	CP14_DCSR mcrne,r1
+	mov	pc,lr
+TT_Cmd:
+	mov	r4,#0
+	mvn	r3,#0
+	mov	rNum2,#1
+	b	Go2
+
+Trace_Cmd:
+	mov	r4,#0
+Trace_Cmd1:
+	mvn	r3,#0
+	b	Go1
+
+
+//IN: rNum1: current PC, r7- cpsr
+//OUT: r0: next PC
+//trashed: r1,r2,r3,r4,r6
+CalcNextPc:
+	mov	r4,lr
+	bl	ClearStickyAbort
+	ldr	r2,[rNum1]
+	add	r0,rNum1,#4
+	nop				//let abort have time to signal
+	bl	ClearStickyAbort
+	movne	pc,r4
+//1st check to see if condition codes allow instruction to execute
+1:
+	mov	r3,r2,LSR #28
+	msr	CPSR_f,r7
+	add	pc,pc,r3,LSL #3
+	nop
+	beq	2f		//0-eq
+	mov	pc,r4
+	bne	2f		//1-ne
+	mov	pc,r4
+	bcs	2f		//2-cs
+	mov	pc,r4
+	bcc	2f		//3-cc
+	mov	pc,r4
+	bmi	2f		//4-mi
+	mov	pc,r4
+	bpl	2f		//5-pl
+	mov	pc,r4
+	bvs	2f		//6-vs
+	mov	pc,r4
+	bvc	2f		//7-vc
+	mov	pc,r4
+	bhi	2f		//8-hi
+	mov	pc,r4
+	bls	2f		//9-ls
+	mov	pc,r4
+	bge	2f		//a-ge
+	mov	pc,r4
+	blt	2f		//b-lt
+	mov	pc,r4
+	bgt	2f		//c-gt
+	mov	pc,r4
+	ble	2f		//d-le
+	mov	pc,r4
+	b	2f		//e-al
+	mov	pc,r4		//just a spacer instruction, never executed
+				//f-nv
+
+	and	r3,r2,#0xfe000000
+	cmp	r3,#0xfa000000
+	movne	pc,r4
+//BLX instruction changing into thumb mode
+	movs	r3,r2,LSL #8		//mov H bit to carry flag
+	orrcs	r3,r3,#1<<7
+	add	r0,r0,#4
+	add	r0,r0,r3,ASR #6
+	mov	pc,r4
+
+
+//instruction WILL execute
+2:
+	mov	r3,r2,LSR #25
+	and	r3,r3,#0x7
+	and	r1,r2,#0x0000f000
+	cmp	r1,   #0x0000f000
+	mov	r1,r2,LSL #20
+	mov	r1,r1,LSR #20		//r1 gets low 12 bits of r2
+	add	pc,pc,r3,LSL #2
+	nop
+	b	10f
+	b	11f
+	b	12f
+	b	13f
+	b	14f
+	b	15f
+	mov	pc,r4		//6
+	mov	pc,r4		//7
+//nnnn 000n
+10:
+	movne	pc,r4
+	and	r3,r2,#0x01800000
+	cmp	r3,   #0x01000000
+	bne	51f
+	and	r3,r2,#0x0ff00000
+	cmp	r3,   #0x01200000
+	andeq	r3,r2,#0x000000d0
+	cmpeq	r3,   #0x00000010
+//B{L} <Rm> instruction -eq
+	andeq	r3,r2,#0xf
+#if DBG_R0
+	addeq	r0,rDBG,#DBG_R0
+	ldreq	r0,[r0,r3,LSL #2]
+#else
+	ldreq	r0,[rDBG,r3,LSL #2]
+#endif
+
+	biceq	r0,r0,#1
+	mov	pc,r4
+
+
+51:	tst	r2,#1<<4
+	bne	52f
+	add	r0,r0,#4		//pc+8
+	bl	RegShiftImmed
+	b	50f
+52:
+	tst	r2,#1<<7
+	movne	pc,r4			//return if LDR|STR<H|D|B|SB|SH>|MUL|MLA...
+//this is a shift by a register value
+	add	r0,r0,#4		//pc+8
+	bl	RegShiftReg
+	b	50f
+
+//nnnn 001n	immediate
+11:
+	movne	pc,r4
+	and	r3,r2,#0x01800000
+	cmp	r3,   #0x01000000
+	moveq	pc,r4			//return if TST|TEQ|CMP|CMN|MRS|MSR|SMLA.....
+	and	r6,r1,#0xff
+	mov	r3,r1,LSR #7
+	BIC	r3,r3,#1
+	mov	r1,r6,ROR r3
+	add	r0,r0,#4		//pc+8
+//r1 has 2nd operand
+50:
+	mov	r3,r2,LSR #16
+	and	r3,r3,#0xf
+	cmp	r3,#0xf
+	moveq	r6,r0			//pc+8
+#if DBG_R0
+	addne	r6,rDBG,#DBG_R0
+	ldrne	r6,[r6,r3,LSL #2]	//<Rn> - r6
+#else
+	ldrne	r6,[rDBG,r3,LSL #2]	//<Rn> - r6
+#endif
+
+//r6 has 1st operand
+	mov	r3,r2,LSR #21
+	and	r3,r3,#0xf
+	msr	CPSR_f,r7
+	add	pc,pc,r3,LSL #3
+	nop
+	and	r0,r6,r1		//0-AND
+	mov	pc,r4
+	eor	r0,r6,r1		//1-EOR
+	mov	pc,r4
+	sub	r0,r6,r1		//2-SUB
+	mov	pc,r4
+	rsb	r0,r6,r1		//3-RSB
+	mov	pc,r4
+	add	r0,r6,r1		//4-ADD
+	mov	pc,r4
+	adc	r0,r6,r1		//5-ADC
+	mov	pc,r4
+	sbc	r0,r6,r1		//6-SBC
+	mov	pc,r4
+	rsc	r0,r6,r1		//7-RSC
+	mov	pc,r4
+	sub	r0,r0,#4		//8-TST, cannot get here
+	mov	pc,r4
+	sub	r0,r0,#4		//9-TEQ, cannot get here
+	mov	pc,r4
+	sub	r0,r0,#4		//A-CMP, cannot get here
+	mov	pc,r4
+	sub	r0,r0,#4		//B-CMN, cannot get here
+	mov	pc,r4
+	orr	r0,r6,r1		//C-ORR
+	mov	pc,r4
+	mov	r0,r1			//D-MOV
+	mov	pc,r4
+	bic	r0,r6,r1		//E-BIC
+	mov	pc,r4
+	mvn	r0,r1			//F-MVN
+	mov	pc,r4
+
+//LDR
+12:
+13:
+	tsteq	r2,#1<<22		//B bit 22  1 : Byte, 0: Word
+	movne	pc,r4
+	tst	r2,#1<<20		//L bit 20  1 : LDR, 0:STR
+	moveq	pc,r4
+
+	add	r0,r0,#4		//pc+8
+	tst	r2,#1<<24		//P bit
+	moveq	r1,#0
+	beq	34f
+	tst	r2,#1<<25
+	beq	34f			//branch if immediate12bits value is in r1
+	bl	RegShiftImmed
+34:
+	mov	r3,r2,LSR #16
+	and	r3,r3,#0xf
+	cmp	r3,#0xf
+	moveq	r6,r0			//pc+8
+#if DBG_R0
+	addne	r6,rDBG,#DBG_R0
+	ldrne	r6,[r6,r3,LSL #2]	//<Rn> - r6
+#else
+	ldrne	r6,[rDBG,r3,LSL #2]	//<Rn> - r6
+#endif
+
+	tst	r2,#1<<23		//U bit Up/Down, Add/Sub
+	addne	r6,r6,r1
+	subeq	r6,r6,r1
+	ldr	r0,[r6]
+	mov	pc,r4
+
+
+//LDM
+14:
+	and	r3,r2,#(1<<15)+(1<<20)
+	cmp	r3,   #(1<<15)+(1<<20)
+	movne	pc,r4
+
+//LDM to PC -eq
+	add	r0,r0,#4		//pc+8
+	mov	r3,r2,LSR #16
+	and	r3,r3,#0xf
+	cmp	r3,#0xf
+	moveq	r1,r0			//pc+8, should never execute
+#if DBG_R0
+	addne	r1,rDBG,#DBG_R0
+	ldrne	r1,[r1,r3,LSL #2]	//<Rn> - r1
+#else
+	ldrne	r1,[rDBG,r3,LSL #2]	//<Rn> - r1
+#endif
+
+//r1 is already correct address for downward from base (U==0), included(P==0)
+	tst	r2,#1<<23		//U bit
+	beq	4f
+	mov	r6,r2,LSL #16
+3:	movs	r6,r6,LSL #1
+	addcs	r1,r1,#4
+	bne	3b
+	eor	r2,r2,#1<<24
+4:	tst	r2,#1<<24		//P bit
+	subne	r1,r1,#4
+	ldr	r0,[r1]
+	mov	pc,r4
+
+//B{L} instruction
+15:
+	mov	r3,r2,LSL #8
+	add	r0,r0,#4
+	add	r0,r0,r3,ASR #6
+	mov	pc,r4
+
+//IN: r0 - pc+4, r2 instruction, r1 low 12 bits of instruction
+//OUT: r1 - shifted value, r2 - unchanged, r0 - pc+8
+RegShiftImmed:
+	mov	r1,r1,LSR #7		//Shift_imm - r1
+	and	r3,r2,#0xf
+	cmp	r3,#0xf
+	moveq	r6,r0			//pc+8
+#if DBG_R0
+	addne	r6,rDBG,#DBG_R0
+	ldrne	r6,[r6,r3,LSL #2]	//<Rm> - r6
+#else
+	ldrne	r6,[rDBG,r3,LSL #2]	//<Rm> - r6
+#endif
+
+	tst	r2,#1<<6
+	bne	32f
+	tst	r2,#1<<5
+	bne	31f
+	mov	r1,r6,LSL r1		//<Rm> shf Shift_imm - r1
+	mov	pc,lr
+
+31:	cmp	r1,#0
+	movne	r1,r6,LSR r1
+	mov	pc,lr
+
+32:	tst	r2,#1<<5
+	bne	33f
+	cmp	r1,#0
+	moveq	r1,#32
+	mov	r1,r6,ASR r1
+	mov	pc,lr
+
+33:	cmp	r1,#0
+	movne	r1,r6,ROR r1
+	movne	pc,lr
+
+	msr	CPSR_f,r7
+	mov	r1,r6, RRX
+	mov	pc,lr
+
+
+//IN: r2 instruction, r1 low 12 bits of instruction
+//OUT: r1 - shifted value, r2 - unchanged, r0 - pc+8
+RegShiftReg:
+	mov	r3,r1,LSR #8
+	cmp	r3,#0xf
+	moveq	r1,r0			//pc+8
+#if DBG_R0
+	addne	r1,rDBG,#DBG_R0
+	ldrne	r1,[r1,r3,LSL #2]	//<Rs> - r1
+#else
+	ldrne	r1,[rDBG,r3,LSL #2]	//<Rs> - r1
+#endif
+
+	and	r3,r2,#0xf
+	cmp	r3,#0xf
+	moveq	r6,r0			//pc+8
+#if DBG_R0
+	addne	r6,rDBG,#DBG_R0
+	ldrne	r6,[r6,r3,LSL #2]	//<Rm> - r6
+#else
+	ldrne	r6,[rDBG,r3,LSL #2]	//<Rm> - r6
+#endif
+	tst	r2,#1<<6
+	bne	32f
+	tst	r2,#1<<5
+	moveq	r1,r6,LSL r1		//<Rm> shf <Rs> - r1
+	movne	r1,r6,LSR r1
+	mov	pc,lr
+
+32:	tst	r2,#1<<5
+	moveq	r1,r6,ASR r1
+	movne	r1,r6,ROR r1
+	mov	pc,lr
+
+
+
+//IN: r0 - register name
+//OUT: r0 - location
+GetSymbolNumber:
+	BigMov	r1,C2(R,0)
+	sub	r2,r0,r1
+	cmp	r2,#10
+	bcc	1f
+
+	BigMov	r1,C3(R,1,0)
+	sub	r2,r0,r1
+	cmp	r2,#6
+	bcc	2f
+
+	BigMov	r1,C3(F,P,0)
+	cmp	r1,r0
+	moveq	r2,#SYM_FP0
+	beq	1f
+
+	BigMov	r1,C2(S,L)
+	cmp	r1,r0
+	moveq	r2,#SYM_SL
+	beq	1f
+
+	BigMov	r1,C2(F,P)
+	cmp	r1,r0
+	moveq	r2,#SYM_FP
+	beq	1f
+
+	BigEor2	r1,C2(F,P)^C2(I,P)
+	cmp	r1,r0
+	moveq	r2,#SYM_IP
+	beq	1f
+
+	BigEor2	r1,C2(I,P)^C2(S,P)
+	cmp	r1,r0
+	moveq	r2,#SYM_SP
+	beq	1f
+
+	BigMov	r1,C2(L,R)
+	cmp	r1,r0
+	moveq	r2,#SYM_LR
+	beq	1f
+
+	BigMov	r1,C2(P,C)
+	cmp	r1,r0
+	moveq	r2,#SYM_PC
+	beq	1f
+
+	BigMov	r1,C4(C,P,S,R)
+	cmp	r1,r0
+	moveq	r2,#SYM_CPSR
+	beq	1f
+
+	BigMov	r1,C3(F,S,R)
+	cmp	r1,r0
+	moveq	r2,#SYM_FSR
+	beq	1f
+
+	BigMov	r1,C3(F,A,R)
+	cmp	r1,r0
+	moveq	r2,#SYM_FAR
+	beq	1f
+
+	BigMov	r1,C4(D,C,S,R)
+	cmp	r1,r0
+	moveq	r2,#SYM_DCSR
+	beq	1f
+
+	BigMov	r1,C4(T,T,B,R)
+	cmp	r1,r0
+	moveq	r2,#SYM_TTBR
+	beq	1f
+
+	BigMov	r1,C4(C,T,R,L)
+	cmp	r1,r0
+	moveq	r2,#SYM_CTRL
+	beq	1f
+
+//	BigMov	r1,C3(F,P,S)
+//	cmp	r1,r0
+//	moveq	r2,#SYM_FPS-SYM_F0
+	movne	pc,lr
+
+
+//3:	add	r2,r2,#SYM_F0-SYM_SL
+2:	add	r2,r2,#SYM_SL
+1:	BigMov	r0,DEBUG_SYM
+	add	r0,r0,r2
+	subs	r2,r2,r2
+	mov	pc,lr
+
+
+
+//IN: r0 - symbol address or number to print
+PrintHexOrSymbol:
+	BigAdd	r1,r0,-DEBUG_SYM
+	cmp	r1,#SYM_LAST+1
+	bcs	PrintHex
+	mov	r0,#0
+
+//IN: r1 register #, r0 {31:16}-  2 characters to print after
+PrintRegName:
+	cmp	r1,#SYM_SL
+	bcs	1f
+	add	r0,r0,r1,LSL #8
+	add	r0,r0,#L2(NULL,0)
+//	cmp	r1,#10
+//	subge	r0,r0,#10<<8
+//	movge	r0,r0,LSL #8
+//	addge	r0,r0,#L2(NULL,1)
+	add	r0,r0,#L1(R)
+20:	b	Transmit1
+1:	BigOrr2Eq r0,L2(S,L)
+	cmp	r1,#SYM_FP
+	BigOrr2Eq r0,L2(F,P)
+	cmp	r1,#SYM_IP
+	BigOrr2Eq r0,L2(I,P)
+	cmp	r1,#SYM_SP
+	BigOrr2Eq r0,L2(S,P)
+	cmp	r1,#SYM_LR
+	BigOrr2Eq r0,L2(L,R)
+	cmp	r1,#SYM_PC
+	BigOrr2Eq r0,L2(P,C)
+	ble	20b
+	cmp	r1,#SYM_FP0
+
+	mov	r0,r0,LSL #8
+	BigOrr2Eq r0,L3(F,P,0)
+	cmp	r1,#SYM_FSR
+	BigOrr2Eq r0,L3(F,S,R)
+	cmp	r1,#SYM_FAR
+	BigOrr2Eq r0,L3(F,A,R)
+
+	cmp	r1,#SYM_CPSR
+	BigMovEq r0,L4(C,P,S,R)
+	cmp	r1,#SYM_DCSR
+	BigMovEq r0,L4(D,C,S,R)
+	cmp	r1,#SYM_TTBR
+	BigMovEq r0,L4(T,T,B,R)
+	cmp	r1,#SYM_CTRL
+	BigMovEq r0,L4(C,T,R,L)
+	b	Transmit1
+
+
+//r2 - symbol #
+PrintRegVal:
+	mov	r6,lr
+	bl	GetRegVal
+	cmp	r2,#SYM_FP0
+	bne	1f
+	mov	r5,r0
+	mov	r0,r1
+	bl	PrintHexByte		//40 bits
+	mov	r0,r5
+1:	mov	lr,r6
+	b	PrintHex
+
+
+
+
+
+//r2 - symbol #, r1:r0 - value
+StoreRegVal:
+	cmp	r2,#SYM_FP0
+	bcs	1f
+#if DBG_R0
+	add	r1,rDBG,#DBG_R0
+	str	r0,[r1,r2,LSL #2]
+#else
+	str	r0,[rDBG,r2,LSL #2]
+#endif
+	mov	pc,lr
+1:
+	bne	2f
+//MAR{<cond>} acc0,<RdLo>,<RdHi>
+	mar	acc0,r0,r1
+	mov	pc,lr
+2:	cmp	r2,#SYM_FSR
+	CP15_FSR mcreq,r0
+	cmp	r2,#SYM_FAR
+	CP15_FAR mcreq,r0
+	cmp	r2,#SYM_DCSR
+	CP14_DCSR mcreq,r0
+	cmp	r2,#SYM_TTBR
+	CP15_TTBR mcreq,r0
+	cmp	r2,#SYM_CTRL
+	CP15_CONTROL mcreq,r0
+	mov	pc,lr
+
+R_Cmd:
+	mov	r7,#0
+1:	mov	r1,r7
+	BigMov	r0,L4(NULL,NULL,COLON,SPACE)
+	bl	PrintRegName
+	bl	TransmitSPACE
+	mov	r2,r7
+	bl	PrintRegVal
+	bl	TransmitSPACE
+	bl	TransmitSPACE
+	add	r7,r7,#1
+	tst	r7,#3
+	bleq	TransmitCRLF
+	cmp	r7,#SYM_LAST_RCMD+1
+	bne	1b
+	b	Prompt
+BS_Cmd:
+	tst	rValidCnt,#F_NUM1_MASK
+	beq	BE_Cmd
+	tst	rSymbol,#F_NUM1_MASK
+	mov	r0,rNum1
+	blne	GetSymValue
+	mov	rNum1,r0
+	bl	BS_Do
+	beq	Prompt
+	b	BE_Cmd
+
+//out: z-1  breakpoint just set
+//	z-0 if r0==rNum1, breakpoint was already set
+BS_Do:
+	CP15_IBCR0 mrc,r0
+	CP15_IBCR1 mrc,r1
+	orr	rNum1,rNum1,#1
+	cmp	r0,rNum1
+	cmpne	r1,rNum1
+	beq	2f
+	tst	r0,#1
+	CP15_IBCR0 mcreq,rNum1
+	moveq	pc,lr
+	tst	r1,#1
+	CP15_IBCR1 mcreq,rNum1
+	mov	pc,lr
+
+2:	mov	r0,rNum1
+	movs	r1,#1
+	mov	pc,lr
+
+BC_Cmd:
+	tst	rValidCnt,#F_NUM1_MASK
+	beq	BE_Cmd
+	tst	rSymbol,#F_NUM1_MASK
+	mov	r0,rNum1
+	blne	GetSymValue
+	mov	rNum1,r0
+	bl	BC_Do
+	beq	Prompt
+	b	BE_Cmd
+
+//out: z-1  breakpoint just cleared
+BC_Do:
+	CP15_IBCR0 mrc,r0
+	CP15_IBCR1 mrc,r1
+	orr	rNum1,rNum1,#1
+	mov	r2,#0
+	cmp	r0,rNum1
+	CP15_IBCR0 mcreq,r2
+	cmp	r1,rNum1
+	CP15_IBCR1 mcreq,r2
+	cmpne	r0,rNum1
+	mov	pc,lr
+
+BE_Cmd:
+	BigMov	r0,L4(B,K,P,T)
+	bl	Transmit1
+	bl	TransmitSPACE
+	BigMov	r0,L4(S,t,a,t)
+	bl	Transmit1
+	BigMov	r0,L4(u,s,COLON,SPACE)
+	bl	Transmit1
+	CP15_IBCR0 mrc,r0
+	tst	r0,#1
+	bic	r0,r0,#1
+	blne	PrintHex
+	bl	TransmitSPACE
+
+	CP15_IBCR1 mrc,r0
+	tst	r0,#1
+	bic	r0,r0,#1
+	blne	PrintHex
+	b	Prompt
+
+WatchStatus:
+	BigMov	r0,L4(W,A,T,C)
+	bl	Transmit1
+	BigMov	r0,L2(H,SPACE)
+	bl	Transmit1
+	BigMov	r0,L4(S,t,a,t)
+	bl	Transmit1
+	BigMov	r0,L4(u,s,COLON,SPACE)
+	bl	Transmit1
+	CP15_DBCON mrc,r5
+	tst	r5,#0x0f
+	beq	10f
+	tst	r5,#0x03
+	bne	1f
+	tst	r5,#0x100
+	bne	10f		//br if dbr1 is mask (nothing being watched)
+	b	4f
+1:
+	CP15_DBR0 mrc,r0
+	bl	PrintHex
+	bl	20f
+	tst	r5,#0x100
+	beq	3f
+	BigMov	r0,L2(M,COLON)
+	bl	Transmit1
+	CP15_DBR1 mrc,r0	//read mask
+	bl	PrintHex
+	b	10f
+3:
+	tst	r5,#3<<2
+	beq	10f
+4:
+	CP15_DBR1 mrc,r0
+	bl	PrintHex
+	mov	r5,r5,LSR #2
+	bl	20f
+10:	b	Prompt
+
+
+20:
+	BigMov	r0,L4(SPACE,R,W,SPACE)
+	tst	r5,#1
+	beq	21f
+	tst	r5,#2
+	BigEor2Eq r0,L4(SPACE,R,W,SPACE)^L4(SPACE,SPACE,W,SPACE)	//store only
+	BigEor2Ne r0,L4(SPACE,R,W,SPACE)^L4(SPACE,R,SPACE,SPACE)	//load only
+21:
+	b	Transmit1
+
+WC_Cmd:
+	mov	r0,#0
+	CP15_DBCON mcr,r0
+	b	Prompt
+WRW_Cmd:
+	mov	r4,#2
+	b	WW_JOIN
+WR_Cmd:
+	mov	r4,#3
+	b	WW_JOIN
+WW_Cmd:
+	mov	r4,#1
+WW_JOIN:
+	tst	rValidCnt,#F_NUM1_MASK
+	beq	WatchStatus
+	tst	rSymbol,#F_NUM1_MASK
+	mov	r0,rNum1
+	blne	GetSymValue
+	mov	rNum1,r0
+
+	tst	rValidCnt,#F_NUM2_MASK
+	beq	3f
+	tst	rSymbol,#F_NUM2_MASK
+	mov	r0,rNum2
+	blne	GetSymValue
+	mov	rNum2,r0
+	orr	r4,r4,#0x100	//mask
+1:
+	mov	r0,#0
+	CP15_DBCON mcr,r0
+	CP15_DBR0 mcr,rNum1
+	CP15_DBR1 mcr,rNum2
+2:
+	CP15_DBCON mcr,r4
+	b	Prompt
+3:
+	CP15_DBCON mrc,r5
+	mov	rNum2,#0
+	tst	r5,#0x100
+	bne	1b		//br if mask was used previously
+	tst	r5,#0x0f
+	beq	1b
+	mov	r0,#0
+	CP15_DBCON mcr,r0
+	tst	r5,#3
+	orreq	r4,r5,r4
+	bicne	r5,r5,#3<<2
+	orrne	r4,r5,r4,LSL #2
+	CP15_DBR0 mcreq,rNum1
+	CP15_DBR1 mcrne,rNum1
+	b	2b
+
+
+//IN: rNum2 address
+//OUT: r1:r0 val
+GetSymValue:
+	BigAdd	r2,rNum2,-DEBUG_SYM
+	cmp	r2,#SYM_LAST+1
+	bcc	GetRegVal
+	mov	r0,rNum2
+	mov	r1,#0
+	mov	pc,lr
+//IN: rPrevNum1 address or symbol
+//OUT: r1:r0 val
+GetValue:
+	BigAdd	r2,rPrevNum1,-DEBUG_SYM
+	cmp	r2,#SYM_LAST+1
+	bcc	GetRegVal
+	ldr	r0,[rPrevNum1]
+	mov	r1,#0
+	mov	pc,lr
+
+
+//IN: rNum1 address
+PrintLocationOrRegVal:
+	BigAdd	r2,rNum1,-DEBUG_SYM
+	cmp	r2,#SYM_LAST+1
+	bcc	PrintRegVal
+	tst	r5,#3
+	tsteq	rNum1,#3
+	bne	1f
+	ldr	r0,[rNum1]
+	b	PrintHex
+1:	ldrb	r0,[rNum1]
+	b	PrintHexByte
+
+//IN: rPrevNum1 address, r1:r0 - value
+StoreLocationOrReg:
+	BigAdd	r2,rPrevNum1,-DEBUG_SYM
+	cmp	r2,#SYM_LAST+1
+	bcc	StoreRegVal
+	tst	r5,#3
+	tsteq	rPrevNum1,#3
+	bne	1f
+	str	r0,[rPrevNum1]
+	mov	pc,lr
+1:	strb	r0,[rPrevNum1]
+	mov	pc,lr
+
+GetChangeAmount:
+	BigAdd	r0,rPrevNum1,-DEBUG_SYM
+	cmp	r0,#SYM_LAST+1
+	movcs	r0,#4
+	movcc	r0,#1
+	tst	r5,#3
+//	tsteq	rPrevNum1,#3
+	movne	r0,#1
+	mov	pc,lr
+
+Examine_Cmd:
+	tst	rValidCnt,#F_NUM1_MASK
+	moveq	rNum1,rPrevNum1
+	movne	rPrevNum1,rNum1
+	mov	r5,rNum1
+	tst	rValidCnt,#F_NUM2_MASK
+	bne	12f
+1:	mov	r0,rNum1
+	bl	PrintHexOrSymbol
+	mov	r0,#L1(FSLASH)
+	bl	Transmit
+
+	bl	PrintLocationOrRegVal
+
+	bl	TransmitSPACE
+	mov	rFieldStart,#1<<(F_INC+F_INC+F_INC+F_INC)	//blank before num2 field
+	str	r5,[rDBG,#DBG_TEMP]
+	bl	ReadCommand
+	ldr	r5,[rDBG,#DBG_TEMP]
+	mov	r3,r0			//save exit character
+	mov	r0,rNum2
+	mov	r1,#0
+	tst	rSymbol,#F_NUM2_MASK
+	beq	20f
+	blne	GetSymbolNumber
+	bne	Invalid
+	mov	rNum2,r0
+	bl	GetSymValue
+
+20:
+	cmp	r3,#L1(PLUS)
+	cmpne	r3,#L1(MINUS)
+	cmpne	r3,#L1(AT_SIGN)
+	beq	2f
+	tst	rValidCnt,#F_NUM2_MASK
+	beq	Prompt
+	bl	StoreLocationOrReg
+	mov	r3,#L1(PLUS)
+	b	3f
+
+2:	mov	r0,r3
+	bl	Transmit
+3:	bl	TransmitCRLF
+	bl	GetChangeAmount
+	cmp	r3,#L1(AT_SIGN)
+	beq	5f
+	cmp	r3,#L1(PLUS)
+	addeq	rPrevNum1,rPrevNum1,r0
+	subne	rPrevNum1,rPrevNum1,r0
+4:	mov	rNum1,rPrevNum1
+	b	1b
+
+5:	bl	GetValue
+	mov	rPrevNum1,r0
+	mov	r5,r0
+	b	4b
+
+11:	sub	r0,rNum1,r5
+	cmp	r0,#0x1000
+	bhs	Prompt		//no more than 128 lines per examine command
+	bl	TransmitCRLF
+12:	mov	r0,rNum1
+	bl	PrintHexOrSymbol
+	mov	r0,#L1(FSLASH)
+	bl	Transmit
+13:
+	bl	GetChangeAmount
+	bcc	14f
+	add	r0,rNum1,#3
+	cmp	r0,rNum2
+	bhi	16f
+	tst	r5,#3
+	tsteq	rNum1,#3
+	bne	16f
+14:	bl	PrintLocationOrRegVal
+	bl	GetChangeAmount
+15:	add	rNum1,rNum1,r0
+	cmp	rNum1,rNum2
+	bhi	Prompt
+	tst	rNum1,#0x1f
+	beq	11b
+	bl	TransmitSPACE
+	tst	rNum1,#0x0f
+	bleq	TransmitSPACE
+	b	13b
+16:
+	ldrb	r0,[rNum1]
+	bl	PrintHexByte
+	mov	r0,#1
+	b	15b
+	
+Deposit_Cmd:
+	tst	rValidCnt,#F_NUM1_MASK
+	beq	Invalid
+	tst	rValidCnt,#F_NUM2_MASK
+	beq	Invalid
+	mov	r0,rNum2
+	mov	r1,#0
+	tst	rSymbol,#F_NUM2_MASK
+	blne	GetSymValue
+	mov	rPrevNum1,rNum1
+	bl	StoreLocationOrReg
+	b	Prompt
+
+
+Download_Cmd:
+	tst	rValidCnt,#F_NUM1_MASK
+	beq	Invalid
+	tst	rNum1,#3
+	bne	Invalid
+	cmp	rNum1,#MEM_START
+	bcc	Invalid			//br if rNum1 is below ram start,
+					//NOTE: arm sets the carry to the opposite of most processors on subtract, compare
+
+	mov	rDest,rNum1
+	mov	rDestHead,rNum1
+	mov	rPrevNum1,rNum1
+	mov	rPrevCRC,#0
+	mov	rRunningCRC,#0
+	mov	rNak,#L1(C)		//current NAK character
+	mov	rBlockNum,#1		//block # to receive
+
+#if DDEBUG
+	b	47f
+91:
+	cmp	rBlockNum,#1
+	beq	47f
+	mov	r2,#L1(1)
+	b	45f
+92:
+	mov	r2,#L1(2)
+	b	45f
+93:
+	mov	r2,#L1(3)
+	b	45f
+94:
+	mov	r2,#L1(4)
+	b	45f
+95:
+	mov	r2,#L1(5)
+45:
+	BigMov	r0,L3(CAN,CAN,CAN)	//abort
+	bl	Transmit1
+46:	bl	Receive
+	bne	46b			//branch until timeout
+	mov	r0,r2
+	bl	Transmit
+	b	Invalid
+#else
+91:
+92:
+93:
+94:
+95:
+#endif
+
+47:
+
+	mov	r0,rNak
+15:
+	bl	Transmit
+2:	bl	Receive
+	beq	91b			//branch on timeout
+
+	mov	rPacketLength,#128-1
+	cmp	r0,#SOH
+	addne	rPacketLength,rPacketLength,#1024-1-(128-1)
+	cmpne	r0,#STX
+	beq	3f
+	cmp	r0,#CAN
+	bne	16f
+	bl	Receive
+	cmp	r0,#CAN
+	bne	10f
+	b	Invalid
+16:	cmp	r0,#EOT
+	bne	10f
+	mov	r0,#ACK
+	bl	Transmit
+
+#if DDEBUG
+	mov	rDestHead,rDest
+	mov	r0,rDest
+	bl	PrintHex
+	bl	TransmitSPACE
+	mov	r0,rBlockNum
+	bl	PrintHex
+
+	bl	TransmitSPACE
+	mov	r0,rRunningCRC
+	bl	PrintHex
+	mov	rDest,rDestHead
+#endif
+
+// now verify that ram is STILL valid by recomputing the CRC
+	mov	rCRC,#0
+	mov	r1,rPrevNum1
+	b	83f
+82:
+	ldrb	r0,[r1],#1
+//
+	eor	r0,rCRC,r0,LSL #24
+	eor	r0,r0,r0,LSR #4		//c is in high byte of r0
+	and	r0,r0,#0xff000000
+
+	mov	rCRC,rCRC,LSL #8
+	eor	rCRC,rCRC,r0,LSL #4
+	orr	rCRC,rCRC,r0,LSR #8
+
+	eor	rCRC,rCRC,r0,LSR #3
+//
+83:	cmp	r1,rDest
+	bne	82b
+#if DDEBUG
+	bl	TransmitSPACE
+	mov	r0,rCRC
+	bl	PrintHex
+#endif
+
+	cmp	rCRC,rRunningCRC
+	bne	84f
+	BigMov	r0,L3(O,K,SPACE)
+	bl	Transmit1
+	mov	r0,rPrevNum1
+	mov	rDestHead,rDest
+	bl	PrintHex
+	mov	r0,#L1(MINUS)
+	bl	Transmit
+	mov	r0,rDestHead
+	bl	PrintHex
+	b	Prompt
+84:
+	BigMov	r0,L4(E,R,R,O)
+	bl	Transmit1
+	mov	r0,#L1(R)
+	bl	Transmit
+	b	Prompt
+
+3:	bl	Receive
+	beq	92b
+	mov	r2,r0
+	bl	Receive
+	beq	93b
+	eor	r0,r0,#0xff
+	cmp	r0,r2			//check 1's complement blk #
+	bne	10f
+	cmp	r2,rBlockNum		//check blk #
+	bne	20f
+80:
+	mov	rDestHead,rDest		//rDestHead - start of buffer, rDest end of buffer
+	mov	rPrevCRC,rRunningCRC
+	mov	rCRC,#0			//crc
+
+//alternative CRC calculation routines
+	.if 0
+	BigMov	r2,CRC_POLY
+4:	bl	Receive
+	beq	8f			//branch on timeout
+	eor	rCRC,rCRC,r0,LSL #24
+	mov	r1,#8
+5:
+	movs	rCRC,rCRC,LSL #1
+	eorcs	rCRC,rCRC,r2
+	subs	r1,r1,#1
+	bne	5b
+	strb	r0,[rDest],#1
+	subs	rPacketLength,rPacketLength,#1
+	bge	4b
+	mov	rCRC,rCRC,LSR #16	//CRC was only in the high half
+
+	.endif
+
+
+
+	.if 1
+4:	bl	Receive
+	beq	8f			//branch on timeout
+//
+//calculate CRC
+//unsigned int crc = 0;
+//unsigned int c = 0;
+//for (i=3; i<max; i++)
+//{
+//	c = crc ^ (buf[i]<<24);
+//	c ^= (c >> 4);
+//	c &= 0xff000000;
+//	crc = (((crc<<8) ^ (c << 4)) |  (c>>8)) ^ (c >> 3);
+//}
+//crc >>= 16;
+//
+	eor	r1,rCRC,r0,LSL #24
+	eor	r1,r1,r1,LSR #4
+	and	r1,r1,#0xff000000
+
+	mov	rCRC,rCRC,LSL #8
+	eor	rCRC,rCRC,r1,LSL #4
+	orr	rCRC,rCRC,r1,LSR #8
+	eor	rCRC,rCRC,r1,LSR #3
+
+//also save a running total CRC to use to verify RAM after download is complete
+//
+	eor	r1,rRunningCRC,r0,LSL #24
+	eor	r1,r1,r1,LSR #4		//c is in high byte of r1
+	and	r1,r1,#0xff000000
+
+	mov	rRunningCRC,rRunningCRC,LSL #8
+	eor	rRunningCRC,rRunningCRC,r1,LSL #4
+	orr	rRunningCRC,rRunningCRC,r1,LSR #8
+
+	eor	rRunningCRC,rRunningCRC,r1,LSR #3
+//
+#if LITTLE_ENDIAN
+	mov	r0,r0,LSL #24
+	orr	r2,r0,r2,LSR #8		//this assumes a little endian memory system
+#else
+	orr	r2,r0,r2,LSL #8		//this assumes a big endian memory system
+#endif
+
+	tst	rPacketLength,#3
+	streq	r2,[rDest],#4
+	subs	rPacketLength,rPacketLength,#1
+	bge	4b
+	mov	rCRC,rCRC,LSR #16	//CRC was only in the high half
+	.endif
+
+
+
+
+	bl	Receive
+	beq	8f			//branch on timeout
+	mov	r2,r0
+	bl	Receive
+	beq	8f			//branch on timeout
+	add	r2,r0,r2,LSL #8
+	cmp	rCRC,r2
+	bne	9f			//branch on crc mismatch
+//packet is good
+	add	rBlockNum,rBlockNum,#1
+	and	rBlockNum,rBlockNum,#0xff
+	mov	rNak,#NAK
+	mov	r0,#ACK
+	b	15b
+20:
+	sub	r1,rBlockNum,#1
+	and	r1,r1,#0xff
+	cmp	r1,r2
+	bne	21f			//br if not trying to transmit the packet I just ACKed
+	mov	rDest,rDestHead		//reset pointer to previous packet
+	mov	rRunningCRC,rPrevCRC
+	mov	rBlockNum,r1		//correct blk #
+	b	80b
+
+21:	BigMov	r0,L3(CAN,CAN,CAN)	//abort code
+	bl	Transmit1
+48:	bl	Receive
+	bne	48b			//branch until timeout
+
+#if DDEBUG
+	mov	r0,r2
+	bl	PrintHex
+	bl	TransmitSPACE
+	mov	r0,rBlockNum
+	bl	PrintHex
+#endif
+
+	b	Invalid			//give up
+
+
+8:	mov	rDest,rDestHead		//reset register
+	mov	rRunningCRC,rPrevCRC
+	b	94b			//send NAK
+9:
+#if DDEBUG				//debug code
+	BigMov	r0,L3(CAN,CAN,CAN)	//abort code
+	bl	Transmit1
+44:	bl	Receive
+	bne	44b			//branch until timeout
+	mov	r0,r2
+	bl	PrintHex
+	bl	TransmitSPACE
+	mov	r0,rCRC
+	bl	PrintHex
+	b	Invalid
+#endif
+
+	mov	rDest,rDestHead
+	mov	rRunningCRC,rPrevCRC
+
+
+10:	bl	Receive
+	bne	10b			//branch until timeout
+	b	95b			//send NAK and wait for packet
+
+
+
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+//Code above this point must fit in 2k mini cache or be burned on flash
+//
+//Code below this point need not be in the 2k mini-instruction cache,
+//it can be temporarily placed in the main instruction cache unlocked
+// *******************************************************************************************
+
+InitializeCont1:
+//pc - 0-0x4000, 0x04000000-0x04004000, 0xa000000-0xffffffff
+	InitIC_Clocks	r0,sp
+	InitUART	r0,sp,FFUART_BASE,BAUDRATE
+	InitUART	r0,sp,BTUART_BASE,BAUDRATE
+	InitUART	r0,sp,STUART_BASE,9600
+	InitChangeCPUSpeed r0
+	InitMemory	r0,sp,r1
+	BigMov	r1,MACH_TYPE_SCANPASS
+	SaveRegisters	r0,sp
+// *******************************************************
+	InitMMU		r0
+	InitPWR		r0,r1,sp	//out: r1 RCSR
+InitializeCont2:
+	cmp	pc,#MEM_START
+	bhs	89f				//if in ram, must be mdebug
+	bic	sp,pc,#FLASH_BASE_ADDRESS
+	cmp	sp,#0x4000
+	mov	r2,#FUNC_REQ_GL
+	bhs	87f				//br if not part of reset vector
+	tst r1,#RCSR_SLEEP_RESET
+	beq 89f		//;  Not sleep.
+	mov	r2,#FUNC_REQ_WAKEUP
+87:	adr	r7,88f
+	adr	lr,89f
+	mov	r10,r1	//RCSR
+	b	TryRoutine1
+88:	ldmia	sp,{rPrevNum1,rUart,rDBG}
+89:
+	mov	r2,lr
+	bl	CalcMemEnd
+	mov	r3,r0
+	mov	lr,r2
+// *******************************************************
+//0xnnnn0000 - 16k  remapping of flash address 0 for relocated vector table
+//0xnnnn4000 - 16k 16k 1st level descriptors table
+//0xnnnn8000 - 16k  2 x 1k 2nd level descriptor tables
+//0xnnnnc000 - 16k  12k skipped, 4k debug data
+//end of ram
+	BigSub	sp,r3,0x8000
+	sub	r2,sp,#0x4000
+	mov	r1,r2
+	BigMov	r0,0x0402			//section descriptor, ap-01, privileged r/w
+						//map virt to phys 1-to-1, non-cache, non-bufferable
+1:	str	r0,[r2],#4
+	add	r0,r0,#1<<20
+	cmp	r2,sp
+	bne	1b
+
+
+	add	sp,r1,r3,LSR #(20-2)
+	add	r1,r1,#((MEM_START>>20)&0xfff)<<2	//microsoft assembler bug propagates the sign bit
+	BigMov	r0,(MEM_START&0xfff00000)+0x040A	//cacheable (write through)
+2:	str	r0,[r1],#4
+	cmp	r1,sp
+	addne	r0,r0,#1<<20
+	bne	2b
+//r0 is physical address of last meg of memory
+	orr	r1,r2,#1			//2nd level descriptor address (1k boundary), coarse page table
+
+	.ifdef __ARMASM
+	GBLA TABLE_CNT
+	.endif
+	.if  ((DEBUG_START&0xfff00000) - (0xffff0000&0xfff00000))
+	.set	TABLE_CNT,2
+	str	r1,[r2,#((DEBUG_START>>18)&0x3ffc)-0x4000] //r2 is the end of the 16k table
+	add	r1,r1,#0x400
+
+	.else
+	.set	TABLE_CNT,1
+	.endif
+
+	str	r1,[r2,#-4]			//map (0xfff00000) to 2nd level page table
+						//last meg of memory (contains relocated reset vector)
+	add	sp,r2,#((256*TABLE_CNT)-16)<<2		//256 - 4byte entries each mapping 4k
+
+//clear out 1 or 2  level 2 page tables
+	mov	r1,#0
+3:	str	r1,[r2],#4
+	cmp	r2,sp
+	bne	3b
+
+
+	BigMov	r1,0x559			//map to flash in 1 - 64k page
+	add	sp,sp,#16<<2
+4:	str	r1,[r2],#4
+	cmp	r2,sp
+	bne	4b
+
+	bic	r0,r0,#0x000ff
+	orr	r0,r0,#0x0000e			//cacheable writeback 4k page
+//	orr	r0,r0,#0x0000a			//cacheable writethru 4k page
+	orr	r0,r0,#0x00aa0			//privileged r/w, user read
+	orr	r0,r0,#0xff000			//last 4k of ram
+
+	str	r0,[r2,#((DEBUG_START>>10)&0x3fc)-(TABLE_CNT*0x400)] //debug variables, r2 is end of 1k tables
+
+	BigMov	r0,0xffffffff
+	CP15_DACR mcr,r0
+
+	BigSub	r0,r3,0xc000			//MEM_END-0xc000
+	CP15_TTBR mcr,r0
+//enable MMU
+	CP15_TLB_UNLOCK_I mcr,r0
+	CP15_TLB_UNLOCK_D mcr,r0
+	CP15_TLB_INVAL_BOTH mcr,r0
+
+	CP15_CONTROL mrc,r1		//get the control register
+	orr	r1,r1,#0x1			//set bit 0 - enable MMU
+	CPWAIT	r0
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+
+//enable the instruction cache
+	CP15_CF_UNLOCK_I mcr,r0
+//	CP15_CF_INVAL_I mcr,r0		//I might be running from cache only, don't invalidate
+
+	orr	r1,r1,#0x1000			//set bit 12 -- the I bit
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+
+//enable the data cache
+	CP15_CF_UNLOCK_D mcr,r0
+	CP15_CF_INVAL_D mcr,r0		//this will also drain write buffer
+	CP15_CF_DRAIN mcr,r0		//make sure it is drained just to be very safe
+
+	orr	r1,r1,#0x4			//set bit 4 -- the D bit
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+
+	.if 0
+//if not in halt mode, lock 64k of flash remap in instruction TLB(contains override relocated vector table)
+//halt mode uses the mini cache and physical addresses only for this
+	CP14_DCSR mrc,r0
+	BigMov	r1,0xffff0000
+	tst	r0,#0x40000000
+//I am currently executing from flash, marked as uncacheable
+	CP15_TLB_LOCK_IENTRY mcreq,r1	//lock 64k if not in halt mode
+	CPWAIT	r0
+	.endif
+
+//now lock debug data into data cache
+	BigMov	r1,DEBUG_START
+	mov	r2,#DEBUG_SPACE>>5		//3 or 4 cache lines to lock
+	CP15_TLB_LOCK_DENTRY mcr,r1
+	mov	sp,#1
+	CP15_CF_LOCK_D_CSR mcr,sp		//data cache is into lock mode
+	CPWAIT	r0
+5:	pld	[r1]
+	add	r1,r1,#32			//lock and load
+	CP15_CF_DRAIN mcr,r0
+	subs	r2,r2,#1
+	bne	5b
+
+	mov	sp,#0
+	CP15_CF_LOCK_D_CSR mcr,sp		//data cache is out of lock mode
+	CPWAIT	r0
+
+	BigMov	r0,0x3fff
+	CP15_CP_ACCESS mcr,r0		//enable access to all coprocessors
+//now disable MMU, Data Cache
+	.if 1
+	CP15_CONTROL mrc,r1		//get the control register
+	bic	r1,r1,#0x5
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+	.endif
+#if (DO_GPTEST==0)
+//	TransMacro L1(U)
+
+#if (PLATFORM_TYPE==BD2003) || (PLATFORM_TYPE==BOUNDARY_OLD_BOARD) || (PLATFORM_TYPE==OLD_GAME_CONTROLLER) || (PLATFORM_TYPE==HALOGEN)
+	sub	r0,r3,#0x100000		//last meg-8k for video ram
+	sub	r1,r3,#0x2000		//8K from end, last 4k is debug variables
+	str	r1,[r1,#FDESC_FDADR]		//next frame descriptor address, loop to self
+	str	r0,[r1,#FDESC_FSADR]		//start of frame
+	str	r0,[r1,#FDESC_FIDR]		//id of frame, anything I want
+	BigMov	r2,SCREEN_WIDTH*SCREEN_HEIGHT*BYTES_PER_PIXEL
+	str	r2,[r1,#FDESC_DCMD]		//length of dma transfer
+
+#if (BYTES_PER_PIXEL==2)
+	BigMov	sp,(BLUE_VAL<<0)+(GREEN_VAL<<5)+(RED_VAL<<11)		//rgb value
+	orr		sp,sp,sp,LSL #16
+79:	str		sp,[r0],#4
+	subs	r2,r2,#4
+	bne		79b
+#else
+	BigMov	r1,(BLUE_VAL<<0)+(GREEN_VAL<<6)+(RED_VAL<<12)		//rgb value
+	orr		r1,r1,r1,LSL #24
+
+	mov		sp,r1,LSR #8
+	orr		sp,sp,sp,LSL #24
+
+	mov		lr,sp,LSR #8
+	orr		lr,lr,lr,LSL #24
+79:	stmia	r0!,{r1,sp,lr}
+	subs	r2,r2,#12
+	bne		79b
+	sub		r1,r3,#0x2000		//8K from end, last 4k is debug variables
+#endif
+
+	InitLCD	r0,sp,r1	//r1 has descriptor address
+#endif
+
+
+// ****************************
+	mrs	r1, CPSR
+	bic	r2, r1,#PSR_MODE_MASK
+	orr	r0, r2,#PSR_NOINTS_MASK+PSR_MODE_SVC	//change to supervisor stack
+	msr	CPSR_c, r0
+	BigMov	r0,SS_START+SS_SUPERVISOR
+	mov	sp, r0
+
+	orr	r2, r2, #PSR_NOINTS_MASK+PSR_MODE_IRQ	//irq stack
+	msr	CPSR_c, r2
+	BigAdd	sp, r0, SS_IRQ
+
+	sub	r2, r2, #PSR_MODE_IRQ-PSR_MODE_FIQ		//fiq stack
+	msr	CPSR_c, r2
+	BigAdd	sp, r0, SS_IRQ+SS_FIQ
+
+	add	r2, r2, #PSR_MODE_SYSTEM-PSR_MODE_FIQ	//system(user mode)
+	msr	CPSR_c, r2
+	BigAdd	sp, r0, SS_IRQ+SS_FIQ+SS_SYSTEM
+
+	sub	r2, r2, #PSR_MODE_SYSTEM-PSR_MODE_UNDEF	//undefined stack
+	msr	CPSR_c, r2
+	BigAdd	sp, r0, SS_IRQ+SS_FIQ+SS_SYSTEM+SS_UNDEFINED
+
+	sub	r2, r2, #PSR_MODE_UNDEF-PSR_MODE_ABORT	//Abort stack
+	msr	CPSR_c, r2
+	BigAdd	sp, r0, SS_IRQ+SS_FIQ+SS_SYSTEM+SS_UNDEFINED+SS_ABORT
+//
+	msr	CPSR_c, r1
+	sub	r2, r2, #PSR_MODE_ABORT-PSR_MODE_SVC	//supervisor stack
+
+// ****************************
+	CP14_DCSR mrc,sp
+	tst	sp,#1<<5		//test sticky abort bit
+	mov	sp,r0
+	BigMovEq r0,DEBUG_BASE+DBG_MAGIC
+	BigAddNe r0,r3,(-0x1000+((DEBUG_BASE+DBG_MAGIC)&0xfff)) //don't use virtual address if memory isn't working right
+	sub	r0,r0,#DBG_MAGIC
+
+	and	r1,r1,#PSR_MODE_MASK
+	mov	r3,#0
+	cmp	r1,#PSR_MODE_DEBUG
+	BigMov	lr,0xa0008000		//default start pc
+	beq	SaveDebug		//br if a debug exception in halt mode
+	mov	r1,#SIG_RESET
+	b	SaveR4andUp
+#else
+//#define GPBIT 2
+//#define GPL GPLR1
+#define GPBIT 9
+#define GPL GPLR0
+#define GPMASK (1<<GPBIT)
+GPTest:
+	BigMov	rUart,UART_BASE
+	BigMov	fp,GPIO_BASE
+	mov	r6,#GPMASK
+	str	r6,[fp,#GPSR0]
+
+2:	bl	TransmitCRLF
+	mov	r3,#40
+20:	mov	r2,#0x300000
+
+1:	ldr	r0,[fp]
+	and	r0,r1,#GPMASK
+	cmp	r0,r6
+	subnes	r2,r2,#1
+	bne	1b			//wait for desired state
+
+	mov	r1,#L1(0)
+	add	r0,r1,r0,LSR #GPBIT
+	bl	Transmit
+
+	mov	r0,#GPMASK
+	eors	r6,r6,#GPMASK		//get new desired state
+	streq	r0,[fp,#GPCR0]
+	strne	r0,[fp,#GPSR0]
+	subs	r3,r3,#1
+	bne	20b
+	b	2b
+#endif
+
+
+
+
+	.if 0		//macro tests
+	BigMov	r0,-1
+	BigMov	r0,-5
+	BigMov	r0,0x0ffffff0
+	BigMov	r0,1
+	BigMov	r0,0xff
+	BigMov	r0,0xf000000f
+	BigMov	r0,0x80010003
+	.endif
+
+
+TransLineR3:
+	mov	r4,#0
+TransLineR4:
+	mov	r5,#0
+TransLineR5:
+	mov	r6,#0
+TransLineR6:
+	mov	r7,#0
+TransLineR7:
+	mov	fp,lr
+	mov	r0,r2
+	bl	Transmit1
+
+	BigEor	r0,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(SPACE,SPACE,MINUS,SPACE)
+	bl	Transmit1
+
+	mov	r0,r3
+	bl	Transmit1
+	movs	r0,r4
+	blne	Transmit1
+	movs	r0,r5
+	blne	Transmit1
+	movs	r0,r6
+	blne	Transmit1
+	movs	r0,r7
+	blne	Transmit1
+	mov	lr,fp
+	b	TransmitCRLF
+
+Help_Cmd:
+	BigMov	rSP,L2(SPACE,SPACE)
+	orr	rSP,rSP,rSP,LSL #16
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(B,C,SPACE,SPACE)	//BC  -Breakpoint clear
+	BigEor	r3,r2, L4(B,C,SPACE,SPACE)^L4(B,r,e,a)
+	BigMov	r4,			   L4(k,p,o,i)
+	BigEor	r5,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(n,t,SPACE,c)
+	BigMov	r6,			   L4(l,e,a,r)
+	bl	TransLineR6
+
+	BigEor2	r2,L4(B,C,SPACE,SPACE)    ^L4(B,E,SPACE,SPACE)	//BE  -Breakpoint examine
+	BigEor2	r5,L4(n,t,SPACE,c)    ^L4(n,t,SPACE,e)
+	BigMov	r6,			   L4(x,a,m,i)
+	BigMov	r7,			   L2(n,e)
+	bl	TransLineR7
+
+	BigEor2	r2,L4(B,E,SPACE,SPACE)    ^L4(B,S,SPACE,SPACE)	//BS  -Breakpoint set
+	BigEor2	r5,L4(n,t,SPACE,e)    ^L4(n,t,SPACE,s)
+	BigMov	r6,			   L2(e,t)
+	bl	TransLineR6
+
+	BigEor2	r2,L4(B,S,SPACE,SPACE)	  ^L4(B,U,R,N)	//BURN-Write to flash
+	BigMov	r3,			   L4(W,r,i,t)
+	BigEor	r4,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(e,SPACE,t,o)
+	BigMov	r5,			   L4(SPACE,f,l,a)
+	BigMov	r6,			   L2(s,h)
+	bl	TransLineR6
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(E,SPACE,SPACE,SPACE)	//E   -Examine
+	BigEor	r3,r2, L4(E,SPACE,SPACE,SPACE)^L4(E,x,a,m)
+	BigMov	r4,			   L3(i,n,e)
+	bl	TransLineR4
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(D,SPACE,SPACE,SPACE)	//D   -Deposit
+	BigEor	r3,r2, L4(D,SPACE,SPACE,SPACE)^L4(D,e,p,o)
+	BigMov	r4,			   L3(s,i,t)
+	bl	TransLineR4
+
+	BigEor2	r2,L4(D,SPACE,SPACE,SPACE)    ^L4(D,L,SPACE,SPACE)	//DL  -Download
+	BigEor2	r3,L4(D,e,p,o)    ^L4(D,o,w,n)
+	BigMov	r4,			   L4(l,o,a,d)
+	bl	TransLineR4
+
+	BigEor2	r2,L4(D,L,SPACE,SPACE)    ^L4(D,L,W,SPACE)	//DLW -Download wireless
+	BigEor	r5,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(SPACE,w,i,r)
+	BigMov	r6,			   L4(e,l,e,s)
+	BigMov	r7,			   L1(s)
+	bl	TransLineR7
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(G,SPACE,SPACE,SPACE)	//G   -Go
+	BigMov	r3,			   L2(G,o)
+	bl	TransLineR3
+
+	BigEor2	r2,L4(G,SPACE,SPACE,SPACE)    ^L4(G,L,SPACE,SPACE)	//GL  -Go Linux
+	BigEor2	r3,L2(G,o)		  ^L4(G,o,SPACE,L)
+	BigMov	r4,			   L4(i,n,u,x)
+	bl	TransLineR4
+
+	BigEor2	r2,L4(G,L,SPACE,SPACE)    ^L4(G,G,SPACE,SPACE)	//GG  -Go no cache clear
+	BigEor2	r3,L4(G,o,SPACE,L)    ^L4(G,o,SPACE,n)
+	BigEor	r4,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(o,SPACE,c,a)
+	BigEor	r5,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(c,h,e,SPACE)
+	BigMov	r6,			   L4(c,l,e,a)
+	BigMov	r7,			   L1(r)
+	bl	TransLineR7
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(R,SPACE,SPACE,SPACE)	//R   -Registers
+	BigEor	r3,r2, L4(R,SPACE,SPACE,SPACE)^L4(R,e,g,i)
+	BigMov	r4,			   L4(s,t,e,r)
+	BigMov	r5,			   L1(s)
+	bl	TransLineR5
+
+	BigMov	r2,			   L4(S,S,I,D)	//SSID- Set SSID string
+	BigEor	r3,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(S,e,t,SPACE)
+	mov	r4,r2
+	BigMov	r5,			   L4(SPACE,s,t,r)
+	BigMov	r6,			   L3(i,n,g)
+	bl	TransLineR6
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(T,SPACE,SPACE,SPACE)	//T   -Trace
+	BigEor	r3,r2, L4(T,SPACE,SPACE,SPACE)^L4(T,r,a,c)
+	BigMov	r4,L1(e)
+	bl	TransLineR4
+
+	BigEor2	r2,L4(T,SPACE,SPACE,SPACE)    ^L4(T,T,SPACE,SPACE)	//TT   -Trace
+	BigEor2	r4,L1(e)		  ^L4(e,SPACE,n,o)
+	BigEor	r5,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(SPACE,c,a,c)
+	BigEor	r6,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(h,e,SPACE,c)
+	BigMov	r7,			   L4(l,e,a,r)
+	bl	TransLineR7
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(V,SPACE,SPACE,SPACE)	//V   -Verify
+	BigEor	r3,r2, L4(V,SPACE,SPACE,SPACE)^L4(V,e,r,i)
+	BigMov	r4,			   L2(f,y)
+	bl	TransLineR4
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(W,C,SPACE,SPACE)	//WC  -Watch clear
+	BigEor	r3,r2, L4(W,C,SPACE,SPACE)^L4(W,a,t,c)
+	BigEor	r4,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(h,SPACE,c,l)
+	BigMov	r5,			   L3(e,a,r)
+	bl	TransLineR5
+
+	BigEor2	r2,L4(W,C,SPACE,SPACE)    ^L4(W,R,SPACE,SPACE)	//WR  -Watch read
+	BigEor2	r4,L4(h,SPACE,c,l)    ^L4(h,SPACE,r,e)
+	BigMov	r5,			   L2(a,d)
+	bl	TransLineR5
+
+	BigEor2	r2,L4(W,R,SPACE,SPACE)    ^L4(W,R,W,SPACE)	//WRW -Watch read/write
+	BigEor2	r5,L2(a,d)            ^L4(a,d,FSLASH,w)
+	BigMov	r6,			   L4(r,i,t,e)
+	bl	TransLineR6
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(W,W,SPACE,SPACE)	//WW  -Watch write
+	BigEor2	r4,L4(h,SPACE,r,e)    ^L4(h,SPACE,w,r)
+	BigMov	r5,			   L3(i,t,e)
+	bl	TransLineR5
+
+	BigEor	r2,rSP,L4(SPACE,SPACE,SPACE,SPACE)^L4(QUESTION_MARK,SPACE,SPACE,SPACE)	//?   -Help
+	BigMov	r3,			   L4(H,e,l,p)
+	bl	TransLineR3
+
+	b	Prompt
+
+//.global	CalcMemEnd
+CalcMemEnd:
+	CalcMemSize	r1,r0,MEMORY_CONTROL_BASE			//out: r0 - mem size
+	BigAdd2	r0,MEM_START		//32 meg
+	mov	pc,lr
+
+
+//rRamSector - start (rNum1)
+//rRamEnd - end (rNum2)
+Verify_Cmd:
+	mov	r5,#CMD_VERIFY
+	b	Burn1
+Verify2_Cmd:
+	mov	r5,#CMD_VERIFY
+	b	Burn2
+BurnAll_Cmd:
+	mov	r5,#CMD_BURNALL
+	b	Burn1
+Burn2_Cmd:
+	mov	r5,#CMD_BURN
+Burn2:
+	BigMov	r4,FLASH_BASE_ADDRESS+(16<<20)
+	b	BurnContinue
+Burn_Cmd:
+	mov	r5,#CMD_BURN
+Burn1:
+	BigMov	r4,FLASH_BASE_ADDRESS
+BurnContinue:
+	tst	rValidCnt,#F_NUM1_MASK
+	tstne	rValidCnt,#F_NUM2_MASK
+	beq	Invalid
+	tst	rRamSector,#3
+	bne	Invalid
+	tst	rRamEnd,#3
+	bne	Invalid
+	cmp	rRamSector,rRamEnd
+	bhs	Invalid
+	cmp	rRamSector,#MEM_START
+	blo	Invalid			//br if rRamSector is below ram start,
+	bl	CalcMemEnd
+	mov	r1,r4
+	cmp	rRamEnd,r0
+	bhi	Invalid			//br if rRamEnd is above ram end,
+	sub	lr,rRamEnd,rRamSector
+	cmp	lr,#f128j3a_SIZE
+	bhi	Invalid
+
+	mvn		r2,#0
+	tst		rRamEnd,#1
+	strneb	r2,[rRamEnd],#1
+	tst		rRamEnd,#2
+	strneh	r2,[rRamEnd],#2
+
+//1st verify that flash needs burned
+	mov	lr,rRamSector
+1:	ldr	r2,[lr],#4
+	ldr	r3,[r1],#4
+	cmp	r2,r3
+	bne	2f
+	cmp	lr,rRamEnd
+	blo	1b
+
+	cmp	r5,#CMD_BURNALL
+	beq	3f
+	BigMov	r0,L4(V,e,r,i)
+	bl	Transmit1
+	BigMov	r0,L4(f,i,e,d)
+	bl	Transmit1
+	b	Prompt
+2:
+	sub	r1,r1,#4
+	cmp	r5,#CMD_VERIFY
+	bne	3f
+	sub	r0,lr,#4
+20:
+	bl	Burn_error
+	b	Prompt
+3:
+	mov	rFlashSector,r1,LSR #18
+	mov	rFlashSector,rFlashSector,LSL #18		//round to 256k boundary
+	add	rRamSector,rRamSector,rFlashSector
+	sub	rRamSector,rRamSector,r4
+	BigMov	r3,MEMORY_CONTROL_BASE
+	tst	rFlashSector,#1<<26
+	ldr	r1,[r3,#MSC0]
+	movne	r1,r1,LSR #16	//nCS1 being used for flash
+	tst	r1,#1<<3		//bit 3 - 1 means 16 bit mode
+	adr	r4,Burn_Rtn32
+	ldr	r3,[r4]
+	BigMov	r2,0xe58d5054	//NOTE: when 1st instruction of Burn_Rtn32 changes (or DBG_TEMP value), this must change as well
+	adrne	r4,Burn_Rtn16
+
+	cmp	r4,#MEM_START
+	bhs	10f
+//I must move the burn code, unless I'm only running from cache
+	cmp	r2,r3
+	bne	10f
+	tst	r1,#1<<3		//bit 3 - 1 means 16 bit mode
+	BigAdd	r1,r0,(-0x1000+((DEBUG_BASE+DBG_START)&0xfe0)-32)
+	moveq	r3,#((Burn_Rtn_End-Burn_Rtn32)+0x1f)&(~0x1f)	//round to 32 byte (cache line)boundary
+	movne	r3,#((Burn_Rtn_End-Burn_Rtn16)+0x1f)&(~0x1f)	//round to 32 byte (cache line)boundary
+	add	r2,r4,r3
+	sub	r1,r1,r3
+	mov	r0,r1
+4:	ldr	r3,[r4],#4
+	str	r3,[r1],#4
+	cmp	r4,r2
+	blo	4b
+
+	mov	r4,r0
+5:
+	CP15_CF_INVAL_ILINE mcr,r4
+	add	r4,r4,#32
+	cmp	r4,r1
+	blo	5b
+
+	CP15_CF_INVAL_BTB mcr,r4
+
+	CP15_CF_DRAIN mcr,r4	//data cache is disabled, but it should still drain first
+	CPWAIT	r1
+
+	BigMov	rFlashBase,FLASH_BASE_ADDRESS
+	mov	rRet,#0
+	blx	r0
+	b	20b		//unknow Man/dev Id if it returns from here
+
+10:
+//I'm running from ram, or from cache only
+	BigMov	rFlashBase,FLASH_BASE_ADDRESS
+	adr	rRet,11f
+	blx	r4
+	b	20b		//unknow Man/dev Id if it returns from here
+11:	b	Prompt
+
+
+
+
+//BurnRtn istr,ildr,mask,shift,inc,plait
+Burn_Rtn32:
+	BurnRtn str,ldr,0xffffffff,0,0,4,0
+Burn_Rtn16:
+#if 1
+	BigMov	r0,FLASH_STATUS_CLEAR_CMD&0xffff
+	strh	r0,[rFlashBase,#0]
+	delay
+	BigMov	r0,FLASH_ID_CMD&0xffff
+	strh	r0,[rFlashBase,#0]
+	delay
+	ldrh	r2,[rFlashBase,#2]
+
+	BigMov	r0,FLASH_READ_CMD&0xffff
+	strh	r0,[rFlashBase,#0]
+	delayCnt r0,((40/10)*COUNT_MULT)
+	cmp	r2,#0x16
+	cmpne	r2,#0x17
+	cmpne	r2,#0x18
+	beq	99f
+//(PLATFORM_TYPE==GAME_CONTROLLER_PLAITED_A1)
+	BurnRtn strh,ldrh,  0xffff,0,1,4,1		//the plait version (a1 jumpered to a high address line)
+99:
+	BurnRtn strh,ldrh,  0xffff,1,1,2,0		//the non-plait version (a1 correct)
+#else
+
+#if (PLATFORM_TYPE==GAME_CONTROLLER_PLAITED_A1)
+	BurnRtn strh,ldrh,  0xffff,0,1,4,1		//the plait version (a1 jumpered to a high address line)
+#else
+99:
+	BurnRtn strh,ldrh,  0xffff,1,1,2,0		//the non-plait version (a1 correct)
+#endif
+
+#endif
+
+Timeout:
+	BigMov	r0,L4(T,i,m,e)
+	bl	TransmitR
+	BigMov	r0,L4(d,SPACE,o,u)
+	bl	TransmitR
+	BigMov	r0,L2(t,SPACE)
+	bl	TransmitR
+
+	mov	r0,rRamSector
+	mov	r1,rFlashSector
+	ldr	r2,[r0]
+	ldr	r3,[r1]
+	bl	Burn_error
+	b	Burn_return
+
+ReturnError:
+	sub	r0,r0,#4
+	sub	r1,r1,#4
+	bl	Burn_error
+	b	Burn_return
+
+PrintSector:
+	mov	r5,lr
+	bl	TransmitR_CRLF
+	BigMov	r0,L4(S,e,c,t)
+	bl	TransmitR
+	BigMov	r0,L3(o,r,SPACE)
+	bl	TransmitR
+	mov	r0,rFlashSector
+	bl	PrintHexR
+	mov	r0,#L1(SPACE)
+	bl	TransmitR
+	mov	r0,rRamSector
+	mov	r1,rFlashSector
+	mov	pc,r5
+
+PrintErasing:
+	mov	r5,lr
+	BigMov	r0,L4(E,r,a,s)
+	bl	TransmitR
+	BigMov	r0,L4(i,n,g,SPACE)
+	mov	lr,r5
+	b	TransmitR
+
+PrintProgramming:
+	mov	r5,lr
+	BigMov	r0,L4(P,r,o,g)
+	bl	TransmitR
+	BigMov	r0,L4(r,a,m,m)
+	bl	TransmitR
+	BigMov	r0,L4(i,n,g,SPACE)
+	bl	TransmitR
+	mov	r0,rRamSector
+	mov	r1,rFlashSector
+	mov	pc,r5
+
+PrintVerifying:
+	mov	r5,lr
+	BigMov	r0,L4(V,e,r,i)
+	bl	TransmitR
+	BigMov	r0,L4(f,y,i,n)
+	bl	TransmitR
+	BigMov	r0,L4(g,PERIOD,PERIOD,PERIOD)
+	bl	TransmitR
+	mov	r0,rRamSector
+	mov	r1,rFlashSector
+	mov	pc,r5
+
+PrintSuccess:
+	bl	TransmitR_CRLF
+	BigMov	r0,L4(S,u,c,c)
+	bl	TransmitR
+	BigMov	r0,L3(e,s,s)
+	bl	TransmitR
+//	b	Burn_return
+
+Burn_return:
+	bl	TransmitR_CRLF
+	bl	WaitTxEmpty
+	movs	rRet,rRet
+	CP15_CF_INVAL_BOTH mcreq,r1	//invalidate if return is reset vector
+	CPWAIT	r1
+	mov	pc,rRet
+
+Burn_error:
+	mov	r8,lr
+	mov	r5,r1
+	mov	sl,r2
+	mov	r7,r3
+	bl	PrintHexR
+	mov	r0,#L1(COLON)
+	bl	TransmitR
+	mov	r0,sl
+	bl	PrintHexR
+	bl	TransmitSPACER
+
+	mov	r0,r5
+	bl	PrintHexR
+	mov	r0,#L1(COLON)
+	bl	TransmitR
+	mov	r0,r7
+	mov	lr,r8
+	b	PrintHexR
+
+	DEFINE_FLASH_GPIO_WAIT_FOR_IDLE
+
+
+WaitTxEmpty:
+1:	ldr	r1,[rUart,#UART_LSR]
+	ands	r1,r1,#0x40
+	beq	1b
+	mov	pc,lr			//return
+
+TransmitSPACER:
+	mov	r0,#L1(SPACE)
+	b	TransmitR
+TransmitR_CRLF:
+	BigMov	r1,L2(CR,LF)
+trR:
+	mov	r0,r1
+//IN: r0 - character to transmit
+//OUT: r0 - last character transmitted, r1 - trashed
+TransmitR:
+1:	ldr	r1,[rUart,#UART_LSR]
+	ands	r1,r1,#0x20
+	beq	1b
+	mov	r1,r0
+	and	r1,r1,#0xff
+	str	r1,[rUart,#UART_THR]
+	movs	r1,r0,LSR #8
+	bne	trR
+	mov	pc,lr			//return
+//IN: r0 - value to print
+//OUT: r0-r4 trashed
+PrintHexR:
+	mov	r2,#8
+	mov	r4,r0
+	mov	r3,lr
+1:	mov	r4,r4,ROR #28
+	and	r0,r4,#0xf
+	cmp	r0,#0xA
+	addcs	r0,r0,#L1(A)-0x0a
+	addcc	r0,r0,#L1(0)
+	bl	TransmitR
+	subs	r2,r2,#1
+	bne	1b
+	mov	pc,r3
+
+Burn_Rtn_End:
+
+
+SSID_Cmd:
+	BigMov	r0,L4(I,d,COLON,SPACE)
+	bl	Transmit1
+	bl	CalcMemEnd
+	BigAdd	r5,r0,(-0x1000+((DEBUG_BASE+DBG_START)&0xfff)-32)
+	mov	r6,#31
+1:	bl	Receive
+	beq	1b			//br on timeout
+	cmp	r0,#CR
+	beq	2f
+	strb	r0,[r5],#1
+	bl	Transmit1
+	subs	r6,r6,#1
+	bne	1b
+2:	mov	r0,#0
+	strb	r0,[r5],#1
+	b	Prompt
+
+MAC_Cmd:
+	mov	r2,#FUNC_REQ_MAC
+	b	join_cmd
+Download_Wireless_Cmd:
+	tst	rValidCnt,#F_NUM1_MASK
+	beq	Invalid
+	tst	rNum1,#3
+	bne	Invalid
+	cmp	rNum1,#MEM_START
+	bcc	Invalid			//br if rNum1 is below ram start,
+					//NOTE: arm sets the carry to the opposite of most processors on subtract, compare
+	mov	r2,#FUNC_REQ_DLW
+join_cmd:
+	bl	TryRoutine
+	ldmia	sp,{rPrevNum1,rUart,rDBG}
+	bl	SetupATAG		//dlw is now overwriting ATAG space, so set it again
+	b	Prompt
+
+//struct tag_mem32 {
+//	u32	size;
+//	u32	start;	/* physical start address */
+//};
+
+//out: r2,r7 - saved, r0 - CalcMemEnd return value
+SetupATAG:
+	mov	r3,lr
+	bl	CalcMemEnd
+	mov	lr,r3
+	BigMov	r1,TAGGED_LIST
+	BigMov	r3,2
+	BigMov	r4,ATAG_CORE
+	BigMov	r5,4
+	BigEor	r6,r4,(ATAG_MEM^ATAG_CORE)
+	stmia	r1!,{r3,r4,r5,r6}
+	BigMov	r4,MEM_START
+	BigMov	r5,0
+	sub	r3,r0,r4
+	stmia	r1,{r3,r4,r5}
+	mov	pc,lr
+
+
+Gl_Cmd:
+	mov	r2,#FUNC_REQ_PIC
+	bl	TryRoutine
+	ldmia	sp,{rPrevNum1,rUart,rDBG}
+
+	BigMov	r1,MACH_TYPE_SCANPASS
+	str	r1,[rDBG,#DBG_R1]
+	mov	r2,#FUNC_REQ_GL
+	bl	TryRoutine
+	ldmia	sp,{rPrevNum1,rUart,rDBG}
+	movs	rNum1,r4
+	bne	Go_Cmd
+	b	Prompt
+
+//r2- function select
+TryRoutine:
+	mov	r10,#0
+	mov	r7,lr
+	bl	TryRoutine1
+	b	Invalid
+//r10- RCSR
+//r2- function select
+//r7- main return
+//lr- error return
+TryRoutine1:
+	adr	r0,MiniDebugEnd
+	ldr	r1,[r0]
+	BigMov	r3,0xe1a08000
+	cmp	r1,r3
+	movne	pc,lr	//failure return
+	bl	SetupATAG	//out: r0 - calcMemEnd return value
+	mov	lr,r7
+
+	BigAdd	r1,r0,(-0x1000+((DEBUG_BASE+DBG_START)&0xfff)-32)	//@ssid
+	mov	r0,r1
+	stmdb	r0!,{rPrevNum1,rUart,rDBG}
+	mov	sp,r0
+	mov	fp,r0
+	mov	r0,rNum1
+	adr	r4,MiniDebugEnd
+	mov	r3,#DEF_DISPLAY_INDEX
+	b	HeadStart
+
+	.ifdef __ARMASM
+	DUP 6,0xffffffff
+	align 256
+	.else
+	.balignl	256,0xffffffff
+	.endif
+
+MiniDebugEnd:
+//This is defined in head.S or minidebug.lds
+//HeadStart:
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/ministart.S u-boot-1.1.2-neon/cpu/pxa/ministart.S
--- u-boot-1.1.2/cpu/pxa/ministart.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/cpu/pxa/ministart.S	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,270 @@
+/*
+ *  armboot - Startup Code for XScale
+ *
+ *  Copyright (C) 1998	Dan Malek <dmalek@jlc.net>
+ *  Copyright (C) 1999	Magnus Damm <kieraypc01.p.y.kie.era.ericsson.se>
+ *  Copyright (C) 2000	Wolfgang Denk <wd@denx.de>
+ *  Copyright (C) 2001	Alex Zuepke <azu@sysgo.de>
+ *  Copyright (C) 2002	Kyle Harris <kharris@nexus-tech.net>
+ *  Copyright (C) 2003  Robert Schwebel <r.schwebel@pengutronix.de>
+ *  Copyright (C) 2003  Kai-Uwe Bloem <kai-uwe.bloem@auerswald.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/pxaMacro.h>
+
+#define Mode_SVC 0x13
+#define NoIntsMask 0xc0
+.globl _bss_start
+.globl _bss_end
+
+//defined globals
+.globl HeadStart
+.globl _armboot_start
+
+//r3 - display type
+HeadStart:
+	mov	r8,r0	//there is a check for this instruction before jumping here
+
+// ********************************************************************
+// Set processor into Supervisior mode (SVC) and disable IRQ & FIQ
+//
+	mrs		r0, CPSR
+	bic		r0, r0,#0x1f
+	orr		r0, r0,#(Mode_SVC | NoIntsMask)
+	msr		cpsr_c, r0
+//exit SDS, if currently active
+	msr		SPSR, r0
+	adr		lr,1f
+	movs	pc,lr
+1:
+	b		relocate
+// ********************************************************************
+_armboot_start:
+_TEXT_BASE:		.word	TEXT_BASE
+
+_start_armboot: .word	start_armboot
+/*
+ * These are defined in the board-specific linker script.
+ */
+_bss_start:		.word __bss_start
+_bss_end:		.word _end
+
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+	.word 0x0badc0de
+#endif
+
+relocate:				/* relocate U-Boot to RAM	    */
+	adr		r0, HeadStart		/* r0 <- current position of code   */
+	bic		r0,r0,#0xff
+	bic		r0,r0,#0xff00		//64k aligned
+	ldr		r1, _TEXT_BASE
+	cmp     r0, r1                  /* don't reloc during debug         */
+	beq     stack_setup
+
+	ldr		r2, _bss_start
+
+copy_loop:
+	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
+	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
+	cmp		r1, r2			/* until dest end addreee [r2]    */
+	ble	copy_loop
+
+	/* Set up the stack						    */
+stack_setup:
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	BigSub2 r0,(CFG_MALLOC_LEN+CFG_GBL_DATA_SIZE+CFG_MMU_SPACE_RESERVED) //malloc area,bdinfo
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+
+clear_bss:
+	ldr	r0, _bss_start		/* find start of bss segment        */
+	ldr	r1, _bss_end		/* stop here                        */
+	mov 	r2, #0x00000000		/* clear                            */
+
+clbss_l:str	r2, [r0]		/* clear loop...                    */
+	add	r0, r0, #4
+	cmp	r0, r1
+	bne	clbss_l
+	bl	dcache_enable
+
+	ldr	pc, _start_armboot
+
+
+FlushCache:
+	CP15_CONTROL mrc,r0
+	tst	r0, #4		//is data cache enabled
+	beq	2f
+//	b	2f
+	mov	r1, #2048
+	add	r0,pc,#0x20000	//make sure I don't alloc a line in this subroutine
+	BigBic2	r0, 0xffff
+1:	CP15_CF_ALLOC_LINE mcr,r0
+	add	r0, r0, #0x20
+	subs	r1, r1, #1
+	bne	1b
+
+	CP15_CF_DRAIN mcr,r0
+	CPWAIT	r0
+2:	CP15_CF_INVAL_BOTH mcr,r0
+	CPWAIT	r0
+	mov	pc, lr
+
+
+
+//void dcache_disable (void)
+.globl dcache_disable
+dcache_disable:
+	mov	r3,lr
+	bl	FlushCache
+	CP15_CONTROL mrc,r1
+
+	BigBic2	r1, 0x2805	//disable high vector, branch target buffer, disable data cache, MMU
+	.balignl 32,0xe1a00000	//cacheline boundary (32 bytes)
+			//Needed so that if new flash is burnt
+			//and flash != ram copy,
+			//mov pc, r3 will be in cache and execute correctly
+			//(r3 is 0) return to the reset vector
+	CP15_CONTROL mcr,r1
+	CPWAIT	r0
+	mov	pc, r3
+
+
+//int dcache_status (void)
+.globl dcache_status
+dcache_status:
+	CP15_CONTROL mrc,r0		//get the control register
+	and	r0,r0,#1
+	mov	pc,lr	
+
+#define MEM_START1 0xa0000000
+#define MEM_END1   0xa4000000
+//void dcache_enable (void)
+.globl dcache_enable
+dcache_enable:
+	stmdb	sp!,{r5,r6,lr}
+	bl	FlushCache
+#if !defined(CFG_MMU_SPACE_RESERVED) || (CFG_MMU_SPACE_RESERVED<(1<<14))
+	mov	r0,#1<<15	//16k plus alignment of 16k
+	bl	malloc
+	add	r6,r0,#(1<<14)	//16k alignment
+	BigBic2	r6,(1<<14)-1
+#else
+	ldr	r6, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	BigSub2 r6,(CFG_MMU_SPACE_RESERVED) //malloc area,bdinfo
+#endif
+	mov	r2,r6
+	add	r5,r6,#(1<<14)	//16k 1st level page table
+	BigMov	r0,0x0402			//section descriptor, ap-01, privileged r/w
+						//map virt to phys 1-to-1, non-cache, non-bufferable
+1:	str	r0,[r2],#4
+	add	r0,r0,#1<<20
+	cmp	r2,r5
+	bne	1b
+
+
+	mov	r3,#MEM_END1
+	add	r5,r6,r3,LSR #(20-2)
+	add	r1,r6,#(MEM_START1>>20)<<2
+	BigMov	r0,(MEM_START1&0xfff00000)+0x040A	//cacheable (write through)
+2:	str	r0,[r1],#4
+	cmp	r1,r5
+	addne	r0,r0,#1<<20
+	bne	2b
+
+	BigMov	r0,0xffffffff
+	CP15_DACR mcr,r0
+
+	CP15_TTBR mcr,r6
+//enable MMU
+	CP15_TLB_UNLOCK_I mcr,r0
+	CP15_TLB_UNLOCK_D mcr,r0
+	CP15_TLB_INVAL_BOTH mcr,r0
+
+	CP15_CONTROL mrc,r1		//get the control register
+	BigOrr2	r1,0x201	// enable MMU, r bit
+	BigBic2 r1,0x100	// disable S bit, ap -0 means read only by all
+	CPWAIT	r0
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+
+//enable the instruction cache
+	CP15_CF_UNLOCK_I mcr,r0
+//	CP15_CF_INVAL_I mcr,r0		//I might be running from cache only, don't invalidate
+
+	orr	r1,r1,#0x1000			//set bit 12 -- the I bit
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+
+//enable the data cache
+//	CP15_CF_UNLOCK_D mcr,r0
+	CP15_CF_INVAL_D mcr,r0		//this will also drain write buffer
+	CP15_CF_DRAIN mcr,r0		//make sure it is drained just to be very safe
+
+	orr	r1,r1,#0x4			//set bit 4 -- the D bit
+	CP15_CONTROL mcr,r1		//set the control register
+	CPWAIT	r0
+
+	BigMov	r0,0x3fff
+	CP15_CP_ACCESS mcr,r0		//enable access to all coprocessors
+	ldmia	sp!,{r5,r6,pc}
+
+
+
+/****************************************************************************/
+/*                                                                          */
+/* Reset function: the PXA250 doesn't have a reset function, so we have to  */
+/* perform a watchdog timeout for a soft reset.                             */
+/*                                                                          */
+/****************************************************************************/
+.globl reset_cpu
+	/* FIXME: this code is PXA250 specific. How is this handled on      */
+	/*        other XScale processors?                                  */
+
+reset_cpu:
+	BigMov	r0,0x40a00000	//OSTIMER_BASE
+	/* We set OWE:WME (watchdog enable) and wait until timeout happens  */
+
+	ldr	r1, [r0, #OWER]
+	orr	r1, r1, #0x0001			/* bit0: WME                */
+	str	r1, [r0, #OWER]
+
+	/* OS timer does only wrap every 1165 seconds, so we have to set    */
+	/* the match register as well.                                      */
+
+	ldr	r1, [r0, #OSCR]			/* read OS timer            */
+	add	r1, r1, #0x800			/* let OSMR3 match after    */
+	add	r1, r1, #0x800			/* 4096*(1/3.6864MHz)=1ms   */
+	str	r1, [r0, #OSMR3]
+
+reset_endless:
+	b	reset_endless
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/mmc.c u-boot-1.1.2-neon/cpu/pxa/mmc.c
--- u-boot-1.1.2/cpu/pxa/mmc.c	2003-10-16 01:53:52.000000000 +0200
+++ u-boot-1.1.2-neon/cpu/pxa/mmc.c	2007-08-11 21:07:20.000000000 +0200
@@ -27,6 +27,7 @@
 #include <asm/errno.h>
 #include <asm/arch/hardware.h>
 #include <part.h>
+#include <command.h>
 
 #ifdef CONFIG_MMC
 
@@ -47,9 +48,19 @@
 static uchar mmc_buf[MMC_BLOCK_SIZE];
 static mmc_csd_t mmc_csd;
 static int mmc_ready = 0;
+static int isSD = 0 ;
+static int startBlock = 0 ;
+static ushort RCA = MMC_DEFAULT_RCA ;
+static struct partition part ;
 
+static void stop_clock( void )
+{
+	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	MMC_I_MASK = ~MMC_I_MASK_CLK_IS_OFF;
+	while (!(MMC_I_REG & MMC_I_REG_CLK_IS_OFF));
+}
 
-static uchar *
+uchar *
 /****************************************************/
 mmc_cmd(ushort cmd, ushort argh, ushort argl, ushort cmdat)
 /****************************************************/
@@ -59,9 +70,8 @@
 	int words, i;
 
 	debug("mmc_cmd %x %x %x %x\n", cmd, argh, argl, cmdat);
-	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
-	MMC_I_MASK = ~MMC_I_MASK_CLK_IS_OFF;
-	while (!(MMC_I_REG & MMC_I_REG_CLK_IS_OFF));
+   stop_clock();
+
 	MMC_CMD    = cmd;
 	MMC_ARGH   = argh;
 	MMC_ARGL   = argl;
@@ -71,9 +81,10 @@
 	while (!(MMC_I_REG & MMC_I_REG_END_CMD_RES));
 
 	status = MMC_STAT;
-	debug("MMC status %x\n", status);
+	debug("MMC status %lx\n", status);
 	if (status & MMC_STAT_TIME_OUT_RESPONSE)
 	{
+      printf( "mmc_cmd timeout: cmd: 0x%x, args: 0x%04x%04x, status 0x%lx\n", cmd, argh, argl, status );
 		return 0;
 	}
 
@@ -85,7 +96,7 @@
 			break;
 
 		case MMC_CMDAT_R2:
-			words = 8;
+			words = 9;
 			break;
 
 		default:
@@ -109,6 +120,22 @@
 	return resp;
 }
 
+static void mmc_setblklen( ulong blklen )
+{
+   static ulong prevLen = -1UL ;
+   if( blklen != prevLen )
+   {
+      ushort argh, argl ;
+
+   	argh = blklen >> 16;
+   	argl = blklen & 0xffff;
+   
+   	/* set block len */
+   	mmc_cmd( MMC_CMD_SET_BLOCKLEN, argh, argl, MMC_CMDAT_R1);
+      prevLen = blklen ;
+   }
+}
+
 int
 /****************************************************/
 mmc_block_read(uchar *dst, ulong src, ulong len)
@@ -117,20 +144,18 @@
 	uchar *resp;
 	ushort argh, argl;
 	ulong status;
+   unsigned char volatile *rxFIFO = (unsigned char *)&(MMC_RXFIFO);
 
 	if (len == 0)
 	{
 		return 0;
 	}
 
-	debug("mmc_block_rd dst %lx src %lx len %d\n", (ulong)dst, src, len);
+   debug("mmc_block_rd dst %lx src %lx len %ld\n", (ulong)dst, src, len);
 
-	argh = len >> 16;
-	argl = len & 0xffff;
-
-	/* set block len */
-	resp = mmc_cmd(MMC_CMD_SET_BLOCKLEN, argh, argl, MMC_CMDAT_R1);
+   mmc_setblklen( len );
 
+   src += (startBlock*MMC_BLOCK_SIZE);
 	/* send read command */
 	argh = src >> 16;
 	argl = src & 0xffff;
@@ -147,15 +172,14 @@
 	{
 		if (MMC_I_REG & MMC_I_REG_RXFIFO_RD_REQ)
 		{
-			*dst++ = MMC_RXFIFO;
-			len--;
-		}
-		status = MMC_STAT;
-		if (status & MMC_STAT_ERRORS)
-		{
-			printf("MMC_STAT error %lx\n", status);
-			return -1;
+   		int i, bytes = min(32,len);
+   		len -= bytes;
+   
+   		for (i=0; i<bytes; i++)
+   			*dst++ = *rxFIFO ;
 		}
+      else if (MMC_STAT & MMC_STAT_ERRORS)
+         break;
 	}
 	MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
 	while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE));
@@ -338,7 +362,7 @@
 	aligned_end = mmc_block_address & end;
 
 	/* all block aligned accesses */
-	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	debug("src %p dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
 	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
 	if (part_start)
 	{
@@ -357,22 +381,22 @@
 		dst += part_len;
 		src += part_len;
 	}
-	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	debug("src %p dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
 	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
 	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size)
 	{
-		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		debug("al src %p dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
 		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
 		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0)
 		{
 			return -1;
 		}
 	}
-	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	debug("src %p dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
 	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
 	if (part_end && dst < end)
 	{
-		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		debug("pe src %p dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
 		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
 		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0)
 		{
@@ -392,13 +416,324 @@
 mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
 /****************************************************/
 {
+   debug( "read %lu blocks at block #%lu\n", blkcnt, blknr );
+   	
+   if( 0 < blkcnt )
+   {
+      if( 0 != getenv( "mblock" ) )
+      {
 	int mmc_block_size = MMC_BLOCK_SIZE;
 	ulong src = blknr * mmc_block_size + CFG_MMC_BASE;
 
 	mmc_read(src, (uchar *)dst, blkcnt*mmc_block_size);
+      }
+      else
+      {
+         ulong src = (blknr+startBlock) * MMC_BLOCK_SIZE ;
+         ulong status ;
+         uchar *dstb = (uchar *)dst ;
+         unsigned char volatile *rxFIFO = (unsigned char *)&(MMC_RXFIFO);
+
+      	MMC_RDTO   = 0xffff;
+      	MMC_BLKLEN = MMC_BLOCK_SIZE ;
+      	MMC_NOB    = blkcnt ;
+         
+         mmc_setblklen( MMC_BLOCK_SIZE );
+         mmc_cmd( MMC_CMD_RD_BLK_MULTI, 
+                  src >> 16, 
+                  src & 0xFFFF,
+                  MMC_CMDAT_R1|MMC_CMDAT_READ|MMC_CMDAT_BLOCK|MMC_CMDAT_DATA_EN );
+          
+         // read the data
+         for( blknr = 0 ; blknr < blkcnt ; blknr++ )
+         {
+            unsigned len = MMC_BLOCK_SIZE ;
+         	
+            while (len)
+            {
+            	int i ;
+               MMC_I_MASK = ~MMC_I_MASK_RXFIFO_RD_REQ;
+               while( (MMC_I_REG & MMC_I_REG_RXFIFO_RD_REQ) == 0 )
+                  {
+                  }
+
+               for (i = 0; i < 32 ; i++ )
+                  {
+                  *dstb++ = *rxFIFO ;
+                  }
+               len -= 32 ;
+            }
+         } // for each block
+         
+         MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
+         while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE));
+         status = MMC_STAT;
+         if (status & MMC_STAT_ERRORS)
+         {
+            printf("MMC_STAT error %lx\n", status);
+            return -1;
+         }
+//         printf( "completed mread... now stop\n" );
+
+      	mmc_cmd( MMC_CMD_STOP, 0, 0, MMC_CMDAT_R1);
+
+      } // multi-block read
+   } // or why bother?
 	return blkcnt;
 }
 
+static void dumpResponse( uchar *resp, unsigned bytes )
+{
+   debug( "rsp: " );
+   if( resp )
+   {
+      while( bytes-- )
+         debug( "%02X ", *resp++ );
+      debug( "\n" );
+   }
+   else
+      debug( "NULL\n" );
+}
+
+int SDCard_test( void )
+{
+   unsigned short response ;
+   unsigned long ignore ;
+   unsigned char *resp ;
+
+	mmc_cmd(0, 0, 0, 0);
+
+   resp = mmc_cmd(SD_APP_CMD55, 0, 0, MMC_CMDAT_R1);
+   if( !resp )
+   {
+      printf( "SDInitErr1\n" );
+      return -ENODEV ;
+   }
+   
+   resp = mmc_cmd(SD_APP_CMD41, 0x0020, 0, MMC_CMDAT_INIT|MMC_CMDAT_R1);
+   if( !resp )
+   {
+      printf( "SDInitErr2\n" );
+      return -ENODEV ;
+   }
+
+   memcpy( &response, resp, sizeof( response ) );
+
+   while (response != 0x3f80)//continue doing ACMD1 until busy bit in response is set
+   {
+      //CMD55 APP_CMD
+      MMC_STRPCL = 0x00000001;//stop clock
+      while ((MMC_STAT & 0x00000100) == 0x00000100); //wait for clock to stop
+      MMC_CMD = 0x00000037;//CMD55 index APP_CMD
+      MMC_ARGH = 0x00000000;//relative card address 0x0
+      MMC_ARGL = 0x00000000;//stuff bits
+      MMC_CMDAT = 0x00000001;//expect response 1
+      MMC_STRPCL = 0x00000002;//start clock
+      while ((MMC_STAT & 0x00002000) == 0x00000000);//wait for end_cmd_res
+      //read response FIFO
+      response = MMC_RES & 0x0000ffff ;
+      ignore = MMC_RES ;
+      ignore = MMC_RES ;
+
+      //ACMD41
+      MMC_STRPCL = 0x00000001;//stop clock
+      while ((MMC_STAT & 0x00000100) == 0x00000100); //wait for clock to stop
+      MMC_CMD = 0x00000029;//ACMD41 index SD_APP_SEND_OP_COND
+      MMC_ARGH = 0x00000020;//set voltage limit of system in command argument
+      MMC_ARGL = 0x00000000;
+      MMC_CMDAT = 0x00000003;//expect response 3
+      MMC_STRPCL = 0x00000002;//start clock
+      while ((MMC_STAT & 0x00002000) == 0x00000000);//wait for end_cmd_res
+      
+      //read response FIFO
+      response = MMC_RES & 0x0000ffff ;
+      ignore = MMC_RES ;
+      ignore = MMC_RES ;
+   }
+
+   return 0 ;
+}
+
+#ifdef DEBUG
+static void print_mmc_csd( struct mmc_csd *csd )
+{
+   printf( "ecc: %u\n", csd->ecc );
+   printf( "file_format: %u\n", csd->file_format );
+   printf( "tmp_write_protect: %u\n", csd->tmp_write_protect );
+   printf( "perm_write_protect: %u\n", csd->perm_write_protect );
+   printf( "copy: %u\n", csd->copy );
+   printf( "file_format_grp: %u\n", csd->file_format_grp );
+	printf( "content_prot_app: %u\n", csd->content_prot_app );
+   printf( "rsvd3: %u\n", csd->rsvd3 );
+   printf( "write_bl_partial: %u\n", csd->write_bl_partial );
+   printf( "write_bl_len: %u\n", csd->write_bl_len );
+   printf( "r2w_factor: %u\n", csd->r2w_factor );
+   printf( "default_ecc: %u\n", csd->default_ecc );
+   printf( "wp_grp_enable: %u\n", csd->wp_grp_enable );
+   printf( "wp_grp_size: %u\n", csd->wp_grp_size );
+   printf( "erase_grp_mult: %u\n", csd->erase_grp_mult );
+   printf( "erase_grp_size: %u\n", csd->erase_grp_size );
+   printf( "c_size_mult1: %u\n", csd->c_size_mult1 );
+   printf( "vdd_w_curr_max: %u\n", csd->vdd_w_curr_max );
+   printf( "vdd_w_curr_min: %u\n", csd->vdd_w_curr_min );
+   printf( "vdd_r_curr_max: %u\n", csd->vdd_r_curr_max );
+   printf( "vdd_r_curr_min: %u\n", csd->vdd_r_curr_min );
+   printf( "c_size: %u\n", csd->c_size );
+   printf( "rsvd2: %u\n", csd->rsvd2 );
+   printf( "dsr_imp: %u\n", csd->dsr_imp );
+   printf( "read_blk_misalign: %u\n", csd->read_blk_misalign );
+   printf( "write_blk_misalign: %u\n", csd->write_blk_misalign );
+   printf( "read_bl_partial: %u\n", csd->read_bl_partial );
+   printf( "read_bl_len: %u\n", csd->read_bl_len );
+   printf( "ccc: %u\n", csd->ccc );
+   printf( "tran_speed %u\n", csd->tran_speed );
+   printf( "nsac; %u\n", csd->nsac );
+	printf( "taac; %u\n", csd->taac );
+   printf( "rsvd1: %u\n", csd->rsvd1 );
+   printf( "spec_vers: %u\n", csd->spec_vers );
+   printf( "csd_structure: %u\n",  csd->csd_structure );
+}
+#endif 
+
+#define DOS_PART_MAGIC_OFFSET	0x1fe
+#define DOS_FS_TYPE_OFFSET	0x36
+#define MSDOS_LABEL_MAGIC1	0x55
+#define MSDOS_LABEL_MAGIC2	0xAA
+
+struct bpb { // see http://staff.washington.edu/dittrich/misc/fatgen103.pdf
+   unsigned char  jump[3];
+   char           oemName[8];
+   unsigned short bytesPerSector ;
+   unsigned char  sectorsPerCluster ;
+   unsigned short reservedSectorCount ;
+   unsigned char  numFats ;
+   unsigned short rootEntCount ;
+   unsigned short totalSec16 ;
+   unsigned char  media ; // 0xF8
+   unsigned short fatSz16 ; 
+   unsigned short secPerTrack ;
+   unsigned short numHeads ;
+   unsigned long  hiddenSectors ;
+   unsigned long  totalSectors32 ;
+   unsigned char  driveNum ;
+   unsigned char  reserved1 ; // 0x00
+   unsigned char  bootSig ; // 0x29 
+   unsigned long  volumeId ;
+   char           volumeLabel[11];
+   char           fileSysType[8];
+} __attribute__((packed));
+
+#define isprint(__c) (((__c)>=0x20)&&((__c)<=0x7f))
+
+static int find_mbr( int max_blocks )
+{
+   int i ;
+   ulong addr = 0 ;
+
+printf( "---- searching %d blocks for MBR\n", max_blocks );
+
+   for( i = 0 ; i < 10 ; i++, addr += MMC_BLOCK_SIZE )
+   {
+      uchar data[MMC_BLOCK_SIZE];
+      if( 0 == mmc_block_read(data, addr, sizeof(data) ))
+      {
+        memcpy( &part, data+0x1be, sizeof(part));
+      	if( ( data[DOS_PART_MAGIC_OFFSET] == MSDOS_LABEL_MAGIC1 )
+             &&
+             ( data[DOS_PART_MAGIC_OFFSET + 1] == MSDOS_LABEL_MAGIC2 ) )
+         {            
+            if( ( ('\x00' == part.boot_ind )
+                  ||
+                  ('\x80' == part.boot_ind ) ) 
+                &&
+                ( 10 > part.head ) 
+                &&
+                ( part.end_head >= part.head ) ) 
+            {
+               printf( "partition info found at block %u\n", i );
+               printf( "boot:%02x head:%02x sec:%02x cyl:%02x sys:%02x endh:%02x ends:%02x endc:%02x start:%08x, count:%08x\n",
+                       part.boot_ind, part.head, part.sector, part.cyl,
+                       part.sys_ind, part.end_head, part.end_sector, part.end_cyl,
+                       part.start_sect, part.nr_sects );
+               printf( "MBR found at block %d\n", i );
+               return part.start_sect ;
+            }
+            else {
+               struct bpb const *bootParams = (struct bpb *)data ;
+               unsigned j ;
+               for( j = 0 ; j < sizeof(data); j++ )
+               {
+                  if( 0 == ( j & 0x0f ) )
+                     printf( "%04x   ", j );
+                  printf( "%02x ", data[j] );
+                  if( 7 == ( j & 7 ) )
+                     printf( "  " );
+                  if( 0x0f == ( j & 0x0f ) )
+                  {
+                     unsigned b ;
+                     for( b = j-15 ; b <= j ; b++ )
+                     {
+                        uchar c = data[b];
+                        if( isprint(c) )
+                           printf( "%c", c );
+                        else
+                           printf( "." );
+                        if( 7 == ( b & 7 ) )
+                           printf( " " );
+                     }
+                     printf( "\n" );
+                  }
+               }
+               printf( "Invalid MBR\n" );
+               printf( "---> Boot Parameter block\n" );
+               printf( "jump %02x %02x %02x\n", bootParams->jump[0],bootParams->jump[1],bootParams->jump[2]);
+               printf( "bytesPerSector: %04x\n", bootParams->bytesPerSector );
+               printf( "sectorsPerCluster: %02x\n", bootParams->sectorsPerCluster );
+               printf( "reservedSectors %04x\n", bootParams->reservedSectorCount );
+               printf( "numFats: %02x\n", bootParams->numFats );
+               printf( "rootEntCount: %04x\n", bootParams->rootEntCount );
+               printf( "totalSec16: %04x\n", bootParams->totalSec16 );
+               printf( "media: %02x\n", bootParams->media );
+               printf( "fatsz16: %04x", bootParams->fatSz16 );
+               printf( "secPerTrack: %04x\n", bootParams->secPerTrack );
+               printf( "numHeads = %04x\n", bootParams->numHeads );
+               printf( "hidden = %08lx\n", bootParams->hiddenSectors );
+               printf( "totalSec32 = %08lx\n", bootParams->totalSectors32 );
+               printf( "drive #%u\n", bootParams->driveNum );
+               printf( "reserved1: %02x\n", bootParams->reserved1 );
+               printf( "bootSig: %02x\n", bootParams->bootSig );
+               printf( "volume: %08lx\n", bootParams->volumeId );
+               part.boot_ind = 0 ;
+               part.head = 0 ; 
+               part.sector = 2 ;
+               part.cyl = 0 ;
+               part.sys_ind = 6 ;
+               part.end_head = bootParams->numHeads ;
+               part.end_sector = 0xe0 ;
+               part.end_cyl = 0xc9 ;
+               part.start_sect = 0 ;
+               part.nr_sects = bootParams->totalSectors32 ;
+               printf( "partition info found at block %u\n", i );
+               printf( "boot:%02x head:%02x sec:%02x cyl:%02x sys:%02x endh:%02x ends:%02x endc:%02x start:%08x, count:%08x\n",
+                       part.boot_ind, part.head, part.sector, part.cyl,
+                       part.sys_ind, part.end_head, part.end_sector, part.end_cyl,
+                       part.start_sect, part.nr_sects );
+               printf( "MBR found at block %d\n", i );
+               return 0 ;
+            }
+         }
+      }
+      else
+      {
+         printf( "!!! Error reading mmc block %u\n", i );
+         break;
+      }
+   }
+
+   printf( "MBR not found!\n" );
+   return -1 ;
+}
+
 int
 /****************************************************/
 mmc_init(int verbose)
@@ -406,7 +741,8 @@
 {
  	int retries, rc = -ENODEV;
 	uchar *resp;
-
+	mmc_cid_t *cid ;
+	mmc_csd_t *csd ;
 #ifdef CONFIG_LUBBOCK
 	set_GPIO_mode( GPIO6_MMCCLK_MD );
 	set_GPIO_mode( GPIO8_MMCCS0_MD );
@@ -419,23 +755,63 @@
 	MMC_RESTO  = MMC_RES_TO_MAX;
 	MMC_SPI    = MMC_SPI_DISABLE;
 
+   if( 0 == SDCard_test() )
+   {
+      printf( "SD card detected!\n" );
+      isSD = 1 ;
+   }
+   else
+   {
+      isSD = 0 ;
+
 	/* reset */
-	retries = 10;
-	resp = mmc_cmd(0, 0, 0, 0);
+   	mmc_cmd(0, 0, 0, 0);
 	resp = mmc_cmd(1, 0x00ff, 0xc000, MMC_CMDAT_INIT|MMC_CMDAT_BUSY|MMC_CMDAT_R3);
-	while (retries-- && resp && !(resp[4] & 0x80))
+      if( 0 == resp )
+      {
+         printf( "MMC CMD1 error\n" );
+         return -1 ;
+      }
+      
+      printf( "init: " ); dumpResponse( resp, 6 );
+      retries = 0 ;
+      do
 	{
-		debug("resp %x %x\n", resp[0], resp[1]);
-		udelay(50);
+         udelay(100);
 		resp = mmc_cmd(1, 0x00ff, 0xff00, MMC_CMDAT_BUSY|MMC_CMDAT_R3);
+         debug( "cmd1: " ); dumpResponse( resp, 6 );
+         retries++ ;
+      } while( resp && ( 0 == ( resp[4] & 0x80 ) ) );
+      
+      if( 0 == resp )
+      {
+         printf( "MMC CMD1 error2\n" );
+         return -1 ;
+      }
+      
+      do {
+         udelay(100);
+         resp = mmc_cmd(1, 0x00ff, 0xff00, MMC_CMDAT_BUSY|MMC_CMDAT_R3);
+         debug( "cmd1: " ); dumpResponse( resp, 6 );
+         retries++ ;
+      } while( resp && ( 0 != ( resp[4] & 0x80 ) ) );
+            
+      printf( "after busy: %s, %d retries\n", 
+              resp ? "have INIT response"
+                   : "no INIT response",
+              retries );
 	}
 
 	/* try to get card id */
 	resp = mmc_cmd(2, 0, 0, MMC_CMDAT_R2);
-	if (resp)
+	if( !resp )
 	{
+      printf( "Bad CMDAT_R2 response\n" );
+      return -1 ;
+   }
+		
 		/* TODO configure mmc driver depending on card attributes */
-		mmc_cid_t *cid = (mmc_cid_t *)resp;
+   cid = (mmc_cid_t *)resp;
 		if (verbose)
 		{
 			printf("MMC found. Card desciption is:\n");
@@ -449,6 +825,12 @@
 			printf("Month = %d\n",cid->month);
 			printf("Year = %d\n",1997 + cid->year);
 		}
+   sprintf(mmc_dev.product,"%s",cid->name);
+   sprintf(mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
+         cid->id[0], cid->id[1], cid->id[2],
+         cid->sn[0], cid->sn[1], cid->sn[2]);
+   sprintf(mmc_dev.revision,"%x %x",cid->hwrev, cid->fwrev);
+
 		/* fill in device description */
 		mmc_dev.if_type = IF_TYPE_MMC;
 		mmc_dev.dev = 0;
@@ -457,30 +839,118 @@
 		/* FIXME fill in the correct size (is set to 32MByte) */
 		mmc_dev.blksz = 512;
 		mmc_dev.lba = 0x10000;
-		sprintf(mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
-				cid->id[0], cid->id[1], cid->id[2],
-				cid->sn[0], cid->sn[1], cid->sn[2]);
-		sprintf(mmc_dev.product,"%s",cid->name);
-		sprintf(mmc_dev.revision,"%x %x",cid->hwrev, cid->fwrev);
 		mmc_dev.removable = 0;
 		mmc_dev.block_read = mmc_bread;
 
 		/* MMC exists, get CSD too */
 		resp = mmc_cmd(MMC_CMD_SET_RCA, MMC_DEFAULT_RCA, 0, MMC_CMDAT_R1);
-		resp = mmc_cmd(MMC_CMD_SEND_CSD, MMC_DEFAULT_RCA, 0, MMC_CMDAT_R2);
-		if (resp)
+   
+   if( resp )
 		{
-			mmc_csd_t *csd = (mmc_csd_t *)resp;
-			memcpy(&mmc_csd, csd, sizeof(csd));
-			rc = 0;
-			mmc_ready = 1;
-			/* FIXME add verbose printout for csd */
+      if( isSD )
+         RCA = ((ushort)resp[4] << 8 ) | resp[3];
+      else
+         RCA = MMC_DEFAULT_RCA ;
 		}
+   else
+   {
+      printf( "no SET_RCA response\n" );
+      return -1 ;
 	}
 
+#if 0
+/*
+ * According to a Toshiba doc, the following is supposed to give
+ * the size of the 'protected' area (so we can ignore it).
+
+ * Unfortunately, I can't get the numbers to add up, so we walk
+ * til we find an MBR instead.
+ */
+   if( isSD )
+   {
+      printf( "sending CMD55\n" );
+      resp = mmc_cmd(SD_APP_CMD55, RCA, 0, MMC_CMDAT_R1);
+      if( !resp )
+      {
+         printf( "Error 0x%04x sending APP CMD\n", MMC_STAT );
+         return -1 ;
+      }
+      else
+      {
+         printf( "have CMD55 response\n" );
+         memset( resp, 0, 20 );
+      }
+
+      resp = mmc_cmd(SD_STATUS, RCA, 0, MMC_CMDAT_R1 );
+      if( resp )
+      {
+         sd_status_t *status ;
+         int i ;
+         printf( "SDSTATUS returned\n" );
+         for( i = 0 ; i < 16 ; i++ )
+            printf( "%02x ", resp[i] );
+         printf( "\n" );
+         status = (sd_status_t *)resp ;
+         printf( "bus_width:     %u\n", status->bus_width );
+         printf( "secured_mode:  %u\n", status->secured_mode );
+         printf( "unused0:       %x\n", status->unused0 );
+         printf( "card_type:     %x\n", status->card_type );
+         printf( "prot_size:     %lx\n", status->prot_size );
+      }
+      else
+      {
+         printf( "Error reading SD_STATUS\n" );
+         return -1 ;
+      }
+   }
+#endif
+
+   MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	MMC_I_MASK = ~MMC_I_MASK_CLK_IS_OFF;
+	while (!(MMC_I_REG & MMC_I_REG_CLK_IS_OFF));
+
 	MMC_CLKRT = 0;	/* 20 MHz */
-	resp = mmc_cmd(7, MMC_DEFAULT_RCA, 0, MMC_CMDAT_R1);
+	resp = mmc_cmd(7, RCA, 0, MMC_CMDAT_R1);
+   if( !resp )
+   {
+      printf( "Error selecting RCA %x\n", RCA );
+      return -1 ;
+   }
+
+   resp = mmc_cmd(7, 0, 0, MMC_CMDAT_R1);
+   if( !resp )
+   {
+      // this is normal
+   }
+
+   resp = mmc_cmd(MMC_CMD_SEND_CSD, RCA, 0, MMC_CMDAT_R2);
+   if (!resp)
+   {
+      printf( "Error reading CSD\n" );
+      return -1 ;
+   }
+   
+   csd = (mmc_csd_t *)resp;
+   memcpy(&mmc_csd, csd, sizeof(*csd));
+   rc = 0;
+
+#ifdef DEBUG
+   dumpResponse( resp, sizeof( *csd ) );
+   print_mmc_csd( csd );
+#endif 
+
+   resp = mmc_cmd(7, RCA, 0, MMC_CMDAT_R1);
+   if( !resp )
+   {
+      printf( "Error selecting RCA %x\n", RCA );
+      return -1 ;
+   }
+   
+   mmc_ready = 1;
+   startBlock = find_mbr(mmc_csd.c_size);
 
+   printf( "registering device: startBlock == %d, isSD ? %s\n", 
+            startBlock, isSD ? "yes" : "no" );
 	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
 
 	return rc;
@@ -503,4 +973,41 @@
 	return 0;
 }
 
+#if (CONFIG_COMMANDS & CFG_CMD_MMC)
+
+int do_mmc_detect (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+   unsigned long gplr1 = GPLR1 ;
+   int rval = ( 0 != (gplr1 & 0x10) ); 
+#ifdef DEBUG
+   printf ("Checking for MMC card: %lx, %d\n", gplr1, rval );
+#endif
+   return rval ;
+}
+
+U_BOOT_CMD(
+	mmcdet,	  1,	0,	do_mmc_detect,
+	"mmcdet  - detect mmc card\n",
+	NULL
+);
+
+int do_mmc_wp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+   unsigned long gplr1 = GPLR1 ;
+   int rval = ( 0 == (gplr1 & 0x40) ); 
+#ifdef DEBUG
+   printf ("Checking MMC write protect: %lx, %d\n", gplr1, rval );
+#endif   
+   return rval ;
+}
+
+U_BOOT_CMD(
+	mmcwp,	  1,	0,	do_mmc_wp,
+	"mmcwp   - detect mmc write protect\n",
+	NULL
+);
+
+#endif
+
 #endif
+
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/pxafb.c u-boot-1.1.2-neon/cpu/pxa/pxafb.c
--- u-boot-1.1.2/cpu/pxa/pxafb.c	2004-10-10 01:26:00.000000000 +0200
+++ u-boot-1.1.2-neon/cpu/pxa/pxafb.c	2007-08-11 21:07:20.000000000 +0200
@@ -36,6 +36,10 @@
 #include <lcd.h>
 #include <asm/arch/pxa-regs.h>
 
+#ifdef CFG_CMD_LCDPANEL
+#include <lcd_panels.h>
+#endif
+
 /* #define DEBUG */
 
 #ifdef CONFIG_LCD
@@ -147,6 +151,38 @@
 #endif /* CONFIG_HITACHI_SX14 */
 
 /*----------------------------------------------------------------------*/
+#ifdef CONFIG_SHARP_QVGA
+/* Sharp 1/4 VGA LCD */
+#define LCD_BPP		LCD_COLOR8
+
+/* you have to set lccr0 and lccr3 (including pcd) */
+#define REG_LCCR0	0x003008F8
+#define REG_LCCR3	(0x0040FF0C|(LCD_BPP<<24))
+
+vidinfo_t panel_info = {
+	vl_col:		320,
+	vl_row:		240,
+	vl_width:	167,
+	vl_height:	109,
+	vl_clkp:	CFG_HIGH,
+	vl_oep:		CFG_HIGH,
+	vl_hsp:		CFG_HIGH,
+	vl_vsp:		CFG_HIGH,
+	vl_dp:		CFG_HIGH,
+	vl_bpix:	LCD_BPP,
+	vl_lbw:		1,
+	vl_splt:	0,
+	vl_clor:	1,
+	vl_tft:		1,
+	vl_hpw:		64,
+	vl_blw:		34,
+	vl_elw:		1,
+	vl_vpw:		20,
+	vl_bfw:		8,
+	vl_efw:		3,
+};
+#endif /* CONFIG_SHARP_QVGA */
+
 
 #if LCD_BPP == LCD_COLOR8
 void lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue);
@@ -163,7 +199,6 @@
 void lcd_ctrl_init	(void *lcdbase);
 void lcd_enable	(void);
 
-int lcd_line_length;
 int lcd_color_fg;
 int lcd_color_bg;
 
@@ -185,10 +220,28 @@
 
 void lcd_ctrl_init (void *lcdbase)
 {
+#ifdef CFG_CMD_LCDPANEL
+   char const *panelName = getenv( "panel" );
+   if( panelName )
+   {
+      struct lcd_panel_info_t const *panel ;
+      panel = find_lcd_panel( panelName );
+      if( panel )
+      {
+         printf( "panel %s found: %u x %u\n", panelName, panel->xres, panel->yres );
+	 panel_info.pxa.screen = (u_long)lcdbase;
+         set_lcd_panel( panel ); 
+      }
+      else
+         printf( "panel %s not found\n", panelName );
+   }
+#else   
 	pxafb_init_mem(lcdbase, &panel_info);
 	pxafb_init(&panel_info);
 	pxafb_setup_gpio(&panel_info);
 	pxafb_enable_controller(&panel_info);
+#endif
+
 }
 
 /*----------------------------------------------------------------------*/
@@ -204,6 +257,7 @@
 void
 lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue)
 {
+#if defined( CONFIG_PXA250 )
 	struct pxafb_info *fbi = &panel_info.pxa;
 	unsigned short *palette = (unsigned short *)fbi->palette;
 	u_int val;
@@ -219,7 +273,22 @@
 		palette[regno] = val;
 #endif
 	}
+#elif defined( CONFIG_PXA270 )
+	struct pxafb_info *fbi = &panel_info.pxa;
+	u32 *palette = (u32 *)fbi->palette;
+	u32 val;
+
+	if (regno < fbi->palette_size) {
+		val = 0xFF000000 ; // transparency
+		val |= (red << 16);
+		val |= (green << 8);
+		val |= blue ;
 
+		palette[regno] = val;
+	}
+#else
+#error no processor defined
+#endif
 	debug ("setcolreg: reg %2d @ %p: R=%02X G=%02X B=%02X => %04X\n",
 		regno, &palette[regno],
 		red, green, blue,
@@ -284,7 +353,7 @@
 	fbi->screen = (u_long)lcdbase;
 
 	fbi->palette_size = NBITS(vid->vl_bpix) == 8 ? 256 : 16;
-	palette_mem_size = fbi->palette_size * sizeof(u16);
+	palette_mem_size = fbi->palette_size * sizeof(PALETTEVAL_TYPE);
 
 	debug("palette_mem_size = 0x%08lx\n", (u_long) palette_mem_size);
 	/* locate palette and descs at end of page following fb */
@@ -376,11 +445,16 @@
 static int pxafb_init (vidinfo_t *vid)
 {
 	struct pxafb_info *fbi = &vid->pxa;
+   unsigned long const REG_LCCR3 = 0x0040FF0C|(LCD_BPP<<24);
 
 	debug("Configuring PXA LCD\n");
 
-	fbi->reg_lccr0 = REG_LCCR0;
-	fbi->reg_lccr3 = REG_LCCR3;
+#if defined( CONFIG_PXA270 )
+	LCCR4 = 0x00010000 ;
+#endif
+
+	fbi->reg_lccr0 = 0x003008F8;
+	fbi->reg_lccr3 = REG_LCCR3 ;
 
 	debug("vid: vl_col=%d hslen=%d lm=%d rm=%d\n",
 		vid->vl_col, vid->vl_hpw,
@@ -429,7 +503,7 @@
 
 	fbi->dmadesc_palette->fsadr = fbi->palette;
 	fbi->dmadesc_palette->fidr  = 0;
-	fbi->dmadesc_palette->ldcmd = (fbi->palette_size * 2) | LDCMD_PAL;
+	fbi->dmadesc_palette->ldcmd = (fbi->palette_size * sizeof(PALETTEVAL_TYPE)) | LDCMD_PAL;
 
 	if( NBITS(vid->vl_bpix) < 12)
 	{
@@ -465,6 +539,39 @@
 	return 0;
 }
 
+
+#ifdef CFG_CMD_LCDPANEL
+
+void set_lcd_panel( struct lcd_panel_info_t const *panel )
+{
+   panel_info.vl_col = panel->xres ;
+   panel_info.vl_row = panel->yres ;
+   panel_info.vl_clkp = panel->act_high ;
+   panel_info.vl_oep  = panel->act_high ;
+   panel_info.vl_hsp  = panel->act_high ;
+   panel_info.vl_vsp  = panel->act_high ;
+   panel_info.vl_dp   = panel->act_high ;
+   panel_info.vl_bpix = LCD_BPP ;
+   panel_info.vl_lcd_line_length = (panel_info.vl_col * NBITS (panel_info.vl_bpix)) >> 3;
+   panel_info.vl_lbw  = 1 ;
+   panel_info.vl_splt = 0 ;
+   panel_info.vl_clor = 1 ;
+   panel_info.vl_tft = panel->active ;
+   panel_info.vl_hpw = panel->hsync_len ;
+   panel_info.vl_blw = panel->left_margin ;
+   panel_info.vl_elw = panel->right_margin ;
+   panel_info.vl_vpw = panel->vsync_len ;
+   panel_info.vl_bfw = panel->upper_margin ;
+   panel_info.vl_efw = panel->lower_margin ;
+
+   pxafb_init_mem( (void *)panel_info.pxa.screen, &panel_info);
+   pxafb_init(&panel_info);
+   pxafb_setup_gpio(&panel_info);
+   pxafb_enable_controller(&panel_info);
+}
+
+#endif // dynamic LCD panel support
+
 /************************************************************************/
 /************************************************************************/
 
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/sm501_usb.h u-boot-1.1.2-neon/cpu/pxa/sm501_usb.h
--- u-boot-1.1.2/cpu/pxa/sm501_usb.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/cpu/pxa/sm501_usb.h	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,66 @@
+#ifndef SM501_USB_INCLUDED
+#define SM501_USB_INCLUDED
+	
+	#if defined(CONFIG_SM501)
+		#define USB_GATE_MODE0	__REG(0xFE00040)
+		#define USB_GATE_MODE1	__REG(0xFE00048)
+		#define ENABLE_USBH	(1<<11)
+
+		/*
+		 * USB Host Controller
+		 */
+		#define USBH_BASE	0xFE40000
+		#define UHCREV		__REG(0xFE40000)
+		#define UHCHCON		__REG(0xFE40004)
+		#define UHCCOMS		__REG(0xFE40008)
+		#define UHCINTS		__REG(0xFE4000C)
+		#define UHCINTE		__REG(0xFE40010)
+		#define UHCINTD		__REG(0xFE40014)
+		#define UHCHCCA		__REG(0xFE40018)
+		#define UHCPCED		__REG(0xFE4001C)
+		#define UHCCHED		__REG(0xFE40020)
+		#define UHCCCED		__REG(0xFE40024)
+		#define UHCBHED		__REG(0xFE40028)
+		#define UHCBCED		__REG(0xFE4002C)
+		#define UHCDHEAD	__REG(0xFE40030)
+		#define UHCFMI		__REG(0xFE40034)
+		#define UHCFMR		__REG(0xFE40038)
+		#define UHCFMN		__REG(0xFE4003C)
+		#define UHCPERS		__REG(0xFE40040)
+		#define UHCLST		__REG(0xFE40044)
+		#define UHCRHDA		__REG(0xFE40048)
+		#define UHCRHDB		__REG(0xFE4004C)
+		#define UHCRHS		__REG(0xFE40050)
+		#define UHCRHPS1	__REG(0xFE40054)
+		#define UHCRHPS2	__REG(0xFE40058)
+		#define UHCRHPS3	__REG(0xFE4005C)
+		#define UHCSTAT		__REG(0xFE40060)
+		#define UHCHR		__REG(0xFE40064)
+		#define UHCHIE		__REG(0xFE40068)
+		#define UHCHIT		__REG(0xFE4006C)
+		
+		#define UHCHR_FSBIR	(1<<0)
+		#define UHCHR_FHR	(1<<1)
+		#define UHCHR_CGR	(1<<2)
+		#define UHCHR_SSDC	(1<<3)
+		#define UHCHR_UIT	(1<<4)
+		#define UHCHR_SSE	(1<<5)
+		#define UHCHR_PSPL	(1<<6)
+		#define UHCHR_PCPL	(1<<7)
+		#define UHCHR_SSEP0	(1<<9)
+		#define UHCHR_SSEP1	(1<<10)
+		#define UHCHR_SSEP2	(1<<11)
+		
+		#define UHCHIE_UPRIE	(1<<13)
+		#define UHCHIE_UPS2IE	(1<<12)
+		#define UHCHIE_UPS1IE	(1<<11)
+		#define UHCHIE_TAIE	(1<<10)
+		#define UHCHIE_HBAIE	(1<<8)
+		#define UHCHIE_RWIE	(1<<7)
+		
+		#define UHCCOMS_HCR	1
+		#define UHCRHS_LPS	1
+		#define UHCHR_SSE	(1<<5)
+		
+	#endif
+#endif
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/start.S u-boot-1.1.2-neon/cpu/pxa/start.S
--- u-boot-1.1.2/cpu/pxa/start.S	2004-06-09 02:11:02.000000000 +0200
+++ u-boot-1.1.2-neon/cpu/pxa/start.S	2007-08-11 21:07:20.000000000 +0200
@@ -61,23 +61,10 @@
  * - jump to second stage
  */
 
-_TEXT_BASE:
-	.word	TEXT_BASE
 
-.globl _armboot_start
-_armboot_start:
-	.word _start
+_textBase:
+	.word TEXT_BASE
 
-/*
- * These are defined in the board-specific linker script.
- */
-.globl _bss_start
-_bss_start:
-	.word __bss_start
-
-.globl _bss_end
-_bss_end:
-	.word _end
 
 #ifdef CONFIG_USE_IRQ
 /* IRQ stack memory (calculated at run-time) */
@@ -111,47 +98,9 @@
 #ifdef CONFIG_INIT_CRITICAL
 	bl	cpu_init_crit		/* we do sys-critical inits	    */
 #endif
+	b	HeadStart
 
-relocate:				/* relocate U-Boot to RAM	    */
-	adr	r0, _start		/* r0 <- current position of code   */
-	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
-	cmp     r0, r1                  /* don't reloc during debug         */
-	beq     stack_setup
-
-	ldr	r2, _armboot_start
-	ldr	r3, _bss_start
-	sub	r2, r3, r2		/* r2 <- size of armboot            */
-	add	r2, r0, r2		/* r2 <- source end address         */
-
-copy_loop:
-	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
-	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
-	cmp	r0, r2			/* until source end addreee [r2]    */
-	ble	copy_loop
-
-	/* Set up the stack						    */
-stack_setup:
-	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
-	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
-	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
-#ifdef CONFIG_USE_IRQ
-	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
-#endif
-	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
-
-clear_bss:
-	ldr	r0, _bss_start		/* find start of bss segment        */
-	ldr	r1, _bss_end		/* stop here                        */
-	mov 	r2, #0x00000000		/* clear                            */
 
-clbss_l:str	r2, [r0]		/* clear loop...                    */
-	add	r0, r0, #4
-	cmp	r0, r1
-	bne	clbss_l
-
-	ldr	pc, _start_armboot
-
-_start_armboot: .word start_armboot
 
 
 /****************************************************************************/
@@ -167,16 +116,7 @@
 IC_BASE:	   .word	   0x40d00000
 #define ICMR	0x04
 
-/* Reset-Controller */
-RST_BASE:	.word	0x40f00030
-#define RCSR	0x00
-
-/* Operating System Timer */
-OSTIMER_BASE:	.word	0x40a00000
-#define OSMR3	0x0C
-#define OSCR	0x10
-#define OWER	0x18
-#define OIER	0x1C
+
 
 /* Clock Manager Registers					            */
 #ifdef CFG_CPUSPEED
@@ -288,7 +228,7 @@
 	stmia	sp, {r0 - r12}			/* Calling r0-r12	    */
 	add	r8, sp, #S_PC
 
-	ldr	r2, _armboot_start
+	ldr	r2, _textBase
 	sub	r2, r2, #(CONFIG_STACKSIZE+CFG_MALLOC_LEN)
 	sub	r2, r2, #(CFG_GBL_DATA_SIZE+8)  @ set base 2 words into abort stack
 	ldmia	r2, {r2 - r4}			/* get pc, cpsr, old_r0	    */
@@ -325,7 +265,7 @@
 	.endm
 
 	.macro get_bad_stack
-	ldr	r13, _armboot_start		@ setup our mode stack
+	ldr	r13, _textBase		@ setup our mode stack
 	sub	r13, r13, #(CONFIG_STACKSIZE+CFG_MALLOC_LEN)
 	sub	r13, r13, #(CFG_GBL_DATA_SIZE+8) @ reserved a couple spots in abort stack
 
@@ -416,36 +356,3 @@
 
 #endif
 
-/****************************************************************************/
-/*                                                                          */
-/* Reset function: the PXA250 doesn't have a reset function, so we have to  */
-/* perform a watchdog timeout for a soft reset.                             */
-/*                                                                          */
-/****************************************************************************/
-
-	.align	5
-.globl reset_cpu
-
-	/* FIXME: this code is PXA250 specific. How is this handled on      */
-	/*        other XScale processors?                                  */
-
-reset_cpu:
-
-	/* We set OWE:WME (watchdog enable) and wait until timeout happens  */
-
-	ldr	r0, OSTIMER_BASE
-	ldr	r1, [r0, #OWER]
-	orr	r1, r1, #0x0001			/* bit0: WME                */
-	str	r1, [r0, #OWER]
-
-	/* OS timer does only wrap every 1165 seconds, so we have to set    */
-	/* the match register as well.                                      */
-
-	ldr	r1, [r0, #OSCR]			/* read OS timer            */
-	add	r1, r1, #0x800			/* let OSMR3 match after    */
-	add	r1, r1, #0x800			/* 4096*(1/3.6864MHz)=1ms   */
-	str	r1, [r0, #OSMR3]
-
-reset_endless:
-
-	b	reset_endless
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/usb_ohci.c u-boot-1.1.2-neon/cpu/pxa/usb_ohci.c
--- u-boot-1.1.2/cpu/pxa/usb_ohci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/cpu/pxa/usb_ohci.c	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,1679 @@
+/*
+ * URB OHCI HCD (Host Controller Driver) for USB on the S3C2400.
+ *
+ * (C) Copyright 2003
+ * Gary Jennejohn, DENX Software Engineering <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Note: Part of this code has been derived from linux
+ *
+ */
+/*
+ * IMPORTANT NOTES
+ * 1 - you MUST define LITTLEENDIAN in the configuration file for the
+ *     board or this driver will NOT work!
+ * 2 - this driver is intended for use with USB Mass Storage Devices
+ *     (BBB) ONLY. There is NO support for Interrupt or Isochronous pipes!
+ */
+
+#include <common.h>
+/* #include <pci.h> no PCI on the S3C24X0 */
+
+#ifdef CONFIG_USB_OHCI
+
+#include <asm/arch/pxa-regs.h>
+
+#include <malloc.h>
+#include <usb.h>
+#include "usb_ohci.h"
+
+#if defined( CONFIG_SM501 )
+#include "sm501_usb.h"
+#endif
+
+// #define OHCI_USE_NPS		/* force NoPowerSwitching mode */
+// #define OHCI_VERBOSE_DEBUG	/* not always helpful */
+
+
+/* For initializing controller (mask in an HCFS mode too) */
+#define	OHCI_CONTROL_INIT \
+	(OHCI_CTRL_CBSR & 0x3) | OHCI_CTRL_IE | OHCI_CTRL_PLE
+
+#define readl(a) (*((vu_long *)(a)))
+#define writel(a, b) (*((vu_long *)(b)) = ((vu_long)a))
+
+#define min_t(type,x,y) ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+
+//#define DEBUG
+#ifdef DEBUG
+#define dbg(format, arg...) printf("DEBUG: " format "\n", ## arg)
+#else
+#define dbg(format, arg...) do {} while(0)
+#endif /* DEBUG */
+#define err(format, arg...) printf("ERROR: " format "\n", ## arg)
+#define SHOW_INFO
+#ifdef SHOW_INFO
+#define info(format, arg...) printf("INFO: " format "\n", ## arg)
+#else
+#define info(format, arg...) do {} while(0)
+#endif
+
+#define m16_swap(x) swap_16(x)
+#define m32_swap(x) swap_32(x)
+
+/* global ohci_t */
+static ohci_t gohci;
+/* this must be aligned to a 256 byte boundary */
+struct ohci_hcca ghcca[1];
+/* a pointer to the aligned storage */
+struct ohci_hcca *phcca;
+/* this allocates EDs for all possible endpoints */
+struct ohci_device ohci_dev;
+/* urb_priv */
+urb_priv_t urb_priv;
+/* RHSC flag */
+int got_rhsc;
+/* device which was disconnected */
+struct usb_device *devgone;
+
+/*-------------------------------------------------------------------------*/
+
+/* AMD-756 (D2 rev) reports corrupt register contents in some cases.
+ * The erratum (#4) description is incorrect.  AMD's workaround waits
+ * till some bits (mostly reserved) are clear; ok for all revs.
+ */
+#define OHCI_QUIRK_AMD756 0xabcd
+#define read_roothub(hc, register, mask) ({ \
+	u32 temp = readl (&hc->regs->roothub.register); \
+	if (hc->flags & OHCI_QUIRK_AMD756) \
+		while (temp & mask) \
+			temp = readl (&hc->regs->roothub.register); \
+	temp; })
+
+static u32 roothub_a (struct ohci *hc)
+	{ return read_roothub (hc, a, 0xfc0fe000); }
+static inline u32 roothub_b (struct ohci *hc)
+	{ return readl (&hc->regs->roothub.b); }
+static inline u32 roothub_status (struct ohci *hc)
+	{ return readl (&hc->regs->roothub.status); }
+static u32 roothub_portstatus (struct ohci *hc, int i)
+	{ return read_roothub (hc, portstatus [i], 0xffe0fce0); }
+
+
+/* forward declaration */
+static int hc_interrupt (void);
+static void
+td_submit_job (struct usb_device * dev, unsigned long pipe, void * buffer,
+	int transfer_len, struct devrequest * setup, urb_priv_t * urb, int interval);
+
+/*-------------------------------------------------------------------------*
+ * URB support functions
+ *-------------------------------------------------------------------------*/
+
+/* free HCD-private data associated with this URB */
+
+static void urb_free_priv (urb_priv_t * urb)
+{
+	int		i;
+	int		last;
+	struct td	* td;
+
+	last = urb->length - 1;
+	if (last >= 0) {
+		for (i = 0; i <= last; i++) {
+			td = urb->td[i];
+			if (td) {
+				td->usb_dev = NULL;
+				urb->td[i] = NULL;
+			}
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+static int sohci_get_current_frame_number (struct usb_device * dev);
+
+/* debug| print the main components of an URB
+ * small: 0) header + data packets 1) just header */
+
+static void pkt_print (struct usb_device * dev, unsigned long pipe, void * buffer,
+	int transfer_len, struct devrequest * setup, char * str, int small)
+{
+	urb_priv_t * purb = &urb_priv;
+
+	dbg("%s URB:[%4x] dev:%2d,ep:%2d-%c,type:%s,len:%d/%d stat:%#lx",
+			str,
+			sohci_get_current_frame_number (dev),
+			usb_pipedevice (pipe),
+			usb_pipeendpoint (pipe),
+			usb_pipeout (pipe)? 'O': 'I',
+			usb_pipetype (pipe) < 2? (usb_pipeint (pipe)? "INTR": "ISOC"):
+				(usb_pipecontrol (pipe)? "CTRL": "BULK"),
+			purb->actual_length,
+			transfer_len, dev->status);
+#ifdef	OHCI_VERBOSE_DEBUG
+	if (!small) {
+		int i, len;
+
+		if (usb_pipecontrol (pipe)) {
+			printf (__FILE__ ": cmd(8):");
+			for (i = 0; i < 8 ; i++)
+				printf (" %02x", ((__u8 *) setup) [i]);
+			printf ("\n");
+		}
+		if (transfer_len > 0 && buffer) {
+			printf (__FILE__ ": data(%d/%d):",
+				purb->actual_length,
+				transfer_len);
+			len = usb_pipeout (pipe)?
+					transfer_len: purb->actual_length;
+			for (i = 0; i < 16 && i < len; i++)
+				printf (" %02x", ((__u8 *) buffer) [i]);
+			printf ("%s\n", i < len? "...": "");
+		}
+	}
+#endif
+}
+
+/* just for debugging; prints non-empty branches of the int ed tree inclusive iso eds*/
+void ep_print_int_eds (ohci_t *ohci, char * str) {
+	int i, j;
+	 __u32 * ed_p;
+	for (i= 0; i < 32; i++) {
+		j = 5;
+		ed_p = &(ohci->hcca->int_table [i]);
+		if (*ed_p == 0)
+		    continue;
+		printf (__FILE__ ": %s branch int %2d(%2x):", str, i, i);
+		while (*ed_p != 0 && j--) {
+			ed_t *ed = (ed_t *)m32_swap(ed_p);
+			printf (" ed: %4x;", ed->hwINFO);
+			ed_p = &ed->hwNextED;
+		}
+		printf ("\n");
+	}
+}
+
+static void ohci_dump_intr_mask (char *label, __u32 mask)
+{
+	dbg ("%s: 0x%08x%s%s%s%s%s%s%s%s%s",
+		label,
+		mask,
+		(mask & OHCI_INTR_MIE) ? " MIE" : "",
+		(mask & OHCI_INTR_OC) ? " OC" : "",
+		(mask & OHCI_INTR_RHSC) ? " RHSC" : "",
+		(mask & OHCI_INTR_FNO) ? " FNO" : "",
+		(mask & OHCI_INTR_UE) ? " UE" : "",
+		(mask & OHCI_INTR_RD) ? " RD" : "",
+		(mask & OHCI_INTR_SF) ? " SF" : "",
+		(mask & OHCI_INTR_WDH) ? " WDH" : "",
+		(mask & OHCI_INTR_SO) ? " SO" : ""
+		);
+}
+
+static void maybe_print_eds (char *label, __u32 value)
+{
+	ed_t *edp = (ed_t *)value;
+
+	if (value) {
+		dbg ("%s %08x", label, value);
+		dbg ("%08x", edp->hwINFO);
+		dbg ("%08x", edp->hwTailP);
+		dbg ("%08x", edp->hwHeadP);
+		dbg ("%08x", edp->hwNextED);
+	}
+}
+
+static char * hcfs2string (int state)
+{
+	switch (state) {
+		case OHCI_USB_RESET:	return "reset";
+		case OHCI_USB_RESUME:	return "resume";
+		case OHCI_USB_OPER:	return "operational";
+		case OHCI_USB_SUSPEND:	return "suspend";
+	}
+	return "?";
+}
+
+/* dump control and status registers */
+static void ohci_dump_status (ohci_t *controller)
+{
+	struct ohci_regs	*regs = controller->regs;
+	__u32			temp;
+
+	temp = readl (&regs->revision) & 0xff;
+	if (temp != 0x10)
+		dbg ("spec %d.%d", (temp >> 4), (temp & 0x0f));
+
+	temp = readl (&regs->control);
+	dbg ("control: 0x%08x%s%s%s HCFS=%s%s%s%s%s CBSR=%d", temp,
+		(temp & OHCI_CTRL_RWE) ? " RWE" : "",
+		(temp & OHCI_CTRL_RWC) ? " RWC" : "",
+		(temp & OHCI_CTRL_IR) ? " IR" : "",
+		hcfs2string (temp & OHCI_CTRL_HCFS),
+		(temp & OHCI_CTRL_BLE) ? " BLE" : "",
+		(temp & OHCI_CTRL_CLE) ? " CLE" : "",
+		(temp & OHCI_CTRL_IE) ? " IE" : "",
+		(temp & OHCI_CTRL_PLE) ? " PLE" : "",
+		temp & OHCI_CTRL_CBSR
+		);
+
+	temp = readl (&regs->cmdstatus);
+	dbg ("cmdstatus: 0x%08x SOC=%d%s%s%s%s", temp,
+		(temp & OHCI_SOC) >> 16,
+		(temp & OHCI_OCR) ? " OCR" : "",
+		(temp & OHCI_BLF) ? " BLF" : "",
+		(temp & OHCI_CLF) ? " CLF" : "",
+		(temp & OHCI_HCR) ? " HCR" : ""
+		);
+
+	ohci_dump_intr_mask ("intrstatus", readl (&regs->intrstatus));
+	ohci_dump_intr_mask ("intrenable", readl (&regs->intrenable));
+
+	maybe_print_eds ("ed_periodcurrent", readl (&regs->ed_periodcurrent));
+
+	maybe_print_eds ("ed_controlhead", readl (&regs->ed_controlhead));
+	maybe_print_eds ("ed_controlcurrent", readl (&regs->ed_controlcurrent));
+
+	maybe_print_eds ("ed_bulkhead", readl (&regs->ed_bulkhead));
+	maybe_print_eds ("ed_bulkcurrent", readl (&regs->ed_bulkcurrent));
+
+	maybe_print_eds ("donehead", readl (&regs->donehead));
+}
+
+static void ohci_dump_roothub (ohci_t *controller, int verbose)
+{
+	__u32			temp, ndp, i;
+
+	temp = roothub_a (controller);
+	ndp = (temp & RH_A_NDP);
+
+	if (verbose) {
+		dbg ("roothub.a: %08x POTPGT=%d%s%s%s%s%s NDP=%d", temp,
+			((temp & RH_A_POTPGT) >> 24) & 0xff,
+			(temp & RH_A_NOCP) ? " NOCP" : "",
+			(temp & RH_A_OCPM) ? " OCPM" : "",
+			(temp & RH_A_DT) ? " DT" : "",
+			(temp & RH_A_NPS) ? " NPS" : "",
+			(temp & RH_A_PSM) ? " PSM" : "",
+			ndp
+			);
+		temp = roothub_b (controller);
+		dbg ("roothub.b: %08x PPCM=%04x DR=%04x",
+			temp,
+			(temp & RH_B_PPCM) >> 16,
+			(temp & RH_B_DR)
+			);
+		temp = roothub_status (controller);
+		dbg ("roothub.status: %08x%s%s%s%s%s%s",
+			temp,
+			(temp & RH_HS_CRWE) ? " CRWE" : "",
+			(temp & RH_HS_OCIC) ? " OCIC" : "",
+			(temp & RH_HS_LPSC) ? " LPSC" : "",
+			(temp & RH_HS_DRWE) ? " DRWE" : "",
+			(temp & RH_HS_OCI) ? " OCI" : "",
+			(temp & RH_HS_LPS) ? " LPS" : ""
+			);
+	}
+
+	for (i = 0; i < ndp; i++) {
+		temp = roothub_portstatus (controller, i);
+		dbg ("roothub.portstatus [%d] = 0x%08x%s%s%s%s%s%s%s%s%s%s%s%s",
+			i,
+			temp,
+			(temp & RH_PS_PRSC) ? " PRSC" : "",
+			(temp & RH_PS_OCIC) ? " OCIC" : "",
+			(temp & RH_PS_PSSC) ? " PSSC" : "",
+			(temp & RH_PS_PESC) ? " PESC" : "",
+			(temp & RH_PS_CSC) ? " CSC" : "",
+
+			(temp & RH_PS_LSDA) ? " LSDA" : "",
+			(temp & RH_PS_PPS) ? " PPS" : "",
+			(temp & RH_PS_PRS) ? " PRS" : "",
+			(temp & RH_PS_POCI) ? " POCI" : "",
+			(temp & RH_PS_PSS) ? " PSS" : "",
+
+			(temp & RH_PS_PES) ? " PES" : "",
+			(temp & RH_PS_CCS) ? " CCS" : ""
+			);
+	}
+}
+
+static void ohci_dump (ohci_t *controller, int verbose)
+{
+	dbg ("OHCI controller usb-%s state", controller->slot_name);
+
+	/* dumps some of the state we know about */
+	ohci_dump_status (controller);
+	if (verbose)
+		ep_print_int_eds (controller, "hcca");
+	dbg ("hcca frame #%04x", controller->hcca->frame_no);
+	ohci_dump_roothub (controller, 1);
+}
+
+
+#endif /* DEBUG */
+
+/*-------------------------------------------------------------------------*
+ * Interface functions (URB)
+ *-------------------------------------------------------------------------*/
+
+/* get a transfer request */
+
+int sohci_submit_job(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, struct devrequest *setup, int interval)
+{
+	ohci_t *ohci;
+	ed_t * ed;
+	urb_priv_t *purb_priv;
+	int i, size = 0;
+
+	ohci = &gohci;
+
+	/* when controller's hung, permit only roothub cleanup attempts
+	 * such as powering down ports */
+	if (ohci->disabled) {
+		err("sohci_submit_job: EPIPE");
+		return -1;
+	}
+
+	/* every endpoint has a ed, locate and fill it */
+	if (!(ed = ep_add_ed (dev, pipe))) {
+		err("sohci_submit_job: ENOMEM");
+		return -1;
+	}
+
+	/* for the private part of the URB we need the number of TDs (size) */
+	switch (usb_pipetype (pipe)) {
+		case PIPE_BULK:	/* one TD for every 4096 Byte */
+			size = (transfer_len - 1) / 4096 + 1;
+			break;
+		case PIPE_CONTROL: /* 1 TD for setup, 1 for ACK and 1 for every 4096 B */
+			size = (transfer_len == 0)? 2:
+						(transfer_len - 1) / 4096 + 3;
+			break;
+	}
+
+	if (size >= (N_URB_TD - 1)) {
+		err("need %d TDs, only have %d", size, N_URB_TD);
+		return -1;
+	}
+	purb_priv = &urb_priv;
+	purb_priv->pipe = pipe;
+
+	/* fill the private part of the URB */
+	purb_priv->length = size;
+	purb_priv->ed = ed;
+	purb_priv->actual_length = 0;
+
+	/* allocate the TDs */
+	/* note that td[0] was allocated in ep_add_ed */
+	for (i = 0; i < size; i++) {
+		purb_priv->td[i] = td_alloc (dev);
+		if (!purb_priv->td[i]) {
+			purb_priv->length = i;
+			urb_free_priv (purb_priv);
+			err("sohci_submit_job: ENOMEM");
+			return -1;
+		}
+	}
+
+	if (ed->state == ED_NEW || (ed->state & ED_DEL)) {
+		urb_free_priv (purb_priv);
+		err("sohci_submit_job: EINVAL");
+		return -1;
+	}
+
+	/* link the ed into a chain if is not already */
+	if (ed->state != ED_OPER)
+		ep_link (ohci, ed);
+
+	/* fill the TDs and link it to the ed */
+	td_submit_job(dev, pipe, buffer, transfer_len, setup, purb_priv, interval);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+/* tell us the current USB frame number */
+
+static int sohci_get_current_frame_number (struct usb_device *usb_dev)
+{
+	ohci_t *ohci = &gohci;
+
+	return m16_swap (ohci->hcca->frame_no);
+}
+#endif
+
+/*-------------------------------------------------------------------------*
+ * ED handling functions
+ *-------------------------------------------------------------------------*/
+
+/* link an ed into one of the HC chains */
+
+static int ep_link (ohci_t *ohci, ed_t *edi)
+{
+	volatile ed_t *ed = edi;
+
+	ed->state = ED_OPER;
+
+	switch (ed->type) {
+	case PIPE_CONTROL:
+		ed->hwNextED = 0;
+		if (ohci->ed_controltail == NULL) {
+			writel (ed, &ohci->regs->ed_controlhead);
+		} else {
+			ohci->ed_controltail->hwNextED = m32_swap (ed);
+		}
+		ed->ed_prev = ohci->ed_controltail;
+		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
+			!ohci->ed_rm_list[1] && !ohci->sleeping) {
+			ohci->hc_control |= OHCI_CTRL_CLE;
+			writel (ohci->hc_control, &ohci->regs->control);
+		}
+		ohci->ed_controltail = edi;
+		break;
+
+	case PIPE_BULK:
+		ed->hwNextED = 0;
+		if (ohci->ed_bulktail == NULL) {
+			writel (ed, &ohci->regs->ed_bulkhead);
+		} else {
+			ohci->ed_bulktail->hwNextED = m32_swap (ed);
+		}
+		ed->ed_prev = ohci->ed_bulktail;
+		if (!ohci->ed_bulktail && !ohci->ed_rm_list[0] &&
+			!ohci->ed_rm_list[1] && !ohci->sleeping) {
+			ohci->hc_control |= OHCI_CTRL_BLE;
+			writel (ohci->hc_control, &ohci->regs->control);
+		}
+		ohci->ed_bulktail = edi;
+		break;
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* unlink an ed from one of the HC chains.
+ * just the link to the ed is unlinked.
+ * the link from the ed still points to another operational ed or 0
+ * so the HC can eventually finish the processing of the unlinked ed */
+
+static int ep_unlink (ohci_t *ohci, ed_t *ed)
+{
+	ed->hwINFO |= m32_swap (OHCI_ED_SKIP);
+
+	switch (ed->type) {
+	case PIPE_CONTROL:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_CLE;
+				writel (ohci->hc_control, &ohci->regs->control);
+			}
+			writel (m32_swap (*((__u32 *)&ed->hwNextED)), &ohci->regs->ed_controlhead);
+		} else {
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_controltail == ed) {
+			ohci->ed_controltail = ed->ed_prev;
+		} else {
+			((ed_t *)m32_swap (*((__u32 *)&ed->hwNextED)))->ed_prev = ed->ed_prev;
+		}
+		break;
+
+	case PIPE_BULK:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_BLE;
+				writel (ohci->hc_control, &ohci->regs->control);
+			}
+			writel (m32_swap (*((__u32 *)&ed->hwNextED)), &ohci->regs->ed_bulkhead);
+		} else {
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_bulktail == ed) {
+			ohci->ed_bulktail = ed->ed_prev;
+		} else {
+			((ed_t *)m32_swap (*((__u32 *)&ed->hwNextED)))->ed_prev = ed->ed_prev;
+		}
+		break;
+	}
+	ed->state = ED_UNLINK;
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* add/reinit an endpoint; this should be done once at the usb_set_configuration command,
+ * but the USB stack is a little bit stateless  so we do it at every transaction
+ * if the state of the ed is ED_NEW then a dummy td is added and the state is changed to ED_UNLINK
+ * in all other cases the state is left unchanged
+ * the ed info fields are setted anyway even though most of them should not change */
+
+static ed_t * ep_add_ed (struct usb_device *usb_dev, unsigned long pipe)
+{
+	td_t *td;
+	ed_t *ed_ret;
+	volatile ed_t *ed;
+
+	ed = ed_ret = &ohci_dev.ed[(usb_pipeendpoint (pipe) << 1) |
+			(usb_pipecontrol (pipe)? 0: usb_pipeout (pipe))];
+
+	if ((ed->state & ED_DEL) || (ed->state & ED_URB_DEL)) {
+		err("ep_add_ed: pending delete");
+		/* pending delete request */
+		return NULL;
+	}
+
+	if (ed->state == ED_NEW) {
+		ed->hwINFO = m32_swap (OHCI_ED_SKIP); /* skip ed */
+		/* dummy td; end of td list for ed */
+		td = td_alloc (usb_dev);
+		ed->hwTailP = m32_swap (td);
+		ed->hwHeadP = ed->hwTailP;
+		ed->state = ED_UNLINK;
+		ed->type = usb_pipetype (pipe);
+		ohci_dev.ed_cnt++;
+	}
+
+	ed->hwINFO = m32_swap (usb_pipedevice (pipe)
+			| usb_pipeendpoint (pipe) << 7
+			| (usb_pipeisoc (pipe)? 0x8000: 0)
+			| (usb_pipecontrol (pipe)? 0: (usb_pipeout (pipe)? 0x800: 0x1000))
+			| usb_pipeslow (pipe) << 13
+			| usb_maxpacket (usb_dev, pipe) << 16);
+
+	return ed_ret;
+}
+
+/*-------------------------------------------------------------------------*
+ * TD handling functions
+ *-------------------------------------------------------------------------*/
+
+/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */
+
+static void td_fill (ohci_t *ohci, unsigned int info,
+	void *data, int len,
+	struct usb_device *dev, int index, urb_priv_t *urb_priv)
+{
+	volatile td_t  *td, *td_pt;
+#ifdef OHCI_FILL_TRACE
+	int i;
+#endif
+
+	if (index > urb_priv->length) {
+		err("index > length");
+		return;
+	}
+	/* use this td as the next dummy */
+	td_pt = urb_priv->td [index];
+	td_pt->hwNextTD = 0;
+
+	/* fill the old dummy TD */
+	td = urb_priv->td [index] = (td_t *)(m32_swap (urb_priv->ed->hwTailP) & ~0xf);
+
+	td->ed = urb_priv->ed;
+	td->next_dl_td = NULL;
+	td->index = index;
+	td->data = (__u32)data;
+#ifdef OHCI_FILL_TRACE
+	if ((usb_pipetype(urb_priv->pipe) == PIPE_BULK) && usb_pipeout(urb_priv->pipe)) {
+		for (i = 0; i < len; i++)
+		printf("td->data[%d] %#2x ",i, ((unsigned char *)td->data)[i]);
+		printf("\n");
+	}
+#endif
+	if (!len)
+		data = 0;
+
+	td->hwINFO = m32_swap (info);
+	td->hwCBP = m32_swap (data);
+	if (data)
+		td->hwBE = m32_swap (data + len - 1);
+	else
+		td->hwBE = 0;
+	td->hwNextTD = m32_swap (td_pt);
+	td->hwPSW [0] = m16_swap (((__u32)data & 0x0FFF) | 0xE000);
+
+	/* append to queue */
+	td->ed->hwTailP = td->hwNextTD;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* prepare all TDs of a transfer */
+
+static void td_submit_job (struct usb_device *dev, unsigned long pipe, void *buffer,
+	int transfer_len, struct devrequest *setup, urb_priv_t *urb, int interval)
+{
+	ohci_t *ohci = &gohci;
+	int data_len = transfer_len;
+	void *data;
+	int cnt = 0;
+	__u32 info = 0;
+	unsigned int toggle = 0;
+
+	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle bits for reseting */
+	if(usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
+		toggle = TD_T_TOGGLE;
+	} else {
+		toggle = TD_T_DATA0;
+		usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 1);
+	}
+	urb->td_cnt = 0;
+	if (data_len)
+		data = buffer;
+	else
+		data = 0;
+
+	switch (usb_pipetype (pipe)) {
+	case PIPE_BULK:
+		info = usb_pipeout (pipe)?
+			TD_CC | TD_DP_OUT : TD_CC | TD_DP_IN ;
+		while(data_len > 4096) {
+			td_fill (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, 4096, dev, cnt, urb);
+			data += 4096; data_len -= 4096; cnt++;
+		}
+		info = usb_pipeout (pipe)?
+			TD_CC | TD_DP_OUT : TD_CC | TD_R | TD_DP_IN ;
+		td_fill (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, data_len, dev, cnt, urb);
+		cnt++;
+
+		if (!ohci->sleeping)
+			writel (OHCI_BLF, &ohci->regs->cmdstatus); /* start bulk list */
+		break;
+
+	case PIPE_CONTROL:
+		info = TD_CC | TD_DP_SETUP | TD_T_DATA0;
+		td_fill (ohci, info, setup, 8, dev, cnt++, urb);
+		if (data_len > 0) {
+			info = usb_pipeout (pipe)?
+				TD_CC | TD_R | TD_DP_OUT | TD_T_DATA1 : TD_CC | TD_R | TD_DP_IN | TD_T_DATA1;
+			/* NOTE:  mishandles transfers >8K, some >4K */
+			td_fill (ohci, info, data, data_len, dev, cnt++, urb);
+		}
+		info = usb_pipeout (pipe)?
+			TD_CC | TD_DP_IN | TD_T_DATA1: TD_CC | TD_DP_OUT | TD_T_DATA1;
+		td_fill (ohci, info, data, 0, dev, cnt++, urb);
+		if (!ohci->sleeping)
+			writel (OHCI_CLF, &ohci->regs->cmdstatus); /* start Control list */
+		break;
+	}
+	if (urb->length != cnt)
+		dbg("TD LENGTH %d != CNT %d", urb->length, cnt);
+}
+
+/*-------------------------------------------------------------------------*
+ * Done List handling functions
+ *-------------------------------------------------------------------------*/
+
+
+/* calculate the transfer length and update the urb */
+
+static void dl_transfer_length(td_t * td)
+{
+	__u32 tdINFO, tdBE, tdCBP;
+	urb_priv_t *lurb_priv = &urb_priv;
+
+	tdINFO = m32_swap (td->hwINFO);
+	tdBE   = m32_swap (td->hwBE);
+	tdCBP  = m32_swap (td->hwCBP);
+
+
+	if (!(usb_pipetype (lurb_priv->pipe) == PIPE_CONTROL &&
+	    ((td->index == 0) || (td->index == lurb_priv->length - 1)))) {
+		if (tdBE != 0) {
+			if (td->hwCBP == 0)
+				lurb_priv->actual_length += tdBE - td->data + 1;
+			else
+				lurb_priv->actual_length += tdCBP - td->data;
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* replies to the request have to be on a FIFO basis so
+ * we reverse the reversed done-list */
+
+static td_t * dl_reverse_done_list (ohci_t *ohci)
+{
+	__u32 td_list_hc;
+	td_t *td_rev = NULL;
+	td_t *td_list = NULL;
+	urb_priv_t *lurb_priv = NULL;
+
+	td_list_hc = m32_swap (ohci->hcca->done_head) & 0xfffffff0;
+	ohci->hcca->done_head = 0;
+
+	while (td_list_hc) {
+		td_list = (td_t *)td_list_hc;
+
+		if (TD_CC_GET (m32_swap (td_list->hwINFO))) {
+			lurb_priv = &urb_priv;
+			dbg(" USB-error/status: %x : %p",
+					TD_CC_GET (m32_swap (td_list->hwINFO)), td_list);
+			if (td_list->ed->hwHeadP & m32_swap (0x1)) {
+				if (lurb_priv && ((td_list->index + 1) < lurb_priv->length)) {
+					td_list->ed->hwHeadP =
+						(lurb_priv->td[lurb_priv->length - 1]->hwNextTD & m32_swap (0xfffffff0)) |
+									(td_list->ed->hwHeadP & m32_swap (0x2));
+					lurb_priv->td_cnt += lurb_priv->length - td_list->index - 1;
+				} else
+					td_list->ed->hwHeadP &= m32_swap (0xfffffff2);
+			}
+		}
+
+		td_list->next_dl_td = td_rev;
+		td_rev = td_list;
+		td_list_hc = m32_swap (td_list->hwNextTD) & 0xfffffff0;
+	}
+	return td_list;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* td done list */
+static int dl_done_list (ohci_t *ohci, td_t *td_list)
+{
+	td_t *td_list_next = NULL;
+	ed_t *ed;
+	int cc = 0;
+	int stat = 0;
+	/* urb_t *urb; */
+	urb_priv_t *lurb_priv;
+	__u32 tdINFO, edHeadP, edTailP;
+
+	while (td_list) {
+		td_list_next = td_list->next_dl_td;
+
+		lurb_priv = &urb_priv;
+		tdINFO = m32_swap (td_list->hwINFO);
+
+		ed = td_list->ed;
+
+		dl_transfer_length(td_list);
+
+		/* error code of transfer */
+		cc = TD_CC_GET (tdINFO);
+		if (cc != 0) {
+			dbg("ConditionCode %#x", cc);
+			stat = cc_to_error[cc];
+		}
+
+		if (ed->state != ED_NEW) {
+			edHeadP = m32_swap (ed->hwHeadP) & 0xfffffff0;
+			edTailP = m32_swap (ed->hwTailP);
+
+			/* unlink eds if they are not busy */
+			if ((edHeadP == edTailP) && (ed->state == ED_OPER))
+				ep_unlink (ohci, ed);
+		}
+
+		td_list = td_list_next;
+	}
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*
+ * Virtual Root Hub
+ *-------------------------------------------------------------------------*/
+
+/* Device descriptor */
+static __u8 root_hub_dev_des[] =
+{
+	0x12,       /*  __u8  bLength; */
+	0x01,       /*  __u8  bDescriptorType; Device */
+	0x10,	    /*  __u16 bcdUSB; v1.1 */
+	0x01,
+	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
+	0x00,	    /*  __u8  bDeviceSubClass; */
+	0x00,       /*  __u8  bDeviceProtocol; */
+	0x08,       /*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x00,       /*  __u16 idVendor; */
+	0x00,
+	0x00,       /*  __u16 idProduct; */
+	0x00,
+	0x00,       /*  __u16 bcdDevice; */
+	0x00,
+	0x00,       /*  __u8  iManufacturer; */
+	0x01,       /*  __u8  iProduct; */
+	0x00,       /*  __u8  iSerialNumber; */
+	0x01        /*  __u8  bNumConfigurations; */
+};
+
+
+/* Configuration descriptor */
+static __u8 root_hub_config_des[] =
+{
+	0x09,       /*  __u8  bLength; */
+	0x02,       /*  __u8  bDescriptorType; Configuration */
+	0x19,       /*  __u16 wTotalLength; */
+	0x00,
+	0x01,       /*  __u8  bNumInterfaces; */
+	0x01,       /*  __u8  bConfigurationValue; */
+	0x00,       /*  __u8  iConfiguration; */
+	0x40,       /*  __u8  bmAttributes;
+		 Bit 7: Bus-powered, 6: Self-powered, 5 Remote-wakwup, 4..0: resvd */
+	0x00,       /*  __u8  MaxPower; */
+
+	/* interface */
+	0x09,       /*  __u8  if_bLength; */
+	0x04,       /*  __u8  if_bDescriptorType; Interface */
+	0x00,       /*  __u8  if_bInterfaceNumber; */
+	0x00,       /*  __u8  if_bAlternateSetting; */
+	0x01,       /*  __u8  if_bNumEndpoints; */
+	0x09,       /*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
+	0x00,       /*  __u8  if_bInterfaceSubClass; */
+	0x00,       /*  __u8  if_bInterfaceProtocol; */
+	0x00,       /*  __u8  if_iInterface; */
+
+	/* endpoint */
+	0x07,       /*  __u8  ep_bLength; */
+	0x05,       /*  __u8  ep_bDescriptorType; Endpoint */
+	0x81,       /*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
+	0x03,       /*  __u8  ep_bmAttributes; Interrupt */
+	0x02,       /*  __u16 ep_wMaxPacketSize; ((MAX_ROOT_PORTS + 1) / 8 */
+	0x00,
+	0xff        /*  __u8  ep_bInterval; 255 ms */
+};
+
+static unsigned char root_hub_str_index0[] =
+{
+	0x04,			/*  __u8  bLength; */
+	0x03,			/*  __u8  bDescriptorType; String-descriptor */
+	0x09,			/*  __u8  lang ID */
+	0x04,			/*  __u8  lang ID */
+};
+
+static unsigned char root_hub_str_index1[] =
+{
+	28,			/*  __u8  bLength; */
+	0x03,			/*  __u8  bDescriptorType; String-descriptor */
+	'O',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'H',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'C',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'I',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	' ',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'R',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'o',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'o',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	't',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	' ',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'H',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'u',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'b',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+};
+
+/* Hub class-specific descriptor is constructed dynamically */
+
+
+/*-------------------------------------------------------------------------*/
+
+#define OK(x) 			len = (x); break
+#ifdef DEBUG
+#define WR_RH_STAT(x) 		{info("WR:status %#8x", (x));writel((x), &gohci.regs->roothub.status);}
+#define WR_RH_PORTSTAT(x) 	{info("WR:portstatus[%d] %#8x", wIndex-1, (x));writel((x), &gohci.regs->roothub.portstatus[wIndex-1]);}
+#else
+#define WR_RH_STAT(x) 		writel((x), &gohci.regs->roothub.status)
+#define WR_RH_PORTSTAT(x) 	writel((x), &gohci.regs->roothub.portstatus[wIndex-1])
+#endif
+#define RD_RH_STAT		roothub_status(&gohci)
+#define RD_RH_PORTSTAT		roothub_portstatus(&gohci,wIndex-1)
+
+/* request to virtual root hub */
+
+int rh_check_port_status(ohci_t *controller)
+{
+	__u32 temp, ndp, i;
+	int res;
+
+	res = -1;
+	temp = roothub_a (controller);
+	ndp = (temp & RH_A_NDP);
+	for (i = 0; i < ndp; i++) {
+		temp = roothub_portstatus (controller, i);
+		/* check for a device disconnect */
+		if (((temp & (RH_PS_PESC | RH_PS_CSC)) ==
+			(RH_PS_PESC | RH_PS_CSC)) &&
+			((temp & RH_PS_CCS) == 0)) {
+			res = i;
+			break;
+		}
+	}
+	return res;
+}
+
+static int ohci_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
+		void *buffer, int transfer_len, struct devrequest *cmd)
+{
+	void * data = buffer;
+	int leni = transfer_len;
+	int len = 0;
+	int stat = 0;
+	__u32 datab[4];
+	__u8 *data_buf = (__u8 *)datab;
+	__u16 bmRType_bReq;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+
+#ifdef DEBUG
+urb_priv.actual_length = 0;
+pkt_print(dev, pipe, buffer, transfer_len, cmd, "SUB(rh)", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+	if ((pipe & PIPE_INTERRUPT) == PIPE_INTERRUPT) {
+		info("Root-Hub submit IRQ: NOT implemented");
+		return 0;
+	}
+
+	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
+	wValue        = m16_swap (cmd->value);
+	wIndex        = m16_swap (cmd->index);
+	wLength       = m16_swap (cmd->length);
+
+	info("Root-Hub: adr: %2x cmd(%1x): %08x %04x %04x %04x",
+		dev->devnum, 8, bmRType_bReq, wValue, wIndex, wLength);
+
+	switch (bmRType_bReq) {
+	/* Request Destination:
+	   without flags: Device,
+	   RH_INTERFACE: interface,
+	   RH_ENDPOINT: endpoint,
+	   RH_CLASS means HUB here,
+	   RH_OTHER | RH_CLASS  almost ever means HUB_PORT here
+	*/
+
+	case RH_GET_STATUS:
+			*(__u16 *) data_buf = m16_swap (1); OK (2);
+	case RH_GET_STATUS | RH_INTERFACE:
+			*(__u16 *) data_buf = m16_swap (0); OK (2);
+	case RH_GET_STATUS | RH_ENDPOINT:
+			*(__u16 *) data_buf = m16_swap (0); OK (2);
+	case RH_GET_STATUS | RH_CLASS:
+			*(__u32 *) data_buf = m32_swap (
+				RD_RH_STAT & ~(RH_HS_CRWE | RH_HS_DRWE));
+			OK (4);
+	case RH_GET_STATUS | RH_OTHER | RH_CLASS:
+			*(__u32 *) data_buf = m32_swap (RD_RH_PORTSTAT); OK (4);
+
+	case RH_CLEAR_FEATURE | RH_ENDPOINT:
+		switch (wValue) {
+			case (RH_ENDPOINT_STALL): OK (0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_CLASS:
+		switch (wValue) {
+			case RH_C_HUB_LOCAL_POWER:
+				OK(0);
+			case (RH_C_HUB_OVER_CURRENT):
+					WR_RH_STAT(RH_HS_OCIC); OK (0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+			case (RH_PORT_ENABLE):
+					WR_RH_PORTSTAT (RH_PS_CCS ); OK (0);
+			case (RH_PORT_SUSPEND):
+					WR_RH_PORTSTAT (RH_PS_POCI); OK (0);
+			case (RH_PORT_POWER):
+					WR_RH_PORTSTAT (RH_PS_LSDA); OK (0);
+			case (RH_C_PORT_CONNECTION):
+					WR_RH_PORTSTAT (RH_PS_CSC ); OK (0);
+			case (RH_C_PORT_ENABLE):
+					WR_RH_PORTSTAT (RH_PS_PESC); OK (0);
+			case (RH_C_PORT_SUSPEND):
+					WR_RH_PORTSTAT (RH_PS_PSSC); OK (0);
+			case (RH_C_PORT_OVER_CURRENT):
+					WR_RH_PORTSTAT (RH_PS_OCIC); OK (0);
+			case (RH_C_PORT_RESET):
+					WR_RH_PORTSTAT (RH_PS_PRSC); OK (0);
+		}
+		break;
+
+	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+			case (RH_PORT_SUSPEND):
+					WR_RH_PORTSTAT (RH_PS_PSS ); OK (0);
+			case (RH_PORT_RESET): /* BUG IN HUP CODE *********/
+					if (RD_RH_PORTSTAT & RH_PS_CCS)
+					    WR_RH_PORTSTAT (RH_PS_PRS);
+					OK (0);
+			case (RH_PORT_POWER):
+					WR_RH_PORTSTAT (RH_PS_PPS ); OK (0);
+			case (RH_PORT_ENABLE): /* BUG IN HUP CODE *********/
+					if (RD_RH_PORTSTAT & RH_PS_CCS)
+					    WR_RH_PORTSTAT (RH_PS_PES );
+					OK (0);
+		}
+		break;
+
+	case RH_SET_ADDRESS: gohci.rh.devnum = wValue; OK(0);
+
+	case RH_GET_DESCRIPTOR:
+		switch ((wValue & 0xff00) >> 8) {
+			case (0x01): /* device descriptor */
+				len = min_t(unsigned int,
+					  leni,
+					  min_t(unsigned int,
+					      sizeof (root_hub_dev_des),
+					      wLength));
+				data_buf = root_hub_dev_des; OK(len);
+			case (0x02): /* configuration descriptor */
+				len = min_t(unsigned int,
+					  leni,
+					  min_t(unsigned int,
+					      sizeof (root_hub_config_des),
+					      wLength));
+				data_buf = root_hub_config_des; OK(len);
+			case (0x03): /* string descriptors */
+				if(wValue==0x0300) {
+					len = min_t(unsigned int,
+						  leni,
+						  min_t(unsigned int,
+						      sizeof (root_hub_str_index0),
+						      wLength));
+					data_buf = root_hub_str_index0;
+					OK(len);
+				}
+				if(wValue==0x0301) {
+					len = min_t(unsigned int,
+						  leni,
+						  min_t(unsigned int,
+						      sizeof (root_hub_str_index1),
+						      wLength));
+					data_buf = root_hub_str_index1;
+					OK(len);
+			}
+			default:
+				stat = USB_ST_STALLED;
+		}
+		break;
+
+	case RH_GET_DESCRIPTOR | RH_CLASS:
+	    {
+		    __u32 temp = roothub_a (&gohci);
+
+		    data_buf [0] = 9;		/* min length; */
+		    data_buf [1] = 0x29;
+		    data_buf [2] = temp & RH_A_NDP;
+		    data_buf [3] = 0;
+		    if (temp & RH_A_PSM) 	/* per-port power switching? */
+			data_buf [3] |= 0x1;
+		    if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
+			data_buf [3] |= 0x10;
+		    else if (temp & RH_A_OCPM)	/* per-port overcurrent reporting? */
+			data_buf [3] |= 0x8;
+
+		    /* corresponds to data_buf[4-7] */
+		    datab [1] = 0;
+		    data_buf [5] = (temp & RH_A_POTPGT) >> 24;
+		    temp = roothub_b (&gohci);
+		    data_buf [7] = temp & RH_B_DR;
+		    if (data_buf [2] < 7) {
+			data_buf [8] = 0xff;
+		    } else {
+			data_buf [0] += 2;
+			data_buf [8] = (temp & RH_B_DR) >> 8;
+			data_buf [10] = data_buf [9] = 0xff;
+		    }
+
+		    len = min_t(unsigned int, leni,
+			      min_t(unsigned int, data_buf [0], wLength));
+		    OK (len);
+		}
+
+	case RH_GET_CONFIGURATION: 	*(__u8 *) data_buf = 0x01; OK (1);
+
+	case RH_SET_CONFIGURATION: 	WR_RH_STAT (0x10000); OK (0);
+
+	default:
+		dbg ("unsupported root hub command");
+		stat = USB_ST_STALLED;
+	}
+
+#ifdef	DEBUG
+	ohci_dump_roothub (&gohci, 1);
+#else
+	wait_ms(1);
+#endif
+
+	len = min_t(int, len, leni);
+	if (data != data_buf)
+	    memcpy (data, data_buf, len);
+	dev->act_len = len;
+	dev->status = stat;
+
+#ifdef DEBUG
+	if (transfer_len)
+		urb_priv.actual_length = transfer_len;
+	pkt_print(dev, pipe, buffer, transfer_len, cmd, "RET(rh)", 0/*usb_pipein(pipe)*/);
+#else
+	wait_ms(1);
+#endif
+
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* common code for handling submit messages - used for all but root hub */
+/* accesses. */
+int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, struct devrequest *setup, int interval)
+{
+	int stat = 0;
+	int maxsize = usb_maxpacket(dev, pipe);
+	int timeout;
+
+	/* device pulled? Shortcut the action. */
+	if (devgone == dev) {
+		dev->status = USB_ST_CRC_ERR;
+		return 0;
+	}
+
+#ifdef DEBUG
+	urb_priv.actual_length = 0;
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+	if (!maxsize) {
+		err("submit_common_message: pipesize for pipe %lx is zero",
+			pipe);
+		return -1;
+	}
+
+	if (sohci_submit_job(dev, pipe, buffer, transfer_len, setup, interval) < 0) {
+		err("sohci_submit_job failed");
+		return -1;
+	}
+
+	wait_ms(10);
+	/* ohci_dump_status(&gohci); */
+
+	/* allow more time for a BULK device to react - some are slow */
+#define BULK_TO	 5000	/* timeout in milliseconds */
+	if (usb_pipetype (pipe) == PIPE_BULK)
+		timeout = BULK_TO;
+	else
+		timeout = 100;
+
+	/* wait for it to complete */
+	for (;;) {
+		/* check whether the controller is done */
+		stat = hc_interrupt();
+		if (stat < 0) {
+			stat = USB_ST_CRC_ERR;
+			break;
+		}
+		if (stat >= 0 && stat != 0xff) {
+			/* 0xff is returned for an SF-interrupt */
+			break;
+		}
+		if (--timeout) {
+			wait_ms(1);
+		} else {
+			err("CTL:TIMEOUT ");
+			stat = USB_ST_CRC_ERR;
+			break;
+		}
+	}
+	/* we got an Root Hub Status Change interrupt */
+	if (got_rhsc) {
+#ifdef DEBUG
+		ohci_dump_roothub (&gohci, 1);
+#endif
+		got_rhsc = 0;
+		/* abuse timeout */
+		timeout = rh_check_port_status(&gohci);
+		if (timeout >= 0) {
+#if 0 /* this does nothing useful, but leave it here in case that changes */
+			/* the called routine adds 1 to the passed value */
+			usb_hub_port_connect_change(gohci.rh.dev, timeout - 1);
+#endif
+			/*
+			 * XXX
+			 * This is potentially dangerous because it assumes
+			 * that only one device is ever plugged in!
+			 */
+			devgone = dev;
+		}
+	}
+
+	dev->status = stat;
+	dev->act_len = transfer_len;
+
+#ifdef DEBUG
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "RET(ctlr)", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+
+	/* free TDs in urb_priv */
+	urb_free_priv (&urb_priv);
+	return 0;
+}
+
+/* submit routines called from usb.c */
+int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len)
+{
+	info("submit_bulk_msg");
+	return submit_common_msg(dev, pipe, buffer, transfer_len, NULL, 0);
+}
+
+int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, struct devrequest *setup)
+{
+	int maxsize = usb_maxpacket(dev, pipe);
+
+	info("submit_control_msg");
+#ifdef DEBUG
+	urb_priv.actual_length = 0;
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+	if (!maxsize) {
+		err("submit_control_message: pipesize for pipe %lx is zero",
+			pipe);
+		return -1;
+	}
+	if (((pipe >> 8) & 0x7f) == gohci.rh.devnum) {
+		gohci.rh.dev = dev;
+		/* root hub - redirect */
+		return ohci_submit_rh_msg(dev, pipe, buffer, transfer_len,
+			setup);
+	}
+
+	return submit_common_msg(dev, pipe, buffer, transfer_len, setup, 0);
+}
+
+int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, int interval)
+{
+	info("submit_int_msg");
+	return -1;
+}
+
+/*-------------------------------------------------------------------------*
+ * HC functions
+ *-------------------------------------------------------------------------*/
+
+/* reset the HC and BUS */
+
+static int hc_reset (ohci_t *ohci)
+{
+	int timeout = 30;
+	int smm_timeout = 50; /* 0,5 sec */
+
+	if (readl (&ohci->regs->control) & OHCI_CTRL_IR) { /* SMM owns the HC */
+		writel (OHCI_OCR, &ohci->regs->cmdstatus); /* request ownership */
+		info("USB HC TakeOver from SMM");
+		while (readl (&ohci->regs->control) & OHCI_CTRL_IR) {
+			wait_ms (10);
+			if (--smm_timeout == 0) {
+				err("USB HC TakeOver failed!");
+				return -1;
+			}
+		}
+	}
+
+	/* Disable HC interrupts */
+	writel (OHCI_INTR_MIE, &ohci->regs->intrdisable);
+
+	dbg("USB HC reset_hc usb-%s: ctrl = 0x%X ;",
+		ohci->slot_name,
+		readl (&ohci->regs->control));
+
+	/* Reset USB (needed by some controllers) */
+	writel (0, &ohci->regs->control);
+
+	/* HC Reset requires max 10 us delay */
+	writel (OHCI_HCR,  &ohci->regs->cmdstatus);
+	while ((readl (&ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
+		if (--timeout == 0) {
+			err("USB HC reset timed out!");
+			return -1;
+		}
+		udelay (1);
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Start an OHCI controller, set the BUS operational
+ * enable interrupts
+ * connect the virtual root hub */
+
+static int hc_start (ohci_t * ohci)
+{
+	__u32 mask;
+	unsigned int fminterval;
+
+	ohci->disabled = 1;
+
+	/* Tell the controller where the control and bulk lists are
+	 * The lists are empty now. */
+
+	writel (0, &ohci->regs->ed_controlhead);
+	writel (0, &ohci->regs->ed_bulkhead);
+
+	writel ((__u32)ohci->hcca, &ohci->regs->hcca); /* a reset clears this */
+
+	fminterval = 0x2edf;
+	writel ((fminterval * 9) / 10, &ohci->regs->periodicstart);
+	fminterval |= ((((fminterval - 210) * 6) / 7) << 16);
+	writel (fminterval, &ohci->regs->fminterval);
+	writel (0x628, &ohci->regs->lsthresh);
+
+	/* start controller operations */
+	ohci->hc_control = OHCI_CONTROL_INIT | OHCI_USB_OPER;
+	ohci->disabled = 0;
+	writel (ohci->hc_control, &ohci->regs->control);
+
+	/* disable all interrupts */
+	mask = (OHCI_INTR_SO | OHCI_INTR_WDH | OHCI_INTR_SF | OHCI_INTR_RD |
+			OHCI_INTR_UE | OHCI_INTR_FNO | OHCI_INTR_RHSC |
+			OHCI_INTR_OC | OHCI_INTR_MIE);
+	writel (mask, &ohci->regs->intrdisable);
+	/* clear all interrupts */
+	mask &= ~OHCI_INTR_MIE;
+	writel (mask, &ohci->regs->intrstatus);
+	/* Choose the interrupts we care about now  - but w/o MIE */
+	mask = OHCI_INTR_RHSC | OHCI_INTR_UE | OHCI_INTR_WDH | OHCI_INTR_SO;
+	writel (mask, &ohci->regs->intrenable);
+
+#ifdef	OHCI_USE_NPS
+	/* required for AMD-756 and some Mac platforms */
+	writel ((roothub_a (ohci) | RH_A_NPS) & ~RH_A_PSM,
+		&ohci->regs->roothub.a);
+	writel (RH_HS_LPSC, &ohci->regs->roothub.status);
+#endif	/* OHCI_USE_NPS */
+
+#define mdelay(n) ({unsigned long msec=(n); while (msec--) udelay(1000);})
+	/* POTPGT delay is bits 24-31, in 2 ms units. */
+	mdelay ((roothub_a (ohci) >> 23) & 0x1fe);
+
+	/* connect the virtual root hub */
+	ohci->rh.devnum = 0;
+
+printf( "---> Done with hc_start\n" );
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* an interrupt happens */
+
+static int
+hc_interrupt (void)
+{
+	ohci_t *ohci = &gohci;
+	struct ohci_regs *regs = ohci->regs;
+	int ints;
+	int stat = -1;
+
+	if ((ohci->hcca->done_head != 0) && !(m32_swap (ohci->hcca->done_head) & 0x01)) {
+		ints =  OHCI_INTR_WDH;
+	} else {
+		ints = readl (&regs->intrstatus);
+	}
+
+dbg("Interrupt: %x frame: %x", ints, ohci->hcca->frame_no);
+
+	if (ints & OHCI_INTR_RHSC) {
+dbg("rhsc\n" );
+		got_rhsc = 1;
+	}
+
+	if (ints & OHCI_INTR_UE) {
+		ohci->disabled++;
+		err ("OHCI Unrecoverable Error, controller usb-%s disabled",
+			ohci->slot_name);
+		/* e.g. due to PCI Master/Target Abort */
+
+#ifdef	DEBUG
+		ohci_dump (ohci, 1);
+#else
+	wait_ms(1);
+#endif
+		/* FIXME: be optimistic, hope that bug won't repeat often. */
+		/* Make some non-interrupt context restart the controller. */
+		/* Count and limit the retries though; either hardware or */
+		/* software errors can go forever... */
+		hc_reset (ohci);
+		return -1;
+	}
+
+	if (ints & OHCI_INTR_WDH) {
+		wait_ms(1);
+		writel (OHCI_INTR_WDH, &regs->intrdisable);
+		stat = dl_done_list (&gohci, dl_reverse_done_list (&gohci));
+		writel (OHCI_INTR_WDH, &regs->intrenable);
+dbg("wdh: %x\n", stat );
+		goto out ;
+	}
+
+	if (ints & OHCI_INTR_SO) {
+		dbg("USB Schedule overrun\n");
+		writel (OHCI_INTR_SO, &regs->intrenable);
+		stat = -1;
+	}
+
+	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
+	if (ints & OHCI_INTR_SF) {
+		unsigned int frame = m16_swap (ohci->hcca->frame_no) & 1;
+		wait_ms(1);
+		writel (OHCI_INTR_SF, &regs->intrdisable);
+		if (ohci->ed_rm_list[frame] != NULL)
+			writel (OHCI_INTR_SF, &regs->intrenable);
+		if( -1 == stat )
+			stat = 0xff;
+dbg("sf\n" );
+	}
+	if( 0 == ints )
+		stat = 0 ;
+out:
+	writel (ints, &regs->intrstatus);
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*-------------------------------------------------------------------------*/
+
+/* De-allocate all resources.. */
+
+static void hc_release_ohci (ohci_t *ohci)
+{
+	dbg ("USB HC release ohci usb-%s", ohci->slot_name);
+
+	if (!ohci->disabled)
+		hc_reset (ohci);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * low level initalisation routine, called from usb.c
+ */
+static char ohci_inited = 0;
+
+int usb_lowlevel_init(void)
+{
+#ifdef FIXME
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+	/*
+	 * Set the 48 MHz UPLL clocking. Values are taken from
+	 * "PLL value selection guide", 6-23, s3c2400_UM.pdf.
+	 */
+	clk_power->UPLLCON = ((40 << 12) + (1 << 4) + 2);
+	gpio->MISCCR |= 0x8; /* 1 = use pads related USB for USB host */
+	/*
+	 * Enable USB host clock.
+	 */
+	clk_power->CLKCON |= (1 << 4);
+#endif
+#ifdef CONFIG_PXA27X
+	/* 
+	 * Section 20.6.1 of PXA Developer's reference manual 
+	 */
+	GPCR3 |= 0x80 ; // GP103 low
+
+	UHCHR |= UHCHR_SSEP2|UHCHR_SSEP1 ; // Port 2 and 3 not supported
+	UHCHR &= ~(UHCHR_SSE|UHCHR_SSEP0);
+
+//	UHCRHS &= ~UHCRHS_LPS ;
+//	UHCCOMS &= ~UHCCOMS_HCR ; // reset
+	CKEN |= CKEN10_USBHOST ;
+	udelay(10);
+	UHCHR &= ~(UHCHR_FHR|UHCHR_SSE);
+#elif defined( CONFIG_SM501 )
+	USB_GATE_MODE0 |= ENABLE_USBH ;
+	USB_GATE_MODE1 |= ENABLE_USBH ;
+#endif
+
+	memset (&gohci, 0, sizeof (ohci_t));
+	memset (&urb_priv, 0, sizeof (urb_priv_t));
+
+	/* align the storage */
+	if ((__u32)&ghcca[0] & 0xff) {
+		err("HCCA not aligned!!");
+		return -1;
+	}
+	phcca = &ghcca[0];
+	info("aligned ghcca %p", phcca);
+	memset(&ohci_dev, 0, sizeof(struct ohci_device));
+	if ((__u32)&ohci_dev.ed[0] & 0x7) {
+		err("EDs not aligned!!");
+		return -1;
+	}
+	memset(gtd, 0, sizeof(td_t) * (NUM_TD + 1));
+	if ((__u32)gtd & 0x7) {
+		err("TDs not aligned!!");
+		return -1;
+	}
+	ptd = gtd;
+	gohci.hcca = phcca;
+	memset (phcca, 0, sizeof (struct ohci_hcca));
+
+	gohci.disabled = 1;
+	gohci.sleeping = 0;
+	gohci.irq = -1;
+	gohci.regs = (struct ohci_regs *)USBH_BASE ;
+	gohci.flags = 0;
+	gohci.slot_name = "s3c2400";
+
+	if (hc_reset (&gohci) < 0) {
+		err( "----> Error from hc_reset\n" );
+		hc_release_ohci (&gohci);
+		/* Initialization failed */
+#ifdef FIXME
+		clk_power->CLKCON &= ~(1 << 4);
+#endif
+#ifdef CONFIG_PXA27X
+		CKEN   &= ~CKEN10_USBHOST ;
+#elif defined( CONFIG_SM501 )
+#endif
+		return -1;
+	}
+
+	/* FIXME this is a second HC reset; why?? */
+	writel (gohci.hc_control = OHCI_USB_RESET, &gohci.regs->control);
+	wait_ms (10);
+
+	if (hc_start (&gohci) < 0) {
+		err ("can't start usb-%s", gohci.slot_name);
+		hc_release_ohci (&gohci);
+		/* Initialization failed */
+#ifdef FIXME
+		clk_power->CLKCON &= ~(1 << 4);
+#endif
+#ifdef CONFIG_PXA27X
+		CKEN   &= ~CKEN10_USBHOST ;
+#elif defined( CONFIG_SM501 )
+#endif
+		return -1;
+	}
+
+#ifdef	DEBUG
+	ohci_dump (&gohci, 1);
+#else
+	wait_ms(1);
+#endif
+printf( "----> end of low_level_init()\n" );
+	ohci_inited = 1;
+	return 0;
+}
+
+int usb_lowlevel_stop(void)
+{
+	/* this gets called really early - before the controller has */
+	/* even been initialized! */
+	if (!ohci_inited)
+		return 0;
+	/* TODO release any interrupts, etc. */
+	/* call hc_release_ohci() here ? */
+	hc_reset (&gohci);
+	
+#ifdef CONFIG_PXA27X
+	/* 
+	 * Section 20.7.4.4 of PXA Developer's reference manual 
+	 */
+	UHCCOMS |= UHCCOMS_HCR ; // reset
+	udelay(10);
+	UHCRHS |= UHCRHS_LPS ;
+	UHCHR  |= UHCHR_SSE ;
+	CKEN   &= ~CKEN10_USBHOST ;
+#elif defined( CONFIG_SM501 )
+#endif
+
+	return 0;
+}
+
+#endif /* CONFIG_USB_OHCI */
diff -u -r --new-file u-boot-1.1.2/cpu/pxa/usb_ohci.h u-boot-1.1.2-neon/cpu/pxa/usb_ohci.h
--- u-boot-1.1.2/cpu/pxa/usb_ohci.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/cpu/pxa/usb_ohci.h	2007-08-11 21:07:20.000000000 +0200
@@ -0,0 +1,419 @@
+/*
+ * URB OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2001 David Brownell <dbrownell@users.sourceforge.net>
+ *
+ * usb-ohci.h
+ */
+
+
+static int cc_to_error[16] = {
+
+/* mapping of the OHCI CC status to error codes */
+	/* No  Error  */               0,
+	/* CRC Error  */               USB_ST_CRC_ERR,
+	/* Bit Stuff  */               USB_ST_BIT_ERR,
+	/* Data Togg  */               USB_ST_CRC_ERR,
+	/* Stall      */               USB_ST_STALLED,
+	/* DevNotResp */               -1,
+	/* PIDCheck   */               USB_ST_BIT_ERR,
+	/* UnExpPID   */               USB_ST_BIT_ERR,
+	/* DataOver   */               USB_ST_BUF_ERR,
+	/* DataUnder  */               USB_ST_BUF_ERR,
+	/* reservd    */               -1,
+	/* reservd    */               -1,
+	/* BufferOver */               USB_ST_BUF_ERR,
+	/* BuffUnder  */               USB_ST_BUF_ERR,
+	/* Not Access */               -1,
+	/* Not Access */               -1
+};
+
+/* ED States */
+
+#define ED_NEW 		0x00
+#define ED_UNLINK 	0x01
+#define ED_OPER		0x02
+#define ED_DEL		0x04
+#define ED_URB_DEL  	0x08
+
+/* usb_ohci_ed */
+struct ed {
+	__u32 hwINFO;
+	__u32 hwTailP;
+	__u32 hwHeadP;
+	__u32 hwNextED;
+
+	struct ed *ed_prev;
+	__u8 int_period;
+	__u8 int_branch;
+	__u8 int_load;
+	__u8 int_interval;
+	__u8 state;
+	__u8 type;
+	__u16 last_iso;
+	struct ed *ed_rm_list;
+
+	struct usb_device *usb_dev;
+	__u32 unused[3];
+} __attribute((aligned(16)));
+typedef struct ed ed_t;
+
+
+/* TD info field */
+#define TD_CC       0xf0000000
+#define TD_CC_GET(td_p) ((td_p >>28) & 0x0f)
+#define TD_CC_SET(td_p, cc) (td_p) = ((td_p) & 0x0fffffff) | (((cc) & 0x0f) << 28)
+#define TD_EC       0x0C000000
+#define TD_T        0x03000000
+#define TD_T_DATA0  0x02000000
+#define TD_T_DATA1  0x03000000
+#define TD_T_TOGGLE 0x00000000
+#define TD_R        0x00040000
+#define TD_DI       0x00E00000
+#define TD_DI_SET(X) (((X) & 0x07)<< 21)
+#define TD_DP       0x00180000
+#define TD_DP_SETUP 0x00000000
+#define TD_DP_IN    0x00100000
+#define TD_DP_OUT   0x00080000
+
+#define TD_ISO	    0x00010000
+#define TD_DEL      0x00020000
+
+/* CC Codes */
+#define TD_CC_NOERROR      0x00
+#define TD_CC_CRC          0x01
+#define TD_CC_BITSTUFFING  0x02
+#define TD_CC_DATATOGGLEM  0x03
+#define TD_CC_STALL        0x04
+#define TD_DEVNOTRESP      0x05
+#define TD_PIDCHECKFAIL    0x06
+#define TD_UNEXPECTEDPID   0x07
+#define TD_DATAOVERRUN     0x08
+#define TD_DATAUNDERRUN    0x09
+#define TD_BUFFEROVERRUN   0x0C
+#define TD_BUFFERUNDERRUN  0x0D
+#define TD_NOTACCESSED     0x0F
+
+
+#define MAXPSW 1
+
+struct td {
+	__u32 hwINFO;
+  	__u32 hwCBP;		/* Current Buffer Pointer */
+  	__u32 hwNextTD;		/* Next TD Pointer */
+  	__u32 hwBE;		/* Memory Buffer End Pointer */
+
+  	__u16 hwPSW[MAXPSW];
+  	__u8 unused;
+  	__u8 index;
+  	struct ed *ed;
+  	struct td *next_dl_td;
+	struct usb_device *usb_dev;
+	int transfer_len;
+	__u32 data;
+
+	__u32 unused2[2];
+} __attribute((aligned(32)));
+typedef struct td td_t;
+
+#define OHCI_ED_SKIP	(1 << 14)
+
+/*
+ * The HCCA (Host Controller Communications Area) is a 256 byte
+ * structure defined in the OHCI spec. that the host controller is
+ * told the base address of.  It must be 256-byte aligned.
+ */
+
+#define NUM_INTS 32	/* part of the OHCI standard */
+struct ohci_hcca {
+	__u32	int_table[NUM_INTS];	/* Interrupt ED table */
+	__u16	frame_no;		/* current frame number */
+	__u16	pad1;			/* set to 0 on each frame_no change */
+	__u32	done_head;		/* info returned for an interrupt */
+	u8		reserved_for_hc[116];
+} __attribute((aligned(256)));
+
+
+/*
+ * Maximum number of root hub ports.
+ */
+#define MAX_ROOT_PORTS	15	/* maximum OHCI root hub ports */
+
+/*
+ * This is the structure of the OHCI controller's memory mapped I/O
+ * region.  This is Memory Mapped I/O.  You must use the readl() and
+ * writel() macros defined in asm/io.h to access these!!
+ */
+struct ohci_regs {
+	/* control and status registers */
+	__u32	revision;
+	__u32	control;
+	__u32	cmdstatus;
+	__u32	intrstatus;
+	__u32	intrenable;
+	__u32	intrdisable;
+	/* memory pointers */
+	__u32	hcca;
+	__u32	ed_periodcurrent;
+	__u32	ed_controlhead;
+	__u32	ed_controlcurrent;
+	__u32	ed_bulkhead;
+	__u32	ed_bulkcurrent;
+	__u32	donehead;
+	/* frame counters */
+	__u32	fminterval;
+	__u32	fmremaining;
+	__u32	fmnumber;
+	__u32	periodicstart;
+	__u32	lsthresh;
+	/* Root hub ports */
+	struct	ohci_roothub_regs {
+		__u32	a;
+		__u32	b;
+		__u32	status;
+		__u32	portstatus[MAX_ROOT_PORTS];
+	} roothub;
+} __attribute((aligned(32)));
+
+
+/* OHCI CONTROL AND STATUS REGISTER MASKS */
+
+/*
+ * HcControl (control) register masks
+ */
+#define OHCI_CTRL_CBSR	(3 << 0)	/* control/bulk service ratio */
+#define OHCI_CTRL_PLE	(1 << 2)	/* periodic list enable */
+#define OHCI_CTRL_IE	(1 << 3)	/* isochronous enable */
+#define OHCI_CTRL_CLE	(1 << 4)	/* control list enable */
+#define OHCI_CTRL_BLE	(1 << 5)	/* bulk list enable */
+#define OHCI_CTRL_HCFS	(3 << 6)	/* host controller functional state */
+#define OHCI_CTRL_IR	(1 << 8)	/* interrupt routing */
+#define OHCI_CTRL_RWC	(1 << 9)	/* remote wakeup connected */
+#define OHCI_CTRL_RWE	(1 << 10)	/* remote wakeup enable */
+
+/* pre-shifted values for HCFS */
+#	define OHCI_USB_RESET	(0 << 6)
+#	define OHCI_USB_RESUME	(1 << 6)
+#	define OHCI_USB_OPER	(2 << 6)
+#	define OHCI_USB_SUSPEND	(3 << 6)
+
+/*
+ * HcCommandStatus (cmdstatus) register masks
+ */
+#define OHCI_HCR	(1 << 0)	/* host controller reset */
+#define OHCI_CLF  	(1 << 1)	/* control list filled */
+#define OHCI_BLF  	(1 << 2)	/* bulk list filled */
+#define OHCI_OCR  	(1 << 3)	/* ownership change request */
+#define OHCI_SOC  	(3 << 16)	/* scheduling overrun count */
+
+/*
+ * masks used with interrupt registers:
+ * HcInterruptStatus (intrstatus)
+ * HcInterruptEnable (intrenable)
+ * HcInterruptDisable (intrdisable)
+ */
+#define OHCI_INTR_SO	(1 << 0)	/* scheduling overrun */
+#define OHCI_INTR_WDH	(1 << 1)	/* writeback of done_head */
+#define OHCI_INTR_SF	(1 << 2)	/* start frame */
+#define OHCI_INTR_RD	(1 << 3)	/* resume detect */
+#define OHCI_INTR_UE	(1 << 4)	/* unrecoverable error */
+#define OHCI_INTR_FNO	(1 << 5)	/* frame number overflow */
+#define OHCI_INTR_RHSC	(1 << 6)	/* root hub status change */
+#define OHCI_INTR_OC	(1 << 30)	/* ownership change */
+#define OHCI_INTR_MIE	(1 << 31)	/* master interrupt enable */
+
+
+/* Virtual Root HUB */
+struct virt_root_hub {
+	int devnum; /* Address of Root Hub endpoint */
+	void *dev;  /* was urb */
+	void *int_addr;
+	int send;
+	int interval;
+};
+
+/* USB HUB CONSTANTS (not OHCI-specific; see hub.h) */
+
+/* destination of request */
+#define RH_INTERFACE               0x01
+#define RH_ENDPOINT                0x02
+#define RH_OTHER                   0x03
+
+#define RH_CLASS                   0x20
+#define RH_VENDOR                  0x40
+
+/* Requests: bRequest << 8 | bmRequestType */
+#define RH_GET_STATUS           0x0080
+#define RH_CLEAR_FEATURE        0x0100
+#define RH_SET_FEATURE          0x0300
+#define RH_SET_ADDRESS		0x0500
+#define RH_GET_DESCRIPTOR	0x0680
+#define RH_SET_DESCRIPTOR       0x0700
+#define RH_GET_CONFIGURATION	0x0880
+#define RH_SET_CONFIGURATION	0x0900
+#define RH_GET_STATE            0x0280
+#define RH_GET_INTERFACE        0x0A80
+#define RH_SET_INTERFACE        0x0B00
+#define RH_SYNC_FRAME           0x0C80
+/* Our Vendor Specific Request */
+#define RH_SET_EP               0x2000
+
+
+/* Hub port features */
+#define RH_PORT_CONNECTION         0x00
+#define RH_PORT_ENABLE             0x01
+#define RH_PORT_SUSPEND            0x02
+#define RH_PORT_OVER_CURRENT       0x03
+#define RH_PORT_RESET              0x04
+#define RH_PORT_POWER              0x08
+#define RH_PORT_LOW_SPEED          0x09
+
+#define RH_C_PORT_CONNECTION       0x10
+#define RH_C_PORT_ENABLE           0x11
+#define RH_C_PORT_SUSPEND          0x12
+#define RH_C_PORT_OVER_CURRENT     0x13
+#define RH_C_PORT_RESET            0x14
+
+/* Hub features */
+#define RH_C_HUB_LOCAL_POWER       0x00
+#define RH_C_HUB_OVER_CURRENT      0x01
+
+#define RH_DEVICE_REMOTE_WAKEUP    0x00
+#define RH_ENDPOINT_STALL          0x01
+
+#define RH_ACK                     0x01
+#define RH_REQ_ERR                 -1
+#define RH_NACK                    0x00
+
+
+/* OHCI ROOT HUB REGISTER MASKS */
+
+/* roothub.portstatus [i] bits */
+#define RH_PS_CCS            0x00000001   	/* current connect status */
+#define RH_PS_PES            0x00000002   	/* port enable status*/
+#define RH_PS_PSS            0x00000004   	/* port suspend status */
+#define RH_PS_POCI           0x00000008   	/* port over current indicator */
+#define RH_PS_PRS            0x00000010  	/* port reset status */
+#define RH_PS_PPS            0x00000100   	/* port power status */
+#define RH_PS_LSDA           0x00000200    	/* low speed device attached */
+#define RH_PS_CSC            0x00010000 	/* connect status change */
+#define RH_PS_PESC           0x00020000   	/* port enable status change */
+#define RH_PS_PSSC           0x00040000    	/* port suspend status change */
+#define RH_PS_OCIC           0x00080000    	/* over current indicator change */
+#define RH_PS_PRSC           0x00100000   	/* port reset status change */
+
+/* roothub.status bits */
+#define RH_HS_LPS	     0x00000001		/* local power status */
+#define RH_HS_OCI	     0x00000002		/* over current indicator */
+#define RH_HS_DRWE	     0x00008000		/* device remote wakeup enable */
+#define RH_HS_LPSC	     0x00010000		/* local power status change */
+#define RH_HS_OCIC	     0x00020000		/* over current indicator change */
+#define RH_HS_CRWE	     0x80000000		/* clear remote wakeup enable */
+
+/* roothub.b masks */
+#define RH_B_DR		0x0000ffff		/* device removable flags */
+#define RH_B_PPCM	0xffff0000		/* port power control mask */
+
+/* roothub.a masks */
+#define	RH_A_NDP	(0xff << 0)		/* number of downstream ports */
+#define	RH_A_PSM	(1 << 8)		/* power switching mode */
+#define	RH_A_NPS	(1 << 9)		/* no power switching */
+#define	RH_A_DT		(1 << 10)		/* device type (mbz) */
+#define	RH_A_OCPM	(1 << 11)		/* over current protection mode */
+#define	RH_A_NOCP	(1 << 12)		/* no over current protection */
+#define	RH_A_POTPGT	(0xff << 24)		/* power on to power good time */
+
+/* urb */
+#define N_URB_TD 48
+typedef struct
+{
+	ed_t *ed;
+	__u16 length;	/* number of tds associated with this request */
+	__u16 td_cnt;	/* number of tds already serviced */
+	int   state;
+	unsigned long pipe;
+	int actual_length;
+	td_t *td[N_URB_TD];	/* list pointer to all corresponding TDs associated with this request */
+} urb_priv_t;
+#define URB_DEL 1
+
+/*
+ * This is the full ohci controller description
+ *
+ * Note how the "proper" USB information is just
+ * a subset of what the full implementation needs. (Linus)
+ */
+
+
+typedef struct ohci {
+	struct ohci_hcca *hcca;		/* hcca */
+	/*dma_addr_t hcca_dma;*/
+
+	int irq;
+	int disabled;			/* e.g. got a UE, we're hung */
+	int sleeping;
+	unsigned long flags;		/* for HC bugs */
+
+	struct ohci_regs *regs;	/* OHCI controller's memory */
+
+	ed_t *ed_rm_list[2];     /* lists of all endpoints to be removed */
+	ed_t *ed_bulktail;       /* last endpoint of bulk list */
+	ed_t *ed_controltail;    /* last endpoint of control list */
+	int intrstatus;
+	__u32 hc_control;		/* copy of the hc control reg */
+	struct usb_device *dev[32];
+	struct virt_root_hub rh;
+
+	const char	*slot_name;
+} ohci_t;
+
+#define NUM_EDS 8		/* num of preallocated endpoint descriptors */
+
+struct ohci_device {
+	ed_t 	ed[NUM_EDS];
+	int ed_cnt;
+};
+
+/* hcd */
+/* endpoint */
+static int ep_link(ohci_t * ohci, ed_t * ed);
+static int ep_unlink(ohci_t * ohci, ed_t * ed);
+static ed_t * ep_add_ed(struct usb_device * usb_dev, unsigned long pipe);
+
+/*-------------------------------------------------------------------------*/
+
+/* we need more TDs than EDs */
+#define NUM_TD 64
+
+/* +1 so we can align the storage */
+td_t gtd[NUM_TD+1];
+/* pointers to aligned storage */
+td_t *ptd;
+
+/* TDs ... */
+static inline struct td *
+td_alloc (struct usb_device *usb_dev)
+{
+	int i;
+	struct td	*td;
+
+	td = NULL;
+	for (i = 0; i < NUM_TD; i++)
+	{
+		if (ptd[i].usb_dev == NULL)
+		{
+			td = &ptd[i];
+			td->usb_dev = usb_dev;
+			break;
+		}
+	}
+
+	return td;
+}
+
+static inline void
+ed_free (struct ed *ed)
+{
+	ed->usb_dev = NULL;
+}
diff -u -r --new-file u-boot-1.1.2/.cvsignore u-boot-1.1.2-neon/.cvsignore
--- u-boot-1.1.2/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/.cvsignore	2007-08-11 21:07:19.000000000 +0200
@@ -0,0 +1,13 @@
+*.map
+*.scr
+*.gz
+select.h
+*.log
+select.mk
+u-boot
+u-boot.bin
+u-boot.map
+u-boot.map.sorted
+u-boot.srec
+u-boot-binaries.zip
+
diff -u -r --new-file u-boot-1.1.2/drivers/lan91c96.h u-boot-1.1.2-neon/drivers/lan91c96.h
--- u-boot-1.1.2/drivers/lan91c96.h	2004-06-07 00:11:41.000000000 +0200
+++ u-boot-1.1.2-neon/drivers/lan91c96.h	2007-08-11 21:07:21.000000000 +0200
@@ -76,7 +76,7 @@
 
 #define	SMC_IO_EXTENT	16
 
-#ifdef CONFIG_PXA250
+#if defined( CONFIG_PXA250 ) || defined( CONFIG_PXA270 )
 
 #define	SMC_inl(r) 	(*((volatile dword *)(SMC_BASE_ADDRESS+( r * 4 ))))
 #define	SMC_inw(r) 	(*((volatile word *)(SMC_BASE_ADDRESS+( r * 4 ))))
@@ -139,7 +139,7 @@
 					};  \
 				})
 
-#else /* if not CONFIG_PXA250 */
+#else /* if not CONFIG_PXA250 or CONFIG_PXA270 */
 
 /*
  * We have only 16 Bit PCMCIA access on Socket 0
diff -u -r --new-file u-boot-1.1.2/drivers/smc91111.c u-boot-1.1.2-neon/drivers/smc91111.c
--- u-boot-1.1.2/drivers/smc91111.c	2004-11-22 23:20:09.000000000 +0100
+++ u-boot-1.1.2-neon/drivers/smc91111.c	2007-08-11 21:07:21.000000000 +0200
@@ -1583,6 +1583,101 @@
 	return (0);
 }
 
+#define SMC_GET_INT_MASK()	(SMC_inw( SMC91111_INT_REG ) >> 8)
+#define SMC_SET_INT_MASK(x)	SMC_outw( (x) << 8, SMC91111_INT_REG )
+#define SMC_CURRENT_BANK()	SMC_inw( BANK_SELECT )
+#define SMC_GET_CTL()		SMC_inw( CTL_REG )
+#define SMC_SET_CTL(x)		SMC_outw( x, CTL_REG )
+#define SMC_GET_MII()		SMC_inw( MII_REG )
+#define SMC_SET_MII(x)		SMC_outw( x, MII_REG )
+#define SMC_GET_PTR()		SMC_inw( PTR_REG )
+#define SMC_SET_PTR(x)		SMC_outw( x, PTR_REG )
+
+static int writeEEprom(int i,unsigned short val,unsigned short ctl)
+{
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_PTR( i );
+	SMC_SELECT_BANK( 1 );
+	SMC_outw( val, GP_REG );
+	udelay(1);
+	SMC_SET_CTL( ctl | CTL_EEPROM_SELECT | CTL_STORE );
+	int j=0;
+	do {
+		udelay(10);
+		j++;
+		if (j>=100000) return -1;
+	} while (SMC_GET_CTL() & CTL_STORE);
+	return 0;
+}
+
+#define SMC_SET_MAC_ADDR(addr)						\
+	do {								\
+		SMC_outw( addr[0]|(addr[1] << 8), ADDR0_REG );	\
+		SMC_outw( addr[2]|(addr[3] << 8), ADDR1_REG );	\
+		SMC_outw( addr[4]|(addr[5] << 8), ADDR2_REG );	\
+	} while (0)
+
+int set_rom_mac (char const *mac)
+{
+	unsigned short saved_bank = SMC_CURRENT_BANK();
+	SMC_SELECT_BANK( 2 );
+
+	unsigned short saved_mask = SMC_GET_INT_MASK();
+	SMC_SET_INT_MASK( 0 );
+
+	unsigned short saved_ptr = SMC_GET_PTR();
+
+	SMC_SELECT_BANK( 1 );
+
+	unsigned short saved_ctl = SMC_GET_CTL();
+
+	SMC_SET_MAC_ADDR(mac);
+
+	SMC_SELECT_BANK( 3 );
+	unsigned short mii_reg = SMC_GET_MII();
+
+	SMC_SET_MII(mii_reg & ~(0x0f));
+
+	SMC_SELECT_BANK( 1 );
+
+	SMC_SET_CTL( saved_ctl | CTL_EEPROM_SELECT );
+	unsigned short cfg = CONFIG_DEFAULT
+				| CONFIG_NO_WAIT
+				| CONFIG_EPH_POWER_EN;
+	unsigned short bar = (unsigned short)( SMC_BASE_ADDRESS );
+//a4, a10,a11,a12 must be all zeros
+	bar = (bar & 0xe000) | ((bar & 0x3e0)<<3) | (0x27);
+	int i=0;
+	while (i < 0x20) {
+		if (writeEEprom(i,cfg,saved_ctl)) break;
+		if (writeEEprom(i+1,bar,saved_ctl)) break;
+		if (writeEEprom(i+2,0,saved_ctl)) break;
+		if (writeEEprom(i+3,0,saved_ctl)) break;
+		i+=4;
+	}
+
+	int j = 0;
+	if (i==0x20) {
+		while (j < 6) {
+			if (writeEEprom(i,mac[j]|(mac[j+1]<<8),saved_ctl)) break;
+			i++; j+=2;
+		}
+	}
+
+	SMC_SET_CTL( saved_ctl );
+
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_PTR( saved_ptr );
+	SMC_SET_INT_MASK( saved_mask );
+	SMC_SELECT_BANK( saved_bank );
+
+	return 6 == j ;
+}
+
+static char const invalidMac[6] = {
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+
 int get_rom_mac (char *v_rom_mac)
 {
 #ifdef HARDCODE_MAC	/* used for testing or to supress run time warnings */
@@ -1601,6 +1696,9 @@
 		valid_mac |= v_rom_mac[i];
 	}
 
+	if( valid_mac )
+		valid_mac = ( 0 != memcmp( invalidMac, v_rom_mac, sizeof(invalidMac) ) );
+
 	return (valid_mac ? 1 : 0);
 #endif
 }
diff -u -r --new-file u-boot-1.1.2/drivers/smc91111.h u-boot-1.1.2-neon/drivers/smc91111.h
--- u-boot-1.1.2/drivers/smc91111.h	2004-11-02 14:00:56.000000000 +0100
+++ u-boot-1.1.2-neon/drivers/smc91111.h	2007-08-11 21:07:21.000000000 +0200
@@ -74,7 +74,7 @@
 
 #define	SMC_IO_EXTENT	16
 
-#ifdef CONFIG_PXA250
+#if defined( CONFIG_PXA250 ) || defined( CONFIG_PXA270 )
 
 #ifdef CONFIG_XSENGINE
 #define	SMC_inl(r) 	(*((volatile dword *)(SMC_BASE_ADDRESS+(r<<1))))
@@ -176,7 +176,7 @@
 					};  \
 				})
 
-#else /* if not CONFIG_PXA250 */
+#else /* if not CONFIG_PXA250 or CONFIG_PXA270 */
 
 #ifndef CONFIG_SMC_USE_IOFUNCS /* these macros don't work on some boards */
 /*
diff -u -r --new-file u-boot-1.1.2/examples/Makefile u-boot-1.1.2-neon/examples/Makefile
--- u-boot-1.1.2/examples/Makefile	2004-10-10 23:27:33.000000000 +0200
+++ u-boot-1.1.2-neon/examples/Makefile	2007-08-11 21:07:21.000000000 +0200
@@ -100,12 +100,12 @@
 LIBCOBJS= stubs.o
 LIBOBJS	= $(LIBAOBJS) $(LIBCOBJS)
 
-gcclibdir := $(shell dirname `$(CC) -print-libgcc-file-name`)
-clibdir := $(shell dirname `$(CC) $(CFLAGS) -print-file-name=libc.a`)
+gcclibdir := $(shell dirname "`$(CC) -print-libgcc-file-name`")
+clibdir := $(shell dirname "`$(CC) $(CFLAGS) -print-file-name=libc.a`")
 
 CPPFLAGS += -I..
 
-all:	.depend $(LIB) $(SREC) $(BIN)
+all:	.depend $(LIB) 
 
 #########################################################################
 $(LIB): .depend $(LIBOBJS)
diff -u -r --new-file u-boot-1.1.2/fs/fat/fat.c u-boot-1.1.2-neon/fs/fat/fat.c
--- u-boot-1.1.2/fs/fat/fat.c	2004-12-16 18:57:26.000000000 +0100
+++ u-boot-1.1.2-neon/fs/fat/fat.c	2007-08-11 21:07:21.000000000 +0200
@@ -52,6 +52,8 @@
 #define DOS_PART_TBL_OFFSET	0x1be
 #define DOS_PART_MAGIC_OFFSET	0x1fe
 #define DOS_FS_TYPE_OFFSET	0x36
+#define DOS_FS_TYPE_OFFSET_FAT_16 0x36  // Code relating to this constant was changed/added by Dubner 2005-05-20 
+#define DOS_FS_TYPE_OFFSET_FAT_32 0x52  // Code relating to this constant was changed/added by Dubner 2005-05-20 
 
 int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr)
 {
@@ -83,7 +85,8 @@
 		/* no signature found */
 		return -1;
 	}
-	if(!strncmp(&buffer[DOS_FS_TYPE_OFFSET],"FAT",3)) {
+	if(!strncmp(&buffer[DOS_FS_TYPE_OFFSET_FAT_16],"FAT",3)
+      || !strncmp (&buffer[DOS_FS_TYPE_OFFSET_FAT_32], "FAT", 3)) {
 		/* ok, we assume we are on a PBR only */
 		cur_part = 1;
 		part_offset=0;
@@ -342,7 +345,7 @@
 			newclust = get_fatent(mydata, endclust);
 			if((newclust -1)!=endclust)
 				goto getit;
-			if (newclust <= 0x0001 || newclust >= 0xfff0) {
+			if (newclust <= 0x0001 ) { //  || newclust >= 0xfff0) {
 				FAT_DPRINT("curclust: 0x%x\n", newclust);
 				FAT_DPRINT("Invalid FAT entry\n");
 				return gotsize;
@@ -890,7 +893,7 @@
 		dentptr++;
 		continue;
 	    }
-	    if (strcmp (fnamecopy, s_name) && strcmp (fnamecopy, l_name)) {
+	    if (fnmatch(fnamecopy, s_name,0) && fnmatch(fnamecopy, l_name,0)) {
 		FAT_DPRINT ("RootMismatch: |%s|%s|\n", s_name, l_name);
 		dentptr++;
 		continue;
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/BigMacro.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/BigMacro.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/BigMacro.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/BigMacro.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,325 @@
+//
+//  linux/include/asm-arm/BigMacro.h
+//
+//  Author:     Troy Kisky
+//  Created:    Jun 30, 2002
+//  Copyright:  Boundary Devices
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+	.nolist
+
+//find set bit pair >= curbit
+//out: __nBit
+	.ifdef __ARMASM
+	GBLA __nBit
+	GBLA __nMask
+	GBLA __nVal
+;	DCD __nV1
+
+.macro NextSetBitUp	val,curBit
+	LCLA __nV1
+	.set	__nBit,(\curBit)
+	.set	__nV1,(\val)
+	WHILE ( (__nBit < 30) :LAND: ( (__nV1 :AND: (0x03:SHL:__nBit))=0) )
+	.set	__nBit,(__nBit)+2
+	WEND
+.endm
+
+//find set bit pair <= curbit
+//out: __nBit
+.macro NextSetBitDown	val,curBit
+	LCLA __nV1
+	.set	__nBit,(\curBit)
+	.set	__nV1,(\val)
+	WHILE ( (__nBit <> 0) :LAND: ( (__nV1:AND:(0xc0:SHL:__nBit))=0) )
+	.set	__nBit,(__nBit)-2
+	WEND
+.endm
+	.else
+
+.macro NextSetBitUp	val,curBit
+	.set	__nBit,(\curBit)
+	.set	__nV1,(\val)
+	.if ((__nV1) & (0x03<<(__nBit)))
+	.else
+		.if ((__nBit)-30)
+			NextSetBitUp __nV1,((__nBit)+2)
+		.endif
+	.endif
+	.set	__nV1,0
+.endm
+
+//find set bit pair <= curbit
+//out: __nBit
+.macro NextSetBitDown	val,curBit
+	.set	__nBit,(\curBit)
+	.set	__nV1,(\val)
+	.if ((__nV1)&(0xc0<<(__nBit)))
+	.else
+		.if (__nBit)
+			NextSetBitDown __nV1,((__nBit)-2)
+		.endif
+	.endif
+	.set	__nV1,0
+.endm
+	.endif
+
+//OUT: __nMask
+.macro NextSetMask	val
+	NextSetBitDown	\val,24
+	.if (__nBit>=20)
+		NextSetBitUp	\val,__nBit
+		.set __nMask,(0xff<<((__nBit)-16))
+		.set __nMask,(((__nMask)>>16)+(((__nMask)<<16)&0xffff0000))
+	.else
+		.set __nMask,(0xff<<(__nBit))
+	.endif
+
+.endm
+
+.macro Big2CC inst,dest,val
+	.set __nVal,(\val)
+	.if (__nVal)<>0
+		NextSetMask __nVal
+		\inst	\dest,\dest,#(__nVal)&(__nMask)
+		Big2CC \inst,\dest,(__nVal)&~(__nMask)
+	.endif
+.endm
+
+.macro BigAnd2CC cc,dest,val
+	.set __nVal,(\val)
+	.if (~__nVal)<>0
+		NextSetMask __nVal
+		.if (((__nVal)&~(__nMask))=0)
+			and\cc	\dest,\dest,#(__nVal)&(__nMask)
+		.else
+			Big2CC bic\cc,\dest,~__nVal
+		.endif
+	.endif
+.endm
+
+///////////////////////////////////////////////////////
+.macro	BigMovCC  cc,dest, val
+	.set __nVal,(\val)
+	NextSetMask ~__nVal
+	.if (((~(__nVal))&~(__nMask)) > 0x255)
+		NextSetMask __nVal
+		mov\cc	\dest,#(__nVal)&(__nMask)
+		.if (((__nVal)&0xffff) ^ (((__nVal)>>16)&0xffff))<>0
+			Big2CC orr\cc,\dest,(__nVal)&~(__nMask)
+		.else
+			.set __nVal,(__nVal)&~(__nMask)
+			.if (__nVal)<>0
+				NextSetMask __nVal
+				orr\cc	\dest,\dest,#(__nVal)&(__nMask)
+				.set __nVal,(__nVal)&~(__nMask)
+				.if (__nVal)<>0
+					orr\cc	\dest,\dest,\dest,LSR #16
+				.endif
+			.endif
+		.endif
+	.else
+		mvn\cc	\dest,#(~(__nVal))&(__nMask)	//complement of complement is original
+		Big2CC bic\cc,\dest,(~(__nVal))&~(__nMask)
+	.endif
+.endm
+
+
+.macro	BigAddCC cc,dest,src,val
+	.set __nVal,(\val)
+	.if (__nVal)<>0
+		NextSetMask -__nVal
+		.if (((-(__nVal))&~(__nMask)) > 0x255)
+			NextSetMask __nVal
+			add\cc	\dest,\src,#(__nVal)&(__nMask)
+			Big2CC add\cc,\dest,(__nVal)&~(__nMask)
+		.else
+			sub\cc	\dest,\src,#(-(__nVal))&(__nMask)
+			Big2CC sub\cc,\dest,(-(__nVal))&~(__nMask)
+		.endif
+	.else
+		mov\cc	\dest,\src
+	.endif
+.endm
+
+.macro	BigSubCC cc,dest,src,val
+	.set __nVal,(\val)
+	BigAddCC \cc,\dest,\src,-__nVal
+.endm
+
+.macro BigCC inst,cc,dest,src,val
+	.set __nVal,(\val)
+	.if (__nVal)<>0
+		NextSetMask __nVal
+		\inst\cc	\dest,\src,#(__nVal)&(__nMask)
+		Big2CC \inst\cc,\dest,(__nVal)&~(__nMask)
+	.else
+		mov\cc	\dest,\src
+	.endif
+.endm
+
+
+.macro BigAndCC cc,dest,src,val
+	.set __nVal,(\val)
+	.if (~__nVal)<>0
+		NextSetMask __nVal
+		.if (((__nVal)&~(__nMask))=0)
+			and\cc	\dest,\src,#(__nVal)&(__nMask)
+		.else
+			BigCC bic,\cc,\dest,\src,~__nVal
+		.endif
+	.else
+		mov\cc	\dest,\src
+	.endif
+.endm
+
+/////////////////////////////////////
+//dest, value
+.macro BigAdd2 dest,val
+	Big2CC add,\dest,\val
+.endm
+.macro BigAdd2Eq dest,val
+	Big2CC addeq,\dest,\val
+.endm
+.macro BigAdd2Ne dest,val
+	Big2CC addne,\dest,\val
+.endm
+
+.macro BigSub2 dest,val
+	Big2CC sub,\dest,\val
+.endm
+.macro BigSub2Eq dest,val
+	Big2CC subeq,\dest,\val
+.endm
+.macro BigSub2Ne dest,val
+	Big2CC subne,\dest,\val
+.endm
+
+.macro BigOrr2 dest,val
+	Big2CC orr,\dest,\val
+.endm
+.macro BigOrr2Eq dest,val
+	Big2CC orreq,\dest,\val
+.endm
+.macro BigOrr2Ne dest,val
+	Big2CC orrne,\dest,\val
+.endm
+
+.macro BigEor2 dest,val
+	Big2CC eor,\dest,\val
+.endm
+.macro BigEor2Eq dest,val
+	Big2CC eoreq,\dest,\val
+.endm
+.macro BigEor2Ne dest,val
+	Big2CC eorne,\dest,\val
+.endm
+.macro BigEor2Cs dest,val
+	Big2CC eorcs,\dest,\val
+.endm
+.macro BigEor2Cc dest,val
+	Big2CC eorcc,\dest,\val
+.endm
+
+.macro BigBic2 dest,val
+	Big2CC bic,\dest,\val
+.endm
+.macro BigBic2Eq dest,val
+	Big2CC biceq,\dest,\val
+.endm
+.macro BigBic2Ne dest,val
+	Big2CC bicne,\dest,\val
+.endm
+
+.macro BigAnd2 dest,val
+	BigAnd2CC al,\dest,\val
+.endm
+.macro BigAnd2Eq dest,val
+	BigAnd2CC eq,\dest,\val
+.endm
+.macro BigAnd2Ne dest,val
+	BigAnd2CC ne,\dest,\val
+.endm
+/////////////////////////////////////
+
+.macro BigMov dest,val
+	BigMovCC  al,\dest,\val
+.endm
+.macro BigMovEq dest,val
+	BigMovCC  eq,\dest,\val
+.endm
+.macro BigMovNe dest,val
+	BigMovCC  ne,\dest,\val
+.endm
+// dest,src,value
+.macro BigAdd dest,src,val
+	BigAddCC  al,\dest,\src,\val
+.endm
+.macro BigAddEq dest,src,val
+	BigAddCC  eq,\dest,\src,\val
+.endm
+.macro BigAddNe dest,src,val
+	BigAddCC  ne,\dest,\src,\val
+.endm
+
+.macro BigSub dest,src,val
+	BigSubCC  al,\dest,\src,\val
+.endm
+.macro BigSubEq dest,src,val
+	BigSubCC  eq,\dest,\src,\val
+.endm
+.macro BigSubNe dest,src,val
+	BigSubCC  ne,\dest,\src,\val
+.endm
+
+.macro BigOrr dest,src,val
+	BigCC  orr,al,\dest,\src,\val
+.endm
+.macro BigOrrEq dest,src,val
+	BigCC  orr,eq,\dest,\src,\val
+.endm
+.macro BigOrrNe dest,src,val
+	BigCC  orr,ne,\dest,\src,\val
+.endm
+
+.macro BigEor dest,src,val
+	BigCC  eor,al,\dest,\src,\val
+.endm
+.macro BigEorEq dest,src,val
+	BigCC  eor,eq,\dest,\src,\val
+.endm
+.macro BigEorNe dest,src,val
+	BigCC  eor,ne,\dest,\src,\val
+.endm
+.macro BigEorCs dest,src,val
+	BigCC  eor,cs,\dest,\src,\val
+.endm
+.macro BigEorCc dest,src,val
+	BigCC  eor,cc,\dest,\src,\val
+.endm
+
+.macro BigBic dest,src,val
+	BigCC  bic,al,\dest,\src,\val
+.endm
+.macro BigBicEq dest,src,val
+	BigCC  bic,eq,\dest,\src,\val
+.endm
+.macro BigBicNe dest,src,val
+	BigCC  bic,ne,\dest,\src,\val
+.endm
+
+.macro BigAnd dest,src,val
+	BigAndCC  al,\dest,\src,\val
+.endm
+.macro BigAndEq dest,src,val
+	BigAndCC  eq,\dest,\src,\val
+.endm
+.macro BigAndNe dest,src,val
+	BigAndCC  ne,\dest,\src,\val
+.endm
+
+// *******************************************************************************************
+	.list
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/burn.inc u-boot-1.1.2-neon/include/asm-arm/arch-pxa/burn.inc
--- u-boot-1.1.2/include/asm-arm/arch-pxa/burn.inc	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/burn.inc	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,367 @@
+#define FLASH_GPIO_STATUS 0				//1 means use gp to tell when flash is ready
+
+#if (PLATFORM_TYPE==NEONB)
+#define FLASH_BASE_ADDRESS 0x04000000
+#else
+#define FLASH_BASE_ADDRESS 0x0
+#endif
+
+
+#define FLASH_ID_CMD		((0x0090<<16) + 0x0090)			//read Identifier Codes
+#define FLASH_STATUS_CMD	((0x0070<<16) + 0x0070)
+#define FLASH_STATUS_CLEAR_CMD	((0x0050<<16) + 0x0050)
+#define FLASH_READ_CMD		((0x00FF<<16) + 0x00FF)			//Read Array/Reset
+#define FLASH_ERASE_CMD		((0x0020<<16) + 0x0020)			//Block Erase
+#define FLASH_CONFIRM_CMD	((0x00D0<<16) + 0x00D0)			//Block Erase and Program Resume
+//#define FLASH_WRITE_CMD		((0x0040<<16) + 0x0040)			//Program word
+#define FLASH_WRITE_TO_BUFFER_CMD	((0x00E8<<16) + 0x00E8)			//Program word
+
+#define FLASH_SUCCESS_RSP	((0x0080<<16) + 0x0080)
+
+#define stmicro_manCode ((0x0020<<16) + 0x0020)
+#define intel_manCode ((0x0089<<16) + 0x0089)
+#define SECT_SIZE (1<<18)		//256k
+
+#define f320j3a_devCode ((0x0016<<16) + 0x0016)
+#define f320j3a_NUM_SECTORS 32		//for 8M flash
+#define f320j3a_SIZE (f320j3a_NUM_SECTORS*SECT_SIZE)
+
+#define f640j3a_devCode ((0x0017<<16) + 0x0017)
+#define f640j3a_NUM_SECTORS 64		//for 16M flash (8 meg on 16bit boards)
+#define f640j3a_SIZE (f640j3a_NUM_SECTORS*SECT_SIZE)
+
+#define f128j3a_devCode ((0x0018<<16) + 0x0018)
+#define f128j3a_NUM_SECTORS 128		//for 32M flash
+#define f128j3a_SIZE (f128j3a_NUM_SECTORS*SECT_SIZE)
+// *****************************
+#define MANCODE 0
+#define DEVCODE 4
+
+
+
+#define rRet		r6
+#define rRamSectorEnd	r7
+#define rRamSector	rNum1
+#define rRamEnd		rNum2
+#define rFlashBase	sl	//r10
+#define rFlashSector	fp	//r11
+
+#define CMD_BURN 0
+#define CMD_VERIFY 1
+#define CMD_BURNALL 2
+
+.macro delayCnt rTemp,cnt
+	mov	\rTemp,#\cnt
+90:	subs	\rTemp,\rTemp,#1
+	bne	90b
+.endm
+// *********************************
+//default delay is for write recovery before read, allow 400 MHZ cpu
+.macro delay
+	delayCnt r4,((40/10)*COUNT_MULT)
+.endm
+
+
+
+.macro FLASH_GPIO_WAIT_FOR_IDLE
+	.if  FLASH_GPIO_STATUS
+	bl FlashGpioWaitForIdle
+	.endif
+.endm
+
+.macro DEFINE_FLASH_GPIO_WAIT_FOR_IDLE
+	.if  FLASH_GPIO_STATUS
+FlashGpioWaitForIdle:
+//500 ns delay for STS going low
+	delayCnt r4,((500/10)*COUNT_MULT)	//500ns /10ns (for 100MHZ cpu cycle time) * 4 (100MHZ cpu)
+	mov	r5,#0x300000
+	BigMov	r4,GPIO_BASE
+91:	ldr	r2,[r4,#GPLR0]
+	and	r2,r2,#3
+	cmp	r2,#3
+	subnes	r5,r5,#1
+	bne	91b
+	mov	pc,lr			//return
+	.endif
+.endm
+
+//out: z-1 timeout
+.macro	waitForReady istr,ildr,mask,inc
+	BigMov	r2,FLASH_STATUS_CMD&\mask
+	\istr	r2,[r1,#-\inc]
+
+	FLASH_GPIO_WAIT_FOR_IDLE
+	BigMov	r3,FLASH_SUCCESS_RSP&\mask
+
+	mov	r5,#0x300000*COUNT_MULT
+	.if  FLASH_GPIO_STATUS
+	b	92f
+	.endif
+
+71:
+	delayCnt r4,((500/10)*COUNT_MULT)
+92:	\ildr	r4,[r1,#-\inc]	//!!! read status
+	and	r4,r4,r3
+	cmp	r4,r3
+	subnes	r5,r5,#1
+	bne	71b
+
+	BigMov	r2,FLASH_READ_CMD&\mask
+	\istr	r2,[r1,#-\inc]
+	delay
+	teq	r5,#0
+.endm
+
+
+
+//out: z-1 timeout
+.macro	WaitForEraseDone istr,ildr,mask
+	FLASH_GPIO_WAIT_FOR_IDLE
+	BigMov	r3,FLASH_SUCCESS_RSP&\mask
+	mov	r5,#0x10000
+92:
+	delayCnt r4,0x3000
+	\ildr	r4,[rFlashSector]
+	and	r4,r4,r3
+	cmp	r4,r3
+	subnes	r5,r5,#1
+	bne	92b
+
+	BigMov	r2,FLASH_READ_CMD&\mask
+	\istr	r2,[rFlashSector,#0]
+	delay
+	teq	r5,#0
+.endm
+// ***********************************
+
+//r5 - command - CMD_BURN or CMD_BURNALL
+//rRet(r6) succesful burn return address
+//rRamSectorEnd(r7) - but not an input, just how it is used
+//rRamSector(r8) - start
+//rRamEnd(r9) - end
+//rFlashBase(sl,r10) - flash base
+//rFlashSector(fp,r11) - starting flash sector
+//rDBG(sp,r13)
+//lr - return address on failure
+
+.macro	BurnRtn istr,ildr,mask,shift,sizeShift,inc,plait
+	str	r5,[rDBG,#DBG_TEMP]
+	BigMov	r0,FLASH_STATUS_CLEAR_CMD&\mask
+	\istr	r0,[rFlashBase,#0]
+	delay
+	BigMov	r0,FLASH_ID_CMD&\mask
+	\istr	r0,[rFlashBase,#0]
+	delay
+	BigMov	r4,intel_manCode&\mask
+	BigMov	r1,stmicro_manCode&\mask
+	BigMov	r5,f320j3a_devCode&\mask
+	\ildr	r2,[rFlashBase,#MANCODE>>\shift]
+	\ildr	r3,[rFlashBase,#DEVCODE>>\shift]
+
+	BigMov	r0,FLASH_READ_CMD&\mask
+	\istr	r0,[rFlashBase,#0]
+	delayCnt r0,((40/10)*COUNT_MULT)
+
+	mov	r0,#f320j3a_SIZE>>\sizeShift
+	cmp	r3,r5
+
+	BigMovNe r5,f128j3a_devCode&\mask
+	movne	r0,#f128j3a_SIZE>>\sizeShift
+	cmpne	r3,r5
+
+	BigMovNe r5,f640j3a_devCode&\mask
+	movne	r0,#f640j3a_SIZE>>\sizeShift
+	cmpne	r3,r5
+
+	cmpeq	r2,r4
+	cmpne	r2,r1
+	movne	r0,#MANCODE>>2
+	movne	r1,#DEVCODE>>2
+	movne	pc,lr			//return if unrecognized chip
+
+	sub	r1,rRamEnd,rRamSector
+	sub	r2,rFlashSector,rFlashBase
+	add	r1,r1,r2
+	cmp	r1,r0
+	movhi	pc,lr			//return if trying to write too much
+
+	ldrb	r5,[rDBG,#DBG_TEMP]
+	cmp	r5,#CMD_BURNALL
+	streq	r0,[rDBG,#DBG_TEMP]	//r0 is size of flash
+
+	FLASH_GPIO_WAIT_FOR_IDLE
+1:
+	bl	PrintSector
+
+//Now see if block needs erased
+	add	rRamSectorEnd,rRamSector,#SECT_SIZE>>\shift
+	cmp	rRamSectorEnd,rRamEnd
+	movhi	rRamSectorEnd,rRamEnd
+	b	3f
+2:
+	ldr	r2,[r0],#4	//read ram
+	ldr	r3,[r1],#4	//read flash
+	and	r4,r3,r2
+	cmp	r4,r2
+	bne	10f
+3:	cmp	r0,rRamSectorEnd
+	blo	2b
+
+
+	ldr	r2,[rDBG,#DBG_TEMP]
+	movs	r2,r2
+	beq	20f
+	add	r0,rFlashSector,#SECT_SIZE>>\shift
+	b	62f
+61:
+	ldr	r2,[r1],#4	//read flash
+	adds	r2,r2,#1
+	bne	10f
+62:	cmp	r1,r0
+	blo	61b
+	b	19f		//erase not needed
+
+//erase
+10:
+	BigMov	r3,FLASH_READ_CMD&\mask
+	\istr	r3,[rFlashBase,#0]
+	delay
+	ldr	r3,[r1,#-4]	//read flash
+	and	r4,r3,r2
+	cmp	r4,r2
+	beq	3b		//br if (we signal) glitch caused a spurious status register read
+
+	BigMov	r0,FLASH_ERASE_CMD&\mask
+	\istr	r0,[rFlashSector]
+	BigMov	r0,FLASH_CONFIRM_CMD&\mask
+	\istr	r0,[rFlashSector]
+	bl	PrintErasing
+
+	WaitForEraseDone \istr,\ildr,\mask
+	beq	Timeout		//br if erase timed out
+
+	.if (\plait)
+	BigMov	r0,FLASH_ERASE_CMD&\mask
+	\istr	r0,[rFlashSector,#2]
+	BigMov	r0,FLASH_CONFIRM_CMD&\mask
+	\istr	r0,[rFlashSector,#2]
+	bl	PrintErasing
+
+	WaitForEraseDone \istr,\ildr,\mask
+	beq	Timeout		//br if erase timed out
+	.endif
+
+19:	cmp	rRamSector,rRamSectorEnd
+	bhs	42f
+
+//programming
+20:
+	bl	PrintProgramming
+21:
+	ldr	r2,[r0],#4	//read ram
+	ldr	r3,[r1],#4	//read flash
+	cmp	r2,r3
+	bne	22f
+28:
+	cmp	r0,rRamSectorEnd
+	blo	21b
+	b	30f		//goto verify
+
+22:
+	sub	r1,r1,#4
+	sub	r0,r0,#4
+	and	r2,r1,#0x3f>>\shift			//align to a 64 byte boundary (32 per device)
+	sub	r1,r1,r2
+	sub	r0,r0,r2
+
+	BigMov	r2,FLASH_WRITE_TO_BUFFER_CMD&\mask
+	\istr	r2,[r1]		//!!! write_to_buffer
+
+	sub	r3,rRamSectorEnd,r0
+	mov	r3,r3,LSR #2-\shift
+	sub	r3,r3,#1
+	cmp	r3,#0x0f
+	movhi	r3,#0x0f
+	orr	r2,r3,r3,LSL #16
+	\istr	r2,[r1]		//!!! word cnt -1
+25:	\ildr	r2,[r0],#\inc
+	\istr	r2,[r1],#\inc	//!!! words
+	subs	r3,r3,#1
+	bpl	25b
+	BigMov	r2,FLASH_CONFIRM_CMD&\mask
+	\istr	r2,[r1,#-\inc]	//!!! confirm
+
+	waitForReady \istr,\ildr,\mask,\inc
+
+	.if (\plait)
+	beq	88f
+	sub	r1,r1,#\inc
+	sub	r0,r0,#\inc
+	and	r2,r1,#0x3f>>\shift			//align to a 64 byte boundary (32 per device)
+	sub	r1,r1,r2
+	sub	r0,r0,r2
+
+	BigMov	r2,FLASH_WRITE_TO_BUFFER_CMD&\mask
+	\istr	r2,[r1,#2]!		//!!! write_to_buffer
+	sub	r3,rRamSectorEnd,r0
+	add	r0,r0,#2
+	mov	r3,r3,LSR #2-\shift
+	sub	r3,r3,#1
+	cmp	r3,#0x0f
+	movhi	r3,#0x0f
+	orr	r2,r3,r3,LSL #16
+	\istr	r2,[r1]		//!!! word cnt -1
+85:	\ildr	r2,[r0],#\inc
+	\istr	r2,[r1],#\inc	//!!! words
+	subs	r3,r3,#1
+	bpl	85b
+	BigMov	r2,FLASH_CONFIRM_CMD&\mask
+	\istr	r2,[r1,#-\inc]	//!!! confirm
+
+	waitForReady \istr,\ildr,\mask,\inc
+	sub	r0,r0,#2
+	sub	r1,r1,#2
+
+	bne	28b
+88:
+
+	.else
+	bne	28b
+	.endif
+	sub	rRamSector,r0,#0x40>>\shift	//whoops, timeout
+	sub	rFlashSector,r1,#0x40>>\shift
+	b	Timeout
+
+
+
+//verify
+30:
+	bl	PrintVerifying
+31:
+	ldr	r2,[r0],#4	//read ram
+	ldr	r3,[r1],#4	//read flash
+	cmp	r2,r3
+	bne	33f
+32:	cmp	r0,rRamSectorEnd
+	blo	31b
+42:
+	add	rRamSector,rRamSector,#SECT_SIZE>>\shift
+	add	rFlashSector,rFlashSector,#SECT_SIZE>>\shift
+	cmp	rRamSector,rRamEnd
+	blo	1b		//goto next sector
+
+	ldr	r2,[rDBG,#DBG_TEMP]
+	add	r2,r2,rFlashBase
+	cmp	rFlashSector,r2
+	blo	1b
+
+	b	PrintSuccess
+33:
+	BigMov	r3,FLASH_READ_CMD&\mask
+	\istr	r3,[rFlashBase,#0]
+	delay
+	ldr	r3,[r1,#-4]	//read flash
+	cmp	r2,r3
+	beq	32b		//br if (we signal) glitch caused a spurious status register read
+	b	ReturnError
+.endm
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/miniMac.inc u-boot-1.1.2-neon/include/asm-arm/arch-pxa/miniMac.inc
--- u-boot-1.1.2/include/asm-arm/arch-pxa/miniMac.inc	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/miniMac.inc	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,476 @@
+#include "platformTypes.h"
+#define SUB_LR_FALL_THRU_FOR_FIQ 1		//0 for branch
+#define LITTLE_ENDIAN 1		//describes memory system
+#define DDEBUG 0
+#define DO_GPTEST 0
+
+#define MACH_TYPE_SCANPASS 332
+
+#define ATAG_CORE       0x54410001
+#define ATAG_MEM		0x54410002
+#define TAGGED_LIST		0xa0000100
+	.ifdef __ARMASM
+	GBLA STACKS_VALID
+	GBLA CONFIG_STACKS_VALID
+	.set	CONFIG_STACKS_VALID,1
+	.endif
+
+#if (SOFTWARE_TYPE==WINCE)
+	.set	STACKS_VALID,1
+	.ifdef __ARMASM
+	.else
+#ifndef CONFIG_STACKS_VALID
+#define CONFIG_STACKS_VALID 1
+#endif
+	.endif
+
+#define SDRAM_BASE_C_VIRTUAL 0xA0000000		//0x80000000 is cached mapped, 0xa0000000 is uncacheable
+#define UART_VIRT_BASE 0xAA100000
+#define VMA_DEBUG (0xfff00000)
+#define VIRTUAL_CS0 0xa8000000
+#define VIRTUAL_CS1 0xa8000000
+
+#else
+#ifdef CONFIG_STACKS_VALID
+	.set	STACKS_VALID,1
+#else
+	.set	STACKS_VALID,0
+#endif
+#define SDRAM_BASE_C_VIRTUAL 0xC0000000
+#define UART_VIRT_BASE 0xf8100000
+//#define VMA_DEBUG 0xff000000
+//!!!!!for some reason the above base causes bizarre problems
+#define VMA_DEBUG (0xfff00000)
+#define VIRTUAL_CS0 0xff000000
+#define VIRTUAL_CS1 0xff100000
+#endif
+
+#define V_rWork r2
+#define V_rBranch r3
+#define I_rWork r2
+#define I_rBranch sp	//r13
+
+#ifdef CONFIG_STACKS_VALID
+#define rWork V_rWork
+#define rBranch V_rBranch
+
+#else
+#define rWork I_rWork
+#define rBranch I_rBranch
+#endif
+
+
+#if 0
+#define RED_VAL   0x15
+#define GREEN_VAL 0x2a
+#define BLUE_VAL  0x0a
+#else
+#define RED_VAL   0x0
+#define GREEN_VAL 0x0
+#define BLUE_VAL  0x0
+#endif
+
+//#define BAUDRATE 9600
+//#define BAUDRATE 38400
+//#define BAUDRATE 57600
+//#define BAUDRATE 57600
+#define BAUDRATE 115200
+//#define BAUDRATE 230400
+
+#if (CPU_CLOCK==100)
+#define COUNT_MULT 1
+#else
+#if (CPU_CLOCK==200)
+#define COUNT_MULT 2
+#else
+#if (CPU_CLOCK==300)
+#define COUNT_MULT 3
+#else
+#define COUNT_MULT 4
+#endif
+#endif
+#endif
+
+#if 1		//(SOFTWARE_TYPE==WINCE)
+#define RECEIVE_LOOP_COUNT 0x10000*COUNT_MULT
+#else
+#if (PLATFORM_TYPE==GAME_CONTROLLER_PLAITED_A1)||(PLATFORM_TYPE==GAME_CONTROLLER)||(PLATFORM_TYPE==GAME_WITH_SMC)
+#define RECEIVE_LOOP_COUNT 0x100000*COUNT_MULT
+#else
+#define RECEIVE_LOOP_COUNT 0x300000*3*COUNT_MULT
+#endif
+#endif
+
+// **********************************************************
+#define DBG_MAGIC 95				//this allows BigMov sp,DEBUG_BASE+DBG_MAGIC to generate just 1 instruction
+//#define DBG_START -95
+#define DBG_START 0
+#define DBG_R0		((0<<2)+DBG_START)
+#define DBG_R1		((1<<2)+DBG_START)
+#define DBG_R2		((2<<2)+DBG_START)
+#define DBG_R3		((3<<2)+DBG_START)
+#define DBG_R4		((4<<2)+DBG_START)
+#define DBG_R5		((5<<2)+DBG_START)
+#define DBG_R6		((6<<2)+DBG_START)
+#define DBG_R7		((7<<2)+DBG_START)
+#define DBG_R8		((8<<2)+DBG_START)
+#define DBG_R9		((9<<2)+DBG_START)
+#define DBG_SL		((10<<2)+DBG_START)
+#define DBG_FP		((11<<2)+DBG_START)
+#define DBG_IP		((12<<2)+DBG_START)
+#define DBG_SP		((13<<2)+DBG_START)
+#define DBG_LR		((14<<2)+DBG_START)
+#define DBG_PC		((15<<2)+DBG_START)
+#define DBG_CPSR	((16<<2)+DBG_START)		//this and above have corresponding symbol #s
+
+#define DBG_HCPSR	((17<<2)+DBG_START)		//interrupt handler original CPSR
+#define DBG_TRACE	((18<<2)+DBG_START)
+#define DBG_LastSignal	((19<<2)+DBG_START)		//only 1 byte
+#define DBG_Mode	(((19<<2)+1)+DBG_START)	//only 1 byte, bit 0 -1 means gdb mode for control breaks
+#define DBG_FFUART_LCR (((19<<2)+2)+DBG_START) //only 1 byte
+#define DBG_HSP		((20<<2)+DBG_START)		//handler stack pointer on entry, for aborts
+#define DBG_TEMP	((21<<2)+DBG_START)
+//22 free
+#define DBG_ABORT_PC    ((23<<2)+DBG_START)
+#define DBG_INDIRECT_R0 ((24<<2)+DBG_START)	//it needs it's own space in case a debug interrupt
+#define DBG_INDIRECT_LR ((25<<2)+DBG_START)	//happens in the return code, but memory is mapped if used
+#define DEBUG_SPACE (((23<<2)|0x1f)+1)			//a multiple of 32 bytes
+
+// *********************************************************
+
+#define DEBUG_START (VMA_DEBUG+0x3000-DEBUG_SPACE)	//this saves on memory, but the else is easier to debug
+#define VMA_DEBUG_OFFSET (0xffff0000-VMA_DEBUG)
+#define DEBUG_BASE (DEBUG_START-DBG_START)
+#define DEBUG_SYM DEBUG_START
+
+
+#define SYM_R0		0
+#define SYM_R1		1
+#define SYM_R2		2
+#define SYM_R3		3
+#define SYM_R4		4
+#define SYM_R5		5
+#define SYM_R6		6
+#define SYM_R7		7
+#define SYM_R8		8
+#define SYM_R9		9
+#define SYM_SL		10
+#define SYM_FP		11
+#define SYM_IP		12
+#define SYM_SP		13
+#define SYM_LR		14
+#define SYM_PC		15
+#define SYM_CPSR	16
+
+//#define SYM_SPSR	17	//nice to have, but do it later
+//#define SYM_FPS		17
+#define SYM_FP0		17		//40 bits, 5
+#define SYM_FSR		18
+#define SYM_FAR		19
+#define SYM_DCSR	20
+#define SYM_TTBR	21
+#define SYM_CTRL	22
+
+#define SYM_LAST	22
+
+#define	SYM_LAST_RCMD	(SYM_FP0)	//last symbol printed by R cmd
+
+
+
+#define SIG_RESET			0
+#define SIG_UNDEFINED_INSTRUCTION	1
+#define SIG_SWI				2
+#define SIG_PREFETCH_ABORT		3
+#define SIG_DATA_ABORT			4
+#define SIG_UNUSED			5
+#define SIG_IRQ				6
+#define SIG_FIQ				7
+#define SIG_DBG				8
+#define SIG_DBG_RESET			8+0
+#define SIG_DBG_INSTRUCTION_BKPT	8+1
+#define SIG_DBG_DATA_BKPT		8+2
+#define SIG_DBG_BKPT_SOFTWARE		8+3
+#define SIG_DBG_EXTERNAL		8+4
+#define SIG_DBG_VECTOR_TRAP		8+5
+#define SIG_DBG_TRACE_BUFFER_FULL	8+6
+#define SIG_DBG_RESERVED		8+7
+
+#define GDB_EXIT_CHAR 0x0d
+// ******************************************************************
+#define rFieldStart r4
+#define rField	    r5
+#define rValidCnt   r6
+#define rCommand    r7
+#define rNum1	    r8
+#define rNum2	    r9
+#define rSymbol     sl	//r10
+#define rPrevNum1   fp	//r11
+#define rUart       ip	//r12
+#define rDBG        sp
+
+//in Go routine, temporary
+#define rBCR0		sl	//r10
+#define rBCR1		fp	//r11
+
+//in GDB routines
+#define rGdbCmd		r5
+#define rGdbNum1	r6
+#define rGdbTermChar1	r7
+#define rGdbNum2	r8
+#define rGdbTermChar2	r9
+#define rGdbNum3 	sl	//r10
+#define rGdbChkSum	fp	//r11
+
+//in Download routine
+#define rDest		r3
+#define rPacketLength	r4
+#define rDestHead	r5
+#define rBlockNum	r6
+#define rNak		r7
+#define rCRC		r8
+#define rRunningCRC	r9
+#define rPrevCRC	sl	//r10
+
+#define rSP r8			//register which contains L4(' ',' ',' ',' '), all spaces
+// ********
+
+#define CR 0x0d
+#define LF 0x0a
+
+// ******************************
+#define F_INC 4
+
+#define F_NUM1_BIT (F_INC*3)
+#define F_NUM2_BIT (F_INC*5)
+
+#define F_COMMAND 1<<(F_INC)
+#define F_NUM1	  1<<(F_NUM1_BIT)
+#define F_NUM2	  1<<(F_NUM2_BIT)
+#define F_UNDEF	  1<<(F_INC*7)
+
+#define F_COMMAND_MASK	((1<<F_INC)-1)<<(F_INC)
+#define F_NUM1_MASK	((1<<F_INC)-1)<<(F_INC*3)
+#define F_NUM2_MASK	((1<<F_INC)-1)<<(F_INC*5)
+// ******************************
+#define cachelinecount 2048		//1024 if baseaddress not used for another purpose
+#define cachelinesize 32
+//#define baseaddress 0		//physical memory does not have to exist here, but a valid descriptor table entry IS required
+
+// *****************************
+#define SOH 1
+#define STX 2
+#define EOT 4
+#define ACK 6
+#define NAK 0x15
+#define CAN 0x18
+
+#define CRC_POLY 0x10210000
+// *****************************
+
+// divide 0x1000 bytes among the stacks
+#define SS_SUPERVISOR	0x0800
+#define SS_IRQ		0x0400
+#define SS_FIQ		0x0100
+#define SS_SYSTEM	0x0100
+#define SS_UNDEFINED	0x0100
+#define SS_ABORT	0x0100
+#define SS_TOTAL (SS_SUPERVISOR+SS_IRQ+SS_FIQ+SS_SYSTEM+SS_UNDEFINED+SS_ABORT)
+#define SS_START	0x0a0008000-0x4400-SS_TOTAL	//-17k, 16k for 1st level page table, 1k for 2nd level page table
+// *****************************
+
+
+
+
+// *********************************
+.macro mac_AfterPCPrint branch		//vector table at 0xffff0000, br to vector table at VMA_DEBUG
+	.ifdef __ARMASM
+	LCLA cnt
+	.set	cnt,$branch
+	WHILE cnt>0
+		b	93f
+		.set	cnt,cnt-1
+	WEND
+	.else
+	.rept (\branch)
+	b	93f
+	.endr
+	.endif
+
+AfterPCPrint:
+	mov		r0,#0x55
+	b		AfterPCPrint1
+InitializeCont:
+	b		MainInitializationCode
+93:
+.endm
+
+
+.macro RelocationVector branch		//vector table at 0xffff0000, br to vector table at VMA_DEBUG
+					//warning, do not use relocated vectors unless memory management is enabled and VMA_DEBUG is mapped
+	.ifdef __ARMASM
+	LCLA cnt
+	.set	cnt,$branch
+	WHILE cnt>0
+		b	71f
+		.set	cnt,cnt-1
+	WEND
+	.else
+	.rept (\branch)
+	b	71f
+	.endr
+	.endif
+
+	mov	pc,#0x00		//0    - reset always goes to 0 because it will be in physical memory mode for instructions
+	b	.-VMA_DEBUG_OFFSET	//4    - UndefinedInstr
+	b	.-VMA_DEBUG_OFFSET	//8    - SWI
+	b	.-VMA_DEBUG_OFFSET	//0x0c - PrefetchAbort
+	b	.-VMA_DEBUG_OFFSET	//0x10 - DataAbort
+	b	.-VMA_DEBUG_OFFSET	//0x14 - Unused
+	b	.-VMA_DEBUG_OFFSET	//0x18 - IRQ
+	.if SUB_LR_FALL_THRU_FOR_FIQ
+	sub	lr,lr,#4		//0x1c - FIQ
+	.else
+	b	.-VMA_DEBUG_OFFSET	//0x1c - FIQ
+	.endif
+
+//these instructions are always at this address
+//to minimize the effect of a mismatch of minicache and flash
+ReturnWithIndirection:
+	mov	r0,r0			//!!!! make sure this instruction is in the 1st 4k of flash so that BigOrr2Ne is guaranteed to work
+	ldr	pc,[sp],#4
+
+//c-0 invalidate caches, c-1 skip cache invalidate
+//z-1 return direct, z-0 return indirect
+InvalidateAndReturn:
+	adrne	lr,ReturnWithIndirection
+	ldreq	lr,[r0,#DBG_PC-DBG_R2]
+	BigOrr2Ne lr,VMA_DEBUG			//this range is sure to give an external abort for errata on exiting SDS
+
+//Invalidate the data/instruction cache and branch target buffer
+
+	CP15_CF_INVAL_BOTH mcrcc,r1
+	CPWAIT	r1
+
+	ldr	sp,[r0,#DBG_HSP-DBG_R2]
+	ldr	r1,[r0,#DBG_R1-DBG_R2]
+	str	r0,[r0,#DBG_ABORT_PC-DBG_R2]	//reset error flag so abort can be retried
+	ldr	r0,[r0,#DBG_R0-DBG_R2]
+	movs	pc,lr
+71:
+.endm
+
+.macro  CheckBranch rTemp,rAddr
+	movs	\rTemp,pc		//don't redirect if running from flash
+	submi	\rAddr, \rAddr, #0x00010000
+	ldrmi	\rTemp, [\rAddr], #8
+	eormi	\rTemp, \rTemp, #0xea000000
+	tstmi	\rTemp, #0xff000000
+	moveq	\rTemp, \rTemp, LSL #8
+	addeq	\rAddr, \rAddr, \rTemp, ASR #6
+.endm
+.macro  CheckLdr rTemp,rAddr		//check for instruction LDR pc,[pc,#nnn]
+	eor	\rTemp, \rTemp, #0x0f900000
+	eor	\rTemp, \rTemp, #0x000ff000
+	cmp	\rTemp, #0x1000
+	ldrcc	\rAddr,[\rAddr,\rTemp]
+.endm
+
+//this is case where stacks are assumed valid
+.macro  V_VectorEntrance Work,Branch,code
+	stmdb	sp!,{\Work,\Branch,lr}
+	mov	\Branch,#\code<<2
+.endm
+.macro  V_VectorExitCC Work,Branch,cc,ccia
+	str\cc	\Branch,[sp,#8]
+	ldm\ccia	sp!,{\Work,\Branch,pc}
+.endm
+.macro  V_VectorExitCC1 Work,Branch,cc,ccia
+	str\cc	\Branch,[sp,#8]
+	ldm\ccia	sp!,{\Work,\Branch,pc}
+.endm
+
+//this is case where stacks are assumed invalid
+.macro  I_VectorEntrance Work,Branch,code
+	BigMov	\Branch,DEBUG_BASE+DBG_MAGIC
+	str	\Work,[\Branch,#DBG_TEMP-DBG_MAGIC]
+	mov	\Branch, #\code<<2
+.endm
+.macro  I_VectorExitCC Work,Branch,cc,ccia
+	BigMovCC \cc,\Work,DEBUG_BASE+DBG_MAGIC
+	ldr\cc	\Work,[\Work,#DBG_TEMP-DBG_MAGIC]
+	bx\cc	\Branch
+.endm
+.macro  I_VectorExitCC1 Work,Branch,cc,ccia
+	BigMov	\Work,DEBUG_BASE+DBG_MAGIC
+	ldr\cc	\Work,[\Work,#DBG_TEMP-DBG_MAGIC]
+	bx\cc	\Branch
+.endm
+.macro	VectorEntrance Work,Branch,code
+	.if STACKS_VALID
+	V_VectorEntrance \Work,\Branch,\code
+	.else
+	I_VectorEntrance \Work,\Branch,\code
+	.endif
+.endm
+.macro	JOIN brcc
+	.if STACKS_VALID
+	\brcc	join_fiq
+	.else
+	\brcc	join_irq
+	.endif
+.endm
+.macro JOIN2 brcc
+	.if STACKS_VALID
+	\brcc	join_fiq2
+	.else
+	\brcc	join_irq2
+	.endif
+.endm
+// *****************************************************
+
+.macro SaveRegisters rBase,rTemp
+	CalcMemSize	\rBase,\rTemp,MEMORY_CONTROL_BASE				//out: \rTemp - mem size
+	BigAdd	\rBase,\rTemp,MEM_START-0x1000+((DEBUG_BASE+DBG_MAGIC)&0xfff)		//last 4k of memory
+	mov	\rTemp,#0
+//great, now memory should be working, let's save registers, only r0(rBase),sp(rTemp) have been lost
+//don't trust LDM,STM instructions in debug mode....
+//or LDR w/Rd=PC, LDR w/RRX addressing mode, SWP, LDC, STC
+// *******************************************************
+// *******************************************************
+	str	\rTemp,[\rBase,#DBG_START-32  -DBG_MAGIC]
+	str	\rTemp,[\rBase,#DBG_R0        -DBG_MAGIC]
+	str	r1,    [\rBase,#DBG_R1        -DBG_MAGIC]
+	str	r2,    [\rBase,#DBG_R2        -DBG_MAGIC]
+	str	r3,    [\rBase,#DBG_R3        -DBG_MAGIC]
+	str	\rTemp,[\rBase,#DBG_TRACE     -DBG_MAGIC]
+	str	\rTemp,[\rBase,#DBG_LastSignal-DBG_MAGIC]
+.endm
+.macro	ReadHexE dest,rCnt1
+
+#if LITTLE_ENDIAN
+	mov	\rCnt1,#4
+	mov	\dest,#0
+1:	bl	ReadHex
+	bcc	CheckSumError
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	mov	r1,r1,LSL #28
+	add	\dest,r1,\dest,LSR #8
+
+	bl	ReadHex
+	bcc	CheckSumError
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	add	\dest,\dest,r1,LSL #24
+#else
+	mov	\rCnt1,#8
+	mov	\dest,#0
+1:	bl	ReadHex
+	bcc	CheckSumError
+	add	rGdbChkSum,rGdbChkSum,r0		//update checksum
+	add	\dest,r1,\dest,LSL #4
+#endif
+	subs	\rCnt1,\rCnt1,#1
+	bne	1b
+.endm
+
+
+
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/mmc.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/mmc.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/mmc.h	2003-06-27 23:32:42.000000000 +0200
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/mmc.h	2007-08-11 21:07:21.000000000 +0200
@@ -4,7 +4,7 @@
  *  Author: Vladimir Shebordaev, Igor Oblakov
  *  Copyright:  MontaVista Software Inc.
  *
- *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
+ *  $Id: mmc.h,v 1.3 2005/04/16 17:05:19 ericn Exp $
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
@@ -113,12 +113,17 @@
 #define MMC_CMD_SET_RCA			3
 #define MMC_CMD_SEND_CSD 		9
 #define MMC_CMD_SEND_CID 		10
+#define MMC_CMD_STOP		12
 #define MMC_CMD_SEND_STATUS		13
 #define MMC_CMD_SET_BLOCKLEN		16
 #define MMC_CMD_READ_BLOCK		17
 #define MMC_CMD_RD_BLK_MULTI		18
 #define MMC_CMD_WRITE_BLOCK		24
 
+#define SD_APP_CMD55  55         /* 0x37 */
+#define SD_APP_CMD41  41         /* 0x29 */
+#define SD_STATUS     13         /* 0x0D */
+
 #define MMC_MAX_BLOCK_SIZE		512
 
 #define MMC_R1_IDLE_STATE		0x01
@@ -197,4 +202,15 @@
 } mmc_csd_t;
 
 
+typedef struct sd_status {
+   ulong  prot_size ;
+   ushort card_type ;
+   ushort bus_width:2,
+          secured_mode:1,
+          unused0: 13 ;
+} sd_status_t ;
+
+extern uchar *
+mmc_cmd(ushort cmd, ushort argh, ushort argl, ushort cmdat);
+
 #endif /* __MMC_PXA_P_H__ */
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/platformTypes.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/platformTypes.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/platformTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/platformTypes.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,19 @@
+#ifndef __PLATFORMTYPES_H__
+#define __PLATFORMTYPES_H__ 1
+#define NEON						1
+#define NEONB						2
+#define BD2003						3
+#define GAME_WITH_SMC				4
+#define GAME_CONTROLLER				5
+#define GAME_CONTROLLER_PLAITED_A1	6
+#define BOUNDARY_OLD_BOARD			7  //lcd pin reordering for rgb problem, don't use VLIO(gp18 is turnstile)
+#define OLD_GAME_CONTROLLER			8
+#define HALOGEN						9
+
+#if (PLATFORM_TYPE==NEONB)
+#define PHYS_FLASH_BASE 0x04000000
+#else
+#define PHYS_FLASH_BASE 0x0
+#endif
+
+#endif
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxa250Base.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxa250Base.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxa250Base.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxa250Base.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,60 @@
+#ifndef __PXA250BASE_H__
+#define __PXA250BASE_H__ 1
+
+#ifdef __ARMASM
+#define USE_PHYSICAL 1
+#else
+#ifndef _MSC_VER
+#define USE_PHYSICAL 1
+#endif
+#endif
+	
+
+#ifndef USE_PHYSICAL
+#if EBOOT_PHYS
+#define USE_PHYSICAL 1
+#endif
+#endif
+
+#if USE_PHYSICAL
+#define PCMCIA_CARD0_IO     0x20000000
+#define PCMCIA_CARD0_ATTR   0x28000000
+#define PCMCIA_CARD0_MEM    0x2c000000
+
+#define PCMCIA_CARD1_IO     0x30000000
+#define PCMCIA_CARD1_ATTR   0x38000000
+#define PCMCIA_CARD1_MEM    0x3c000000
+
+#define FFUART_BASE         0x40100000
+#define BTUART_BASE         0x40200000
+#define STUART_BASE         0x40700000
+#define UART_BASE           FFUART_BASE
+//#define UART_BASE           BTUART_BASE
+
+#define OS_TIMER_BASE       0x40a00000
+#define IC_BASE             0x40D00000
+#define GPIO_BASE           0x40E00000
+#define PWR_MANAGER_BASE    0x40F00000
+#define CLK_MANAGER_BASE    0x41300000
+#define LCD_CONTROL_BASE    0x44000000
+#define MEMORY_CONTROL_BASE 0x48000000
+
+#define MEM_START           0xa0000000
+
+
+#else
+#include "xsc1.h"
+
+#define PCMCIA_CARD0_IO     PCMCIA_S0_IO_U_VIRTUAL
+#define PCMCIA_CARD0_ATTR   PCMCIA_S0_ATTR_U_VIRTUAL
+#define PCMCIA_CARD0_MEM    PCMCIA_S0_CMN_U_VIRTUAL
+
+#define PCMCIA_CARD1_IO     PCMCIA_S1_IO_U_VIRTUAL
+#define PCMCIA_CARD1_ATTR   PCMCIA_S1_ATTR_U_VIRTUAL
+#define PCMCIA_CARD1_MEM    PCMCIA_S0_CMN_U_VIRTUAL
+
+#define MEMORY_CONTROL_BASE MEMC_BASE_U_VIRTUAL
+#define GPIO_BASE           GPIO_BASE_U_VIRTUAL
+#endif
+
+#endif
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaGpio25x.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaGpio25x.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaGpio25x.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaGpio25x.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,218 @@
+//gpios for PLATFORM_TYPE== NEON,NEONB,BD2003, or BOUNDARY_OLD_BOARD
+
+#define LCD_CS_STATE HIGH
+
+//CP  - Clock and Power Management Unit
+//MMC - Multimedia Card Controller
+//MC  - Memory Controller
+//SIU - System Integration Unit
+//SSP - Synchronous Serial Port
+//AC  - Audio Controller (AC97)
+//FF  - Full Function UART
+//BT  - Blue Tooth UART
+//ST  - standard UART Port
+//LCD - LCD Controller
+	SPEC_GP  0,IN,HIGH,0		//        flash ready low 16, or magStripe T1 Clk(SMC)
+	SPEC_GP  1,IN,HIGH,0		//CP_RST, flash ready high 16, or magStripe T2 Clk(SMC)
+
+#if (PLATFORM_TYPE==NEONB)
+	SPEC_GP  2,IN,HIGH,0		//USB client connection status
+	SPEC_GP  3,IN,HIGH,0		//float means USB Slave not ready to accept data
+								//out 1 means ready (D+ signal)
+	SPEC_GP  4,OUT,LOW,0		//low means don't provide 12 volts to I2C bus
+#else
+#if (PLATFORM_TYPE==NEON)
+	SPEC_GP  2,IN,HIGH,0		//USB client connection status
+	SPEC_GP  3,IN,HIGH,0		//float means USB Slave not ready to accept data
+	SPEC_GP  4,IN,HIGH,0		//UCB1400 irq on NEON board
+#else
+	SPEC_GP  2,OUT,LOW,0		//output to transistor (unused), OUT_DRY_CONTACT2
+	SPEC_GP  3,OUT,HIGH,0
+	SPEC_GP  4,IN,HIGH,0		//interrupt for USB irq 1
+#endif
+#endif
+
+	SPEC_GP  5,IN,HIGH,0		//interrupt for USB irq 2,  or SM501
+	SPEC_GP  6,OUT,HIGH,1		//MMC_CLK
+	SPEC_GP  7,OUT,LOW,0		//CP_48MHZ	!!! red led, NEON:J13,pin3
+	SPEC_GP  8,OUT,HIGH,1		//MMC_CCS0
+	SPEC_GP  9,OUT,LOW,0		//MMC_CCS1, !!! doorlock, or OUT_DRY_CONTACT1
+	SPEC_GP  10,IN,HIGH,0		//SIU_RTCCLK, Neon/Neonb data 1 for SDIO interrupt
+
+#if (PLATFORM_TYPE==NEON)
+	SPEC_GP  11,OUT,HIGH,0		//CP_3600KHZ, NEON:J12,pin1
+#else
+	SPEC_GP  11,IN,HIGH,0		//CP_3600KHZ, suspend USB slave
+#endif
+	SPEC_GP  12,IN,HIGH,0		//CP_32KHZ, suspend USB host
+
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==NEONB)
+	SPEC_GP  13,OUT,HIGH,2		//MC_MBGNT
+	SPEC_GP  14,IN,HIGH,1		//MC_MBREQ
+#else
+	SPEC_GP  13,OUT,HIGH,0		//USB wakeup slave
+	SPEC_GP  14,IN,HIGH,0		//UCB1400 IRQ
+#endif
+
+
+#if (PLATFORM_TYPE==NEONB)
+	SPEC_GP  15,OUT,HIGH,2		//MC_nCS1, eeprom
+#else
+#if (PLATFORM_TYPE==NEON)
+	SPEC_GP  15,OUT,LOW,0		//MC_nCS1,  NEON:J13, pin 1
+#else
+	SPEC_GP  15,OUT,LOW,0		//MC_nCS1, !!! amber led
+#endif
+#endif
+
+
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==NEONB)
+	SPEC_GP  16,OUT,HIGH,0		//LCD backlight brightness control
+	SPEC_GP  17,OUT,HIGH,0		//LCD backlight ON/OFF
+#else
+	SPEC_GP  16,IN,HIGH,0		//SIU_PWM0, !!! feedback2, left in
+	SPEC_GP  17,IN,HIGH,0		//SIU_PWM1, !!! feedback1, right in
+#endif
+
+#if (PLATFORM_TYPE==BOUNDARY_OLD_BOARD)
+	SPEC_GP  18,OUT,HIGH,0		//MC_RDY, !!! turnstile
+#else
+	SPEC_GP  18,IN,HIGH,1		//MC_RDY, VIO_READY
+#endif
+
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==NEONB)
+	SPEC_GP  19,OUT,HIGH,0		//MC_DREQ1, nc
+#else
+	SPEC_GP  19,IN,HIGH,1		//MC_DREQ1, DMA request for USB DC
+#endif
+
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==NEONB)
+	SPEC_GP  20,OUT,HIGH,1		//MC_DREQ0, nc
+#else
+	SPEC_GP  20,IN,HIGH,1		//MC_DREQ0, DMA request for USB HC
+#endif
+
+	SPEC_GP  21,IN,HIGH,0		//	pcmcia card detect
+	SPEC_GP  22,IN,HIGH,0		//	pcmcia intr (active low)
+
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==NEONB)
+	SPEC_GP  23,IN,LOW,0		//UCB1400 irq for NEONB, nc for NEW NEON
+#else
+	SPEC_GP  23,OUT,HIGH,0		//SSP_SCLK, nc
+#endif
+
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==NEONB)
+	SPEC_GP  24,IN,LOW,0		//SSP_SFRM, SMSC interrupt (active high)
+#else
+	SPEC_GP  24,OUT,HIGH,0		//SSP_SFRM, nc
+#endif
+
+	SPEC_GP  25,OUT,HIGH,0		//SSP_TXD, nc
+	SPEC_GP  26,OUT,HIGH,0		//SSP_RXD, nc
+	SPEC_GP  27,OUT,LOW,0		//SSP_EXTCLK, DC1 (SMC)
+
+	SPEC_GP  28,IN,HIGH,1		//AC_BITCLK,	ac97 bitclk
+	SPEC_GP  29,IN,HIGH,1		//AC_SDATAIN0,	ac97 datain0
+	SPEC_GP  30,OUT,HIGH,2		//AC_SDATAOUT,	ac97 data out
+	SPEC_GP  31,OUT,HIGH,2		//AC_SYNC,	ac97 sync
+////////////////////////////////////////////////////////////////////////////////////////////
+
+
+	SPEC_GP  32,OUT,HIGH,0		//AC_SDATAIN1, wet contact
+	SPEC_GP  33,OUT,LOW,0		//MC_nCS5, green led (left), NEON:J13,pin 2
+	SPEC_GP  34,IN,HIGH,1		//FF_RXD
+	SPEC_GP  35,IN,HIGH,1		//FF_CTS
+	SPEC_GP  36,IN,HIGH,0		//FF_DCD, MMC Card Detect
+	SPEC_GP  37,IN,HIGH,1		//FF_DSR
+	SPEC_GP  38,IN,HIGH,0		//FF_RI, MMC Write Protect, MMC/SDIO IRQ
+	SPEC_GP  39,OUT,HIGH,2		//FF_TXD
+	SPEC_GP  40,OUT,HIGH,2		//FF_DTR
+	SPEC_GP  41,OUT,HIGH,2		//FF_RTS
+	SPEC_GP  42,IN,HIGH,1		//BT_RXD
+	SPEC_GP  43,OUT,HIGH,2		//BT_TXD
+#if (PLATFORM_TYPE==NEON)
+	SPEC_GP  44,IN,HIGH,0		//BT_CTS, NEON:J12,pin 2
+#else
+	SPEC_GP  44,OUT,HIGH,0		//BT_CTS, USB wakeup host
+#endif
+	SPEC_GP  45,OUT,LOW,0		//BT_RTS, HIGH 2
+#if (PLATFORM_TYPE==NEON)
+	SPEC_GP  46,IN,HIGH,0		//ST_RXD, NEON:J12,pin 3
+#else
+	SPEC_GP  46,IN,HIGH,2		//ST_RXD
+#endif
+	SPEC_GP  47,OUT,HIGH,1		//ST_TXD
+	SPEC_GP  48,OUT,HIGH,2		//MC_nPOE,    pcmcia
+	SPEC_GP  49,OUT,HIGH,2		//MC_nPWE,    pcmcia
+	SPEC_GP  50,OUT,HIGH,2		//MC_nPIOR,   pcmcia
+	SPEC_GP  51,OUT,HIGH,2		//MC_nPIOW,   pcmcia
+	SPEC_GP  52,OUT,HIGH,2		//MC_nPCE1,   pcmcia
+	SPEC_GP  53,OUT,HIGH,2		//MC_nPCE2,   pcmcia
+	SPEC_GP  54,OUT,HIGH,2		//MC_nPSKTSEL, nc
+	SPEC_GP  55,OUT,HIGH,2		//MC_nPREG,   pcmcia attribe vs Io space
+	SPEC_GP  56,IN,HIGH,1		//MC_nPWAIT   pcmcia busy
+	SPEC_GP  57,IN,HIGH,1		//MC_nIOIS16, pcmcia 16 bit wide
+	SPEC_GP  58,OUT,HIGH,ALT_LCD	//LCD_LDD0, also GP_PIX_D0
+	SPEC_GP  59,OUT,HIGH,ALT_LCD	//LCD_LDD1, also GP_PIX_D1
+	SPEC_GP  60,OUT,HIGH,ALT_LCD	//LCD_LDD2, also GP_PIX_D2
+	SPEC_GP  61,OUT,HIGH,ALT_LCD	//LCD_LDD3, also GP_PIX_D3
+	SPEC_GP  62,OUT,HIGH,ALT_LCD	//LCD_LDD4, also GP_PIX_D4
+	SPEC_GP  63,OUT,HIGH,ALT_LCD	//LCD_LDD5, also GP_PIX_D5
+
+
+////////////////////////////////////////////////////////////////////////////////////////////
+
+
+	SPEC_GP  64,OUT,HIGH,ALT_LCD	//LCD_LDD6, also GP_PIX_D6
+	SPEC_GP  65,OUT,HIGH,ALT_LCD	//LCD_LDD7, also GP_PIX_D7
+	SPEC_GP  66,OUT,HIGH,ALT_LCD	//LCD_LDD8, also GP_PIX_RESET
+	SPEC_GP  67,OUT,HIGH,ALT_LCD	//LCD_LDD9
+	SPEC_GP  68,OUT,HIGH,ALT_LCD	//LCD_LDD10
+	SPEC_GP  69,OUT,HIGH,ALT_LCD	//LCD_LDD11
+	SPEC_GP  70,OUT,HIGH,ALT_LCD	//LCD_LDD12
+
+	SPEC_GP  71,OUT,HIGH,ALT_LCD	//LCD_LDD13
+
+	SPEC_GP  72,OUT,HIGH,ALT_LCD	//LCD_LDD14
+	SPEC_GP  73,OUT,HIGH,ALT_LCD	//LCD_LDD15
+	SPEC_GP  74,OUT,HIGH,ALT_LCD	//LCD_FCLK, also GP_PIX_READ
+	SPEC_GP  75,OUT,LCD_CS_STATE,ALT_LCD	//LCD_LCLK, also GP_PIX_CS1
+	SPEC_GP  76,OUT,LCD_CS_STATE,ALT_LCD	//LCD_PCLK, also GP_PIX_CS0
+	SPEC_GP  77,OUT,HIGH,ALT_LCD	//LCD_ACBIAS, also GP_PIX_A0
+	SPEC_GP  78,OUT,HIGH,2		//nCS2, DMA acknowledge channel 1 for USB, SMC91c111 Chip Select nDATACS
+	SPEC_GP  79,OUT,HIGH,2		//nCS3, DMA acknowledge channel 2 for USB, SM501 Chip Select
+	SPEC_GP  80,OUT,HIGH,2		//nCS4, USB chip select, SMC91c111 Chip Select
+	SPEC_GP  81,IN,LOW,0		//GND (pin F16), pxa255 has 9 extra gpios
+	SPEC_GP  82,IN,LOW,0		//GND (pin E16)
+	SPEC_GP  83,IN,LOW,0		//GND (pin E15)
+	SPEC_GP  84,IN,LOW,0		//GND (pin D16)
+	SPEC_GP  85,IN,LOW,0		//GND (pin F15)
+//to maintain compatibility with code written for the pxa250
+//the meaning of gp86-gp89's direction bit is reversed, and alternate function is forced to the SDRAM/AC97 unit's control
+	SPEC_GP  86,IN,HIGH,0		//SDCS2 (pin G3) set as OUTPUT!!!
+	SPEC_GP  87,IN,HIGH,0		//SDCS3 (pin F2) set as OUTPUT!!!
+	SPEC_GP  88,IN,HIGH,0		//old RDnWR(pin D3) set as OUTPUT!!!
+	SPEC_GP  89,IN,LOW,0		//old ac97_reset(pin D10), set as OUTPUT!!!
+	SPEC_GP  90,IN,LOW,0		//undefined
+	SPEC_GP  91,IN,LOW,0		//undefined
+	SPEC_GP  92,IN,LOW,0		//undefined
+	SPEC_GP  93,IN,LOW,0		//undefined
+	SPEC_GP  94,IN,LOW,0		//undefined
+	SPEC_GP  95,IN,LOW,0		//undefined
+
+// ****************************************************************************
+	CREATE_MASK_DIR		DRVAL0, SPEC_, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+	CREATE_MASK_LEVEL	SRVAL0, SPEC_, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+	CREATE_MASK_ALT		AFVAL0, SPEC_, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
+	CREATE_MASK_ALT		AFVAL16,SPEC_,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+
+	CREATE_MASK_DIR		DRVAL32,SPEC_,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63
+	CREATE_MASK_LEVEL	SRVAL32,SPEC_,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63
+	CREATE_MASK_ALT		AFVAL32,SPEC_,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47
+	CREATE_MASK_ALT		AFVAL48,SPEC_,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63
+
+	CREATE_MASK_DIR		DRVAL64,SPEC_,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95
+	CREATE_MASK_LEVEL	SRVAL64,SPEC_,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95
+	CREATE_MASK_ALT		AFVAL64,SPEC_,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79
+	CREATE_MASK_ALT		AFVAL80,SPEC_,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95
+
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaGpio27x.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaGpio27x.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaGpio27x.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaGpio27x.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,221 @@
+//gpios for HALOGEN
+
+//CP  - Clock and Power Management Unit
+//MMC - Multimedia Card Controller
+//MC  - Memory Controller
+//SIU - System Integration Unit
+//SSP - Synchronous Serial Port
+//AC  - Audio Controller (AC97)
+//FF  - Full Function UART
+//BT  - Blue Tooth UART
+//ST  - standard UART Port
+//LCD - LCD Controller
+
+	SPEC_GP  0,IN,HIGH,0		//
+	SPEC_GP  1,IN,HIGH,0		//nRESET_GPIO, usb client connect interrupt
+
+	SPEC_GP  2,IN,HIGH,0		//SYS_EN
+
+	SPEC_GP  3,IN,HIGH,0		//PWR_SCL, Rev 1 usb client enable, float means USB Slave not ready to accept data
+								//out 1 means ready
+
+	SPEC_GP  4,IN,HIGH,0		//PWR_SDA
+
+	SPEC_GP  5,IN,HIGH,0		//PWR_CAP 0
+	SPEC_GP  6,IN,HIGH,0		//PWR_CAP 1
+	SPEC_GP  7,IN,HIGH,0		//PWR_CAP 2
+	SPEC_GP  8,IN,HIGH,0		//PWR_CAP 3
+	SPEC_GP  9,OUT,HIGH,0		//NC
+#if (PLATFORM_REV==1)
+	SPEC_GP  10,OUT,HIGH,0		//NC, rev 1 doesn't have MMC write protect, or card detect
+#else
+	SPEC_GP  10,IN,HIGH,0		//MMC card detect
+#endif
+
+	SPEC_GP  11,OUT,HIGH,0		//NC
+	SPEC_GP  12,OUT,HIGH,0		//NC
+	SPEC_GP  13,OUT,HIGH,0		//NC
+
+	SPEC_GP  14,OUT,HIGH,0		//NC
+	SPEC_GP  15,OUT,HIGH,2		//nCS1, NC
+
+
+	SPEC_GP  16,OUT,LOW,0		//PWM0 backlight intensity, 0 brightest
+	SPEC_GP  17,OUT,HIGH,0		//NC
+
+	SPEC_GP  18,IN,HIGH,1		//MC_RDY, VIO_READY
+
+	SPEC_GP  19,OUT,HIGH,0		//NC
+
+	SPEC_GP  20,OUT,HIGH,1		//MC_DREQ0, NC
+
+	SPEC_GP  21,OUT,HIGH,0		//NC
+	SPEC_GP  22,OUT,HIGH,0		//NC
+
+#if (PLATFORM_REV==1)
+	SPEC_GP  23,OUT,HIGH,0		//NC
+#else
+	SPEC_GP  23,IN,HIGH,0		//rev 2 UCB1400 int
+#endif
+
+	SPEC_GP  24,IN,LOW,0		//LAN91c111 Interrupt pin (SMSC)
+
+	SPEC_GP  25,OUT,HIGH,0		//SSP_TXD, nc
+	SPEC_GP  26,OUT,HIGH,0		//SSP_RXD, nc
+	SPEC_GP  27,OUT,HIGH,0		//NC
+
+	SPEC_GP  28,IN,HIGH,1		//AC_BITCLK,	ac97 bitclk
+	SPEC_GP  29,IN,HIGH,1		//AC_SDATAIN0,	ac97 datain0
+	SPEC_GP  30,OUT,HIGH,2		//AC_SDATAOUT,	ac97 data out
+	SPEC_GP  31,OUT,HIGH,2		//AC_SYNC,	ac97 sync
+////////////////////////////////////////////////////////////////////////////////////////////
+
+
+	SPEC_GP  32,OUT,HIGH,2		//MMCLK
+	SPEC_GP  33,OUT,HIGH,0		//MC_nCS5, NC
+	SPEC_GP  34,IN,HIGH,1		//(in alt 1:FF_RXD) (out alt 1:USB_P2_2)		2    input, Session Valid
+	SPEC_GP  35,IN,HIGH,0		//(in alt 1:FF_CTS) (in alt 2:USB_P2_1)			1    input, SRP Detect
+#if (PLATFORM_REV==1)
+	SPEC_GP  36,OUT,HIGH,0		//(in alt 1:FF_DCD)
+#else
+	SPEC_GP  36,IN,HIGH,0		//(in alt 1:FF_DCD) (out alt 1:USB_P2_4)		4    output Vbus Enable
+#endif
+	SPEC_GP  37,OUT,HIGH,0		//(in alt 1:FF_DSR) (out alt 1:USB_P2_8)		 8	 output Vbus Pulsing Enable for SRP
+
+	SPEC_GP  38,IN,HIGH,0		//(in alt 1:FF_RI)  (in alt 3:USB_P2_3)		//MMC Write Protect (rev 1 is NC),// 3    input, Vbus valid 4.4 Volts
+	SPEC_GP  39,OUT,HIGH,2		//(out alt 2:FF_TXD) (out alt 1:USB_P2_6)		
+
+#if (PLATFORM_REV==1)
+	SPEC_GP  40,OUT,HIGH,2		//(out alt 2:FF_DTR)
+#else
+	SPEC_GP  40,IN,HIGH,0		//(out alt 2:FF_DTR) (in alt 3:USB_P2_5)		5    input, Vbus valid 4.0 Volts
+#endif
+
+	SPEC_GP  41,OUT,HIGH,2		//(out alt 2:FF_RTS) (in alt 2:USB_P2_7)		7    input OTG ID
+	SPEC_GP  42,IN,HIGH,1		//BT_RXD
+	SPEC_GP  43,OUT,HIGH,2		//BT_TXD
+	SPEC_GP  44,OUT,HIGH,0		//BT_CTS, NC
+	SPEC_GP  45,OUT,LOW,0		//BT_RTS, NC
+	SPEC_GP  46,IN,HIGH,2		//ST_RXD
+	SPEC_GP  47,OUT,HIGH,1		//ST_TXD
+	SPEC_GP  48,OUT,HIGH,2		//MC_nPOE,NC
+	SPEC_GP  49,OUT,HIGH,2		//MC_nPWE
+	SPEC_GP  50,OUT,HIGH,2		//MC_nPIOR, NC
+	SPEC_GP  51,OUT,HIGH,2		//MC_nPIOW, NC
+	SPEC_GP  52,OUT,HIGH,2		//MC_nPCE1, NC
+	SPEC_GP  53,OUT,HIGH,2		//MC_nPCE2, NC
+	SPEC_GP  54,OUT,HIGH,2		//MC_nPSKTSEL, nc
+	SPEC_GP  55,OUT,HIGH,2		//MC_nPREG,   NC
+	SPEC_GP  56,IN,HIGH,1		//MC_nPWAIT  NC
+	SPEC_GP  57,IN,HIGH,1		//MC_nIOIS16, NC
+	SPEC_GP  58,OUT,HIGH,ALT_LCD	//LCD_LDD0
+	SPEC_GP  59,OUT,HIGH,ALT_LCD	//LCD_LDD1
+	SPEC_GP  60,OUT,HIGH,ALT_LCD	//LCD_LDD2
+	SPEC_GP  61,OUT,HIGH,ALT_LCD	//LCD_LDD3
+	SPEC_GP  62,OUT,HIGH,ALT_LCD	//LCD_LDD4
+	SPEC_GP  63,OUT,HIGH,ALT_LCD	//LCD_LDD5
+
+
+////////////////////////////////////////////////////////////////////////////////////////////
+
+
+	SPEC_GP  64,OUT,HIGH,ALT_LCD	//LCD_LDD6
+	SPEC_GP  65,OUT,HIGH,ALT_LCD	//LCD_LDD7
+	SPEC_GP  66,OUT,HIGH,ALT_LCD	//LCD_LDD8
+	SPEC_GP  67,OUT,HIGH,ALT_LCD	//LCD_LDD9
+	SPEC_GP  68,OUT,HIGH,ALT_LCD	//LCD_LDD10
+	SPEC_GP  69,OUT,HIGH,ALT_LCD	//LCD_LDD11
+	SPEC_GP  70,OUT,HIGH,ALT_LCD	//LCD_LDD12
+
+	SPEC_GP  71,OUT,HIGH,ALT_LCD	//LCD_LDD13
+
+	SPEC_GP  72,OUT,HIGH,ALT_LCD	//LCD_LDD14
+	SPEC_GP  73,OUT,HIGH,ALT_LCD	//LCD_LDD15
+	SPEC_GP  74,OUT,HIGH,ALT_LCD	//LCD_FCLK, NC
+	SPEC_GP  75,OUT,HIGH,ALT_LCD	//LCD_LCLK
+	SPEC_GP  76,OUT,HIGH,ALT_LCD	//LCD_PCLK
+	SPEC_GP  77,OUT,HIGH,ALT_LCD	//LCD_ACBIAS
+	SPEC_GP  78,OUT,HIGH,2		//nCS2, SMC91c111 Chip Select nDATACS
+	SPEC_GP  79,OUT,HIGH,2		//nCS3, NC
+	SPEC_GP  80,OUT,HIGH,2		//nCS4, SMC91c111 Chip Select
+	SPEC_GP  81,OUT,HIGH,0		//NC
+	SPEC_GP  82,OUT,HIGH,0		//NC
+	SPEC_GP  83,OUT,HIGH,0		//NC
+	SPEC_GP  84,OUT,HIGH,0		//NC
+	SPEC_GP  85,OUT,HIGH,0		//NC
+	SPEC_GP  86,OUT,HIGH,ALT_LCD	//LDD16
+	SPEC_GP  87,OUT,HIGH,ALT_LCD	//LDD17
+#if (PLATFORM_REV==1)
+	SPEC_GP  88,OUT,HIGH,0		//NC
+	SPEC_GP  89,OUT,HIGH,0		//NC
+#else
+	SPEC_GP  88,IN,HIGH,1		//port 1 usb power over current
+	SPEC_GP  89,OUT,HIGH,0		//port 1 usb power enable (driver needs to enable usb power (LOW,2)
+#endif
+
+	SPEC_GP  90,OUT,HIGH,0		//NC
+	SPEC_GP  91,OUT,HIGH,0		//NC
+	SPEC_GP  92,OUT,HIGH,1		//MMDAT
+	SPEC_GP  93,OUT,HIGH,0		//NC
+	SPEC_GP  94,OUT,HIGH,0		//NC
+	SPEC_GP  95,OUT,HIGH,0		//NC
+	SPEC_GP  96,OUT,HIGH,0		//NC
+	SPEC_GP  97,OUT,HIGH,0		//NC
+	SPEC_GP  98,OUT,HIGH,0		//NC
+	SPEC_GP  99,OUT,HIGH,0		//NC
+	SPEC_GP  100,OUT,HIGH,0		//NC
+	SPEC_GP  101,OUT,HIGH,0		//NC
+	SPEC_GP  102,OUT,HIGH,0		//NC
+	SPEC_GP  103,OUT,HIGH,0		//port 1,USB Power Enable for REV 1 board (driver needs to enable usb power (LOW,0)
+	SPEC_GP  104,OUT,HIGH,0		//NC
+
+#if (PLATFORM_REV==1)
+	SPEC_GP  105,IN,HIGH,0		//USB Overcurrent
+#else
+	SPEC_GP	 105,OUT,HIGH,0		//NC
+#endif
+
+	SPEC_GP  106,OUT,HIGH,0		//NC
+	SPEC_GP  107,OUT,HIGH,0		//NC
+	SPEC_GP  108,OUT,HIGH,0		//NC
+	SPEC_GP  109,OUT,HIGH,1		//MMDAT 1
+	SPEC_GP  110,OUT,HIGH,1		//MMDAT 2
+	SPEC_GP  111,OUT,HIGH,1		//MMDAT 3
+	SPEC_GP  112,OUT,HIGH,1		//MMCMD
+	SPEC_GP  113,OUT,HIGH,2		//AC97 Reset, NC
+	SPEC_GP  114,OUT,HIGH,0		//NC
+	SPEC_GP  115,OUT,HIGH,0		//NC
+	SPEC_GP  116,OUT,HIGH,0		//NC
+	SPEC_GP  117,OUT,HIGH,1		//SCL (I2C)
+	SPEC_GP  118,OUT,HIGH,1		//SDA (I2C)
+	SPEC_GP  119,OUT,HIGH,0		//NC
+	SPEC_GP  120,OUT,HIGH,0		//NC
+	SPEC_GP  121,IN,LOW,0		//undefined
+	SPEC_GP  122,IN,LOW,0		//undefined
+	SPEC_GP  123,IN,LOW,0		//undefined
+	SPEC_GP  124,IN,LOW,0		//undefined
+	SPEC_GP  125,IN,LOW,0		//undefined
+	SPEC_GP  126,IN,LOW,0		//undefined
+	SPEC_GP  127,IN,LOW,0		//undefined
+
+// ****************************************************************************
+	CREATE_MASK_DIR		DRVAL0, SPEC_, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+	CREATE_MASK_LEVEL	SRVAL0, SPEC_, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+	CREATE_MASK_ALT		AFVAL0, SPEC_, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
+	CREATE_MASK_ALT		AFVAL16,SPEC_,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+
+	CREATE_MASK_DIR		DRVAL32,SPEC_,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63
+	CREATE_MASK_LEVEL	SRVAL32,SPEC_,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63
+	CREATE_MASK_ALT		AFVAL32,SPEC_,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47
+	CREATE_MASK_ALT		AFVAL48,SPEC_,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63
+
+	CREATE_MASK_DIR		DRVAL64,SPEC_,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95
+	CREATE_MASK_LEVEL	SRVAL64,SPEC_,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95
+	CREATE_MASK_ALT		AFVAL64,SPEC_,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79
+	CREATE_MASK_ALT		AFVAL80,SPEC_,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95
+
+	CREATE_MASK_DIR		DRVAL96,SPEC_,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
+	CREATE_MASK_LEVEL	SRVAL96,SPEC_,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
+	CREATE_MASK_ALT		AFVAL96,SPEC_,  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111
+	CREATE_MASK_ALT		AFVAL112,SPEC_,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
+
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaGpio.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaGpio.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaGpio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaGpio.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,142 @@
+#include "platformTypes.h"
+
+#define IN 0
+#define OUT 1
+
+#define LOW 0
+#define HIGH 1
+
+	.ifdef __ARMASM
+.macro	SPEC_GP gp_,dir,level,alt
+SPEC_\gp_	EQU	\dir+(\level<<8)+(\alt<<16)
+.endm
+	.else
+.macro	SPEC_GP gp_,dir,level,alt
+	.set	SPEC_\gp_,\dir+(\level<<8)+(\alt<<16)
+.endm
+	.endif
+// *****************************************************************************************
+.macro	CREATE_MASK_DIR name,prefix,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31
+	.ifdef __ARMASM
+	LCLA	mask
+	.endif
+	.set	mask,((\prefix\p0&1)<<(\p0&0x1f))
+	.set	mask,mask | ((\prefix\p1&1)<<(\p1&0x1f))
+	.set	mask,mask | ((\prefix\p2&1)<<(\p2&0x1f))
+	.set	mask,mask | ((\prefix\p3&1)<<(\p3&0x1f))
+	.set	mask,mask | ((\prefix\p4&1)<<(\p4&0x1f))
+	.set	mask,mask | ((\prefix\p5&1)<<(\p5&0x1f))
+	.set	mask,mask | ((\prefix\p6&1)<<(\p6&0x1f))
+	.set	mask,mask | ((\prefix\p7&1)<<(\p7&0x1f))
+	.set	mask,mask | ((\prefix\p8&1)<<(\p8&0x1f))
+	.set	mask,mask | ((\prefix\p9&1)<<(\p9&0x1f))
+	.set	mask,mask | ((\prefix\p10&1)<<(\p10&0x1f))
+	.set	mask,mask | ((\prefix\p11&1)<<(\p11&0x1f))
+	.set	mask,mask | ((\prefix\p12&1)<<(\p12&0x1f))
+	.set	mask,mask | ((\prefix\p13&1)<<(\p13&0x1f))
+	.set	mask,mask | ((\prefix\p14&1)<<(\p14&0x1f))
+	.set	mask,mask | ((\prefix\p15&1)<<(\p15&0x1f))
+	.set	mask,mask | ((\prefix\p16&1)<<(\p16&0x1f))
+	.set	mask,mask | ((\prefix\p17&1)<<(\p17&0x1f))
+	.set	mask,mask | ((\prefix\p18&1)<<(\p18&0x1f))
+	.set	mask,mask | ((\prefix\p19&1)<<(\p19&0x1f))
+	.set	mask,mask | ((\prefix\p20&1)<<(\p20&0x1f))
+	.set	mask,mask | ((\prefix\p21&1)<<(\p21&0x1f))
+	.set	mask,mask | ((\prefix\p22&1)<<(\p22&0x1f))
+	.set	mask,mask | ((\prefix\p23&1)<<(\p23&0x1f))
+	.set	mask,mask | ((\prefix\p24&1)<<(\p24&0x1f))
+	.set	mask,mask | ((\prefix\p25&1)<<(\p25&0x1f))
+	.set	mask,mask | ((\prefix\p26&1)<<(\p26&0x1f))
+	.set	mask,mask | ((\prefix\p27&1)<<(\p27&0x1f))
+	.set	mask,mask | ((\prefix\p28&1)<<(\p28&0x1f))
+	.set	mask,mask | ((\prefix\p29&1)<<(\p29&0x1f))
+	.set	mask,mask | ((\prefix\p30&1)<<(\p30&0x1f))
+	.set	mask,mask | ((\prefix\p31&1)<<(\p31&0x1f))
+	.ifdef __ARMASM
+\name	EQU mask
+	.else
+	.set	\name,mask
+	.endif
+.endm
+
+.macro	CREATE_MASK_LEVEL name,prefix,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31
+	.ifdef __ARMASM
+	LCLA	mask
+	.endif
+	.set	mask,(((\prefix\p0>>8)&1)<<(\p0&0x1f))
+	.set	mask,mask | (((\prefix\p1>>8)&1)<<(\p1&0x1f))
+	.set	mask,mask | (((\prefix\p2>>8)&1)<<(\p2&0x1f))
+	.set	mask,mask | (((\prefix\p3>>8)&1)<<(\p3&0x1f))
+	.set	mask,mask | (((\prefix\p4>>8)&1)<<(\p4&0x1f))
+	.set	mask,mask | (((\prefix\p5>>8)&1)<<(\p5&0x1f))
+	.set	mask,mask | (((\prefix\p6>>8)&1)<<(\p6&0x1f))
+	.set	mask,mask | (((\prefix\p7>>8)&1)<<(\p7&0x1f))
+	.set	mask,mask | (((\prefix\p8>>8)&1)<<(\p8&0x1f))
+	.set	mask,mask | (((\prefix\p9>>8)&1)<<(\p9&0x1f))
+	.set	mask,mask | (((\prefix\p10>>8)&1)<<(\p10&0x1f))
+	.set	mask,mask | (((\prefix\p11>>8)&1)<<(\p11&0x1f))
+	.set	mask,mask | (((\prefix\p12>>8)&1)<<(\p12&0x1f))
+	.set	mask,mask | (((\prefix\p13>>8)&1)<<(\p13&0x1f))
+	.set	mask,mask | (((\prefix\p14>>8)&1)<<(\p14&0x1f))
+	.set	mask,mask | (((\prefix\p15>>8)&1)<<(\p15&0x1f))
+	.set	mask,mask | (((\prefix\p16>>8)&1)<<(\p16&0x1f))
+	.set	mask,mask | (((\prefix\p17>>8)&1)<<(\p17&0x1f))
+	.set	mask,mask | (((\prefix\p18>>8)&1)<<(\p18&0x1f))
+	.set	mask,mask | (((\prefix\p19>>8)&1)<<(\p19&0x1f))
+	.set	mask,mask | (((\prefix\p20>>8)&1)<<(\p20&0x1f))
+	.set	mask,mask | (((\prefix\p21>>8)&1)<<(\p21&0x1f))
+	.set	mask,mask | (((\prefix\p22>>8)&1)<<(\p22&0x1f))
+	.set	mask,mask | (((\prefix\p23>>8)&1)<<(\p23&0x1f))
+	.set	mask,mask | (((\prefix\p24>>8)&1)<<(\p24&0x1f))
+	.set	mask,mask | (((\prefix\p25>>8)&1)<<(\p25&0x1f))
+	.set	mask,mask | (((\prefix\p26>>8)&1)<<(\p26&0x1f))
+	.set	mask,mask | (((\prefix\p27>>8)&1)<<(\p27&0x1f))
+	.set	mask,mask | (((\prefix\p28>>8)&1)<<(\p28&0x1f))
+	.set	mask,mask | (((\prefix\p29>>8)&1)<<(\p29&0x1f))
+	.set	mask,mask | (((\prefix\p30>>8)&1)<<(\p30&0x1f))
+	.set	mask,mask | (((\prefix\p31>>8)&1)<<(\p31&0x1f))
+	.ifdef __ARMASM
+\name	EQU mask
+	.else
+	.set	\name,mask
+	.endif
+.endm
+
+.macro	CREATE_MASK_ALT name,prefix,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15
+	.ifdef __ARMASM
+	LCLA	mask
+	.endif
+	.set	mask,(((\prefix\p0>>16)&3)<<((\p0&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p1>>16)&3)<<((\p1&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p2>>16)&3)<<((\p2&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p3>>16)&3)<<((\p3&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p4>>16)&3)<<((\p4&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p5>>16)&3)<<((\p5&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p6>>16)&3)<<((\p6&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p7>>16)&3)<<((\p7&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p8>>16)&3)<<((\p8&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p9>>16)&3)<<((\p9&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p10>>16)&3)<<((\p10&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p11>>16)&3)<<((\p11&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p12>>16)&3)<<((\p12&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p13>>16)&3)<<((\p13&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p14>>16)&3)<<((\p14&0x0f)<<1))
+	.set	mask,mask | (((\prefix\p15>>16)&3)<<((\p15&0x0f)<<1))
+	.ifdef __ARMASM
+\name	EQU mask
+	.else
+	.set	\name,mask
+	.endif
+.endm
+
+#if (PLATFORM_TYPE==NEON)||(PLATFORM_TYPE==NEONB)||(PLATFORM_TYPE==BD2003)||(PLATFORM_TYPE==BOUNDARY_OLD_BOARD)
+#define ALT_LCD 2
+#include "pxaGpio25x.h"
+#else
+#if (PLATFORM_TYPE==HALOGEN)
+#define ALT_LCD 2
+#include "pxaGpio27x.h"
+#else
+#include "pxaGpioGame.h"
+#endif
+#endif
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaHardware.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaHardware.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaHardware.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaHardware.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,288 @@
+//#define GPIO_BASE 0x40E00000
+#define GPLR0	0x00	//level
+#define GPLR1	0x04
+#define GPLR2	0x08
+#define GPLR3	0x100	//level
+
+#define GPDR0	0x0c	//direction
+#define GPDR1	0x10
+#define GPDR2	0x14
+#define GPDR3	0x10c	//direction
+
+#define GPSR0	0x18	//set
+#define GPSR1	0x1C
+#define GPSR2	0x20
+#define GPSR3	0x118	//set
+
+#define GPCR0	0x24	//clear
+#define GPCR1	0x28
+#define GPCR2	0x2c
+#define GPCR3	0x124	//clear
+
+#define GRER0	0x30	//enable rising edge detect
+#define GRER1	0x34
+#define GRER2	0x38
+#define GRER3	0x130	//enable rising edge detect
+
+#define GFER0	0x3C	//enable falling edge detect
+#define GFER1	0x40
+#define GFER2	0x44
+#define GFER3	0x13C	//enable falling edge detect
+
+#define GEDR0	0x48	//edge detect status
+#define GEDR1	0x4C
+#define GEDR2	0x50
+#define GEDR3	0x148	//edge detect status
+
+#define GAFR0_L	0x54	//alternate function
+#define GAFR0_U	0x58
+#define GAFR1_L	0x5C
+#define GAFR1_U	0x60
+#define GAFR2_L	0x64
+#define GAFR2_U	0x68
+#define GAFR3_L	0x6c
+#define GAFR3_U	0x70
+
+
+#define UART_RBR		0		//read, DLAB-0	:RECEIVE_BUFFER
+#define UART_THR		0		//write, DLAB-0	:TRANSMIT_BUFFER
+#define UART_DLL		0		//r/w, DLAB-1	:DIVISOR_LOW
+#define UART_IER		4		//r/w, DLAB-0	:INTERRUPT_ENABLE
+#define UART_DLH		4		//r/w, DLAB-1	:DIVISOR_HIGH
+
+#define UART_IIR		8		//read		:INTERRUPT_INDENTIFICATION
+#define UART_FCR		8		//write		:FIFO_CONTROL
+#define UART_LCR		0x0c		//r/w		:LINE_CONTROL
+#define UART_MCR		0x10		//r/w		:MODEM_CONTROL
+#define UART_LSR		0x14		//read		:LINE_STATUS
+#define UART_MSR		0x18		//read		:MODEM_STATUS
+#define UART_SPR		0x1c		//r/w		:SCRATCH_PAD
+#define UART_ISR		0x20		//r/w		:INFRARED
+
+//#define IC_BASE 0x40D00000
+#define ICIP	0x00	//IRQ pending status
+#define ICMR	0x04	//interrupt controller mask
+#define ICLR	0x08	//level, 0 - irq, 1 -fiq
+#define ICFP	0x0C	//FIQ pending status
+#define ICPR	0x10	//all interrupts pending, no mask
+#define ICCR	0x14	//0 - ignore ICMR in idle mode, 1 - only unmasked interrupts will awaken processor
+
+
+#define __SKIP 8
+#define ICL1_GPIO0		(8 - __SKIP)
+#define ICL1_GPIO1		(9 - __SKIP)
+#define ICL1_GPIO2_80		(10 - __SKIP)
+#define ICL1_USB		(11 - __SKIP)
+#define ICL1_PMU		(12 - __SKIP)
+#define ICL1_I2S		(13 - __SKIP)
+#define ICL1_AC97		(14 - __SKIP)
+#define ICL1_LCD		(17 - __SKIP)
+#define ICL1_I2C		(18 - __SKIP)
+#define ICL1_ICP		(19 - __SKIP)
+#define ICL1_STUART		(20 - __SKIP)
+#define ICL1_BTUART		(21 - __SKIP)
+#define ICL1_FFUART		(22 - __SKIP)
+#define ICL1_MMC		(23 - __SKIP)
+#define ICL1_SSP		(24 - __SKIP)
+#define ICL1_DMA		(25 - __SKIP)
+#define ICL1_OS_TIMER0		(26 - __SKIP)
+#define ICL1_OS_TIMER1		(27 - __SKIP)
+#define ICL1_OS_TIMER2		(28 - __SKIP)
+#define ICL1_OS_TIMER3		(29 - __SKIP)
+#define ICL1_RTC_TICK		(30 - __SKIP)
+#define ICL1_RTC_ALARM_MATCH	(31 - __SKIP)
+
+//#define OS_TIMER_BASE 0x40a00000
+#define OSMR0	0x00
+#define OSMR1	0x04
+#define OSMR2	0x08
+#define OSMR3	0x0c
+#define OSCR	0x10		//OS timer Count register, increments at 3.6864 Mhz
+#define OSSR	0x14		//OS timer Status Register
+#define OWER	0x18		//OS timer Watchdog Match enable register
+#define OIER	0x1c
+
+//3686400 ticks/seconds = 3.6864 ticks/usec = 1 tick/.271267361111 usec
+#define TICK_PER_USEC_WHOLE 3
+#define TICK_PER_USEC_FRAC 0xAFB7E910
+//////////////////////////////////////////////////////////////////////////////////////////
+
+//#define PWR_MANAGER_BASE 0x40F00000
+#define PMCR  0
+#define PSSR  4
+#define PSPR  8
+#define PWER  0x0c
+#define PRER  0x10
+#define PFER  0x14
+#define PEDR  0x18
+#define PCFR  0x1c
+#define PGSR0 0x20
+#define PGSR1 0x24
+#define PGSR2 0x28
+#define RCSR  0x30
+
+#define PSSR_MASK 0x37
+#define RCSR_MASK 0x0f
+#define RCSR_SLEEP_RESET 4
+
+//#define CLK_MANAGER_BASE 0x41300000
+#define CCCR 0
+#define CKEN 4
+#define OSCC 8
+
+//#define MEMORY_CONTROL_BASE 0x48000000
+#define MDCNFG		0
+#define MDREFR		4
+#define MSC0		8
+#define MSC1		0x0c
+#define MSC2		0x10
+#define MECR		0x14
+#define SXCNFG		0x1c
+#define SXMRS		0x24
+#define MCMEM0		0x28
+#define MCMEM1		0x2c
+#define MCATT0		0x30
+#define MCATT1		0x34
+#define MCIO0		0x38
+#define MCIO1		0x3c
+#define MDMRS		0x40
+#define BOOT_DEF	0x44
+
+
+//#define LCD_CONTROL_BASE 0x44000000
+#define LCD_CR0		0		//master enable last
+#define LCD_CR1		4
+#define LCD_CR2		8
+#define LCD_CR3 	0x0c
+#define LCD_FBR0	0x20			//Frame branch register
+#define LCD_FBR1	0x24			//Frame branch register
+#define LCD_SR		0x38
+#define LCD_INT_ID	0x3c
+#define LCD_TMEDS	0x40			//TMED RGB seed
+#define LCD_TMEDC	0x44			//TMED control
+#define LCD_FDADR0	0x200		//frame descriptor address register
+#define LCD_FDADR1	0x210		//frame descriptor address register
+
+#define LCD_FSADR0	0x204		//frame source address register
+#define LCD_FSADR1	0x214		//frame source address register
+
+#define LCD_FIDR0	0x208		//frame ID register
+#define LCD_FIDR1	0x218		//frame ID register
+
+#define LCD_DCMD0	0x20c		//dma command
+#define LCD_DCMD1	0x21c		//dma command
+
+#define CRO_LDDALT	26	//LDDALT	;0 selects RGB 555, 1 selects RGB 565
+#define CRO_OUC		25	//OUC		;0 underlays, 1 overlays
+#define CR0_CMDIM	24	//CMDIM		;command interrupt mask, 0 - enabled, 1 disabled
+#define CR0_RDSTM	23	//RDSTM		;read status interrupt mask, 0 - enabled, 1 disabled
+#define CR0_LCDT	22	//LCDT		;LCD Panel Type, 1 - internal frame buffer
+#define CR0_IM_OUTPUT_FIFO_UNDERRUN		21	//OUM IM stands for Interrupt Mask
+#define CR0_IM_BRANCH					20	//BSM0
+#define CR0_PALETTE_DMA_REQUEST_DELAY	12	//PDD  8 bit field, 0-255
+#define CR0_IM_LCD_QUICK_DISABLE		11	//QDM
+#define CR0_DISABLE						10	//DIS
+#define CR0_DOUBLE_PIXEL_DATA			9	//DPD
+#define CR0_ACTIVE_SELECT				7	//PAS
+#define CR0_IM_END_OF_FRAME				6	//EOFM0
+#define CR0_IM_INPUT_FIFO_UNDERRUN		5	//IUM
+#define CR0_IM_START_OF_FRAME			4	//SOFM0
+#define CR0_IM_DISABLE_DONE				3	//LDM
+#define CR0_DUAL_PANEL_SELECT			2	//SDS
+#define CR0_MONOCHROME_SELECT			1	//CMS
+#define CR0_ENABLE						0	//ENB
+
+
+
+
+#define CR1_BEGINNING_OF_LINE_WAIT		24	//8 bit field +1
+#define CR1_END_OF_LINE_WAIT			16	//8 bit field +1
+#define CR1_HORIZONTAL_SYNC_PULSE_WIDTH		10	//6 bit field +1
+#define CR1_PIXELS_PER_LINE			0	//10 bit field +1
+
+
+
+#define CR2_BEGINNING_OF_FRAME_WAIT		24	//8 bit field
+#define CR2_END_OF_FRAME_WAIT			16	//8 bit field
+#define CR2_VERTICAL_SYNC_PULSE_WIDTH		10	//6 bit field +1
+#define CR2_LINES_PER_PANEL			0	//10 bit field +1
+
+
+#define CR3_PDFOR 					30
+#define CR3_DOUBLE_PCLK				27
+#define CR3_BITS_PER_PIXEL			24	//3 bit field
+//0 - 1 bit
+//1 - 2 bits
+//2 - 4 bits
+//3 - 8 bits
+//4 - 16 bits,
+//5-7 reserved
+#define CR3_BIAS_POLARITY			23
+#define CR3_PCLK_POLARITY			22
+#define CR3_LCLK_POLARITY			21
+#define CR3_FCLK_POLARITY			20
+#define CR3_API					16	//4 bits field, ac bias transitions per interrupt, 0 disable
+#define CR3_ACBIAS_TOGGLE			8	//8 bit field +1
+#define CR3_PCLK_DIVISOR			0	//8 bit field +1
+
+
+
+#define FBR_BRANCH_INT	1
+#define FBR_BRANCH	0
+
+
+#define SR_MISSED_INT		10
+#define SR_BRANCH_INT		9
+#define SR_END_OF_FRAME_INT	8
+#define SR_QUICK_DISABLE_INT	7
+#define SR_OUTPUT_FIFO_UNDERRUN	6
+#define SR_INPUT_FIFO_UNDERRUN0 5
+#define SR_INPUT_FIFO_UNDERRUN1 4
+#define SR_ACBIAS_COUNT_INT	3
+#define SR_BUS_ERROR		2
+#define SR_START_OF_FRAME	1
+#define SR_DISABLE_DONE		0
+
+#define TMEDS_BLUE		16	//8 bit field
+#define TMEDS_GREEN		8	//8 bit field
+#define TMEDS_RED		0	//8 bit field
+
+
+#define TMEDC_MATRIX2_SELECT			14
+#define TMEDC_RESERVED				12		//2 bit field
+#define TMEDC_HORIZONTAL_BEAT_SUPPRESSION	8		//4 bit field
+#define TMEDC_VERTICAL_BEAT_SUPPRESSION		4		//4 bit field
+#define TMEDC_FRAME_NUMBER_ADJUST_EN		3
+#define TMEDC_COLOR_OFFSET_ADJUST_EN		2
+#define TMEDC_FRAME_NUMBER_ADJUST_MATRIX2	1
+#define TMEDC_COLOR_OFFSET_ADJUST_MATRIX2	0
+
+
+#define DCMD_PALETTE			26
+#define DCMD_START_OF_FRAME_INTERRUPT	22
+#define DCMD_END_OF_FRAME_INTERRUPT	21
+#define DCMD_LENGTH			0		//21 bit field
+
+
+#define FDESC_FDADR	0
+#define FDESC_FSADR	4
+#define FDESC_FIDR	8
+#define FDESC_DCMD	0x0c
+
+#define PSR_MODE_MASK   0x1f
+#define PSR_MODE_USER   0x10
+#define PSR_MODE_FIQ    0x11
+#define PSR_MODE_IRQ    0x12
+#define PSR_MODE_SVC    0x13
+#define PSR_MODE_DEBUG  0x15
+#define PSR_MODE_ABORT  0x17
+#define PSR_MODE_UNDEF  0x1b
+#define PSR_MODE_SYSTEM 0x1f
+#define PSR_NOINTS_MASK 0xc0
+
+#define FUNC_REQ_GL 0
+#define FUNC_REQ_DLW 1
+#define FUNC_REQ_GAME 2 //not specifically referenced
+#define FUNC_REQ_MAC 3
+#define FUNC_REQ_WAKEUP 4
+#define FUNC_REQ_PIC 5
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaLcd2.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaLcd2.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaLcd2.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaLcd2.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,78 @@
+#include "pxaLcd.h"
+#define DA320X240 0
+#define DA640X240 1
+#define DA800X480 2
+#define DA640X480 3
+#define DA240X320 4
+#define DA800X600 5
+#define DA1024X768 6
+#define DP480X320 7
+#define DP320X240 8
+#define DL122X32  9
+#define UNKNOWN   0xcc
+
+#ifdef __ARMASM
+	GBLS DEF_P
+#endif
+
+#if DISPLAY_TYPE==DA320X240			//5.7 inch display
+#define DEF_P DA320X240_P
+#define DEF_DISPLAY_INDEX 0
+#else
+#if DISPLAY_TYPE==DA640X240		//6.2 inch display
+#define DEF_P DA640X240_P
+#define DEF_DISPLAY_INDEX 1
+#else
+#if DISPLAY_TYPE==DA800X480		//7 or 9 inch display
+#define DEF_P DA800X480_P
+#define DEF_DISPLAY_INDEX 2
+#else
+#if DISPLAY_TYPE==DA640X480		//10.4 inch display
+#define DEF_P DA640X480_P
+#define DEF_DISPLAY_INDEX 3
+#else
+#if DISPLAY_TYPE==DA240X320		//3.5 inch display
+#define DEF_P DA240X320_P
+#define DEF_DISPLAY_INDEX 4
+#else
+#if DISPLAY_TYPE==DA800X600
+#define DEF_P DA800X600_P
+#define DEF_DISPLAY_INDEX 5
+#else
+#if DISPLAY_TYPE==DA1024X768
+#define DEF_P DA1024X768_P
+#define DEF_DISPLAY_INDEX 6
+#else
+#if DISPLAY_TYPE==DP480X320		//5.7 inch display
+#define DEF_P DP480X320_P
+#define DEF_DISPLAY_INDEX 7
+#else
+#if DISPLAY_TYPE==DP320X240	//5.7 inch display
+#define DEF_P DP320X240_P
+#define DEF_DISPLAY_INDEX 8
+#else
+#if DISPLAY_TYPE==DL122X32
+#define DEF_P DL122X32_P
+#define DEF_DISPLAY_INDEX 9
+#else
+#if DISPLAY_TYPE==UNKNOWN
+#define DEF_P DA320X240_P
+#define DEF_DISPLAY_INDEX 0xcc
+
+#else
+#define DEF_P DA320X240_P
+#define DEF_DISPLAY_INDEX 0
+#warning "No display selected, defaulting to DA320X240"
+
+#endif		//0xcc
+#endif		//9
+#endif		//8
+#endif		//7
+#endif		//6
+#endif		//5
+#endif		//4
+#endif		//3
+#endif		//2
+#endif		//1
+#endif		//0
+
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaLcd.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaLcd.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaLcd.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaLcd.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,79 @@
+#include "platformTypes.h"
+#define WINCE	1
+#define LINUX	2
+#define GAME	3
+
+#define PXAFB_BPP 16
+
+#define LCD_PANEL 0
+#define CRT 1
+
+//pixel clock frequency = LCLK / (2*(PCD+1))
+#if (PLATFORM_TYPE==HALOGEN)
+#define __BPP 18
+#define BPP_FORMAT 6
+#define PDFOR 3
+#define BYTES_PER_PIXEL 3
+#else
+#define __BPP 16
+#define BPP_FORMAT 4
+#define PDFOR 0
+#define BYTES_PER_PIXEL 2
+#endif
+
+// ****************************************************************************
+// This is where different display settings reside
+//              xres,xsyncWidth,xbegin,xend,  yres,ysyncWidth,ybegin,yend,  enable,unscramble,rotate,active,bpp,clkdiv,type
+//#define DA320X240_P  320, 64, 34, 1,             240, 20, 8, 3,           1,0,0,1,PXAFB_BPP,4,LCD_PANEL //0
+#define DA320X240_P  320, 64, 34, 11,             240, 5, 8, 3,           1,0,0,1,PXAFB_BPP,4,LCD_PANEL //0
+
+#define DA640X240_P  640, 64, 34, 1,             240, 20, 8, 3,           1,1,0,1,PXAFB_BPP,2,LCD_PANEL //1
+#define DA800X480_P  800, 64, 34, 1,             480, 20, 8, 3,           1,1,0,1,PXAFB_BPP,2,LCD_PANEL //2
+#define DA640X480_P  640, 64, 34,105,            480, 20, 8,14,           1,1,0,1,PXAFB_BPP,2,LCD_PANEL //3
+#define DA240X320_P  240, 64, 34, 1,             320, 20, 8, 3,           1,0,1,1,PXAFB_BPP,5,LCD_PANEL //4
+#define DA800X600_P  800,0x9b,0x31,0x69,         600,0x04,0x01,0x17,      1,1,0,1,PXAFB_BPP,2,CRT       //5
+//#define DA1024X768_P 1024,0xc8,0x55,0xb4,        768,0x06,0x0b,0x1d,      1,1,0,1,PXAFB_BPP,2,CRT		//6
+//#define DA1024X768_P 1024,0xe4,0x3c,0x70,        768,0x0c,0x0b,0x20,      1,1,0,1,PXAFB_BPP,2,CRT		//6
+#define DA1024X768_P 1024,0xe4,0x3c,0x70,        768,0x0c,0x0b,0x20,      1,1,0,1,PXAFB_BPP,2,LCD_PANEL //6
+#define DP480X320_P  480, 64, 34, 1,             320,20,8,3,              1,0,0,0,PXAFB_BPP,3,LCD_PANEL //7
+#define DP320X240_P  320, 64, 34, 1,             240,20,8,3,              1,0,0,0,PXAFB_BPP,4,LCD_PANEL //8
+#define DL122X32_P   320, 64, 34, 1,             240,20,8,3,              0,0,0,0,PXAFB_BPP,4,0         //9
+
+// ********************************************************************************
+#if (PLATFORM_TYPE==BOUNDARY_OLD_BOARD)
+#define MOTHERBOARD_SCRAMBLED
+#endif
+
+//#define CONFIG_UNSCRAMBLE_LCD
+#ifdef CONFIG_UNSCRAMBLE_LCD
+#if 1  //FL_ACTIVE(DEF_P)					//passive cannot swap pin order
+#ifdef MOTHERBOARD_SCRAMBLED
+
+#ifndef DAUGHTERBOARD_UNSCRAMBLE
+#define LCD_REORDER_BLUE  15,14, 8, 7, 6
+#define LCD_REORDER_GREEN 13,12,11, 5, 4, 3
+#define LCD_REORDER_RED   10, 9, 2, 1, 0
+#endif
+
+#else
+//motherboard is NOT scrambled
+#ifdef DAUGHTERBOARD_UNSCRAMBLE
+#define LCD_REORDER_BLUE  15,14,13,10, 9
+#define LCD_REORDER_GREEN  8, 4, 3, 2, 12, 11
+#define LCD_REORDER_RED    7, 6, 5, 1, 0
+#endif
+#endif	//#ifdef MOTHERBOARD_SCRAMBLED
+#endif	//#if FL_ACTIVE(DEF_P)
+#endif	//#ifdef CONFIG_UNSCRAMBLE_LCD
+
+#ifndef LCD_REORDER_BLUE
+#if (BYTES_PER_PIXEL==2)
+#define LCD_REORDER_BLUE  0,1,2,3,4
+#define LCD_REORDER_GREEN 5,6,7,8,9,10
+#define LCD_REORDER_RED   11,12,13,14,15
+#else
+#define LCD_REORDER_BLUE  0,1,2,3,4,5
+#define LCD_REORDER_GREEN 6,7,8,9,10,11
+#define LCD_REORDER_RED   12,13,14,15,16,17
+#endif
+#endif
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaMacro2.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaMacro2.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaMacro2.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaMacro2.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,540 @@
+#include "pxaMacro.h"
+//  ************************************************************************************************
+//  ************************************************************************************************
+
+//In: c-0 try 64meg, c-1 try 32meg
+// or if 16 bit mode
+//    c-0 try 32meg, c-1 try 16meg
+//Out: z-0 if 16 bit mode
+.macro InitRam	rBase,rTemp
+	BigMov	\rBase,MEMORY_CONTROL_BASE
+	ldr	\rTemp,[\rBase,#BOOT_DEF]
+	tst	\rTemp,#1			//bit 0 - 1 means 16 bit mode
+	BigMov	\rTemp,M64_MDCNFG_VAL
+	BigEor2Cs \rTemp,(M64_MDCNFG_VAL)^(M32_MDCNFG_VAL)
+#if (!(PLATFORM_TYPE==NEONB)) && (!(PLATFORM_TYPE==HALOGEN))
+	BigOrr2Ne \rTemp,(1<<2)			//select 16 bit width
+#endif
+	str	\rTemp,[\rBase,#MDCNFG]
+
+	mov	\rTemp,#0
+	nop						//pxa270 may need this for some reason, depending upon instruction alignment
+	str	\rTemp,[\rBase,#MDMRS]
+
+
+	BigMov	\rTemp,M64_MDREFR_VAL
+	BigEor2Cs \rTemp,(M64_MDREFR_VAL)^(M32_MDREFR_VAL)
+	str	\rTemp,[\rBase,#MDREFR]
+.endm
+
+
+//In: z-1   -  c-0 try 64meg, c-1 try 32meg
+//    z-0   -  c-0 try 32meg, c-1 try 16meg
+//out: rTemp - memory size
+.macro CheckRam	rBase,rTemp,rTemp2
+	// Issue read requests to disabled bank to start refresh
+	BigMov	\rBase,MEM_START+0x0C000000
+	ldr	\rTemp, [\rBase]
+	mov	\rTemp,#M32_MEM_SIZE
+	movcc	\rTemp,#M64_MEM_SIZE
+#if (!(PLATFORM_TYPE==NEONB)) && (!(PLATFORM_TYPE==HALOGEN))
+	movne	\rTemp,\rTemp,LSR #1
+#endif
+	BigMov	\rBase,MEM_START
+#if 1
+	mov	\rTemp2,#0x24<<2	//0x24 seems to work, but keep it safe
+81:	sub	\rTemp2,\rTemp2,#1
+	str	\rTemp2,[\rBase]
+	movs	\rTemp2,\rTemp2	//don't affect carry flag
+	bne	81b
+#endif
+	str	\rTemp,[\rBase]
+	str	\rBase,[\rBase,\rTemp,LSR #1]
+	ldr	\rTemp2,[\rBase]
+	movcs	\rTemp2,\rTemp	//if 2nd time through, force match
+	cmp	\rTemp2,\rTemp
+#if 1
+	strne	\rTemp2,[\rBase,#4]
+//	teq	\rTemp2,\rTemp2
+#endif
+.endm
+
+#define tEHEL	0	//R14
+#define tAPA	3	//r15 25ns/10ns rounded up
+
+#define RDFSelect 13	//R2 : tAVQV : 110ns/10ns = 11; 11-1=10=RDF
+//#define RDFSelect 10	//R2 : tAVQV : 110ns/10ns = 11; 11-1=10=RDF
+			//0-11 map to 0-11
+			//12 -> 13, 13 ->15, 14->18, 15->23
+
+//#if (PLATFORM_TYPE==GAME_CONTROLLER_PLAITED_A1)
+#if (PLATFORM_TYPE==GAME_CONTROLLER_PLAITED_A1)||(PLATFORM_TYPE==GAME_CONTROLLER)||(PLATFORM_TYPE==GAME_WITH_SMC)
+#define BurstSelect 0	//if plaited bug, burst mode will no longer work.
+#else
+#define BurstSelect 2	//0->nonburst,1->SRAM,2->burst of4, 3->burst of 8, 4->variable latency i/o
+#endif
+
+
+#if (PLATFORM_TYPE==NEONB)
+//access time 70ns, 25ns after CS data becomes valid
+//							RRR					RDN					RDF					RBW			RTX
+//						  gap between	     Address to
+//				1-fast    chip selects	     data valid
+//				0-slow    recovery           2nd burst access     1st access delay   16-bit bus    non-burst(0), sram(1), 4cycle(2), 8cycle(3), VLIO(4)
+#define CS0_MSC (1<<15)+   (1<<12)+           (7<<8)+              ((7-1)<<4)+                       0
+#define CS1_MSC (1<<15)+(((tEHEL+1)>>1)<<12)+((tAPA-1)<<8)+     (RDFSelect<<4)+                 (BurstSelect)			//fast device
+#else
+#define CS0_MSC (1<<15)+(((tEHEL+1)>>1)<<12)+((tAPA-1)<<8)+     (RDFSelect<<4)+                 (BurstSelect)			//fast device
+#define CS1_MSC (1<<15)+   (3<<12)+            (2<<8)+             ((3-1)<<4)+        (1<<3) +       4		//SMC chip
+//#define CS1_MSC (1<<15)+   (6<<12)+           ((11-1)<<8)+        ((4-1)<<4)+        (1<<3) +       4		//SMC chip
+#endif
+
+.macro InitCS0_CS1	rBase,rTemp
+	BigMov	\rBase,MEMORY_CONTROL_BASE
+	ldr		\rTemp,[\rBase,#BOOT_DEF]
+	tst		\rTemp,#1			//bit 0 - 1 means 16 bit mode
+	BigMov	\rTemp,(CS0_MSC)|((CS1_MSC)<<16)
+///////	BigMov	\rTemp,0x7ff07ff0
+	orrne	\rTemp,\rTemp,#1<<3		//16 bit bus
+	str		\rTemp,[\rBase,#MSC0]
+.endm
+
+
+.macro InitMemory	rBase,rTemp,rTemp2
+	cmp	pc,#MEM_START
+	bcs	92f		//exit if running from ram
+#if 0	//1 to force smaller memory
+	subs	\rTemp,\rTemp,\rTemp	//set carry flag
+#endif
+
+1:
+	InitRam \rBase, \rTemp		//out: \rBase - MEMORY_CONTROL_BASE
+
+#if (PLATFORM_TYPE==BOUNDARY_OLD_BOARD)
+#define CHIP_MODE 0		//don't use VIO_READY
+#else
+#define CHIP_MODE 4		//gp18 is VIO_READY
+#endif
+
+//							RRR					RDN					RDF					RBW			RTX
+//						  gap between	     Address to
+//				1-fast    chip selects	     data valid
+//				0-slow    recovery           2nd burst access     1st access delay   16-bit bus    non-burst(0), sram(1), 4cycle(2), 8cycle(3), VLIO(4)
+#if 1
+#define CS2_MSC (1<<15)+   (4<<12)+           ((6-2)<<8)+         ((4-1)<<4)+        (1<<3) +       CHIP_MODE		//for USB dma
+//#define CS2_MSC (1<<15)+   (7<<12)+           ((16-1)<<8)+         ((16-1)<<4)+        (1<<3) +       CHIP_MODE		//for USB dma
+
+//											vlio min 2             vlio min 3
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==NEONB)
+#define CS3_MSC (1<<15)+   (1<<12)+            (2<<8)+            ((4-1)<<4)+        (0<<3) +       4		//SM501
+#define CS4_MSC (1<<15)+   (3<<12)+            (2<<8)+            ((4-1)<<4)+        (0<<3) +       4		//SMC chip
+#else
+#if (PLATFORM_TYPE==HALOGEN)
+#define CS3_MSC (1<<15)+   (1<<12)+            (2<<8)+            ((4-1)<<4)+        (0<<3) +       4		//NC
+#define CS4_MSC (1<<15)+   (3<<12)+            (2<<8)+            ((5-1)<<4)+        (0<<3) +       4		//SMC chip
+#else
+#define CS3_MSC (1<<15)+   (4<<12)+           ((6-2)<<8)+         ((4-1)<<4)+        (1<<3) +       CHIP_MODE		//for USB dma
+//#define CS3_MSC (1<<15)+   (7<<12)+           ((16-1)<<8)+        ((16-1)<<4)+        (1<<3) +       CHIP_MODE		//for USB dma
+#define CS4_MSC (1<<15)+   (6<<12)+           ((11-1)<<8)+        ((4-1)<<4)+        (1<<3) +       CHIP_MODE		//for USB IO
+#endif
+#endif
+
+#define CS5_MSC (0<<15)+   (7<<12)+           ((8-1)<<8)+         ((8-1)<<4)+       (1<<3) +       (0)			//for USB IO delay after CMD write
+#else
+#define CS2_MSC (1<<15)+   (7<<12)+           ((16-1)<<8)+        ((16-1)<<4)+       (1<<3) +       CHIP_MODE		//for USB dma
+#define CS3_MSC (1<<15)+   (7<<12)+           ((16-1)<<8)+        ((16-1)<<4)+       (1<<3) +       CHIP_MODE		//for USB dma
+#define CS4_MSC (1<<15)+   (7<<12)+           ((16-1)<<8)+        ((16-1)<<4)+       (1<<3) +       CHIP_MODE		//for USB IO
+#define CS5_MSC (0<<15)+   (7<<12)+           ((16-1)<<8)+        ((16-1)<<4)+       (1<<3) +       (0)			//for USB IO delay after CMD write
+#endif
+	BigMov	\rTemp,(CS2_MSC)|((CS3_MSC)<<16)
+	str	\rTemp,[\rBase,#MSC1]
+	BigMov	\rTemp,(CS4_MSC)|((CS5_MSC)<<16)
+	str	\rTemp,[\rBase,#MSC2]
+
+
+
+#define PCMCIA_MEM_SETUP_ADDRESS 5	//0-127
+#define PCMCIA_MEM_COMMAND_CODE	3	//0-31
+#define PCMCIA_MEM_HOLD_ADDRESS	2	//0-63
+	BigMov	\rTemp,(PCMCIA_MEM_HOLD_ADDRESS<<14)+(PCMCIA_MEM_COMMAND_CODE<<7)+(PCMCIA_MEM_SETUP_ADDRESS<<0)
+	str	\rTemp,[\rBase,#MCMEM0]
+	str	\rTemp,[\rBase,#MCMEM1]
+#define PCMCIA_ATT_SETUP_ADDRESS 5	//0-127
+#define PCMCIA_ATT_COMMAND_CODE	3	//0-31
+#define PCMCIA_ATT_HOLD_ADDRESS	2	//0-63
+	BigMov	\rTemp,(PCMCIA_ATT_HOLD_ADDRESS<<14)+(PCMCIA_ATT_COMMAND_CODE<<7)+(PCMCIA_ATT_SETUP_ADDRESS<<0)
+	str	\rTemp,[\rBase,#MCATT0]
+	str	\rTemp,[\rBase,#MCATT1]
+#define PCMCIA_IO_SETUP_ADDRESS	5	//0-127
+#define PCMCIA_IO_COMMAND_CODE	3	//0-31
+#define PCMCIA_IO_HOLD_ADDRESS	2	//0-63
+	BigMov	\rTemp,(PCMCIA_IO_HOLD_ADDRESS<<14)+(PCMCIA_IO_COMMAND_CODE<<7)+(PCMCIA_IO_SETUP_ADDRESS<<0)
+	str	\rTemp,[\rBase,#MCIO0]
+	str	\rTemp,[\rBase,#MCIO1]
+	mov	\rTemp,#2
+	str	\rTemp,[\rBase,#MECR]
+
+	CheckRam \rBase, \rTemp, \rTemp2
+	cmpne	\rTemp,#0x0		//set carry flag, keep z-0 (memory size!=0)
+	bne	1b
+92:
+.endm
+
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+#define CKEN_PWM0	0
+#define CKEN_PWM1	1
+#define CKEN_AC97	2
+#define CKEN_SSP	3
+#define CKEN_HWUART	4
+#define CKEN_STUART	5
+#define CKEN_FFUART	6
+#define CKEN_BTUART	7
+#define CKEN_I2S	8
+#define CKEN_USB	11
+#define CKEN_MMC	12
+#define CKEN_FICP	13
+#define CKEN_I2C	14
+#define CKEN_LCD	16
+
+#if (PLATFORM_TYPE==NEON) || (PLATFORM_TYPE==BD2003) || (PLATFORM_TYPE==BOUNDARY_OLD_BOARD) || (PLATFORM_TYPE==OLD_GAME_CONTROLLER) || (PLATFORM_TYPE==HALOGEN)
+#define __ENABLED_BTUART_MASK (1<<CKEN_BTUART)
+#define __ENABLED_STUART_MASK (1<<CKEN_STUART)
+#endif
+
+#if (PLATFORM_TYPE==BD2003) || (PLATFORM_TYPE==BOUNDARY_OLD_BOARD) || (PLATFORM_TYPE==OLD_GAME_CONTROLLER) || (PLATFORM_TYPE==HALOGEN)
+#define __ENABLED_LCD_MASK (1<<CKEN_LCD)
+#endif
+
+#ifndef __ENABLED_BTUART_MASK
+#define __ENABLED_BTUART_MASK 0
+#endif
+
+#ifndef __ENABLED_STUART_MASK
+#define __ENABLED_STUART_MASK 0
+#endif
+
+#ifndef __ENABLED_LCD_MASK
+#define __ENABLED_LCD_MASK 0
+#endif
+
+.macro InitIC_Clocks rBase,rTemp
+	BigMov	\rBase,IC_BASE
+	mov	\rTemp,#0
+	str	\rTemp,[\rBase,#ICMR]			//disable all interrupts
+
+	BigMov	\rBase,CLK_MANAGER_BASE
+#if (PLATFORM_TYPE==HALOGEN)
+#define CKEN_MEMORY_CONTROLLER 22
+#define CKEN_OS_TIMER 			9
+
+#define CCCR_L_BIT		0
+#define CCCR_2N_BIT		7
+#define CCCR_A_BIT		25
+
+#define CLKCFG_TURBO_BIT		0
+#define CLKCFG_FREQUENCY_CHANGE_BIT	1
+#define CLKCFG_HALF_TURBO_BIT	2
+#define CLKCFG_FAST_BUS_BIT		3
+
+#if (CPU_CLOCK==104)	//13*8 = 104MHz
+#define CCCR_2N	2
+#define CCCR_L	8
+#define CCCR_A 0
+#define CLKCFG_TURBO 0
+#define CLKCFG_FAST_BUS 0
+#else
+#if (CPU_CLOCK==208)	//13*16 = 208MHz
+#define CCCR_2N	2
+#define CCCR_L	16
+#define CCCR_A 0
+#define CLKCFG_TURBO 0
+#define CLKCFG_FAST_BUS 0
+#else
+#if (CPU_CLOCK==312)	//312MHz
+#define CCCR_2N	3
+#define CCCR_L	16
+#define CCCR_A 0
+#define CLKCFG_TURBO 1
+#define CLKCFG_FAST_BUS 0
+#else
+#if (CPU_CLOCK==416)	//416MHz
+#define CCCR_2N	4
+#define CCCR_L	16
+#define CCCR_A 0
+#define CLKCFG_TURBO 1
+#define CLKCFG_FAST_BUS 1
+#else
+#if (CPU_CLOCK==520)	//520MHz
+#define CCCR_2N	5
+#define CCCR_L	16
+#define CCCR_A 0
+#define CLKCFG_TURBO 1
+#define CLKCFG_FAST_BUS 1
+#else
+#if (CPU_CLOCK==624)	//624MHz
+#define CCCR_2N	6
+#define CCCR_L	16
+#define CCCR_A 0
+#define CLKCFG_TURBO 1
+#define CLKCFG_FAST_BUS 1
+
+#else
+#warning CPU_CLOCK selection not made
+#endif
+#endif
+#endif
+#endif
+#endif
+#endif
+	BigMov	\rTemp,(CCCR_L<<CCCR_L_BIT)+(CCCR_2N<<CCCR_2N_BIT)+(CCCR_A<<CCCR_A_BIT)
+	str	\rTemp,[\rBase,#CCCR]
+
+	BigMov	\rTemp,(1<<CKEN_OS_TIMER)+(1<<CKEN_MEMORY_CONTROLLER)+(1<<CKEN_FFUART)+__ENABLED_BTUART_MASK+__ENABLED_STUART_MASK+__ENABLED_LCD_MASK
+	str	\rTemp,[\rBase,#CKEN]
+
+#else
+#define tRP  20
+#define tRCD 20
+#define tRAS 45		//45 ns
+#define	tRC  65
+// CRYSTALns 10000000/ 36864	//271ns
+
+#define LSelect 1	//1 : *27 = 10.0469 ns memory clk time, 99.53 MHz
+			//	tRP_clk = tRCD_clk= 1.99066 -> 2 clks
+			//	tRAS_clk= 4.47899 -> 5 clks
+			//	tRC_clk= 6.46966 -> 7 clks
+			//2 : *32 = 8.47711 ns, 117.96 MHz
+			//	tRP_clk = tRCD_clk= 2.35929 -> 3 clks
+			//	tRAS_clk=5.30841 -> 6
+			//	tRC_clk =7.66771 -> 8 clks
+			//3 : *36 = 7.5352 ns, 132.71 MHz
+			//	tRP_clk = tRCD_clk=  2.65421 -> 3 clks
+			//	tRAS_clk=5.97197 -> 6
+			//	tRC_clk = 8.62618 -> 9 clks
+			//4 : *40 = 6.78168ns, 147.46 MHz
+			//	tRP_clk = tRCD_clk=  2.94912 -> 3 clks
+			//	tRAS_clk=6.63522 -> 7
+			//	tRC_clk = 9.58465 -> 10 clks
+			//5 : *45 = 6.02816ns, 165.89 MHz
+			//	tRP_clk = tRCD_clk=  3.31776 -> 4 clks
+			//	tRAS_clk=7.46496 -> 8
+			//	tRC_clk = 10.7827 -> 11 clks
+//MSelect
+//1 : *1
+//2 : *2
+
+//NSelect
+//2 : *1;
+//3 : *1.5;
+//4 : *2;
+//6 : *3
+
+#if (CPU_CLOCK==100)
+#define MSelect	1	//1 : *1	100MHz
+#define NSelect 4	//4 : *2;	turbo 200 MHZ
+#define FCS_MASK 2	//		turbo off
+#else
+#if (CPU_CLOCK==200)
+#define MSelect	2	//2 : *2	200 MHz
+#define NSelect 3	//3 : *1.5;	turbo 300 MHZ
+#define FCS_MASK 2	//		turbo off
+#else
+#if (CPU_CLOCK==300)
+#define MSelect	2	//2 : *2	200 MHz
+#define NSelect 3	//3 : *1.5;	turbo 300 MHZ
+#define FCS_MASK 3	//		turbo on
+#else
+#if (CPU_CLOCK==400)
+
+#if 0	//only pxa255 runs with 200Mhz internal bus, pxa250 doesn't
+#define MSelect	2	//2 : *2	200 MHz
+#define NSelect 4	//4 : *2;	turbo 400 MHZ
+#define FCS_MASK 3	//		turbo on
+#else
+#define MSelect	3	//2 : *4	400 MHz
+#define NSelect 2	//4 : *1;	turbo 400 MHZ
+#define FCS_MASK 2	//		turbo off
+#endif
+
+#else
+//////#WARNING CPU_CLOCK selection not made
+#endif
+#endif
+#endif
+#endif
+
+	BigMov	\rTemp,(NSelect<<7)+(MSelect<<5)+(LSelect)
+	str	\rTemp,[\rBase,#CCCR]
+
+	BigMov	\rTemp,(1<<CKEN_FFUART)+__ENABLED_BTUART_MASK+__ENABLED_STUART_MASK+__ENABLED_LCD_MASK
+	str	\rTemp,[\rBase,#CKEN]
+#endif	//not HALOGEN
+	mov \rTemp,#0					//disable 32.768khz oscillator
+//	mov	\rTemp,#2					//enable 32.768khz oscillator
+	str	\rTemp,[\rBase,#OSCC]
+.endm
+
+.macro	InitChangeCPUSpeed rTemp
+#if (PLATFORM_TYPE==HALOGEN)
+	mov	\rTemp,#(CLKCFG_FAST_BUS<<CLKCFG_FAST_BUS_BIT)+(CLKCFG_TURBO<<CLKCFG_TURBO_BIT)+(1<<CLKCFG_FREQUENCY_CHANGE_BIT)
+	CP14_CCLKCFG	mcr,\rTemp
+#else
+	mov	\rTemp,#FCS_MASK
+	CP14_CCLKCFG	mcr,\rTemp
+#endif
+.endm
+
+// *******************************************************************************************
+// *******************************************************************************************
+
+.macro InitUART rBase,rTemp,uartaddr,baudrate
+	BigMov	\rBase,\uartaddr
+
+	mov	\rTemp,#0x83			//DLAB, 8-bit characters
+	str	\rTemp,[\rBase,#UART_LCR]
+	mov	\rTemp,#(14745600/((\baudrate)<<4))&0xff
+	str	\rTemp,[\rBase,#UART_DLL]
+	mov	\rTemp,#((14745600/((\baudrate)<<4))>>8)
+	str	\rTemp,[\rBase,#UART_DLH]
+
+	mov	\rTemp,#3				//8-bit characters
+	str	\rTemp,[\rBase,#UART_LCR]
+
+	mov	\rTemp,#0xc1			//enable fifo, 32 byte level
+	str	\rTemp,[\rBase,#UART_FCR]
+
+	mov	\rTemp,#0x40			//UUE- UART unit enable
+	str	\rTemp,[\rBase,#UART_IER]
+.endm
+.macro InitGPIO rBase,rTemp
+	BigMov	\rBase,GPIO_BASE
+
+	BigMov	\rTemp,~SRVAL0
+	str	\rTemp,[\rBase,#GPCR0]
+	mvn	\rTemp,\rTemp
+	str	\rTemp,[\rBase,#GPSR0]
+
+	BigMov	\rTemp,~SRVAL32
+	str	\rTemp,[\rBase,#GPCR1]
+	mvn	\rTemp,\rTemp
+	str	\rTemp,[\rBase,#GPSR1]
+
+	BigMov	\rTemp,~SRVAL64
+	str	\rTemp,[\rBase,#GPCR2]
+	mvn	\rTemp,\rTemp
+	str	\rTemp,[\rBase,#GPSR2]
+#if (PLATFORM_TYPE==HALOGEN)
+	BigMov	\rTemp,~SRVAL96
+	str	\rTemp,[\rBase,#GPCR3]
+	mvn	\rTemp,\rTemp
+	str	\rTemp,[\rBase,#GPSR3]
+#endif
+////////
+	BigMov	\rTemp,DRVAL0
+	str	\rTemp,[\rBase,#GPDR0]
+
+	BigMov	\rTemp,DRVAL32
+	str	\rTemp,[\rBase,#GPDR1]
+
+	BigMov	\rTemp,DRVAL64
+	str	\rTemp,[\rBase,#GPDR2]
+#if (PLATFORM_TYPE==HALOGEN)
+	BigMov	\rTemp,DRVAL96
+	str	\rTemp,[\rBase,#GPDR3]
+#endif
+////////
+	BigMov	\rTemp,AFVAL0
+	str	\rTemp,[\rBase,#GAFR0_L]
+	BigMov	\rTemp,AFVAL16
+	str	\rTemp,[\rBase,#GAFR0_U]
+
+	BigMov	\rTemp,AFVAL32
+	str	\rTemp,[\rBase,#GAFR1_L]
+	BigMov	\rTemp,AFVAL48
+	str	\rTemp,[\rBase,#GAFR1_U]
+
+	BigMov	\rTemp,AFVAL64
+	str	\rTemp,[\rBase,#GAFR2_L]
+	BigMov	\rTemp,AFVAL80
+	str	\rTemp,[\rBase,#GAFR2_U]
+#if (PLATFORM_TYPE==HALOGEN)
+	BigMov	\rTemp,AFVAL96
+	str	\rTemp,[\rBase,#GAFR3_L]
+	BigMov	\rTemp,AFVAL112
+	str	\rTemp,[\rBase,#GAFR3_U]
+#endif
+	BigMov	\rBase,PWR_MANAGER_BASE
+	mov	\rTemp,#0x30
+	str	\rTemp,[\rBase,#PSSR]
+.endm
+
+
+
+.macro TransMacro val
+	BigMov	r12,UART_BASE
+91:
+	BigMov	r0,\val
+	bl	Transmit
+	b	91b
+.endm
+// *******************************************************************************************
+.macro InitMMU rBase,rTemp
+//	mov	r0,#PSR_NOINTS_MASK+PSR_MODE_SVC
+//	msr	cpsr_c,r0
+// ********************************************************************
+// Disable the MMU and gang regardless of why we are here.
+	BigMov \rBase,0x2001			//; enable access to all coprocessors
+	CP15_CP_ACCESS	mcr,\rBase
+	CPWAIT \rBase
+
+	mov	\rBase,#0x00000078			//; get a zero to turn things off (must write bits[6:3] as 1's)
+	CP15_CONTROL	mcr,\rBase		//; Turn Off MMU, I&D Caches, WB.
+	CPWAIT \rBase 
+
+	mov	\rBase,#0x00000000         //; get a zero to turn things off
+	cmp	pc,#MEM_START
+	CP15_TLB_INVAL_BOTH	mcr,\rBase	//; flush (invalidate) I/D tlb's
+	CP15_CF_INVAL_BTB	mcr,\rBase	//invalidate Branch target buffer
+	CP15_CF_INVAL_D		mcr,\rBase
+	CP15_CF_INVAL_I		mcrcs,\rBase		//I might be running from cache only, invalidate if in ram
+	CP15_CF_DRAIN		mcr,\rBase		//; Drain the write buffer
+	nop
+	nop
+	nop
+	mvn	r0, #0					//; grant manager access to all domains
+	CP15_DACR	mcr,\rBase
+.endm
+
+//out rTemp1 reset reason
+.macro InitPWR rBase,rTemp1,rTemp2
+	BigMov	\rBase,PWR_MANAGER_BASE
+// ********************************************************************
+	ldr     \rTemp1,[\rBase,#RCSR]		// Read & Init Reset Cause bits in RCSR.
+	and     \rTemp1,\rTemp1,#RCSR_MASK	// extract the reset cause bits
+	str     \rTemp1,[\rBase,#RCSR]		// clear the reset cause bits (they're sticky)
+// ********************************************************************
+// Read and store PSSR, too - it will be reset later, after GPIOs are initialized.  
+// Unclear when we'll need this information, but don't throw a good status away.
+//	ldr     \rTemp2, [\rBase,#PSSR]                       
+// extract the reset cause bits
+//	and     \rTemp2,\rTemp2,#PSSR_MASK		//; r12 now holds the conditioned PSSR
+//	orr     \rTemp1,\rTemp1,\rTemp2,lsl #16			//; R10 now has RCSR in lower half and PSSR in upper.
+// ********************************************************************
+// Reasons for being here:
+//  1) Hard Reset
+//  2) Wake from Sleep
+//  3) GPIO Reset
+//  4) Watchdog Reset
+//  5) Eboot Handoff     
+// If Sleep_Reset:     reinit all but RTC, PWRMAN, CLKS (except cp14)... so reinit: OST, INTC, GPIO
+// If GPIO_Reset:      reinit all but MEMC.Config, RTC, CLKS (except cp14)... so reinit: treat like sleep
+// If Watchdog_Reset:  reinit all but RTC.RTTR, CLK.OSCC... so reinit: treat like a hard reset, minus OSCC and RTTR init.
+// If Hard_Reset:      reinit all 
+.endm
+
+// *******************************************************************************************
+// *******************************************************************************************
+	.list
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaMacro3.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaMacro3.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaMacro3.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaMacro3.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,74 @@
+#include "pxaLcd2.h"
+#include "pxaMacro2.h"
+.macro	DEFINE_SCREEN_WIDTH xres,xsyncWidth,xbegin,xend,  yres,ysyncWidth,ybegin,yend, enable,unscramble,rotate,active,bpp,clkdiv,type
+	.ifdef __ARMASM
+	GBLA SCREEN_WIDTH
+	.endif
+	.set	SCREEN_WIDTH,\xres
+.endm
+
+.macro	DEFINE_SCREEN_HEIGHT xres,xsyncWidth,xbegin,xend,  yres,ysyncWidth,ybegin,yend,  enable,unscramble,rotate,active,bpp,clkdiv,type
+	.ifdef __ARMASM
+	GBLA SCREEN_HEIGHT
+	.endif
+	.set	SCREEN_HEIGHT,\yres
+.endm
+
+	DEFINE_SCREEN_WIDTH  DEF_P
+	DEFINE_SCREEN_HEIGHT DEF_P
+
+.macro	CR0_INIT_VAL reg,xres,xsyncWidth,xbegin,xend,  yres,ysyncWidth,ybegin,yend,  enable,unscramble,rotate,active,bpp,clkdiv,type
+	BigMov	\reg,(\enable<<CR0_ENABLE)+(1<<CR0_IM_DISABLE_DONE)+(1<<CR0_IM_START_OF_FRAME)+\
+	(1<<CR0_IM_INPUT_FIFO_UNDERRUN)+(1<<CR0_IM_END_OF_FRAME)+(\active<<CR0_ACTIVE_SELECT)+\
+	(1<<CR0_IM_LCD_QUICK_DISABLE)+(1<<CR0_IM_BRANCH)+(1<<CR0_IM_OUTPUT_FIFO_UNDERRUN)
+.endm
+
+.macro	CR1_INIT_VAL reg,xres,xsyncWidth,xbegin,xend,  yres,ysyncWidth,ybegin,yend,  enable,unscramble,rotate,active,bpp,clkdiv,type
+	BigMov	\reg,((\xres-1)<<CR1_PIXELS_PER_LINE)+((\xsyncWidth-1)<<CR1_HORIZONTAL_SYNC_PULSE_WIDTH)+\
+	((\xend-1)<<CR1_END_OF_LINE_WAIT)+((\xbegin-1)<<CR1_BEGINNING_OF_LINE_WAIT)
+.endm
+
+.macro	CR2_INIT_VAL reg,xres,xsyncWidth,xbegin,xend,  yres,ysyncWidth,ybegin,yend,  enable,unscramble,rotate,active,bpp,clkdiv,type
+	BigMov	\reg,((\yres-1)<<CR2_LINES_PER_PANEL)+((\ysyncWidth-1)<<CR2_VERTICAL_SYNC_PULSE_WIDTH)+\
+	(\yend<<CR2_END_OF_FRAME_WAIT)+(\ybegin<<CR2_BEGINNING_OF_FRAME_WAIT)
+.endm
+
+.macro	CR3_INIT_VAL reg,xres,xsyncWidth,xbegin,xend,  yres,ysyncWidth,ybegin,yend,  enable,unscramble,rotate,active,bpp,clkdiv,type
+//LCD Clock is same as memory clock
+	BigMov	\reg,(\clkdiv<<CR3_PCLK_DIVISOR)+((256-1)<<CR3_ACBIAS_TOGGLE)+\
+	(0<<CR3_API)+(0<<CR3_FCLK_POLARITY)+(0<<CR3_LCLK_POLARITY)+\
+	(1<<CR3_PCLK_POLARITY)+(0<<CR3_BIAS_POLARITY)+\
+	(BPP_FORMAT<<CR3_BITS_PER_PIXEL)+(0<<CR3_DOUBLE_PCLK)+(PDFOR<<CR3_PDFOR)
+.endm
+
+#define TMEDS_INIT_VAL	(0xaa<<TMEDS_BLUE)+(0x55<<TMEDS_GREEN)+(0x00<<TMEDS_RED)
+#define TMEDC_INIT_VAL	(1<<TMEDC_MATRIX2_SELECT)+(3<<TMEDC_RESERVED)+(5<<TMEDC_HORIZONTAL_BEAT_SUPPRESSION)+(4<<TMEDC_VERTICAL_BEAT_SUPPRESSION)+(1<<TMEDC_FRAME_NUMBER_ADJUST_EN)+(1<<TMEDC_COLOR_OFFSET_ADJUST_EN)+(1<<TMEDC_FRAME_NUMBER_ADJUST_MATRIX2)+(1<<TMEDC_COLOR_OFFSET_ADJUST_MATRIX2)
+
+
+.macro	InitLCD rBase,rTemp,rDescript
+
+	BigMov	\rBase,LCD_CONTROL_BASE
+
+	CR1_INIT_VAL	\rTemp,DEF_P
+	str	\rTemp,[\rBase,#LCD_CR1]
+
+	CR2_INIT_VAL	\rTemp,DEF_P
+	str	\rTemp,[\rBase,#LCD_CR2]
+
+	CR3_INIT_VAL	\rTemp,DEF_P
+	str	\rTemp,[\rBase,#LCD_CR3]
+
+	BigMov	\rTemp,0
+	str	\rTemp,[\rBase,#LCD_FBR0]
+	str	\rTemp,[\rBase,#LCD_FBR1]
+
+	BigMov	\rTemp,TMEDS_INIT_VAL
+	str	\rTemp,[\rBase,#LCD_TMEDS]
+	BigMov	\rTemp,TMEDC_INIT_VAL
+	str	\rTemp,[\rBase,#LCD_TMEDC]
+
+	str	\rDescript,[\rBase,#LCD_FDADR0]
+
+	CR0_INIT_VAL	\rTemp,DEF_P
+	str	\rTemp,[\rBase,#LCD_CR0]
+.endm
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxaMacro.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaMacro.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxaMacro.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxaMacro.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,343 @@
+#include "pxa250Base.h"
+#include "pxaHardware.h"
+#include "BigMacro.h"
+	.nolist
+
+//CP14 registers
+.macro	CP14_PMNC	ins,rx
+	\ins	p14,0,\rx,c0,c0,0
+.endm
+.macro	CP14_CCNT	ins,rx
+	\ins	p14,0,\rx,c1,c0,0
+.endm
+.macro	CP14_PMN0	ins,rx
+	\ins	p14,0,\rx,c2,c0,0
+.endm
+.macro	CP14_PMN1	ins,rx
+	\ins	p14,0,\rx,c3,c0,0
+.endm
+.macro	CP14_CCLKCFG	ins,rx
+	\ins	p14,0,\rx,c6,c0,0
+.endm
+.macro	CP14_PWRMODE	ins,rx
+	\ins	p14,0,\rx,c7,c0,0
+.endm
+.macro	CP14_TX	ins,rx
+	\ins	p14,0,\rx,c8,c0,0
+.endm
+.macro	CP14_RX	ins,rx
+	\ins	p14,0,\rx,c9,c0,0
+.endm
+.macro	CP14_DCSR	ins,rx
+	\ins	p14,0,\rx,c10,c0,0	//debug control and status register
+.endm
+.macro	CP14_TBREG	ins,rx
+	\ins	p14,0,\rx,c11,c0,0	//trace buffer register
+.endm
+.macro	CP14_CHKPT0	ins,rx
+	\ins	p14,0,\rx,c12,c0,0	//checkpoint register 0
+.endm
+.macro	CP14_CHKPT1	ins,rx
+	\ins	p14,0,\rx,c13,c0,0	//checkpoint register 1
+.endm
+.macro	CP14_TXRXCTRL	ins,rx
+	\ins	p14,0,\rx,c14,c0,0
+.endm
+
+
+//CP15 registers
+.macro	CP15_ID	ins,rx
+	\ins	p15,0,\rx,c0,c0,0
+.endm
+.macro	CP15_CACHETYPE	ins,rx
+	\ins	p15,0,\rx,c0,c0,1
+.endm
+.macro	CP15_CONTROL	ins,rx
+	\ins	p15,0,\rx,c1,c0,0
+.endm
+.macro	CP15_AUXCONTROL	ins,rx
+	\ins	p15,0,\rx,c1,c0,1
+.endm
+.macro	CP15_TTBR	ins,rx
+	\ins	p15,0,\rx,c2,c0,0		//translation table base
+.endm
+.macro	CP15_DACR	ins,rx
+	\ins	p15,0,\rx,c3,c0,0		//domain access control register
+.endm
+.macro	CP15_FSR	ins,rx
+	\ins	p15,0,\rx,c5,c0,0		//fault status register
+.endm
+.macro	CP15_FAR	ins,rx
+	\ins	p15,0,\rx,c6,c0,0		//fault address register
+.endm
+
+.macro	CP15_CF_ALLOC_LINE	ins,rx
+	\ins	p15,0,\rx,c7,c2,5		//allocate line in data cache
+.endm
+.macro	CP15_CF_INVAL_I	ins,rx
+	\ins	p15,0,\rx,c7,c5,0		//invalidate instruction cache
+.endm
+.macro	CP15_CF_INVAL_ILINE	ins,rx
+	\ins	p15,0,\rx,c7,c5,1
+.endm
+.macro	CP15_CF_INVAL_BTB	ins,rx
+	\ins	p15,0,\rx,c7,c5,6		//invalidate Branch target buffer
+.endm
+.macro	CP15_CF_INVAL_D	ins,rx
+	\ins	p15,0,\rx,c7,c6,0
+.endm
+.macro	CP15_CF_INVAL_DLINE	ins,rx
+	\ins	p15,0,\rx,c7,c6,1
+.endm
+.macro	CP15_CF_INVAL_BOTH	ins,rx
+	\ins	p15,0,\rx,c7,c7,0		//invalidate instruction & data cache & BTB
+.endm
+.macro	CP15_CF_CLEAN_DLINE	ins,rx
+	\ins	p15,0,\rx,c7,c10,1
+.endm
+.macro	CP15_CF_DRAIN	ins,rx
+	\ins	p15,0,\rx,c7,c10,4
+.endm
+
+.macro	CP15_TLB_INVAL_I	ins,rx
+	\ins	p15,0,\rx,c8,c5,0
+.endm
+.macro	CP15_TLB_INVAL_IENTRY	ins,rx
+	\ins	p15,0,\rx,c8,c5,1
+.endm
+.macro	CP15_TLB_INVAL_D	ins,rx
+	\ins	p15,0,\rx,c8,c6,0
+.endm
+.macro	CP15_TLB_INVAL_DENTRY	ins,rx
+	\ins	p15,0,\rx,c8,c6,1
+.endm
+.macro	CP15_TLB_INVAL_BOTH	ins,rx
+	\ins	p15,0,\rx,c8,c7,0
+.endm
+
+.macro	CP15_CF_LOCK_ILINE	ins,rx
+	\ins	p15,0,\rx,c9,c1,0		//mva to fetch and lock
+.endm
+.macro	CP15_CF_UNLOCK_I	ins,rx
+	\ins	p15,0,\rx,c9,c1,1		//unlock all lines
+.endm
+.macro	CP15_CF_LOCK_D_CSR	ins,rx
+	\ins	p15,0,\rx,c9,c2,0
+.endm
+.macro	CP15_CF_UNLOCK_D	ins,rx
+	\ins	p15,0,\rx,c9,c2,1		//unlock all lines in data cache
+.endm
+
+.macro	CP15_TLB_LOCK_IENTRY	ins,rx
+	\ins	p15,0,\rx,c10,c4,0
+.endm
+.macro	CP15_TLB_UNLOCK_I	ins,rx
+	\ins	p15,0,\rx,c10,c4,1
+.endm
+.macro	CP15_TLB_LOCK_DENTRY	ins,rx
+	\ins	p15,0,\rx,c10,c8,0
+.endm
+.macro	CP15_TLB_UNLOCK_D	ins,rx
+	\ins	p15,0,\rx,c10,c8,1
+.endm
+
+.macro	CP15_PID	ins,rx
+	\ins	p15,0,\rx,c13,c0,0
+.endm
+
+.macro	CP15_DBR0	ins,rx
+	\ins	p15,0,\rx,c14,c0,0	//Data Breakpoint address register 0
+.endm
+.macro	CP15_DBR1	ins,rx
+	\ins	p15,0,\rx,c14,c3,0	//Data Breakpoint address/mask register 1
+.endm
+.macro	CP15_DBCON	ins,rx
+	\ins	p15,0,\rx,c14,c4,0	//Data Breakpoint control register
+.endm
+.macro	CP15_IBCR0	ins,rx
+	\ins	p15,0,\rx,c14,c8,0	//Instruction Breakpoint Control Register 0
+.endm
+.macro	CP15_IBCR1	ins,rx
+	\ins	p15,0,\rx,c14,c9,0	//Instruction Breakpoint Control Register 1
+.endm
+
+.macro	CP15_CP_ACCESS	ins,rx
+	\ins	p15,0,\rx,c15,c1,0	//Coprocessor access register, set bit n to enable access to coprocessor n
+.endm
+
+
+.macro CPWAIT dest
+	CP15_ID mrc,\dest		//read some register in CP15
+	mov	\dest,\dest		//wait for the read to complete
+	sub	pc,pc,#4		//branch to the next instruction, flushing the instruction pipeline
+.endm
+
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+//  ************************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+// *******************************************************************************************
+
+#define numColumnAddrBits 9
+#define numBankAddrBits 2
+#define ClkSelect 1	//0 : tRP = 2, tRCD = 1, tRAS = 3, tRC = 4
+			//1 : tRP = 2, tRCD = 2, tRAS = 5, tRC = 8
+			//2 : tRP = 3, tRCD = 3, tRAS = 7, tRC = 10
+			//3 : tRP = 3, tRCD = 3, tRAS = 7, tRC = 11
+//64 meg option
+#define M64_numRowAddrBits 13	//for k4s561632a
+#define M64_SA1111_mask 0		//(1<<12)
+#define M64_DRI_cnt  (((99530*64)>>M64_numRowAddrBits)>>5)	//(# of cycles/ms  * # of ms for entire refresh period)/ # of rows/refresh period /32
+#define M64_MDCNFG_VAL 1+((numColumnAddrBits-8)<<3)+((M64_numRowAddrBits-11)<<5)+((numBankAddrBits-1)<<7)+(ClkSelect<<8)+(1<<11)+(M64_SA1111_mask)	//DLATCH0, latch return data with return clock
+#define M64_MDREFR_VAL (1<<16)+(1<<15)+(M64_DRI_cnt&0xfff)		//don't set bit 20: APD (buggy), bit 16: K1RUN, 15:E1PIN
+//#define M64_MDREFR_VAL (1<<20)+(1<<16)+(1<<15)+(M64_DRI_cnt&0xfff)		//20: APD, bit 16: K1RUN, 15:E1PIN
+//			 13		9		  2	       2 (4bytes per address)=2**26=64 MB
+#define M64_MEM_SIZE (1<<(M64_numRowAddrBits+numColumnAddrBits+numBankAddrBits+2))
+#define M64_MEM_END ((MEM_START)+M64_MEM_SIZE)
+
+//32 meg option
+#define M32_numRowAddrBits 12	//for MT48LC8M16A2 - 75 B
+#define M32_SA1111_mask 0
+#define M32_DRI_cnt  (((99530*64)>>M32_numRowAddrBits)>>5)	//(# of cycles/ms  * # of ms for entire refresh period)/ # of rows/refresh period /32
+#define M32_MDCNFG_VAL 1+((numColumnAddrBits-8)<<3)+((M32_numRowAddrBits-11)<<5)+((numBankAddrBits-1)<<7)+(ClkSelect<<8)+(1<<11)+(M32_SA1111_mask)	//DLATCH0, latch return data with return clock
+#define M32_MDREFR_VAL (1<<16)+(1<<15)+(M32_DRI_cnt&0xfff)		//don't set bit 20: APD (buggy), bit 16: K1RUN, 15:E1PIN
+//			 12		9		  2	       2 (4bytes per address)=2**25=32 MB
+#define M32_MEM_SIZE (1<<(M32_numRowAddrBits+numColumnAddrBits+numBankAddrBits+2))
+#define M32_MEM_END ((MEM_START)+M32_MEM_SIZE)
+// *******************************************************************************************
+//out: rTemp - memory size
+.macro CalcMemSize rBase,rTemp,mem_control_base
+	BigMov	\rBase,\mem_control_base
+	ldr	\rTemp,[\rBase,#MDCNFG]
+	movs	\rTemp,\rTemp,LSR #2+1		//bit 2 - 1 means 16 bit mode, 0 means 32 bit mode, mov to carry flag
+	tst	\rTemp,#1<<(5-3)				//is number of row address bits 12 or 13 ?
+	moveq	\rTemp,#M64_MEM_SIZE
+	movne	\rTemp,#M32_MEM_SIZE
+	movcs	\rTemp,\rTemp,LSR #1		//half as much if 16 bit mode
+.endm
+
+
+#define CH_NULL			0x00
+#define CH_BACKSPACE	0x08
+#define CH_LF			0x0a
+#define CH_CR			0x0d
+#define CH_CAN			0x18
+#define CH_SPACE		0x20		//" "
+#define CH_EXCLAMATION	0x21		//!
+#define CH_DQUOTE		0x22		//"
+#define CH_POUND		0x23		//#
+#define CH_DOLLAR		0x24		//$
+#define CH_PERCENT		0x25		//%
+#define CH_AMPERSAND	0x26		//&
+#define CH_SQUOTE		0x27		//'
+#define CH_OPEN_PAREN	0x28		//(
+#define CH_CLOSE_PAREN	0x29		//)
+#define CH_ASTERISK		0x2a		//*
+#define CH_PLUS			0x2b		//+
+#define CH_COMMA		0x2c		//,
+#define CH_HYPHEN		0x2d		//-
+#define CH_MINUS		0x2d		//-
+#define CH_PERIOD		0x2e		//.
+#define CH_FSLASH		0x2f		// /
+#define CH_0	0x30
+#define CH_1	0x31
+#define CH_2	0x32
+#define CH_3	0x33
+#define CH_4	0x34
+#define CH_5	0x35
+#define CH_6	0x36
+#define CH_7	0x37
+#define CH_8	0x38
+#define CH_9	0x39
+#define CH_COLON		0x3a		//:
+#define CH_SEMICOLON	0x3b		//;
+#define CH_LESS_THAN	0x3c		//<
+#define CH_EQUAL		0x3d		//=
+#define CH_GREATER_THAN	0x3e		//>
+#define CH_QUESTION_MARK	0x3f	//?
+#define CH_AT_SIGN		0x40		//@
+
+#define CH_A	0x41
+#define CH_B	0x42
+#define CH_C	0x43
+#define CH_D	0x44
+#define CH_E	0x45
+#define CH_F	0x46
+#define CH_G	0x47
+#define CH_H	0x48
+#define CH_I	0x49
+#define CH_J	0x4a
+#define CH_K	0x4b
+#define CH_L	0x4c
+#define CH_M	0x4d
+#define CH_N	0x4e
+#define CH_O	0x4f
+#define CH_P	0x50
+#define CH_Q	0x51
+#define CH_R	0x52
+#define CH_S	0x53
+#define CH_T	0x54
+#define CH_U	0x55
+#define CH_V	0x56
+#define CH_W	0x57
+#define CH_X	0x58
+#define CH_Y	0x59
+#define CH_Z	0x5a
+#define CH_OPEN_SQUARE	0x5b	//[
+#define CH_BSLASH		0x5c	//\..
+#define CH_CLOSE_SQUARE	0x5d	//]
+#define CH_CARET		0x5e	//^
+#define CH__			0x5f	//_
+#define CH_OPEN_SQUOTE	0x60	//`
+
+#define CH_a	0x61
+#define CH_b	0x62
+#define CH_c	0x63
+#define CH_d	0x64
+#define CH_e	0x65
+#define CH_f	0x66
+#define CH_g	0x67
+#define CH_h	0x68
+#define CH_i	0x69
+#define CH_j	0x6a
+#define CH_k	0x6b
+#define CH_l	0x6c
+#define CH_m	0x6d
+#define CH_n	0x6e
+#define CH_o	0x6f
+#define CH_p	0x70
+#define CH_q	0x71
+#define CH_r	0x72
+#define CH_s	0x73
+#define CH_t	0x74
+#define CH_u	0x75
+#define CH_v	0x76
+#define CH_w	0x77
+#define CH_x	0x78
+#define CH_y	0x79
+#define CH_z	0x7a
+#define CH_OPEN_CURLY		0x7b	//{
+#define CH_VERTICAL_BAR		0x7c	//|
+#define CH_CLOSE_CURLY		0x7d	//}
+#define CH_TILDE			0x7e	//~
+#define CH_DELETE			0x7f
+
+
+.macro	STARTUPTEXT
+	GBLS AreaName
+	AREA |.astart|,ALIGN=2,CODE
+AreaName SETS "|.astart|"
+.endm
+
+.macro	DUP count,val
+	LCLA	cnt
+cnt	SETA $count
+	WHILE ( cnt<>0)
+		DCD	$val
+cnt	SETA cnt-1
+	WEND
+.endm
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/arch-pxa/pxa-regs.h u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxa-regs.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/pxa-regs.h	2003-06-27 23:32:42.000000000 +0200
+++ u-boot-1.1.2-neon/include/asm-arm/arch-pxa/pxa-regs.h	2007-08-11 21:07:21.000000000 +0200
@@ -107,6 +107,17 @@
 #define DCSR_RUN	(1 << 31)	/* Run Bit (read / write) */
 #define DCSR_NODESC	(1 << 30)	/* No-Descriptor Fetch (read / write) */
 #define DCSR_STOPIRQEN	(1 << 29)	/* Stop Interrupt Enable (read / write) */
+
+#if defined(CONFIG_PXA27X)
+#define DCSR_EORIRQEN	(1 << 28)	/* End of Receive Interrupt Enable (R/W) */
+#define DCSR_EORJMPEN	(1 << 27)	/* Jump to next descriptor on EOR */
+#define DCSR_EORSTOPEN	(1 << 26)	/* STOP on an EOR */
+#define DCSR_SETCMPST	(1 << 25)	/* Set Descriptor Compare Status */
+#define DCSR_CLRCMPST	(1 << 24)	/* Clear Descriptor Compare Status */
+#define DCSR_CMPST	(1 << 10)	/* The Descriptor Compare Status */
+#define DCSR_ENRINTR	(1 << 9)	/* The end of Receive */
+#endif
+
 #define DCSR_REQPEND	(1 << 8)	/* Request Pending (read-only) */
 #define DCSR_STOPSTATE	(1 << 3)	/* Stop State (read-only) */
 #define DCSR_ENDINTR	(1 << 2)	/* End Interrupt (read / write) */
@@ -156,6 +167,10 @@
 #define DRCMR38		__REG(0x40000198)  /* Request to Channel Map Register for USB endpoint 14 Request */
 #define DRCMR39		__REG(0x4000019C)  /* Reserved */
 
+#define DRCMR68		       __REG(0x40001110)  /* Request to Channel Map Register for Camera FIFO 0 Request */
+#define DRCMR69		       __REG(0x40001114)  /* Request to Channel Map Register for Camera FIFO 1 Request */
+#define DRCMR70		       __REG(0x40001118)  /* Request to Channel Map Register for Camera FIFO 2 Request */
+
 #define DRCMRRXSADR	DRCMR2
 #define DRCMRTXSADR	DRCMR3
 #define DRCMRRXBTRBR	DRCMR4
@@ -424,6 +439,12 @@
 #define ISR		__REG(0x40301698)  /* I2C Status Register - ISR */
 #define ISAR		__REG(0x403016A0)  /* I2C Slave Address Register - ISAR */
 
+#define PWRIBMR		__REG(0x40f00180)  /* Power I2C Bus Monitor Register-IBMR */
+#define PWRIDBR		__REG(0x40f00188)  /* Power I2C Data Buffer Register-IDBR */
+#define PWRICR		__REG(0x40f00190)  /* Power I2C Control Register - ICR */
+#define PWRISR		__REG(0x40f00198)  /* Power I2C Status Register - ISR */
+#define PWRISAR		__REG(0x40f001A0)  /* Power I2C Slave Address Register-ISAR */
+
 /* ----- Control register bits ---------------------------------------- */
 
 #define ICR_START	0x1		/* start bit */
@@ -460,11 +481,9 @@
 /*
  * Serial Audio Controller
  */
-
-
 /* FIXME the audio defines collide w/ the SA1111 defines.  I don't like these
- * short defines because there is too much chance of namespace collision */
-
+ * short defines because there is too much chance of namespace collision
+ */
 /*#define SACR0		__REG(0x40400000)  /  Global Control Register */
 /*#define SACR1		__REG(0x40400004)  /  Serial Audio I 2 S/MSB-Justified Control Register */
 /*#define SASR0		__REG(0x4040000C)  /  Serial Audio I 2 S/MSB-Justified Interface and FIFO Status Register */
@@ -711,10 +730,68 @@
 #define USIR1_IR15	(1 << 7)	/* Interrup request ep 15 */
 
 
+#if defined(CONFIG_PXA27X)
 /*
- * Fast Infrared Communication Port
+ * USB Host Controller
  */
+#define USBH_BASE	0x4C000000
+#define UHCREV		__REG(0x4C000000)
+#define UHCHCON		__REG(0x4C000004)
+#define UHCCOMS		__REG(0x4C000008)
+#define UHCINTS		__REG(0x4C00000C)
+#define UHCINTE		__REG(0x4C000010)
+#define UHCINTD		__REG(0x4C000014)
+#define UHCHCCA		__REG(0x4C000018)
+#define UHCPCED		__REG(0x4C00001C)
+#define UHCCHED		__REG(0x4C000020)
+#define UHCCCED		__REG(0x4C000024)
+#define UHCBHED		__REG(0x4C000028)
+#define UHCBCED		__REG(0x4C00002C)
+#define UHCDHEAD	__REG(0x4C000030)
+#define UHCFMI		__REG(0x4C000034)
+#define UHCFMR		__REG(0x4C000038)
+#define UHCFMN		__REG(0x4C00003C)
+#define UHCPERS		__REG(0x4C000040)
+#define UHCLST		__REG(0x4C000044)
+#define UHCRHDA		__REG(0x4C000048)
+#define UHCRHDB		__REG(0x4C00004C)
+#define UHCRHS		__REG(0x4C000050)
+#define UHCRHPS1	__REG(0x4C000054)
+#define UHCRHPS2	__REG(0x4C000058)
+#define UHCRHPS3	__REG(0x4C00005C)
+#define UHCSTAT		__REG(0x4C000060)
+#define UHCHR		__REG(0x4C000064)
+#define UHCHIE		__REG(0x4C000068)
+#define UHCHIT		__REG(0x4C00006C)
+
+#define UHCHR_FSBIR	(1<<0)
+#define UHCHR_FHR	(1<<1)
+#define UHCHR_CGR	(1<<2)
+#define UHCHR_SSDC	(1<<3)
+#define UHCHR_UIT	(1<<4)
+#define UHCHR_SSE	(1<<5)
+#define UHCHR_PSPL	(1<<6)
+#define UHCHR_PCPL	(1<<7)
+#define UHCHR_SSEP0	(1<<9)
+#define UHCHR_SSEP1	(1<<10)
+#define UHCHR_SSEP2	(1<<11)
+
+#define UHCHIE_UPRIE	(1<<13)
+#define UHCHIE_UPS2IE	(1<<12)
+#define UHCHIE_UPS1IE	(1<<11)
+#define UHCHIE_TAIE	(1<<10)
+#define UHCHIE_HBAIE	(1<<8)
+#define UHCHIE_RWIE	(1<<7)
+
+#define UHCCOMS_HCR	1
+#define UHCRHS_LPS	1
+#define UHCHR_SSE	(1<<5)
+
+#endif
 
+/*
+ * Fast Infrared Communication Port
+ */
 #define ICCR0		__REG(0x40800000)  /* ICP Control Register 0 */
 #define ICCR1		__REG(0x40800004)  /* ICP Control Register 1 */
 #define ICCR2		__REG(0x40800008)  /* ICP Control Register 2 */
@@ -731,7 +808,21 @@
 #define RTAR		__REG(0x40900004)  /* RTC Alarm Register */
 #define RTSR		__REG(0x40900008)  /* RTC Status Register */
 #define RTTR		__REG(0x4090000C)  /* RTC Timer Trim Register */
-
+#define RDAR1	   __REG(0x40900018)  /* Wristwatch Day Alarm Reg 1 */
+#define RDAR2	   __REG(0x40900020)  /* Wristwatch Day Alarm Reg 2 */
+#define RYAR1	   __REG(0x4090001C)  /* Wristwatch Year Alarm Reg 1 */
+#define RYAR2	   __REG(0x40900024)  /* Wristwatch Year Alarm Reg 2 */
+#define SWAR1	   __REG(0x4090002C)  /* Stopwatch Alarm Register 1 */
+#define SWAR2	   __REG(0x40900030)  /* Stopwatch Alarm Register 2 */
+#define PIAR	   __REG(0x40900038)  /* Periodic Interrupt Alarm Register */
+#define RDCR	   __REG(0x40900010)  /* RTC Day Count Register. */
+#define RYCR	   __REG(0x40900014)  /* RTC Year Count Register. */
+#define SWCR	   __REG(0x40900028)  /* Stopwatch Count Register */
+#define RTCPICR	   __REG(0x40900034)  /* Periodic Interrupt Counter Register */
+
+#define RTSR_PICE  (1 << 15)   /* Peridoc interrupt count enable */
+#define RTSR_PIALE (1 << 14)   /* Peridoc interrupt Alarm enable */
+#define RTSR_PIAL  (1 << 13)   /* Peridoc  interrupt Alarm status */
 #define RTSR_HZE	(1 << 3)	/* HZ interrupt enable */
 #define RTSR_ALE	(1 << 2)	/* RTC alarm interrupt enable */
 #define RTSR_HZ		(1 << 1)	/* HZ rising-edge detected */
@@ -831,6 +922,37 @@
 /* More handy macros.  The argument is a literal GPIO number. */
 
 #define GPIO_bit(x)	(1 << ((x) & 0x1f))
+
+#ifdef CONFIG_PXA27X
+
+/* Interrupt Controller */
+
+#define ICIP2		__REG(0x40D0009C)  /* Interrupt Controller IRQ Pending Register 2 */
+#define ICMR2		__REG(0x40D000A0)  /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40D000A4)  /* Interrupt Controller Level Register 2 */
+#define ICFP2		__REG(0x40D000A8)  /* Interrupt Controller FIQ Pending Register 2 */
+#define ICPR2		__REG(0x40D000AC)  /* Interrupt Controller Pending Register 2 */
+
+#define _GPLR(x)	__REG2(0x40E00000, ((x) & 0x60) >> 3)
+#define _GPDR(x)	__REG2(0x40E0000C, ((x) & 0x60) >> 3)
+#define _GPSR(x)	__REG2(0x40E00018, ((x) & 0x60) >> 3)
+#define _GPCR(x)	__REG2(0x40E00024, ((x) & 0x60) >> 3)
+#define _GRER(x)	__REG2(0x40E00030, ((x) & 0x60) >> 3)
+#define _GFER(x)	__REG2(0x40E0003C, ((x) & 0x60) >> 3)
+#define _GEDR(x)	__REG2(0x40E00048, ((x) & 0x60) >> 3)
+#define _GAFR(x)	__REG2(0x40E00054, ((x) & 0x70) >> 2)
+
+#define GPLR(x)		((((x) & 0x7f) < 96) ? _GPLR(x) : GPLR3)
+#define GPDR(x)		((((x) & 0x7f) < 96) ? _GPDR(x) : GPDR3)
+#define GPSR(x)		((((x) & 0x7f) < 96) ? _GPSR(x) : GPSR3)
+#define GPCR(x)		((((x) & 0x7f) < 96) ? _GPCR(x) : GPCR3)
+#define GRER(x)		((((x) & 0x7f) < 96) ? _GRER(x) : GRER3)
+#define GFER(x)		((((x) & 0x7f) < 96) ? _GFER(x) : GFER3)
+#define GEDR(x)		((((x) & 0x7f) < 96) ? _GEDR(x) : GEDR3)
+#define GAFR(x)		((((x) & 0x7f) < 96) ? _GAFR(x) : \
+			 ((((x) & 0x7f) < 112) ? GAFR3_L : GAFR3_U))
+#else
+
 #define GPLR(x)		__REG2(0x40E00000, ((x) & 0x60) >> 3)
 #define GPDR(x)		__REG2(0x40E0000C, ((x) & 0x60) >> 3)
 #define GPSR(x)		__REG2(0x40E00018, ((x) & 0x60) >> 3)
@@ -840,6 +962,8 @@
 #define GEDR(x)		__REG2(0x40E00048, ((x) & 0x60) >> 3)
 #define GAFR(x)		__REG2(0x40E00054, ((x) & 0x70) >> 2)
 
+#endif
+
 /* GPIO alternate function assignments */
 
 #define GPIO1_RST		1	/* reset */
@@ -1038,6 +1162,8 @@
 #define GPIO79_nCS_3_MD		(79 | GPIO_ALT_FN_2_OUT)
 #define GPIO80_nCS_4_MD		(80 | GPIO_ALT_FN_2_OUT)
 
+#define GPIO117_SCL	     (117 | GPIO_ALT_FN_1_OUT)
+#define GPIO118_SDA	     (118 | GPIO_ALT_FN_1_OUT)
 
 /*
  * Power Manager
@@ -1054,8 +1180,62 @@
 #define PGSR0		__REG(0x40F00020)  /* Power Manager GPIO Sleep State Register for GP[31-0] */
 #define PGSR1		__REG(0x40F00024)  /* Power Manager GPIO Sleep State Register for GP[63-32] */
 #define PGSR2		__REG(0x40F00028)  /* Power Manager GPIO Sleep State Register for GP[84-64] */
+#define PGSR3		__REG(0x40F0002C)  /* Power Manager GPIO Sleep State Register for GP[118-96] */
 #define RCSR		__REG(0x40F00030)  /* Reset Controller Status Register */
 
+#define	   PSLR	   __REG(0x40F00034)	/* Power Manager Sleep Config Register */
+#define	   PSTR	   __REG(0x40F00038)	/* Power Manager Standby Config Register */
+#define	   PSNR	   __REG(0x40F0003C)	/* Power Manager Sense Config Register */
+#define	   PVCR	   __REG(0x40F00040)	/* Power Manager VoltageControl Register */
+#define	   PKWR	   __REG(0x40F00050)	/* Power Manager KB Wake-up Enable Reg */
+#define	   PKSR	   __REG(0x40F00054)	/* Power Manager KB Level-Detect Register */
+#define	   PCMD(x) __REG(0x40F00080 + x*4)
+#define	   PCMD0   __REG(0x40F00080 + 0 * 4)
+#define	   PCMD1   __REG(0x40F00080 + 1 * 4)
+#define	   PCMD2   __REG(0x40F00080 + 2 * 4)
+#define	   PCMD3   __REG(0x40F00080 + 3 * 4)
+#define	   PCMD4   __REG(0x40F00080 + 4 * 4)
+#define	   PCMD5   __REG(0x40F00080 + 5 * 4)
+#define	   PCMD6   __REG(0x40F00080 + 6 * 4)
+#define	   PCMD7   __REG(0x40F00080 + 7 * 4)
+#define	   PCMD8   __REG(0x40F00080 + 8 * 4)
+#define	   PCMD9   __REG(0x40F00080 + 9 * 4)
+#define	   PCMD10  __REG(0x40F00080 + 10 * 4)
+#define	   PCMD11  __REG(0x40F00080 + 11 * 4)
+#define	   PCMD12  __REG(0x40F00080 + 12 * 4)
+#define	   PCMD13  __REG(0x40F00080 + 13 * 4)
+#define	   PCMD14  __REG(0x40F00080 + 14 * 4)
+#define	   PCMD15  __REG(0x40F00080 + 15 * 4)
+#define	   PCMD16  __REG(0x40F00080 + 16 * 4)
+#define	   PCMD17  __REG(0x40F00080 + 17 * 4)
+#define	   PCMD18  __REG(0x40F00080 + 18 * 4)
+#define	   PCMD19  __REG(0x40F00080 + 19 * 4)
+#define	   PCMD20  __REG(0x40F00080 + 20 * 4)
+#define	   PCMD21  __REG(0x40F00080 + 21 * 4)
+#define	   PCMD22  __REG(0x40F00080 + 22 * 4)
+#define	   PCMD23  __REG(0x40F00080 + 23 * 4)
+#define	   PCMD24  __REG(0x40F00080 + 24 * 4)
+#define	   PCMD25  __REG(0x40F00080 + 25 * 4)
+#define	   PCMD26  __REG(0x40F00080 + 26 * 4)
+#define	   PCMD27  __REG(0x40F00080 + 27 * 4)
+#define	   PCMD28  __REG(0x40F00080 + 28 * 4)
+#define	   PCMD29  __REG(0x40F00080 + 29 * 4)
+#define	   PCMD30  __REG(0x40F00080 + 30 * 4)
+#define	   PCMD31  __REG(0x40F00080 + 31 * 4)
+
+#define	   PCMD_MBC    (1<<12)
+#define	   PCMD_DCE    (1<<11)
+#define	   PCMD_LC     (1<<10)
+/* FIXME:  PCMD_SQC need be checked.   */
+#define	   PCMD_SQC    (3<<8)  /* currently only bit 8 is changerable, */
+				/* bit 9 should be 0 all day. */
+#define PVCR_VCSA		   (0x1<<14)
+#define PVCR_CommandDelay	   (0xf80)
+/* define MACRO for Power Manager General Configuration Register (PCFR) */
+#define PCFR_FVC		   (0x1 << 10)
+#define PCFR_PI2C_EN		   (0x1 << 6)
+
+#define PSSR_OTGPH	(1 << 6)	/* OTG Peripheral control Hold */
 #define PSSR_RDH	(1 << 5)	/* Read Disable Hold */
 #define PSSR_PH		(1 << 4)	/* Peripheral Control Hold */
 #define PSSR_VFS	(1 << 2)	/* VDD Fault Status */
@@ -1117,14 +1297,29 @@
 #define OSCC		__REG(0x41300008)  /* Oscillator Configuration Register */
 
 #define CCCR_N_MASK	0x0380		/* Run Mode Frequency to Turbo Mode Frequency Multiplier */
+#if !defined(CONFIG_PXA27X)
 #define CCCR_M_MASK	0x0060		/* Memory Frequency to Run Mode Frequency Multiplier */
+#endif
 #define CCCR_L_MASK	0x001f		/* Crystal Frequency to Memory Frequency Multiplier */
 
+#define CKEN24_CAMERA	(1 << 24)	/* Camera Interface Clock Enable */
+#define CKEN23_SSP1	(1 << 23)	/* SSP1 Unit Clock Enable */
+#define CKEN22_MEMC	(1 << 22)	/* Memory Controller Clock Enable */
+#define CKEN21_MEMSTK	(1 << 21)	/* Memory Stick Host Controller */
+#define CKEN20_IM	(1 << 20)	/* Internal Memory Clock Enable */
+#define CKEN19_KEYPAD	(1 << 19)	/* Keypad Interface Clock Enable */
+#define CKEN18_USIM	(1 << 18)	/* USIM Unit Clock Enable */
+#define CKEN17_MSL	(1 << 17)	/* MSL Unit Clock Enable */
 #define CKEN16_LCD	(1 << 16)	/* LCD Unit Clock Enable */
+#define CKEN15_PWRI2C	(1 << 15)	/* PWR I2C Unit Clock Enable */
 #define CKEN14_I2C	(1 << 14)	/* I2C Unit Clock Enable */
 #define CKEN13_FICP	(1 << 13)	/* FICP Unit Clock Enable */
 #define CKEN12_MMC	(1 << 12)	/* MMC Unit Clock Enable */
 #define CKEN11_USB	(1 << 11)	/* USB Unit Clock Enable */
+#if defined(CONFIG_PXA27X)
+#define CKEN10_USBHOST	(1 << 10)	/* USB Host Unit Clock Enable */
+#define CKEN24_CAMERA	(1 << 24)	/* Camera Unit Clock Enable */
+#endif
 #define CKEN8_I2S	(1 << 8)	/* I2S Unit Clock Enable */
 #define CKEN7_BTUART	(1 << 7)	/* BTUART Unit Clock Enable */
 #define CKEN6_FFUART	(1 << 6)	/* FFUART Unit Clock Enable */
@@ -1137,6 +1332,7 @@
 #define OSCC_OON	(1 << 1)	/* 32.768kHz OON (write-once only bit) */
 #define OSCC_OOK	(1 << 0)	/* 32.768kHz OOK (read-only bit) */
 
+#if !defined(CONFIG_PXA27X)
 #define  CCCR_L09      (0x1F)
 #define  CCCR_L27      (0x1)
 #define  CCCR_L32      (0x2)
@@ -1153,6 +1349,7 @@
 #define  CCCR_N20      (0x4 << 7)
 #define  CCCR_N25      (0x5 << 7)
 #define  CCCR_N30      (0x6 << 7)
+#endif
 
 /*
  * LCD
@@ -1164,7 +1361,8 @@
 #define LCCR3		__REG(0x4400000C)  /* LCD Controller Control Register 3 */
 #define DFBR0		__REG(0x44000020)  /* DMA Channel 0 Frame Branch Register */
 #define DFBR1		__REG(0x44000024)  /* DMA Channel 1 Frame Branch Register */
-#define LCSR		__REG(0x44000038)  /* LCD Controller Status Register */
+#define LCSR0		__REG(0x44000038)  /* LCD Controller Status Register */
+#define LCSR1		__REG(0x44000034)  /* LCD Controller Status Register */
 #define LIIDR		__REG(0x4400003C)  /* LCD Controller Interrupt ID Register */
 #define TMEDRGBR	__REG(0x44000040)  /* TMED RGB Seed Register */
 #define TMEDCR		__REG(0x44000044)  /* TMED Control Register */
@@ -1194,6 +1392,11 @@
 #define LCCR0_PDD_S	12
 #define LCCR0_BM	(1 << 20) 	/* Branch mask */
 #define LCCR0_OUM	(1 << 21)	/* Output FIFO underrun mask */
+#if defined(CONFIG_PXA27X)
+#define LCCR0_LCDT	(1 << 22)	/* LCD Panel Type */
+#define LCCR0_RDSTM	(1 << 23)	/* Read Status Interrupt Mask */
+#define LCCR0_CMDIM	(1 << 24)	/* Command Interrupt Mask */
+#endif
 
 #define LCCR1_PPL       Fld (10, 0)      /* Pixels Per Line - 1 */
 #define LCCR1_DisWdth(Pixel)            /* Display Width [1..800 pix.]  */ \
@@ -1257,6 +1460,11 @@
 #endif
 #define LCCR3_DPC	(1 << 27)	/* double pixel clock mode */
 
+#define LCCR3_PDFOR_0	 (0 << 30)
+#define LCCR3_PDFOR_1	 (1 << 30)
+#define LCCR3_PDFOR_2	 (2 << 30)
+#define LCCR3_PDFOR_3	 (3 << 30)
+
 
 #define LCCR3_PCD       Fld (8, 0)      /* Pixel Clock Divisor */
 #define LCCR3_PixClkDiv(Div)            /* Pixel Clock Divisor */ \
@@ -1265,7 +1473,7 @@
 
 #define LCCR3_BPP       Fld (3, 24)     /* Bit Per Pixel */
 #define LCCR3_Bpp(Bpp)                  /* Bit Per Pixel */ \
-			(((Bpp) << FShft (LCCR3_BPP)))
+			((((Bpp&0x7) << FShft (LCCR3_BPP)))|(((Bpp&0x8)<<26)))
 
 #define LCCR3_ACB       Fld (8, 8)      /* AC Bias */
 #define LCCR3_Acb(Acb)                  /* BAC Bias */ \
@@ -1280,33 +1488,50 @@
 #define LCCR3_VrtSnchL  (LCCR3_VSP*1)   /*  Vertical Synchronization pulse */
 					/*  active Low                     */
 
-#define LCSR_LDD	(1 << 0)	/* LCD Disable Done */
-#define LCSR_SOF	(1 << 1)	/* Start of frame */
-#define LCSR_BER	(1 << 2)	/* Bus error */
-#define LCSR_ABC	(1 << 3)	/* AC Bias count */
-#define LCSR_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
-#define LCSR_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
-#define LCSR_OU		(1 << 6)	/* output FIFO underrun */
-#define LCSR_QD		(1 << 7)	/* quick disable */
-#define LCSR_EOF	(1 << 8)	/* end of frame */
-#define LCSR_BS		(1 << 9)	/* branch status */
-#define LCSR_SINT	(1 << 10)	/* subsequent interrupt */
-
-#define LDCMD_PAL	(1 << 26)	/* instructs DMA to load palette buffer */
-
-#define LCSR_LDD	(1 << 0)	/* LCD Disable Done */
-#define LCSR_SOF	(1 << 1)	/* Start of frame */
-#define LCSR_BER	(1 << 2)	/* Bus error */
-#define LCSR_ABC	(1 << 3)	/* AC Bias count */
-#define LCSR_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
-#define LCSR_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
-#define LCSR_OU		(1 << 6)	/* output FIFO underrun */
-#define LCSR_QD		(1 << 7)	/* quick disable */
-#define LCSR_EOF	(1 << 8)	/* end of frame */
-#define LCSR_BS		(1 << 9)	/* branch status */
-#define LCSR_SINT	(1 << 10)	/* subsequent interrupt */
+#define LCSR0_LDD	(1 << 0)	/* LCD Disable Done */
+#define LCSR0_SOF	(1 << 1)	/* Start of frame */
+#define LCSR0_BER	(1 << 2)	/* Bus error */
+#define LCSR0_ABC	(1 << 3)	/* AC Bias count */
+#define LCSR0_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
+#define LCSR0_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
+#define LCSR0_OU	(1 << 6)	/* output FIFO underrun */
+#define LCSR0_QD	(1 << 7)	/* quick disable */
+#define LCSR0_EOF0	(1 << 8)	/* end of frame */
+#define LCSR0_BS	(1 << 9)	/* branch status */
+#define LCSR0_SINT	(1 << 10)	/* subsequent interrupt */
+
+#define LCSR1_SOF1	(1 << 0)
+#define LCSR1_SOF2	(1 << 1)
+#define LCSR1_SOF3	(1 << 2)
+#define LCSR1_SOF4	(1 << 3)
+#define LCSR1_SOF5	(1 << 4)
+#define LCSR1_SOF6	(1 << 5)
+
+#define LCSR1_EOF1	(1 << 8)
+#define LCSR1_EOF2	(1 << 9)
+#define LCSR1_EOF3	(1 << 10)
+#define LCSR1_EOF4	(1 << 11)
+#define LCSR1_EOF5	(1 << 12)
+#define LCSR1_EOF6	(1 << 13)
+
+#define LCSR1_BS1	(1 << 16)
+#define LCSR1_BS2	(1 << 17)
+#define LCSR1_BS3	(1 << 18)
+#define LCSR1_BS4	(1 << 19)
+#define LCSR1_BS5	(1 << 20)
+#define LCSR1_BS6	(1 << 21)
+
+#define LCSR1_IU2	(1 << 25)
+#define LCSR1_IU3	(1 << 26)
+#define LCSR1_IU4	(1 << 27)
+#define LCSR1_IU5	(1 << 28)
+#define LCSR1_IU6	(1 << 29)
 
 #define LDCMD_PAL	(1 << 26)	/* instructs DMA to load palette buffer */
+#if defined(CONFIG_PXA27X)
+#define LDCMD_SOFINT	(1 << 22)
+#define LDCMD_EOFINT	(1 << 21)
+#endif
 
 /*
  * Memory controller
@@ -1369,5 +1594,191 @@
 #define MDREFR_K0RUN	(1 << 13)	/* SDCLK0 Run Control/Status */
 #define MDREFR_E0PIN	(1 << 12)	/* SDCKE0 Level Control/Status */
 
+#if defined(CONFIG_PXA27X)
 
-#endif
+#define ARB_CNTRL	__REG(0x48000048)  /* Arbiter Control Register */
+
+#define ARB_DMA_SLV_PARK	(1<<31)	   /* Be parked with DMA slave when idle */
+#define ARB_CI_PARK		(1<<30)	   /* Be parked with Camera Interface when idle */
+#define ARB_EX_MEM_PARK		(1<<29)	   /* Be parked with external MEMC when idle */
+#define ARB_INT_MEM_PARK	(1<<28)	   /* Be parked with internal MEMC when idle */
+#define ARB_USB_PARK		(1<<27)	   /* Be parked with USB when idle */
+#define ARB_LCD_PARK		(1<<26)	   /* Be parked with LCD when idle */
+#define ARB_DMA_PARK		(1<<25)	   /* Be parked with DMA when idle */
+#define ARB_CORE_PARK		(1<<24)	   /* Be parked with core when idle */
+#define ARB_LOCK_FLAG		(1<<23)	   /* Only Locking masters gain access to the bus */
+
+/* Interrupt Controller */
+
+#define ICIP2		__REG(0x40D0009C)  /* Interrupt Controller IRQ Pending Register 2 */
+#define ICMR2		__REG(0x40D000A0)  /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40D000A4)  /* Interrupt Controller Level Register 2 */
+#define ICFP2		__REG(0x40D000A8)  /* Interrupt Controller FIQ Pending Register 2 */
+#define ICPR2		__REG(0x40D000AC)  /* Interrupt Controller Pending Register 2 */
+
+/* General Purpose I/O */
+
+#define GAFR3_L		__REG(0x40E0006C)  /* GPIO Alternate Function Select Register GPIO<111:96> */
+#define GAFR3_U		__REG(0x40E00070)  /* GPIO Alternate Function Select Register GPIO<127:112> */
+#define GPLR3		__REG(0x40E00100)  /* GPIO Pin-Level Register GPIO<127:96> */
+#define GPDR3		__REG(0x40E0010C)  /* GPIO Pin Direction Register GPIO<127:96> */
+#define GPSR3		__REG(0x40E00118)  /* GPIO Pin Output Set Register GPIO<127:96> */
+#define GPCR3		__REG(0x40E00124)  /* GPIO Pin Output Clear Register GPIO <127:96> */
+#define GRER3		__REG(0x40E00130)  /* GPIO Rising-Edge Detect Register GPIO<127:96> */
+#define GFER3		__REG(0x40E0013C)  /* GPIO Falling-Edge Detect Register GPIO<31:0> */
+#define GEDR3		__REG(0x40E00148)  /* GPIO Edge Detect Status Register GPIO<127:96> */
+
+/* Core Clock */
+
+#define CCSR		__REG(0x4130000C) /* Core Clock Status Register */
+
+#define CKEN23_SSP1	(1 << 23) /* SSP1 Unit Clock Enable */
+#define CKEN22_MEMC	(1 << 22) /* Memory Controler */
+#define CKEN21_MSHC	(1 << 21) /* Memery Stick Host Controller */
+#define CKEN20_IM	(1 << 20) /* Internal Memory Clock Enable */
+#define CKEN19_KEYPAD	(1 << 19) /* Keypad Interface Clock Enable */
+#define CKEN18_USIM	(1 << 18) /* USIM Unit Clock Enable */
+#define CKEN17_MSL	(1 << 17) /* MSL Interface Unit Clock Enable */
+#define CKEN15_PWR_I2C	(1 << 15) /* PWR_I2C Unit Clock Enable */
+#define CKEN9_OST	(1 << 9)  /* OS Timer Unit Clock Enable */
+#define CKEN4_SSP3	(1 << 4)  /* SSP3 Unit Clock Enable */
+
+/* Memory controller */
+
+#define MDREFR_K0DB4	(1 << 29)	  /* SDCLK[0] divide by 4 */
+
+/* LCD registers */
+#define LCCR4		__REG(0x44000010)  /* LCD Controller Control Register 4 */
+#define LCCR5		__REG(0x44000014)  /* LCD Controller Control Register 5 */
+#define FBR0		__REG(0x44000020)  /* DMA Channel 0 Frame Branch Register */
+#define FBR1		__REG(0x44000024)  /* DMA Channel 1 Frame Branch Register */
+#define FBR2		__REG(0x44000028)  /* DMA Channel 2 Frame Branch Register */
+#define FBR3		__REG(0x4400002C)  /* DMA Channel 3 Frame Branch Register */
+#define FBR4		__REG(0x44000030)  /* DMA Channel 4 Frame Branch Register */
+#define FDADR2		__REG(0x44000220)  /* DMA Channel 2 Frame Descriptor Address Register */
+#define FSADR2		__REG(0x44000224)  /* DMA Channel 2 Frame Source Address Register */
+#define FIDR2		__REG(0x44000228)  /* DMA Channel 2 Frame ID Register */
+#define LDCMD2		__REG(0x4400022C)  /* DMA Channel 2 Command Register */
+#define FDADR3		__REG(0x44000230)  /* DMA Channel 3 Frame Descriptor Address Register */
+#define FSADR3		__REG(0x44000234)  /* DMA Channel 3 Frame Source Address Register */
+#define FIDR3		__REG(0x44000238)  /* DMA Channel 3 Frame ID Register */
+#define LDCMD3		__REG(0x4400023C)  /* DMA Channel 3 Command Register */
+#define FDADR4		__REG(0x44000240)  /* DMA Channel 4 Frame Descriptor Address Register */
+#define FSADR4		__REG(0x44000244)  /* DMA Channel 4 Frame Source Address Register */
+#define FIDR4		__REG(0x44000248)  /* DMA Channel 4 Frame ID Register */
+#define LDCMD4		__REG(0x4400024C)  /* DMA Channel 4 Command Register */
+#define FDADR5		__REG(0x44000250)  /* DMA Channel 5 Frame Descriptor Address Register */
+#define FSADR5		__REG(0x44000254)  /* DMA Channel 5 Frame Source Address Register */
+#define FIDR5		__REG(0x44000258)  /* DMA Channel 5 Frame ID Register */
+#define LDCMD5		__REG(0x4400025C)  /* DMA Channel 5 Command Register */
+
+#define OVL1C1		__REG(0x44000050)  /* Overlay 1 Control Register 1 */
+#define OVL1C2		__REG(0x44000060)  /* Overlay 1 Control Register 2 */
+#define OVL2C1		__REG(0x44000070)  /* Overlay 2 Control Register 1 */
+#define OVL2C2		__REG(0x44000080)  /* Overlay 2 Control Register 2 */
+#define CCR		__REG(0x44000090)  /* Cursor Control Register */
+
+#define FBR5		__REG(0x44000110)  /* DMA Channel 5 Frame Branch Register */
+#define FBR6		__REG(0x44000114)  /* DMA Channel 6 Frame Branch Register */
+
+#define LCCR0_LDDALT	(1<<26)		/* LDD Alternate mapping bit when base pixel is RGBT16 */
+#define LCCR0_OUC	(1<<25)		/* Overlay Underlay Control Bit */
+
+#define LCCR5_SOFM1	(1<<0)		/* Start Of Frame Mask for Overlay 1 (channel 1) */
+#define LCCR5_SOFM2	(1<<1)		/* Start Of Frame Mask for Overlay 2 (channel 2) */
+#define LCCR5_SOFM3	(1<<2)		/* Start Of Frame Mask for Overlay 2 (channel 3) */
+#define LCCR5_SOFM4	(1<<3)		/* Start Of Frame Mask for Overlay 2 (channel 4) */
+#define LCCR5_SOFM5	(1<<4)		/* Start Of Frame Mask for cursor (channel 5) */
+#define LCCR5_SOFM6	(1<<5)		/* Start Of Frame Mask for command data (channel 6) */
+
+#define LCCR5_EOFM1	(1<<8)		/* End Of Frame Mask for Overlay 1 (channel 1) */
+#define LCCR5_EOFM2	(1<<9)		/* End Of Frame Mask for Overlay 2 (channel 2) */
+#define LCCR5_EOFM3	(1<<10)		/* End Of Frame Mask for Overlay 2 (channel 3) */
+#define LCCR5_EOFM4	(1<<11)		/* End Of Frame Mask for Overlay 2 (channel 4) */
+#define LCCR5_EOFM5	(1<<12)		/* End Of Frame Mask for cursor (channel 5) */
+#define LCCR5_EOFM6	(1<<13)		/* End Of Frame Mask for command data (channel 6) */
+
+#define LCCR5_BSM1	(1<<16)		/* Branch mask for Overlay 1 (channel 1) */
+#define LCCR5_BSM2	(1<<17)		/* Branch mask for Overlay 2 (channel 2) */
+#define LCCR5_BSM3	(1<<18)		/* Branch mask for Overlay 2 (channel 3) */
+#define LCCR5_BSM4	(1<<19)		/* Branch mask for Overlay 2 (channel 4) */
+#define LCCR5_BSM5	(1<<20)		/* Branch mask for cursor (channel 5) */
+#define LCCR5_BSM6	(1<<21)		/* Branch mask for data command	 (channel 6) */
+
+#define LCCR5_IUM1	(1<<24)		/* Input FIFO Underrun Mask for Overlay 1  */
+#define LCCR5_IUM2	(1<<25)		/* Input FIFO Underrun Mask for Overlay 2  */
+#define LCCR5_IUM3	(1<<26)		/* Input FIFO Underrun Mask for Overlay 2  */
+#define LCCR5_IUM4	(1<<27)		/* Input FIFO Underrun Mask for Overlay 2  */
+#define LCCR5_IUM5	(1<<28)		/* Input FIFO Underrun Mask for cursor */
+#define LCCR5_IUM6	(1<<29)		/* Input FIFO Underrun Mask for data command */
+
+#define OVL1C1_O1EN	(1<<31)		/* Enable bit for Overlay 1 */
+#define OVL2C1_O2EN	(1<<31)		/* Enable bit for Overlay 2 */
+#define CCR_CEN		(1<<31)		/* Enable bit for Cursor */
+
+/* Keypad controller */
+
+#define KPC		__REG(0x41500000) /* Keypad Interface Control register */
+#define KPDK		__REG(0x41500008) /* Keypad Interface Direct Key register */
+#define KPREC		__REG(0x41500010) /* Keypad Intefcace Rotary Encoder register */
+#define KPMK		__REG(0x41500018) /* Keypad Intefcace Matrix Key register */
+#define KPAS		__REG(0x41500020) /* Keypad Interface Automatic Scan register */
+#define KPASMKP0	__REG(0x41500028) /* Keypad Interface Automatic Scan Multiple Key Presser register 0 */
+#define KPASMKP1	__REG(0x41500030) /* Keypad Interface Automatic Scan Multiple Key Presser register 1 */
+#define KPASMKP2	__REG(0x41500038) /* Keypad Interface Automatic Scan Multiple Key Presser register 2 */
+#define KPASMKP3	__REG(0x41500040) /* Keypad Interface Automatic Scan Multiple Key Presser register 3 */
+#define KPKDI		__REG(0x41500048) /* Keypad Interface Key Debounce Interval register */
+
+#define KPC_AS		(0x1 << 30)  /* Automatic Scan bit */
+#define KPC_ASACT	(0x1 << 29)  /* Automatic Scan on Activity */
+#define KPC_MI		(0x1 << 22)  /* Matrix interrupt bit */
+#define KPC_IMKP	(0x1 << 21)  /* Ignore Multiple Key Press */
+#define KPC_MS7		(0x1 << 20)  /* Matrix scan line 7 */
+#define KPC_MS6		(0x1 << 19)  /* Matrix scan line 6 */
+#define KPC_MS5		(0x1 << 18)  /* Matrix scan line 5 */
+#define KPC_MS4		(0x1 << 17)  /* Matrix scan line 4 */
+#define KPC_MS3		(0x1 << 16)  /* Matrix scan line 3 */
+#define KPC_MS2		(0x1 << 15)  /* Matrix scan line 2 */
+#define KPC_MS1		(0x1 << 14)  /* Matrix scan line 1 */
+#define KPC_MS0		(0x1 << 13)  /* Matrix scan line 0 */
+#define KPC_ME		(0x1 << 12)  /* Matrix Keypad Enable */
+#define KPC_MIE		(0x1 << 11)  /* Matrix Interrupt Enable */
+#define KPC_DK_DEB_SEL	(0x1 <<	 9)  /* Direct Key Debounce select */
+#define KPC_DI		(0x1 <<	 5)  /* Direct key interrupt bit */
+#define KPC_DEE0	(0x1 <<	 2)  /* Rotary Encoder 0 Enable */
+#define KPC_DE		(0x1 <<	 1)  /* Direct Keypad Enable */
+#define KPC_DIE		(0x1 <<	 0)  /* Direct Keypad interrupt Enable */
+
+#define KPDK_DKP	(0x1 << 31)
+#define KPDK_DK7	(0x1 <<	 7)
+#define KPDK_DK6	(0x1 <<	 6)
+#define KPDK_DK5	(0x1 <<	 5)
+#define KPDK_DK4	(0x1 <<	 4)
+#define KPDK_DK3	(0x1 <<	 3)
+#define KPDK_DK2	(0x1 <<	 2)
+#define KPDK_DK1	(0x1 <<	 1)
+#define KPDK_DK0	(0x1 <<	 0)
+
+#define KPREC_OF1	(0x1 << 31)
+#define kPREC_UF1	(0x1 << 30)
+#define KPREC_OF0	(0x1 << 15)
+#define KPREC_UF0	(0x1 << 14)
+
+#define KPMK_MKP	(0x1 << 31)
+#define KPAS_SO		(0x1 << 31)
+#define KPASMKPx_SO	(0x1 << 31)
+
+#define GPIO113_BIT	   (1 << 17)/* GPIO113 in GPSR, GPCR, bit 17 */
+#define PSLR	   __REG(0x40F00034)
+#define PSTR	   __REG(0x40F00038)  /* Power Manager Standby Configuration Reg */
+#define PSNR	   __REG(0x40F0003C)  /* Power Manager Sense Configuration Reg */
+#define PVCR	   __REG(0x40F00040)  /* Power Manager Voltage Change Control Reg */
+#define PKWR	   __REG(0x40F00050)  /* Power Manager KB Wake-Up Enable Reg */
+#define PKSR	   __REG(0x40F00054)  /* Power Manager KB Level-Detect Status Reg */
+#define OSMR4	    __REG(0x40A00080)  /* */
+#define OSCR4	    __REG(0x40A00040)  /* OS Timer Counter Register */
+#define OMCR4	    __REG(0x40A000C0)  /* */
+
+#endif	/* CONFIG_PXA27X */
+
+#endif	/* _PXA_REGS_H_ */
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/mach-types.h u-boot-1.1.2-neon/include/asm-arm/mach-types.h
--- u-boot-1.1.2/include/asm-arm/mach-types.h	2004-10-10 20:41:14.000000000 +0200
+++ u-boot-1.1.2-neon/include/asm-arm/mach-types.h	2007-08-11 21:07:21.000000000 +0200
@@ -624,6 +624,9 @@
 #define MACH_TYPE_RMS100               611
 #define MACH_TYPE_KB9200               612
 #define MACH_TYPE_SX1                  613
+#define MACH_TYPE_NEON                 332
+#define MACH_TYPE_BD2003               332
+#define MACH_TYPE_HALOGEN              332
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -7945,6 +7948,42 @@
 # define machine_is_sx1()	(0)
 #endif
 
+#ifdef CONFIG_ARCH_NEON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEON
+# endif
+# define machine_is_neon()	(machine_arch_type == MACH_TYPE_NEON)
+#else
+# define machine_is_neon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BD2003
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BD2003
+# endif
+# define machine_is_bd2003()	(machine_arch_type == MACH_TYPE_BD2003)
+#else
+# define machine_is_bd2003()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HALOGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HALOGEN
+# endif
+# define machine_is_halogen()	(machine_arch_type == MACH_TYPE_HALOGEN)
+#else
+# define machine_is_halogen()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff -u -r --new-file u-boot-1.1.2/include/asm-arm/processor.h u-boot-1.1.2-neon/include/asm-arm/processor.h
--- u-boot-1.1.2/include/asm-arm/processor.h	2003-06-26 00:26:36.000000000 +0200
+++ u-boot-1.1.2-neon/include/asm-arm/processor.h	2007-08-11 21:07:21.000000000 +0200
@@ -48,11 +48,22 @@
 #include <asm/proc/processor.h>
 #include <asm/types.h>
 
+#ifdef arm
+#warning arm defined by preprocessor
+#define armX arm
+#undef arm
+#endif
+
 union debug_insn {
 	u32	arm;
 	u16	thumb;
 };
 
+#ifdef armX
+#define arm
+#undef armX
+#endif
+
 struct debug_entry {
 	u32			address;
 	union debug_insn	insn;
diff -u -r --new-file u-boot-1.1.2/include/cmd_confdefs.h u-boot-1.1.2-neon/include/cmd_confdefs.h
--- u-boot-1.1.2/include/cmd_confdefs.h	2004-12-16 18:59:53.000000000 +0100
+++ u-boot-1.1.2-neon/include/cmd_confdefs.h	2007-08-11 21:07:21.000000000 +0200
@@ -92,6 +92,8 @@
 #define CFG_CMD_XIMG	0x0400000000000000ULL	/* Load part of Multi Image	*/
 #define CFG_CMD_UNIVERSE 0x0800000000000000ULL	/* Tundra Universe Support      */
 #define CFG_CMD_EXT2    0x1000000000000000ULL	/* EXT2 Support                 */
+#define CFG_CMD_LCDPANEL    0x2000000000000000ULL	/* Dynamic LCD Panel Support */
+#define CFG_CMD_NOT     0x4000000000000000ULL	/* Negate a command */
 
 #define CFG_CMD_ALL	0xFFFFFFFFFFFFFFFFULL	/* ALL commands			*/
 
diff -u -r --new-file u-boot-1.1.2/include/configs/bd2003.h u-boot-1.1.2-neon/include/configs/bd2003.h
--- u-boot-1.1.2/include/configs/bd2003.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/configs/bd2003.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,315 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * bd2003.h
+ *
+ * This header file declares the configuration constants for the Boundary
+ * Devices BD2003 board.
+ *
+ * Change History : 
+ *
+ * $Log: bd2003.h,v $
+ * Revision 1.7  2005/07/18 01:51:59  tkisky
+ * -define display types
+ *
+ * Revision 1.6  2005/07/17 22:52:10  ericn
+ * -fix comment
+ *
+ * Revision 1.5  2005/07/17 22:36:37  ericn
+ * -merge w/boundaryLib
+ *
+ * Revision 1.4  2005/07/02 18:45:55  ericn
+ * -bring up-to-date
+ *
+ * Revision 1.3  2005/04/20 09:05:36  tkisky
+ * -include select.h
+ *
+ * Revision 1.2  2005/04/15 10:40:52  tkisky
+ * -remove LCD_XRES,LCD_YRES
+ *
+ * Revision 1.1  2005/04/09 17:49:24  ericn
+ * -Initial import
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Copyright Boundary Devices, Inc. 2005
+ */
+
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+#include "select.h"
+
+#define CONFIG_INIT_CRITICAL		/* undef for developing */
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_PXA250		1	/* This is an PXA250 CPU    */
+#define PXALCD          1     /* Using the PXA display controller */
+#define CONFIG_LCD		1
+
+#define CONFIG_MMC		1
+#define BOARD_LATE_INIT		1
+
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN	    (CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CFG_MMU_SPACE_RESERVED (1<<14)
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_DRIVER_SMC91111
+#define CONFIG_SMC91111_BASE 0x10000300
+#define CONFIG_SMC_USE_32_BIT
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_FFUART	       1       /* we use FFUART on BD2003 */
+
+/* allow to overwrite serial and ethaddr */
+//#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+#define SKIP_COMMANDS ( CFG_CMD_MISC \
+                      | CFG_CMD_BDI \
+                      | CFG_CMD_BOOTD \
+                      | CFG_CMD_LOADS \
+                      | CFG_CMD_LOADB \
+                      | CFG_CMD_ITEST \
+                      | CFG_CMD_FPGA \
+                      | CFG_CMD_ECHO \
+                      | CFG_CMD_DIAG \
+                      | CFG_CMD_DATE \
+                      | CFG_CMD_BOOTP \
+                      | CFG_CMD_NFS \
+                      )
+//                      | CFG_CMD_FLASH
+//                      | CFG_CMD_DHCP
+//                      | CFG_CMD_NET
+//                      | CFG_CMD_MEMORY 
+//                      | CFG_CMD_ENV 
+                        
+#define CONFIG_COMMANDS		( (CONFIG_CMD_DFL \
+                             | CFG_CMD_MMC \
+                             | CFG_CMD_FAT \
+                             | CFG_CMD_LCDPANEL \
+                             | CFG_CMD_FLASH \
+                             | CFG_CMD_DHCP \
+                             | CFG_CMD_ENV \
+                             | CFG_CMD_BMP) & ~(SKIP_COMMANDS) )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTCOMMAND	"mmcinit; " \
+                           "fatload mmc 0 a0000000 init.scr ; autoscr a0000000 ; "
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 DEBUG=1 ENV=/etc/bashrc init=/linuxrc rw mtdparts=phys:1024k(armboot),256k(params),-(rootfs1) root=/dev/mtdblock3 rootfstype=cramfs"
+#define CONFIG_CMDLINE_TAG
+
+#define CONFIG_GZIP
+
+/*
+ * Choose one of the following:
+ *       
+ *    hitachi_qvga
+ *    sharp_qvga
+ *    hitachi_hvga
+ *    sharp_vga
+ *    hitachi_wvga    -    7 or 9 inch
+ */
+#ifndef DA320X240
+#define DA320X240 0
+#define DA640X240 1
+#define DA800X480 2
+#define DA640X480 3
+#define DA240X320 4
+#define DA800X600 5
+#define DA1024X768 6
+#define DP480X320 7
+#define DP320X240 8
+#define DL122X32  9
+#endif
+
+#if DISPLAY_TYPE == DA640X240
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_hvga" "\0"
+#elif DISPLAY_TYPE == DA240X320
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=qvga_portrait" "\0"
+#elif DISPLAY_TYPE == DA320X240
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_qvga" "\0"
+#elif DISPLAY_TYPE == DA8000X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_wvga" "\0"
+#elif DISPLAY_TYPE == DA640X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=sharp_vga" "\0"
+#elif DISPLAY_TYPE == DA800X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_wvga" "\0"
+#elif DISPLAY_TYPE == DA1024X768
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=crt1024x768" "\0"
+#else
+#error No display selected
+#endif
+
+#define LCD_BPP			LCD_COLOR8
+
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400		/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_HUSH_PARSER		1
+#define CFG_PROMPT_HUSH_PS2	"> "
+
+#define CFG_LONGHELP				/* undef to save memory		*/
+#ifdef CFG_HUSH_PARSER
+#define CFG_PROMPT		"$ "		/* Monitor Command Prompt */
+#else
+#define CFG_PROMPT		"=> "		/* Monitor Command Prompt */
+#endif
+#define CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+#define CFG_DEVICE_NULLDEV	1
+
+#define CFG_MEMTEST_START	0xa0400000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0xa0800000	/* 4 ... 8 MB in DRAM	*/
+
+#undef	CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CFG_LOAD_ADDR		0xa0030000	/* default load address */
+
+#define CFG_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CFG_CPUSPEED		0x161		/* set core clock to 400/200/100 MHz */
+
+						/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+#define CFG_MMC_BASE		0xF0000000
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0xa0000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x02000000 /* 32 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+#define PHYS_FLASH_2		0x04000000 /* Flash Bank #2 */
+#define PHYS_FLASH_SIZE		0x02000000 /* 32 MB */
+#define PHYS_FLASH_BANK_SIZE	0x02000000 /* 32 MB Banks */
+#define PHYS_FLASH_SECT_SIZE	0x00040000 /* 256 KB sectors (x2) */
+
+#define CFG_DRAM_BASE		0xa0000000
+#define CFG_DRAM_SIZE		0x04000000
+
+
+/*
+ * Memory settings
+ */
+#define CFG_MSC0_VAL		0x23F223F2
+#define CFG_MSC1_VAL		0x3FF1A441
+#define CFG_MSC2_VAL		0x7FF97FF1
+#define CFG_MDCNFG_VAL		0x00001AC9
+#define CFG_MDREFR_VAL		0x00018018
+#define CFG_MDMRS_VAL		0x00000000
+
+/*
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	128  /* max number of sectors on one chip    */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(25*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(25*CFG_HZ) /* Timeout for Flash Write */
+
+/* 
+ * Environment is saved in flash at offset 1MB
+ */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_FLASH_BASE     0
+#define CFG_ENV_ADDR		   ((CFG_FLASH_BASE)+0x100000)	/* Addr of Environment Sector	*/
+#define CFG_ENV_OFFSET     ((CFG_ENV_ADDR)-(CFG_FLASH_BASE))
+#define CFG_ENV_SIZE		   PHYS_FLASH_SECT_SIZE	/* Total Size of Environment Sector	*/
+
+/*
+ * GPIO settings
+ */
+#define CFG_GPSR0_VAL		0x00008000
+#define CFG_GPSR1_VAL		0x00FC0382
+#define CFG_GPSR2_VAL		0x0001FFFF
+#define CFG_GPCR0_VAL		0x00000000
+#define CFG_GPCR1_VAL		0x00000000
+#define CFG_GPCR2_VAL		0x00000000
+#define CFG_GPDR0_VAL		0x0060A800
+#define CFG_GPDR1_VAL		0x00FF0382
+#define CFG_GPDR2_VAL		0x0001C000
+#define CFG_GAFR0_L_VAL		0x98400000
+#define CFG_GAFR0_U_VAL		0x00002950
+#define CFG_GAFR1_L_VAL		0x000A9558
+#define CFG_GAFR1_U_VAL		0x0005AAAA
+#define CFG_GAFR2_L_VAL		0xA0000000
+#define CFG_GAFR2_U_VAL		0x00000002
+
+#define CFG_PSSR_VAL		0x20
+
+/*
+ * PCMCIA and CF Interfaces
+ */
+#define CFG_MECR_VAL		0x00000000
+#define CFG_MCMEM0_VAL		0x00010504
+#define CFG_MCMEM1_VAL		0x00010504
+#define CFG_MCATT0_VAL		0x00010504
+#define CFG_MCATT1_VAL		0x00010504
+#define CFG_MCIO0_VAL		0x00004715
+#define CFG_MCIO1_VAL		0x00004715
+
+#ifndef __ASSEMBLY__
+
+extern unsigned long const fbStart ;
+extern unsigned long       paletteRegs ;
+
+#endif  /* _ASMLANGUAGE */
+
+#endif
+
diff -u -r --new-file u-boot-1.1.2/include/configs/.cvsignore u-boot-1.1.2-neon/include/configs/.cvsignore
--- u-boot-1.1.2/include/configs/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/configs/.cvsignore	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1 @@
+select.h
diff -u -r --new-file u-boot-1.1.2/include/configs/halogen.h u-boot-1.1.2-neon/include/configs/halogen.h
--- u-boot-1.1.2/include/configs/halogen.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/configs/halogen.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,325 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * halogen.h
+ *
+ * This header file declares the configuration constants for the Boundary
+ * Devices Halogen (PXA-270) boards.
+ *
+ * Change History : 
+ *
+ * $Log: halogen.h,v $
+ * Revision 1.6  2005/07/18 01:51:59  tkisky
+ * -define display types
+ *
+ * Revision 1.5  2005/07/17 22:52:10  ericn
+ * -fix comment
+ *
+ * Revision 1.4  2005/07/17 22:36:37  ericn
+ * -merge w/boundaryLib
+ *
+ * Revision 1.3  2005/07/16 16:26:00  ericn
+ * -fix name, memsize
+ *
+ * Revision 1.2  2005/07/10 14:32:45  ericn
+ * -include USB
+ *
+ * Revision 1.1  2005/07/04 16:40:32  ericn
+ * -Initial import
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Copyright Boundary Devices, Inc. 2005
+ */
+
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+#include "select.h"
+
+#define CONFIG_INIT_CRITICAL		/* undef for developing */
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_PXA270		1	/* This is a PXA270 CPU    */
+#define CONFIG_PXA27X		1	/* Which is a PXA27X */
+
+#define PXALCD          1     /* Using the PXA display controller */
+#define CONFIG_LCD		1
+
+#define CONFIG_MMC		1
+#define BOARD_LATE_INIT		1
+
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN	    (CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CFG_MMU_SPACE_RESERVED (1<<14)
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_DRIVER_SMC91111
+#define CONFIG_SMC91111_BASE 0x10000300
+#define CONFIG_SMC_USE_32_BIT
+
+/************************************************************
+ * USB support
+ ************************************************************/
+#define LITTLEENDIAN		1  /* Needed by usb_ohci.c */
+#define CFG_DEVICE_DEREGISTER	1  /* Needed by usb_kbd */
+#define CONFIG_DOS_PARTITION	1
+#define CONFIG_USB_OHCI		1
+#define CONFIG_USB_KEYBOARD	1
+#define CONFIG_USB_STORAGE	1
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_FFUART	       1       /* we use FFUART on HALOGEN */
+
+/* allow to overwrite serial and ethaddr */
+//#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+#define SKIP_COMMANDS ( CFG_CMD_MISC \
+                      | CFG_CMD_BDI \
+                      | CFG_CMD_BOOTD \
+                      | CFG_CMD_LOADS \
+                      | CFG_CMD_LOADB \
+                      | CFG_CMD_ITEST \
+                      | CFG_CMD_FPGA \
+                      | CFG_CMD_ECHO \
+                      | CFG_CMD_DIAG \
+                      | CFG_CMD_DATE \
+                      | CFG_CMD_BOOTP \
+                      | CFG_CMD_NFS \
+                      )
+//                      | CFG_CMD_FLASH
+//                      | CFG_CMD_DHCP
+//                      | CFG_CMD_NET
+//                      | CFG_CMD_MEMORY 
+//                      | CFG_CMD_ENV 
+                        
+#define CONFIG_COMMANDS		( (CONFIG_CMD_DFL \
+                             | CFG_CMD_MMC \
+                             | CFG_CMD_FAT \
+                             | CFG_CMD_LCDPANEL \
+                             | CFG_CMD_FLASH \
+                             | CFG_CMD_DHCP \
+                             | CFG_CMD_ENV \
+			     | CFG_CMD_USB \
+                             | CFG_CMD_BMP) & ~(SKIP_COMMANDS) )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTCOMMAND	"mmcinit; " \
+                           "fatload mmc 0 a0000000 init.scr ; autoscr a0000000 ; "
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 DEBUG=1 ENV=/etc/bashrc init=/linuxrc rw mtdparts=phys:1024k(armboot),256k(params),-(rootfs1) root=/dev/mtdblock3 rootfstype=cramfs"
+#define CONFIG_CMDLINE_TAG
+
+#define CONFIG_GZIP
+
+/*
+ * Choose one of the following:
+ *       
+ *    hitachi_qvga
+ *    sharp_qvga
+ *    hitachi_hvga
+ *    sharp_vga
+ *    hitachi_wvga    -    7 or 9 inch
+ */
+#ifndef DA320X240
+#define DA320X240 0
+#define DA640X240 1
+#define DA800X480 2
+#define DA640X480 3
+#define DA240X320 4
+#define DA800X600 5
+#define DA1024X768 6
+#define DP480X320 7
+#define DP320X240 8
+#define DL122X32  9
+#endif
+
+#if DISPLAY_TYPE == DA640X240
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_hvga" "\0"
+#elif DISPLAY_TYPE == DA240X320
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=qvga_portrait" "\0"
+#elif DISPLAY_TYPE == DA320X240
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_qvga" "\0"
+#elif DISPLAY_TYPE == DA8000X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_wvga" "\0"
+#elif DISPLAY_TYPE == DA640X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=sharp_vga" "\0"
+#elif DISPLAY_TYPE == DA800X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_wvga" "\0"
+#elif DISPLAY_TYPE == DA1024X768
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=crt1024x768" "\0"
+#else
+#error No display selected
+#endif
+
+#define LCD_BPP			LCD_COLOR8
+
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400		/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_HUSH_PARSER		1
+#define CFG_PROMPT_HUSH_PS2	"> "
+
+#define CFG_LONGHELP				/* undef to save memory		*/
+#ifdef CFG_HUSH_PARSER
+#define CFG_PROMPT		"$ "		/* Monitor Command Prompt */
+#else
+#define CFG_PROMPT		"=> "		/* Monitor Command Prompt */
+#endif
+#define CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+#define CFG_DEVICE_NULLDEV	1
+
+#define CFG_MEMTEST_START	0xa0400000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0xa0800000	/* 4 ... 8 MB in DRAM	*/
+
+#undef	CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CFG_LOAD_ADDR		0xa0030000	/* default load address */
+
+#define CFG_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CFG_CPUSPEED		0x161		/* set core clock to 400/200/100 MHz */
+
+						/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+#define CFG_MMC_BASE		0xF0000000
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0xa0000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+#define PHYS_FLASH_2		0x04000000 /* Flash Bank #2 */
+#define PHYS_FLASH_SIZE		0x02000000 /* 32 MB */
+#define PHYS_FLASH_BANK_SIZE	0x02000000 /* 32 MB Banks */
+#define PHYS_FLASH_SECT_SIZE	0x00040000 /* 256 KB sectors (x2) */
+
+#define CFG_DRAM_BASE		0xa0000000
+#define CFG_DRAM_SIZE		0x04000000
+
+
+/*
+ * Memory settings
+ */
+#define CFG_MSC0_VAL		0x23F223F2
+#define CFG_MSC1_VAL		0x3FF1A441
+#define CFG_MSC2_VAL		0x7FF97FF1
+#define CFG_MDCNFG_VAL		0x00001AC9
+#define CFG_MDREFR_VAL		0x00018018
+#define CFG_MDMRS_VAL		0x00000000
+
+/*
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	128  /* max number of sectors on one chip    */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(25*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(25*CFG_HZ) /* Timeout for Flash Write */
+
+/* 
+ * Environment is saved in flash at offset 1MB
+ */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_FLASH_BASE     0
+#define CFG_ENV_ADDR		   ((CFG_FLASH_BASE)+0x100000)	/* Addr of Environment Sector	*/
+#define CFG_ENV_OFFSET     ((CFG_ENV_ADDR)-(CFG_FLASH_BASE))
+#define CFG_ENV_SIZE		   PHYS_FLASH_SECT_SIZE	/* Total Size of Environment Sector	*/
+
+/*
+ * GPIO settings
+ */
+#define CFG_GPSR0_VAL		0x00008000
+#define CFG_GPSR1_VAL		0x00FC0382
+#define CFG_GPSR2_VAL		0x0001FFFF
+#define CFG_GPCR0_VAL		0x00000000
+#define CFG_GPCR1_VAL		0x00000000
+#define CFG_GPCR2_VAL		0x00000000
+#define CFG_GPDR0_VAL		0x0060A800
+#define CFG_GPDR1_VAL		0x00FF0382
+#define CFG_GPDR2_VAL		0x0001C000
+#define CFG_GAFR0_L_VAL		0x98400000
+#define CFG_GAFR0_U_VAL		0x00002950
+#define CFG_GAFR1_L_VAL		0x000A9558
+#define CFG_GAFR1_U_VAL		0x0005AAAA
+#define CFG_GAFR2_L_VAL		0xA0000000
+#define CFG_GAFR2_U_VAL		0x00000002
+
+#define CFG_PSSR_VAL		0x20
+
+/*
+ * PCMCIA and CF Interfaces
+ */
+#define CFG_MECR_VAL		0x00000000
+#define CFG_MCMEM0_VAL		0x00010504
+#define CFG_MCMEM1_VAL		0x00010504
+#define CFG_MCATT0_VAL		0x00010504
+#define CFG_MCATT1_VAL		0x00010504
+#define CFG_MCIO0_VAL		0x00004715
+#define CFG_MCIO1_VAL		0x00004715
+
+#ifndef __ASSEMBLY__
+
+extern unsigned long const fbStart ;
+extern unsigned long       paletteRegs ;
+
+#endif  /* _ASMLANGUAGE */
+
+#endif
+
diff -u -r --new-file u-boot-1.1.2/include/configs/neon.h u-boot-1.1.2-neon/include/configs/neon.h
--- u-boot-1.1.2/include/configs/neon.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/configs/neon.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,395 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * neon.h
+ *
+ * This header file declares the configuration constants for the Boundary
+ * Devices Neon board.
+ *
+ * Change History : 
+ *
+ * $Log: neon.h,v $
+ * Revision 1.27  2006/05/30 15:52:17  ericn
+ * -clear screen after SD wait loop
+ *
+ * Revision 1.26  2006/05/27 22:11:50  ericn
+ * -include 'not', 'sleep' commands, wait for SD, <esc><esc><esc> for prompt
+ *
+ * Revision 1.25  2005/10/22 02:09:31  ericn
+ * -add CONFIG_SUPPORT_VFAT
+ *
+ * Revision 1.24  2005/07/23 19:35:42  ericn
+ * -fix name
+ *
+ * Revision 1.23  2005/07/23 17:13:25  ericn
+ * -add USB support
+ *
+ * Revision 1.22  2005/07/18 01:48:15  tkisky
+ * -define display types
+ *
+ * Revision 1.21  2005/07/17 22:52:10  ericn
+ * -fix comment
+ *
+ * Revision 1.20  2005/07/17 22:36:37  ericn
+ * -merge w/boundaryLib
+ *
+ * Revision 1.19  2005/07/02 18:46:16  ericn
+ * -Neon always has CONFIG_SM501
+ *
+ * Revision 1.18  2005/07/02 14:57:11  ericn
+ * -include INITRD tag
+ *
+ * Revision 1.17  2005/06/02 04:55:06  ericn
+ * -auto-choose qvga_portrait for DA240X320
+ *
+ * Revision 1.16  2005/06/02 04:10:30  ericn
+ * -save environment in flash
+ *
+ * Revision 1.15  2005/05/08 22:07:31  ericn
+ * -added 1024x768, 800x480 options
+ *
+ * Revision 1.14  2005/05/05 04:11:53  ericn
+ * -add flash commands, sharp_vga display selector
+ *
+ * Revision 1.13  2005/05/05 03:22:20  ericn
+ * -change default load addr to WinCE's
+ *
+ * Revision 1.12  2005/05/04 04:22:23  ericn
+ * -updated to allow DHCP
+ *
+ * Revision 1.11  2005/05/03 15:28:56  ericn
+ * -include DHCP support
+ *
+ * Revision 1.10  2005/05/02 15:14:26  ericn
+ * -add SMC driver, remove hard-coded MAC
+ *
+ * Revision 1.9  2005/05/01 15:21:41  ericn
+ * -change crtPalette -> paletteRegs
+ *
+ * Revision 1.8  2005/04/28 03:41:23  ericn
+ * -pass RAM qty to Linux
+ *
+ * Revision 1.7  2005/04/28 03:35:32  ericn
+ * -default to cramfs
+ *
+ * Revision 1.6  2005/04/22 01:57:39  ericn
+ * -fix default boot args
+ *
+ * Revision 1.5  2005/04/20 09:05:36  tkisky
+ * -include select.h
+ *
+ * Revision 1.4  2005/04/18 13:49:10  ericn
+ * -default wvga, use init.scr
+ *
+ * Revision 1.3  2005/04/18 03:58:48  ericn
+ * -added autoscr, hush parser support
+ *
+ * Revision 1.2  2005/04/15 10:41:35  tkisky
+ * -remove LCD_XRES,LCD_YRES, remove extra mmcinit
+ *
+ * Revision 1.1  2005/04/09 17:49:25  ericn
+ * -Initial import
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Copyright Boundary Devices, Inc. 2005
+ */
+
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+#include "select.h"
+
+#define CONFIG_INIT_CRITICAL		/* undef for developing */
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_PXA250		1	/* This is an PXA250 CPU    */
+#define CONFIG_NEON		1	/* on a Neon Board	    */
+#define CONFIG_SM501		1
+#define CONFIG_LCD		1
+
+#define CONFIG_MMC		1
+#define BOARD_LATE_INIT		1
+
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN	    (CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CFG_MMU_SPACE_RESERVED (1<<14)
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_DRIVER_SMC91111
+#define CONFIG_SMC91111_BASE 0x10000300
+#define CONFIG_SMC_USE_32_BIT
+
+/************************************************************
+ * USB support
+ ************************************************************/
+#define LITTLEENDIAN		1  /* Needed by usb_ohci.c */
+#define CFG_DEVICE_DEREGISTER	1  /* Needed by usb_kbd */
+#define CONFIG_DOS_PARTITION	1
+#define CONFIG_USB_OHCI		1
+#define CONFIG_USB_KEYBOARD	1
+#define CONFIG_USB_STORAGE	1
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_FFUART	       1       /* we use FFUART on NEON */
+
+/* allow to overwrite serial and ethaddr */
+//#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+#define SKIP_COMMANDS ( CFG_CMD_BDI \
+                      | CFG_CMD_BOOTD \
+                      | CFG_CMD_LOADS \
+                      | CFG_CMD_LOADB \
+                      | CFG_CMD_ITEST \
+                      | CFG_CMD_FPGA \
+                      | CFG_CMD_ECHO \
+                      | CFG_CMD_DIAG \
+                      | CFG_CMD_DATE \
+                      | CFG_CMD_BOOTP \
+                      | CFG_CMD_NFS \
+                      )
+//                      | CFG_CMD_FLASH
+//                      | CFG_CMD_DHCP
+//                      | CFG_CMD_NET
+//                      | CFG_CMD_MEMORY 
+//                      | CFG_CMD_ENV 
+
+#define CONFIG_SUPPORT_VFAT
+#define CONFIG_COMMANDS	( (CONFIG_CMD_DFL \
+                             | CFG_CMD_MMC \
+                             | CFG_CMD_FAT \
+                             | CFG_CMD_LCDPANEL \
+                             | CFG_CMD_FLASH \
+                             | CFG_CMD_DHCP \
+                             | CFG_CMD_ENV \
+			     | CFG_CMD_USB \
+                             | CFG_CMD_NOT \
+                             | CFG_CMD_MISC \
+                             | CFG_CMD_BMP) & ~(SKIP_COMMANDS) )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTCOMMAND	"while not mmcdet ; do cls ; lecho \"insert SD card\" ; sleep 1 ; done ; cls" \
+                                "if mmcwp ; then lecho \"write protected\" ; else lecho \"not write protected\" ; fi ; " \
+                                "mmcinit; " \
+                                "if fatload mmc 0 a0000000 init.scr ; then autoscr a0000000 ; fi"
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 DEBUG=1 ENV=/etc/bashrc init=/linuxrc rw mtdparts=phys:1024k(armboot),256k(params),-(rootfs1) root=/dev/mtdblock3 rootfstype=cramfs"
+#define CONFIG_CMDLINE_TAG
+
+#define CONFIG_GZIP
+
+#define	CONFIG_AUTOBOOT_KEYED		/* Enable password protection */
+#define	CONFIG_AUTOBOOT_PROMPT		"\nEnter password - autoboot in %d sec...\n"
+#define	CONFIG_AUTOBOOT_DELAY_STR	"\x1b\x1b\x1b"
+
+/*
+ * Choose one of the following:
+ *       
+ *    hitachi_qvga
+ *    sharp_qvga
+ *    hitachi_hvga
+ *    sharp_vga
+ *    hitachi_wvga    -    7 or 9 inch
+ */
+#ifndef DA320X240
+#define DA320X240 0
+#define DA640X240 1
+#define DA800X480 2
+#define DA640X480 3
+#define DA240X320 4
+#define DA800X600 5
+#define DA1024X768 6
+#define DP480X320 7
+#define DP320X240 8
+#define DL122X32  9
+#endif
+
+#if DISPLAY_TYPE == DA640X240
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_hvga" "\0"
+#elif DISPLAY_TYPE == DA240X320
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=qvga_portrait" "\0"
+#elif DISPLAY_TYPE == DA320X240
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_qvga" "\0"
+#elif DISPLAY_TYPE == DA8000X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_wvga" "\0"
+#elif DISPLAY_TYPE == DA640X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=sharp_vga" "\0"
+#elif DISPLAY_TYPE == DA800X480
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=hitachi_wvga" "\0"
+#elif DISPLAY_TYPE == DA1024X768
+#define CONFIG_EXTRA_ENV_SETTINGS "panel=crt1024x768" "\0"
+#else
+#error No display selected
+#endif
+
+#define LCD_BPP			LCD_COLOR8
+
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400		/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_HUSH_PARSER		1
+#define CFG_PROMPT_HUSH_PS2	"> "
+
+#define CFG_LONGHELP				/* undef to save memory		*/
+#ifdef CFG_HUSH_PARSER
+#define CFG_PROMPT		"$ "		/* Monitor Command Prompt */
+#else
+#define CFG_PROMPT		"=> "		/* Monitor Command Prompt */
+#endif
+#define CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+#define CFG_DEVICE_NULLDEV	1
+
+#define CFG_MEMTEST_START	0xa0400000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0xa0800000	/* 4 ... 8 MB in DRAM	*/
+
+#undef	CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CFG_LOAD_ADDR		0xa0030000	/* default load address */
+
+#define CFG_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CFG_CPUSPEED		0x161		/* set core clock to 400/200/100 MHz */
+
+						/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+#define CFG_MMC_BASE		0xF0000000
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0xa0000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+#define PHYS_FLASH_2		0x04000000 /* Flash Bank #2 */
+#define PHYS_FLASH_SIZE		0x02000000 /* 32 MB */
+#define PHYS_FLASH_BANK_SIZE	0x02000000 /* 32 MB Banks */
+#define PHYS_FLASH_SECT_SIZE	0x00040000 /* 256 KB sectors (x2) */
+
+#define CFG_DRAM_BASE		0xa0000000
+#define CFG_DRAM_SIZE		0x04000000
+
+
+/*
+ * Memory settings
+ */
+#define CFG_MSC0_VAL		0x23F223F2
+#define CFG_MSC1_VAL		0x3FF1A441
+#define CFG_MSC2_VAL		0x7FF97FF1
+#define CFG_MDCNFG_VAL		0x00001AC9
+#define CFG_MDREFR_VAL		0x00018018
+#define CFG_MDMRS_VAL		0x00000000
+
+/*
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	128  /* max number of sectors on one chip    */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(25*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(25*CFG_HZ) /* Timeout for Flash Write */
+
+/* 
+ * Environment is saved in flash at offset 1MB
+ */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_FLASH_BASE     0
+#define CFG_ENV_ADDR		   ((CFG_FLASH_BASE)+0x100000)	/* Addr of Environment Sector	*/
+#define CFG_ENV_OFFSET     ((CFG_ENV_ADDR)-(CFG_FLASH_BASE))
+#define CFG_ENV_SIZE		   PHYS_FLASH_SECT_SIZE	/* Total Size of Environment Sector	*/
+
+/*
+ * GPIO settings
+ */
+#define CFG_GPSR0_VAL		0x00008000
+#define CFG_GPSR1_VAL		0x00FC0382
+#define CFG_GPSR2_VAL		0x0001FFFF
+#define CFG_GPCR0_VAL		0x00000000
+#define CFG_GPCR1_VAL		0x00000000
+#define CFG_GPCR2_VAL		0x00000000
+#define CFG_GPDR0_VAL		0x0060A800
+#define CFG_GPDR1_VAL		0x00FF0382
+#define CFG_GPDR2_VAL		0x0001C000
+#define CFG_GAFR0_L_VAL		0x98400000
+#define CFG_GAFR0_U_VAL		0x00002950
+#define CFG_GAFR1_L_VAL		0x000A9558
+#define CFG_GAFR1_U_VAL		0x0005AAAA
+#define CFG_GAFR2_L_VAL		0xA0000000
+#define CFG_GAFR2_U_VAL		0x00000002
+
+#define CFG_PSSR_VAL		0x20
+
+/*
+ * PCMCIA and CF Interfaces
+ */
+#define CFG_MECR_VAL		0x00000000
+#define CFG_MCMEM0_VAL		0x00010504
+#define CFG_MCMEM1_VAL		0x00010504
+#define CFG_MCATT0_VAL		0x00010504
+#define CFG_MCATT1_VAL		0x00010504
+#define CFG_MCIO0_VAL		0x00004715
+#define CFG_MCIO1_VAL		0x00004715
+
+#ifndef __ASSEMBLY__
+
+extern unsigned long const fbStart ;
+extern unsigned long       paletteRegs ;
+
+#endif  /* _ASMLANGUAGE */
+
+#endif
+
diff -u -r --new-file u-boot-1.1.2/include/fat.h u-boot-1.1.2-neon/include/fat.h
--- u-boot-1.1.2/include/fat.h	2004-04-23 22:32:07.000000000 +0200
+++ u-boot-1.1.2-neon/include/fat.h	2007-08-11 21:07:21.000000000 +0200
@@ -177,13 +177,13 @@
 
 /* Private filesystem parameters */
 typedef struct {
+	__u8	fatbuf[FATBUFSIZE]; /* Current FAT buffer */
 	int	fatsize;	/* Size of FAT in bits */
 	__u16	fatlength;	/* Length of FAT in sectors */
 	__u16	fat_sect;	/* Starting sector of the FAT */
 	__u16	rootdir_sect;	/* Start sector of root directory */
 	__u16	clust_size;	/* Size of clusters in sectors */
 	short	data_begin;	/* The sector of the first cluster, can be negative */
-	__u8	fatbuf[FATBUFSIZE]; /* Current FAT buffer */
 	int	fatbufnum;	/* Used by get_fatent, init to -1 */
 } fsdata;
 
diff -u -r --new-file u-boot-1.1.2/include/lcd.h u-boot-1.1.2-neon/include/lcd.h
--- u-boot-1.1.2/include/lcd.h	2004-10-10 01:26:01.000000000 +0200
+++ u-boot-1.1.2-neon/include/lcd.h	2007-08-11 21:07:21.000000000 +0200
@@ -31,7 +31,6 @@
 
 extern char lcd_is_enabled;
 
-extern int lcd_line_length;
 extern int lcd_color_fg;
 extern int lcd_color_bg;
 
@@ -53,6 +52,7 @@
 	ushort	vl_row;		/* Number of rows (i.e. 480) */
 	ushort	vl_width;	/* Width of display area in millimeters */
 	ushort	vl_height;	/* Height of display area in millimeters */
+	int 	vl_lcd_line_length;
 
 	/* LCD configuration register */
 	u_char	vl_clkp;	/* Clock polarity */
@@ -77,7 +77,7 @@
 
 extern vidinfo_t panel_info;
 
-#elif defined CONFIG_PXA250
+#elif defined( PXALCD )
 /*
  * PXA LCD DMA descriptor
  */
@@ -119,6 +119,7 @@
 	ushort	vl_row;		/* Number of rows (i.e. 480) */
 	ushort	vl_width;	/* Width of display area in millimeters */
 	ushort	vl_height;	/* Height of display area in millimeters */
+	int 	vl_lcd_line_length;
 
 	/* LCD configuration register */
 	u_char	vl_clkp;	/* Clock polarity */
@@ -148,7 +149,29 @@
 
 extern vidinfo_t panel_info;
 
-#endif /* CONFIG_MPC823 or CONFIG_PXA250 */
+#if defined( CONFIG_PXA250 )
+	#define PALETTEVAL_TYPE u16
+#elif defined( CONFIG_PXA270 )
+	#define PALETTEVAL_TYPE u32
+#else
+#error no processor defined
+#endif
+
+#elif defined( CONFIG_SM501 )
+
+/*
+ * LCD controller stucture for PXA CPU
+ */
+typedef struct vidinfo {
+	ushort	vl_col;		/* Number of columns (i.e. 640) */
+	ushort	vl_row;		/* Number of rows (i.e. 480) */
+	int 	vl_lcd_line_length;
+	u_char	vl_bpix;	/* Bits per pixel, 0 = 1, 1 = 2, 2 = 4, 3 = 8, 4 = 16 */
+} vidinfo_t;
+
+extern vidinfo_t panel_info;
+
+#endif /* CONFIG_MPC823 */
 
 /* Video functions */
 
@@ -272,7 +295,7 @@
 #endif
 
 #define CONSOLE_COLS		(panel_info.vl_col / VIDEO_FONT_WIDTH)
-#define CONSOLE_ROW_SIZE	(VIDEO_FONT_HEIGHT * lcd_line_length)
+#define CONSOLE_ROW_SIZE	(VIDEO_FONT_HEIGHT * panel_info.vl_lcd_line_length)
 #define CONSOLE_ROW_FIRST	(lcd_console_address)
 #define CONSOLE_ROW_SECOND	(lcd_console_address + CONSOLE_ROW_SIZE)
 #define CONSOLE_ROW_LAST	(lcd_console_address + CONSOLE_SIZE \
diff -u -r --new-file u-boot-1.1.2/include/lcd_panels.h u-boot-1.1.2-neon/include/lcd_panels.h
--- u-boot-1.1.2/include/lcd_panels.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/include/lcd_panels.h	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,83 @@
+#ifndef __LCD_PANELS_H__
+#define __LCD_PANELS_H__ "$Id: lcd_panels.h,v 1.3 2005/06/02 04:03:37 ericn Exp $"
+
+/*
+ * lcd_panels.h
+ *
+ * This header file declares the lcd_panel_info_t 
+ * data type and the num_lcd_panels and lcd_panels 
+ * constants for use in initializing a variety of displays.
+ *
+ * Note that this is based on the pxafb_mach_info structure
+ * in linux-2.4.19/drivers/video/pxafb.h (Nico's patches), 
+ * but differs in a couple of respects:
+ *
+ *    Doesn't support the color-mapping stuff
+ *    Includes an 'active' flag
+ *
+ * Doesn't include the lccr0 and lccr3 fields, since most of 
+ * the fields in those registers are display controller options, 
+ * not panel options, and the others (so far) can have reasonable
+ * defaults. When (if) we need to support a non-standard display,
+ * we can fill in the blanks with defaults in the previously 
+ * supported displays and compute lccr0 and lccr3.
+ *
+ * Change History : 
+ *
+ * $Log: lcd_panels.h,v $
+ * Revision 1.3  2005/06/02 04:03:37  ericn
+ * -added rotation field
+ *
+ * Revision 1.2  2005/04/30 20:33:36  ericn
+ * -added CRT support
+ *
+ * Revision 1.1  2005/04/09 17:49:18  ericn
+ * -Initial import
+ *
+ *
+ * Copyright Boundary Devices, Inc. 2005
+ */
+
+struct lcd_panel_info_t {
+   char const       *name ;
+	unsigned long		pixclock;
+
+	unsigned short		xres;
+	unsigned short		yres;
+
+	unsigned     		act_high ;     // clock is active high
+	unsigned     		hsync_len;
+	unsigned     		left_margin;
+	unsigned     		right_margin;
+	unsigned     		vsync_len;
+	unsigned     		upper_margin;
+	unsigned     		lower_margin;
+   unsigned          active ;       // active matrix (TFT) LCD
+   unsigned          crt ;          // 1 == CRT, not LCD
+   unsigned          rotation ;
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+extern unsigned const num_lcd_panels ;
+extern struct lcd_panel_info_t const * const lcd_panels ;
+
+extern struct lcd_panel_info_t const *find_lcd_panel( char const * name );
+
+
+//
+// Each platform needs to define this routine, and  
+// set cur_lcd_panel within
+//
+void set_lcd_panel( struct lcd_panel_info_t const *panel );
+extern struct lcd_panel_info_t const *cur_lcd_panel ;
+void disable_lcd_panel( void );
+
+#ifdef __CPLUSPLUS
+};
+#endif 
+
+#endif
+
diff -u -r --new-file u-boot-1.1.2/include/part.h u-boot-1.1.2-neon/include/part.h
--- u-boot-1.1.2/include/part.h	2004-04-18 19:39:40.000000000 +0200
+++ u-boot-1.1.2-neon/include/part.h	2007-08-11 21:07:21.000000000 +0200
@@ -24,6 +24,48 @@
 #define _PART_H
 #include <ide.h>
 
+enum {
+/* These three have identical behaviour; use the second one if DOS fdisk gets
+   confused about extended/logical partitions starting past cylinder 1023. */
+	DOS_EXTENDED_PARTITION = 5,
+	LINUX_EXTENDED_PARTITION = 0x85,
+	WIN98_EXTENDED_PARTITION = 0x0f,
+
+	LINUX_SWAP_PARTITION = 0x82,
+	LINUX_RAID_PARTITION = 0xfd,	/* autodetect RAID partition */
+
+	SOLARIS_X86_PARTITION =	LINUX_SWAP_PARTITION,
+
+	DM6_PARTITION =	0x54,	/* has DDO: use xlated geom & offset */
+	EZD_PARTITION =	0x55,	/* EZ-DRIVE */
+	DM6_AUX1PARTITION = 0x51,	/* no DDO:  use xlated geom */
+	DM6_AUX3PARTITION = 0x53,	/* no DDO:  use xlated geom */
+
+	FREEBSD_PARTITION = 0xa5,    /* FreeBSD Partition ID */
+	OPENBSD_PARTITION = 0xa6,    /* OpenBSD Partition ID */
+	NETBSD_PARTITION = 0xa9,   /* NetBSD Partition ID */
+	BSDI_PARTITION = 0xb7,    /* BSDI Partition ID */
+/* Ours is not to wonder why.. */
+	BSD_PARTITION =	FREEBSD_PARTITION,
+	MINIX_PARTITION = 0x81,  /* Minix Partition ID */
+	PLAN9_PARTITION = 0x39,  /* Plan 9 Partition ID */
+	UNIXWARE_PARTITION = 0x63,		/* Partition ID, same as */
+						/* GNU_HURD and SCO Unix */
+};
+
+struct partition {
+	unsigned char boot_ind;		/* 0x80 - active */
+	unsigned char head;		/* starting head */
+	unsigned char sector;		/* starting sector */
+	unsigned char cyl;		/* starting cylinder */
+	unsigned char sys_ind;		/* What partition type */
+	unsigned char end_head;		/* end head */
+	unsigned char end_sector;	/* end sector */
+	unsigned char end_cyl;		/* end cylinder */
+	unsigned int start_sect;	/* starting sector counting from 0 */
+	unsigned int nr_sects;		/* nr of sectors in partition */
+} __attribute__((packed));
+
 typedef struct block_dev_desc {
 	int		if_type;	/* type of the interface */
 	int	        dev;	  	/* device number */
@@ -118,4 +160,15 @@
 int   test_part_amiga (block_dev_desc_t *dev_desc);
 #endif
 
+/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
+#define	FNM_NOMATCH	1
+
+/* Bits set in the FLAGS argument to `fnmatch'.  */
+#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
+#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
+#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
+#define FNM_NOSYS	(-1)
+
+int fnmatch(const char *pattern, const char *string, int flags);
+
 #endif /* _PART_H */
diff -u -r --new-file u-boot-1.1.2/lib_arm/armlinux.c u-boot-1.1.2-neon/lib_arm/armlinux.c
--- u-boot-1.1.2/lib_arm/armlinux.c	2004-10-10 01:26:01.000000000 +0200
+++ u-boot-1.1.2-neon/lib_arm/armlinux.c	2007-08-11 21:07:21.000000000 +0200
@@ -29,6 +29,7 @@
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
+#include "lcd_panels.h"
 
 /*cmd_boot.c*/
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
@@ -88,6 +89,16 @@
 
 #ifdef CONFIG_CMDLINE_TAG
 	char *commandline = getenv ("bootargs");
+   if( ( 0 != cur_lcd_panel ) && ( 0 != cur_lcd_panel->rotation ) )
+   {
+      char temp[80];
+      int addedLen = sprintf( temp, " fbrotation=%u", cur_lcd_panel->rotation );
+      unsigned cmdLen = strlen( commandline );
+      char *bigger = (char *)malloc( cmdLen + addedLen + 1 );
+      strcpy( bigger, commandline );
+      strcpy( bigger+cmdLen, temp );
+      commandline = bigger ;
+   }
 #endif
 
 	theKernel = (void (*)(int, int, uint))ntohl(hdr->ih_ep);
@@ -365,6 +376,7 @@
 	 * We only use it to pass the address and size, the other entries
 	 * in the tag_videolfb are not of interest.
 	 */
+#ifdef VESA_DISPLAY
 	params->hdr.tag = ATAG_VIDEOLFB;
 	params->hdr.size = tag_size (tag_videolfb);
 
@@ -374,6 +386,7 @@
 	params->u.videolfb.lfb_size = calc_fbsize();
 
 	params = tag_next (params);
+#endif
 }
 #endif /* CONFIG_VFD || CONFIG_LCD */
 
diff -u -r --new-file u-boot-1.1.2/lib_arm/board.c u-boot-1.1.2-neon/lib_arm/board.c
--- u-boot-1.1.2/lib_arm/board.c	2004-08-02 00:48:22.000000000 +0200
+++ u-boot-1.1.2-neon/lib_arm/board.c	2007-08-11 21:07:21.000000000 +0200
@@ -216,7 +216,10 @@
 #endif
 
 	/* Pointer is writable since we allocated a register for it */
-	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
+#ifndef CFG_MMU_SPACE_RESERVED
+#define CFG_MMU_SPACE_RESERVED 0
+#endif
+	gd = (gd_t*)(_armboot_start - CFG_MMU_SPACE_RESERVED - CFG_MALLOC_LEN - sizeof(gd_t));
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("": : :"memory");
 
@@ -263,7 +266,7 @@
 #endif /* CONFIG_LCD */
 
 	/* armboot_start is defined in the board-specific linker script */
-	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
+	mem_malloc_init (_armboot_start - CFG_MMU_SPACE_RESERVED - CFG_MALLOC_LEN);
 
 #if (CONFIG_COMMANDS & CFG_CMD_NAND)
 	puts ("NAND:");
diff -u -r --new-file u-boot-1.1.2/make_all u-boot-1.1.2-neon/make_all
--- u-boot-1.1.2/make_all	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/make_all	2007-08-11 21:07:21.000000000 +0200
@@ -0,0 +1,31 @@
+#!/bin/sh
+halogen1_clock="416"
+halogen2_clock="416"
+bd2003_clock="400"
+neon_clock="400"
+neonb_clock="400"
+
+SOFTWARE="LINUX"
+
+targets="halogen1 halogen2 bd2003 neon neonb"
+for suff in $targets ; do 
+   make distclean ;
+   REV=""
+   PLATFORM="$suff"
+   if [ $suff = "halogen1" ] ; then REV="1\n"; PLATFORM="halogen"
+   	else
+		if [ $suff = "halogen2" ] ;	then REV="2\n"; PLATFORM="halogen"
+		fi
+	fi
+   eval clock=\$$suff"_clock"
+   echo -e "DA640X240\n$REV$SOFTWARE\ny\n$clock\n" | make $PLATFORM"_config" ;
+   make u-boot.bin ;
+   mv u-boot.bin u-boot-$suff
+done
+
+
+for suff in $targets ; do 
+   mv u-boot-$suff u-boot-$suff.bin
+done
+
+zip u-boot-binaries.zip u-boot-*.bin
diff -u -r --new-file u-boot-1.1.2/Makefile u-boot-1.1.2-neon/Makefile
--- u-boot-1.1.2/Makefile	2004-12-19 10:58:11.000000000 +0100
+++ u-boot-1.1.2-neon/Makefile	2007-08-11 21:17:14.000000000 +0200
@@ -57,7 +57,7 @@
 CROSS_COMPILE = ppc_8xx-
 endif
 ifeq ($(ARCH),arm)
-CROSS_COMPILE = arm-linux-
+CROSS_COMPILE = arm-elf-
 endif
 ifeq ($(ARCH),i386)
 ifeq ($(HOSTARCH),i386)
@@ -89,6 +89,9 @@
 #########################################################################
 # U-Boot objects....order is important (i.e. start must be first)
 
+ifeq ($(CPU),pxa)
+OBJS =
+else
 OBJS  = cpu/$(CPU)/start.o
 ifeq ($(CPU),i386)
 OBJS += cpu/$(CPU)/start16.o
@@ -100,6 +103,7 @@
 ifeq ($(CPU),mpc85xx)
 OBJS += cpu/$(CPU)/resetvec.o
 endif
+endif
 
 LIBS  = lib_generic/libgeneric.a
 LIBS += board/$(BOARDDIR)/lib$(BOARD).a
@@ -121,7 +125,8 @@
 .PHONY : $(LIBS)
 
 # Add GCC lib
-PLATFORM_LIBS += --no-warn-mismatch -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
+LIBGCC_DIRNAME := $(shell dirname "`$(CC) $(CFLAGS) -print-libgcc-file-name`")
+PLATFORM_LIBS += --no-warn-mismatch -L "$(LIBGCC_DIRNAME)" -lgcc
 
 
 # The "tools" are needed early, so put this first
@@ -129,13 +134,14 @@
 SUBDIRS	= tools \
 	  examples \
 	  post \
-	  post/cpu
+	  post/cpu \
+	  cpu/$(CPU)
 .PHONY : $(SUBDIRS)
 
 #########################################################################
 #########################################################################
 
-ALL = u-boot.srec u-boot.bin System.map
+ALL = u-boot.srec u-boot.bin System.map init.scr upgrade.scr
 
 all:		$(ALL)
 
@@ -192,6 +198,12 @@
 		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
 		sort > System.map
 
+init.scr: board/$(BOARDDIR)/init.script
+	tools/mkimage -A arm -O linux -T script -C none -a 0 -e 0 -n "autoscript" -d $< $@
+
+upgrade.scr: upgrade.script
+	tools/mkimage -A arm -O linux -T script -C none -a 0 -e 0 -n "U-Boot upgrade script" -d $< $@
+
 #########################################################################
 else
 all install u-boot u-boot.srec depend dep:
@@ -203,6 +215,7 @@
 
 unconfig:
 	@rm -f include/config.h include/config.mk board/*/config.tmp
+	@rm -f select.mk include/configs/select.h
 
 #========================================================================
 # PowerPC
@@ -1388,6 +1401,22 @@
 wepep250_config	:	unconfig
 	@./mkconfig $(@:_config=) arm pxa wepep250
 
+bd-neon_config	:	unconfig
+	@./mkconfig $(@:_config=) arm pxa neon
+	./Configure --PLATFORM_TYPE=NEON
+
+neonb_config	:	unconfig
+	@./mkconfig neon arm pxa neon
+	./Configure --PLATFORM_TYPE=NEONB --SOFTWARE_TYPE=WINCE --DISPLAY_TYPE=DA640X240
+
+bd2003_config	:	unconfig
+	@./mkconfig $(@:_config=) arm pxa bd2003
+	./Configure --PLATFORM_TYPE=BD2003
+
+halogen_config	:	unconfig
+	@./mkconfig $(@:_config=) arm pxa halogen
+	./Configure --PLATFORM_TYPE=HALOGEN
+
 xaeniax_config	:	unconfig
 	@./mkconfig $(@:_config=) arm pxa xaeniax
 
@@ -1558,10 +1587,16 @@
 #########################################################################
 #########################################################################
 
+ifeq ($(HOSTOS),cygwin)
+FIND = /bin/find
+else
+FIND = find
+endif
+
 clean:
-	find . -type f \
+	$(FIND) . -type f \
 		\( -name 'core' -o -name '*.bak' -o -name '*~' \
-		-o -name '*.o'  -o -name '*.a'  \) -print \
+		-o -name '*.o'  -o -name '*.a' -o -name '*.lst' \) -print \
 		| xargs rm -f
 	rm -f examples/hello_world examples/timer \
 	      examples/eepro100_eeprom examples/sched \
@@ -1575,7 +1610,7 @@
 	rm -f board/trab/trab_fkt
 
 clobber:	clean
-	find . -type f \( -name .depend \
+	$(FIND) . -type f \( -name .depend \
 		-o -name '*.srec' -o -name '*.bin' -o -name u-boot.img \) \
 		-print0 \
 		| xargs -0 rm -f
@@ -1585,6 +1620,8 @@
 	rm -f tools/crc32.c tools/environment.c tools/env/crc32.c
 	rm -f tools/inca-swap-bytes cpu/mpc824x/bedbug_603e.c
 	rm -f include/asm/proc include/asm/arch include/asm
+	cd tools && rm -f *.exe
+	rm -f include/configs/select.h select.mk select.log
 
 mrproper \
 distclean:	clobber unconfig
diff -u -r --new-file u-boot-1.1.2/patches/arm_flags.patch u-boot-1.1.2-neon/patches/arm_flags.patch
--- u-boot-1.1.2/patches/arm_flags.patch	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/patches/arm_flags.patch	2007-08-11 21:01:36.000000000 +0200
@@ -0,0 +1,15 @@
+
+#
+# Patch managed by http://www.holgerschurig.de/patcher.html
+#
+
+--- u-boot-1.1.2/cpu/pxa/config.mk~armflags
++++ u-boot-1.1.2/cpu/pxa/config.mk
+@@ -23,6 +23,6 @@
+ #
+ 
+ PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
+-	-mshort-load-bytes -msoft-float
++	-msoft-float
+ 
+ PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4 -mtune=strongarm1100
diff -u -r --new-file u-boot-1.1.2/README u-boot-1.1.2-neon/README
--- u-boot-1.1.2/README	2004-12-16 22:44:03.000000000 +0100
+++ u-boot-1.1.2-neon/README	2007-08-11 21:07:19.000000000 +0200
@@ -608,6 +608,7 @@
 		CFG_CMD_ITEST	  Integer/string test of 2 values
 		CFG_CMD_JFFS2	* JFFS2 Support
 		CFG_CMD_KGDB	* kgdb
+		CFG_CMD_LCDPANEL	* Dynamic LCD Panel support
 		CFG_CMD_LOADB	  loadb
 		CFG_CMD_LOADS	  loads
 		CFG_CMD_MEMORY	  md, mm, nm, mw, cp, cmp, crc, base,
@@ -812,6 +813,9 @@
 				for differential drivers: 0x00001000
 				for single ended drivers: 0x00005000
 
+- Dynamic LCD Panel support
+      Allows the choice of an LCD panel through the environment.
+      Also allows prompting for panel characteristics.
 
 - MMC Support:
 		The MMC controller on the Intel PXA is supported. To
diff -u -r --new-file u-boot-1.1.2/tools/mkimage.c u-boot-1.1.2-neon/tools/mkimage.c
--- u-boot-1.1.2/tools/mkimage.c	2004-11-21 01:06:36.000000000 +0100
+++ u-boot-1.1.2-neon/tools/mkimage.c	2007-08-11 21:07:22.000000000 +0200
@@ -618,10 +618,10 @@
 	printf ("Image Name:   %.*s\n", IH_NMLEN, hdr->ih_name);
 	printf ("Created:      %s", ctime(&timestamp));
 	printf ("Image Type:   "); print_type(hdr);
-	printf ("Data Size:    %d Bytes = %.2f kB = %.2f MB\n",
+	printf ("Data Size:    %ld Bytes = %.2f kB = %.2f MB\n",
 		size, (double)size / 1.024e3, (double)size / 1.048576e6 );
-	printf ("Load Address: 0x%08X\n", ntohl(hdr->ih_load));
-	printf ("Entry Point:  0x%08X\n", ntohl(hdr->ih_ep));
+	printf ("Load Address: 0x%08lX\n", ntohl(hdr->ih_load));
+	printf ("Entry Point:  0x%08lX\n", ntohl(hdr->ih_ep));
 
 	if (hdr->ih_type == IH_TYPE_MULTI || hdr->ih_type == IH_TYPE_SCRIPT) {
 		int i, ptrs;
@@ -640,7 +640,7 @@
 		for (i=0; len_ptr[i]; ++i) {
 			size = ntohl(len_ptr[i]);
 
-			printf ("   Image %d: %8d Bytes = %4d kB = %d MB\n",
+			printf ("   Image %d: %8ld Bytes = %4ld kB = %ld MB\n",
 				i, size, size>>10, size>>20);
 			if (hdr->ih_type == IH_TYPE_SCRIPT && i > 0) {
 				/*
@@ -648,7 +648,7 @@
 				 * if planning to do something with
 				 * multiple files
 				 */
-				printf ("    Offset = %08X\n", pos);
+				printf ("    Offset = %08lX\n", pos);
 			}
 			/* copy_file() will pad the first files to even word align */
 			size += 3;
diff -u -r --new-file u-boot-1.1.2/upgrade.script u-boot-1.1.2-neon/upgrade.script
--- u-boot-1.1.2/upgrade.script	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.2-neon/upgrade.script	2007-08-11 21:07:22.000000000 +0200
@@ -0,0 +1,32 @@
+lecho "---------> upgrade to newest U-Boot"
+echo "---------> upgrade to newest U-Boot"
+if fatload mmc 0 a0008000 u-boot-*.bin ; then
+         if cmp.b 0 a0008000 $filesize ; then
+            fatload mmc 0 a0008000 *.bmp
+            bmp display a0008000
+            lecho 'Already upgraded. Latest U-Boot is installed' ;
+            echo 'Already upgraded. Latest U-Boot is installed' ;
+            if mmcwp ; then 
+               lecho "write protected" ; 
+            else 
+               lecho "not write protected" ; 
+            fi
+         else
+            lecho 'Old U-Boot found. Upgrading' ;
+            echo 'Old U-Boot found. Upgrading' ;
+            protect off all ;
+            lecho 'Erasing' ;
+            echo 'Erasing' ;
+            erase 0 3FFFF ;
+            lecho 'Programming' ;
+            echo 'Programming' ;
+            cp.b a0008000 0 $filesize ;
+            lecho 'Done programming. Cycle power' ;
+            echo 'Done programming. Cycle power' ;
+         fi
+else
+        lecho 'Error loading new U-Boot from SD card'
+        echo 'Error loading new U-Boot from SD card'
+        lecho 'Should have u-boot-neon-something.bin'
+        echo 'Should have u-boot-neon-something.bin'
+fi
\ No newline at end of file
