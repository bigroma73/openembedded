diff -uNr u-boot-1.1.2/.pc/.version u-boot-emetec-1.1.2/.pc/.version
--- u-boot-1.1.2/.pc/.version	2007-04-20 00:01:06.000000000 +0300
+++ u-boot-emetec-1.1.2/.pc/.version	1970-01-01 02:00:00.000000000 +0200
@@ -1 +0,0 @@
-2
diff -uNr u-boot-1.1.2/.pc/applied-patches u-boot-emetec-1.1.2/.pc/applied-patches
--- u-boot-1.1.2/.pc/applied-patches	2007-04-20 00:01:06.000000000 +0300
+++ u-boot-emetec-1.1.2/.pc/applied-patches	1970-01-01 02:00:00.000000000 +0200
@@ -1 +0,0 @@
-arm_flags.patch
diff -uNr u-boot-1.1.2/.pc/arm_flags.patch/cpu/pxa/config.mk u-boot-emetec-1.1.2/.pc/arm_flags.patch/cpu/pxa/config.mk
--- u-boot-1.1.2/.pc/arm_flags.patch/cpu/pxa/config.mk	2003-05-23 15:36:21.000000000 +0300
+++ u-boot-emetec-1.1.2/.pc/arm_flags.patch/cpu/pxa/config.mk	1970-01-01 02:00:00.000000000 +0200
@@ -1,28 +0,0 @@
-#
-# (C) Copyright 2002
-# Sysgo Real-Time Solutions, GmbH <www.elinos.com>
-# Marius Groeger <mgroeger@sysgo.de>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
-	-mshort-load-bytes -msoft-float
-
-PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4 -mtune=strongarm1100
diff -uNr u-boot-1.1.2/MAKEALL u-boot-emetec-1.1.2/MAKEALL
--- u-boot-1.1.2/MAKEALL	2004-12-31 11:32:48.000000000 +0200
+++ u-boot-emetec-1.1.2/MAKEALL	2005-03-11 22:23:47.000000000 +0200
@@ -69,7 +69,7 @@
 	ml300		OCOTEA		OCRTC		ORSG		\
 	PCI405		PIP405		PLU405		PMC405		\
 	PPChameleonEVB	VOH405		W7OLMC		W7OLMG		\
-	WALNUT405	WUH405          XPEDITE1K			\
+	WALNUT405	WUH405          XPEDITE1K	EMETEC405	\
 "
 
 #########################################################################
diff -uNr u-boot-1.1.2/Makefile u-boot-emetec-1.1.2/Makefile
--- u-boot-1.1.2/Makefile	2004-12-19 11:58:11.000000000 +0200
+++ u-boot-emetec-1.1.2/Makefile	2005-03-14 22:43:56.000000000 +0200
@@ -54,7 +54,7 @@
 CROSS_COMPILE =
 else
 ifeq ($(ARCH),ppc)
-CROSS_COMPILE = ppc_8xx-
+CROSS_COMPILE = ppc_4xx-
 endif
 ifeq ($(ARCH),arm)
 CROSS_COMPILE = arm-linux-
@@ -127,7 +127,6 @@
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
 SUBDIRS	= tools \
-	  examples \
 	  post \
 	  post/cpu
 .PHONY : $(SUBDIRS)
@@ -838,6 +837,9 @@
 
 VOM405_config:	unconfig
 	@./mkconfig $(@:_config=) ppc ppc4xx vom405 esd
+	
+EMETEC405_config: unconfig
+	@./mkconfig $(@:_config=) ppc ppc4xx emetec405
 
 W7OLMC_config	\
 W7OLMG_config: unconfig
diff -uNr u-boot-1.1.2/board/emetec405/Makefile u-boot-emetec-1.1.2/board/emetec405/Makefile
--- u-boot-1.1.2/board/emetec405/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/board/emetec405/Makefile	2005-04-26 22:34:53.000000000 +0300
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -uNr u-boot-1.1.2/board/emetec405/config.mk u-boot-emetec-1.1.2/board/emetec405/config.mk
--- u-boot-1.1.2/board/emetec405/config.mk	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/board/emetec405/config.mk	2005-03-11 22:26:43.000000000 +0200
@@ -0,0 +1,28 @@
+#
+# (C) Copyright 2000
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# emetec EMETEC405 boards
+#
+
+TEXT_BASE = 0xFFFC0000
diff -uNr u-boot-1.1.2/board/emetec405/emetec405.c u-boot-emetec-1.1.2/board/emetec405/emetec405.c
--- u-boot-1.1.2/board/emetec405/emetec405.c	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/board/emetec405/emetec405.c	2005-04-26 23:02:01.000000000 +0300
@@ -0,0 +1,106 @@
+/*
+ * (C) Copyright 2001-2003
+ * Stefan Roese, esd gmbh germany, stefan.roese@esd-electronics.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+#include <command.h>
+#include <malloc.h>
+
+
+int board_early_init_f (void)
+{
+   /*-------------------------------------------------------------------------+
+   | Interrupt controller setup for the Walnut board.
+   | Note: IRQ 0-15  405GP internally generated; active high; level sensitive
+   |       IRQ 16    405GP internally generated; active low; level sensitive
+   |       IRQ 17-24 RESERVED
+   |       IRQ 25 (EXT IRQ 0) FPGA; active high; level sensitive
+   |       IRQ 26 (EXT IRQ 1) SMI; active high; level sensitive
+   |       IRQ 27 (EXT IRQ 2) Not Used
+   |       IRQ 28 (EXT IRQ 3) PCI SLOT 3; active low; level sensitive
+   |       IRQ 29 (EXT IRQ 4) PCI SLOT 2; active low; level sensitive
+   |       IRQ 30 (EXT IRQ 5) PCI SLOT 1; active low; level sensitive
+   |       IRQ 31 (EXT IRQ 6) PCI SLOT 0; active low; level sensitive
+   | Note for Walnut board:
+   |       An interrupt taken for the FPGA (IRQ 25) indicates that either
+   |       the Mouse, Keyboard, IRDA, or External Expansion caused the
+   |       interrupt. The FPGA must be read to determine which device
+   |       caused the interrupt. The default setting of the FPGA clears
+   |
+   +-------------------------------------------------------------------------*/
+
+	mtdcr (uicsr, 0xFFFFFFFF);	/* clear all ints */
+	mtdcr (uicer, 0x00000000);	/* disable all ints */
+	mtdcr (uiccr, 0x00000000);	/* set all to be non-critical */
+	mtdcr (uicpr, 0xFFFFFFE0);	/* set int polarities */
+	mtdcr (uictr, 0x10000000);	/* set int trigger levels */
+	mtdcr (uicvcr, 0x00000001);	/* set vect base=0,INT0 highest priority */
+	mtdcr (uicsr, 0xFFFFFFFF);	/* clear all ints */
+
+	return 0;
+}
+
+
+int misc_init_f (void)
+{
+	return 0;  /* dummy implementation */
+}
+
+
+int misc_init_r (void)
+{
+	return 0;  /* dummy implementation */
+}
+
+
+/*
+ * Check Board Identity:
+ */
+int checkboard (void)
+{
+	unsigned char str[64];
+
+	puts ("Board: MAGICBOX\n");
+
+	return 0;
+}
+
+
+long int initdram (int board_type)
+{
+	unsigned long val;
+
+	mtdcr(memcfga, mem_mb0cf);
+	val = mfdcr(memcfgd);
+	
+	return (4*1024*1024 << ((val & 0x000e0000) >> 17));
+}
+
+
+int testdram (void)
+{
+	printf ("test: 32 MB - ok\n");
+
+	return (0);
+}
+
diff -uNr u-boot-1.1.2/board/emetec405/flash.c u-boot-emetec-1.1.2/board/emetec405/flash.c
--- u-boot-1.1.2/board/emetec405/flash.c	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/board/emetec405/flash.c	2005-05-25 10:14:13.000000000 +0300
@@ -0,0 +1,544 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <ppc4xx.h>
+#include <asm/processor.h>
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long * addr, flash_info_t * info);
+static void flash_get_offsets (ulong base, flash_info_t * info);
+
+/*-----------------------------------------------------------------------
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size_b0;
+	int i;
+	uint pbcr;
+	unsigned long base_b0;
+	int size_val = 0;
+
+	/* Init: no FLASHes known */
+	for (i=0; i<CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	/* Static FLASH Bank configuration here - FIXME XXX */
+
+	size_b0 = flash_get_size((vu_long *)FLASH_BASE0_PRELIM, &flash_info[0]);
+
+	if (flash_info[0].flash_id == FLASH_UNKNOWN) {
+		printf ("## Unknown FLASH on Bank 0 - Size = 0x%08lx = %ld MB\n",
+			size_b0, size_b0<<20);
+	}
+
+	/* Setup offsets */
+	flash_get_offsets (-size_b0, &flash_info[0]);
+
+	/* Re-do sizing to get full correct info */
+	mtdcr(ebccfga, pb0cr);
+	pbcr = mfdcr(ebccfgd);
+	mtdcr(ebccfga, pb0cr);
+	base_b0 = -size_b0;
+	switch (size_b0) {
+	case 1 << 20:
+		size_val = 0;
+		break;
+	case 2 << 20:
+		size_val = 1;
+		break;
+	case 4 << 20:
+		size_val = 2;
+		break;
+	case 8 << 20:
+		size_val = 3;
+		break;
+	case 16 << 20:
+		size_val = 4;
+		break;
+	}
+	pbcr = (pbcr & 0x0001ffff) | base_b0 | (size_val << 17);
+	mtdcr(ebccfgd, pbcr);
+
+	/* Monitor protection ON by default */
+	(void)flash_protect(FLAG_PROTECT_SET,
+			    -CFG_MONITOR_LEN,
+			    0xffffffff,
+			    &flash_info[0]);
+
+	flash_info[0].size = size_b0;
+
+	return (size_b0);
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t *info)
+{
+	int i;
+	short n;
+	
+	base += info->size;
+	i = info->sector_count;
+	
+	switch (info->flash_id & FLASH_TYPEMASK) 
+	{	
+		case FLASH_STMW320DT :
+			/*  1 x 16k boot sector */
+			base -= 16 << 10;
+			--i;
+			info->start[i] = base;
+			/*  2 x 8k  boot sectors */
+			for (n=0; n<2; ++n) {
+				base -= 8 << 10;
+				--i;
+				info->start[i] = base;
+			}
+			/*  1 x 32k boot sector */
+			base -= 32 << 10;
+			--i;
+			info->start[i] = base;		
+			break;
+			
+		case FLASH_STMW640DT :
+			/*  8 x 8k  boot sectors */
+			for (n=0; n<8; ++n) {
+				base -= 8 << 10;
+				--i;
+				info->start[i] = base;
+			}
+			break;
+	};
+	/* 64k regular sectors	*/
+	while (i > 0) {
+		base -= 64 << 10;
+		--i;
+		info->start[i] = base;
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	short i;
+	short n;
+	CFG_FLASH_WORD_SIZE value;
+	ulong base = (ulong)addr;
+	volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *)addr;
+
+	/* Write auto select command: read Manufacturer ID */
+	addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00AA00AA;
+	addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE)0x00550055;
+	addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00900090;
+
+	value = addr2[CFG_FLASH_READ0];
+
+	switch (value) {
+	case (CFG_FLASH_WORD_SIZE)SST_MANUFACT:
+		info->flash_id = FLASH_MAN_SST;
+		break;
+	case (CFG_FLASH_WORD_SIZE)STM_MANUFACT:
+		info->flash_id = FLASH_MAN_STM;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);
+	}
+
+	value = addr2[CFG_FLASH_READ1];		/* device ID		*/
+
+	switch (value) {
+	case (CFG_FLASH_WORD_SIZE)STM_ID_29W320DT:
+		info->flash_id += FLASH_STMW320DT;
+		info->sector_count = 67;
+		info->size = 0x00400000;  
+		
+		/* set up sector start address table for FLASH_STMW320DT */
+		/* set sector offsets for top boot block type		*/
+		base += info->size;
+		i = info->sector_count;
+		/*  1 x 16k boot sector */
+		base -= 16 << 10;
+		--i;
+		info->start[i] = base;
+		/*  2 x 8k  boot sectors */
+		for (n=0; n<2; ++n) {
+			base -= 8 << 10;
+			--i;
+			info->start[i] = base;
+		};
+		/*  1 x 32k boot sector */
+		base -= 32 << 10;
+		--i;
+		info->start[i] = base;
+	
+		/* 64k regular sectors	*/
+		while (i > 0) 
+		{	
+			base -= 64 << 10;
+			--i;
+			info->start[i] = base;
+		};
+		break;	/* => 4 MB	*/
+		
+	case (CFG_FLASH_WORD_SIZE)STM_ID_29W640DT:
+		info->flash_id += FLASH_STMW640DT;
+		info->sector_count = 135;
+		info->size = 0x00800000;  
+		
+		/* set up sector start address table for FLASH_STMW640DT */
+		/* set sector offsets for top boot block type		*/
+		base += info->size;
+		i = info->sector_count;
+		/*  8 x 8k  boot sectors */
+		for (n=0; n<8; ++n) {
+			base -= 8 << 10;
+			--i;
+			info->start[i] = base;
+		};
+	
+		/* 64k regular sectors	*/
+		while (i > 0) 
+		{	
+			base -= 64 << 10;
+			--i;
+			info->start[i] = base;
+		};
+		
+		break;	/* => 8 MB	*/
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		return (0);			/* => no or unknown flash */
+	}
+
+	/* check for protected sectors */
+	for (i = 0; i < info->sector_count; i++) {
+		/* read sector protection at sector address, (A7 .. A0) = 0x02 */
+		/* D0 = 1 if protected */
+		addr2 = (volatile CFG_FLASH_WORD_SIZE *)(info->start[i]);
+		if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+		  info->protect[i] = 0;
+		else
+		  info->protect[i] = addr2[CFG_FLASH_READ2] & 1;
+	}
+
+	/*
+	 * Prevent writes to uninitialized FLASH.
+	 */
+	if (info->flash_id != FLASH_UNKNOWN) {
+		addr2 = (CFG_FLASH_WORD_SIZE *)info->start[0];
+		*addr2 = (CFG_FLASH_WORD_SIZE)0x00F000F0;	/* reset bank */
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+	int k;
+	int size;
+	int erased;
+	volatile unsigned long *flash;
+
+	switch (info->flash_id & FLASH_TYPEMASK)
+	{
+		case FLASH_STMW320DT :
+			printf ("ST M29W320DT (32 M, top sector)\n");
+			break;
+		case FLASH_STMW640DT :
+			printf ("ST M29W640DT (64 M, top sector)\n");
+			break;
+		default :
+			printf ("Missing or unknown FLASH type\n");
+			return;
+	};
+	printf ("  Size: %ld MB in %d Sectors\n", info->size >> 20, info->sector_count);
+		
+	printf ("  Sector Start Addresses:");
+	for (i=0; i<info->sector_count; ++i) {
+		/*
+		 * Check if whole sector is erased
+		 */
+		if (i != (info->sector_count-1))
+		  size = info->start[i+1] - info->start[i];
+		else
+		  size = info->start[0] + info->size - info->start[i];
+		erased = 1;
+		flash = (volatile unsigned long *)info->start[i];
+		size = size >> 2;        /* divide by 4 for longword access */
+		for (k=0; k<size; k++)
+		  {
+		    if (*flash++ != 0xffffffff)
+		      {
+			erased = 0;
+			break;
+		      }
+		  }
+
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s%s",
+			info->start[i],
+			erased ? " E" : "  ",
+			info->protect[i] ? "RO " : "   "
+		);
+	}
+	printf ("\n");
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	volatile CFG_FLASH_WORD_SIZE *addr = (CFG_FLASH_WORD_SIZE *)(info->start[0]);
+	volatile CFG_FLASH_WORD_SIZE *addr2;
+	int flag, prot, sect, l_sect;
+	ulong start, now, last;
+	int i;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("Can't erase unknown flash type - aborted\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	l_sect = -1;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+		    addr2 = (CFG_FLASH_WORD_SIZE *)(info->start[sect]);
+		    if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) {
+			addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00AA00AA;
+			addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE)0x00550055;
+			addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00800080;
+			addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00AA00AA;
+			addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE)0x00550055;
+			addr2[0] = (CFG_FLASH_WORD_SIZE)0x00500050;  /* block erase */
+			for (i=0; i<50; i++)
+			  udelay(1000);  /* wait 1 ms */
+		    } else {
+			if (sect == s_first) {
+			    addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00AA00AA;
+			    addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE)0x00550055;
+			    addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00800080;
+			    addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00AA00AA;
+			    addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE)0x00550055;
+			}
+			addr2[0] = (CFG_FLASH_WORD_SIZE)0x00300030;  /* sector erase */
+		    }
+		    l_sect = sect;
+		}
+	}
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts();
+
+	/* wait at least 80us - let's wait 1 ms */
+	udelay (1000);
+
+	/*
+	 * We wait for the last triggered sector
+	 */
+	if (l_sect < 0)
+		goto DONE;
+
+	start = get_timer (0);
+	last  = start;
+	addr = (CFG_FLASH_WORD_SIZE *)(info->start[l_sect]);
+	while ((addr[0] & (CFG_FLASH_WORD_SIZE)0x00800080) != (CFG_FLASH_WORD_SIZE)0x00800080) {
+		if ((now = get_timer(start)) > CFG_FLASH_ERASE_TOUT) {
+			printf ("Timeout\n");
+			return 1;
+		}
+		/* show that we're waiting */
+		if ((now - last) > 1000) {	/* every second */
+			putc ('.');
+			last = now;
+		}
+	}
+
+DONE:
+	/* reset to read mode */
+	addr = (CFG_FLASH_WORD_SIZE *)info->start[0];
+	addr[0] = (CFG_FLASH_WORD_SIZE)0x00F000F0;	/* reset bank */
+
+	printf (" done\n");
+	return 0;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong cp, wp, data;
+	int i, l, rc;
+
+	wp = (addr & ~3);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i=0, cp=wp; i<l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *)cp);
+		}
+		for (; i<4 && cnt>0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt==0 && i<4; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *)cp);
+		}
+
+		if ((rc = write_word(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 4;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 4) {
+		data = 0;
+		for (i=0; i<4; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_word(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp  += 4;
+		cnt -= 4;
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i=0, cp=wp; i<4 && cnt>0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i<4; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *)cp);
+	}
+
+	return (write_word(info, wp, data));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word (flash_info_t *info, ulong dest, ulong data)
+{
+	volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *)(info->start[0]);
+	volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *)dest;
+	volatile CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *)&data;
+	ulong start;
+	int flag;
+	int i;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*((volatile ulong *)dest) & data) != data) {
+		return (2);
+	}
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	for (i=0; i<4/sizeof(CFG_FLASH_WORD_SIZE); i++)
+	  {
+	    addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00AA00AA;
+	    addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE)0x00550055;
+	    addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE)0x00A000A0;
+
+	    dest2[i] = data2[i];
+
+	    /* re-enable interrupts if necessary */
+	    if (flag)
+	      enable_interrupts();
+
+	    /* data polling for D7 */
+	    start = get_timer (0);
+	    while ((dest2[i] & (CFG_FLASH_WORD_SIZE)0x00800080) !=
+		   (data2[i] & (CFG_FLASH_WORD_SIZE)0x00800080)) {
+	      if (get_timer(start) > CFG_FLASH_WRITE_TOUT) {
+		return (1);
+	      }
+	    }
+	  }
+
+	return (0);
+}
diff -uNr u-boot-1.1.2/board/emetec405/pllmr.c u-boot-emetec-1.1.2/board/emetec405/pllmr.c
--- u-boot-1.1.2/board/emetec405/pllmr.c	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/board/emetec405/pllmr.c	2005-03-14 22:32:04.000000000 +0200
@@ -0,0 +1,19 @@
+#define PLL_CPUDIV_1               0x00000000
+#define PLL_PLBDIV_2               0x00010000
+#define PLL_OPBDIV_2               0x00001000
+#define PLL_EXTBUSDIV_3            0x00000100
+#define PLL_MALDIV_1               0x00000000
+#define PLL_PCIDIV_4               0x00000003
+
+#define PLL_FBKDIV_8               0x00800000
+#define PLL_FWDDIVA_4              0x00040000
+#define PLL_FWDDIVB_4              0x00004000
+#define PLL_TUNE_15_M_40           0x0000023E     /* 14 <  M <= 40              */
+#define PLL_TUNE_VCO_LOW           0x00000000     /* 500MHz <= VCO <=  800MHz   */
+
+#define PLLMR0_200_100_50_25 (PLL_CPUDIV_1 | PLL_PLBDIV_2 |  \
+			      PLL_OPBDIV_2 | PLL_EXTBUSDIV_3 |  \
+			      PLL_MALDIV_1 | PLL_PCIDIV_4)
+#define PLLMR1_200_100_50_25 (PLL_FBKDIV_8  |  \
+			      PLL_FWDDIVA_4 | PLL_FWDDIVB_4 |  \
+			      PLL_TUNE_15_M_40 | PLL_TUNE_VCO_LOW)
diff -uNr u-boot-1.1.2/board/emetec405/u-boot.lds u-boot-emetec-1.1.2/board/emetec405/u-boot.lds
--- u-boot-1.1.2/board/emetec405/u-boot.lds	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/board/emetec405/u-boot.lds	2003-09-12 11:41:39.000000000 +0300
@@ -0,0 +1,147 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    /* WARNING - the following is hand-optimized to fit within	*/
+    /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+
+    cpu/ppc4xx/start.o	(.text)
+    cpu/ppc4xx/traps.o	(.text)
+    cpu/ppc4xx/interrupts.o	(.text)
+    cpu/ppc4xx/serial.o	(.text)
+    cpu/ppc4xx/cpu_init.o	(.text)
+    cpu/ppc4xx/speed.o	(.text)
+    cpu/ppc4xx/405gp_enet.o	(.text)
+    common/dlmalloc.o	(.text)
+    lib_generic/crc32.o		(.text)
+    lib_ppc/extable.o	(.text)
+    lib_generic/zlib.o		(.text)
+
+/*    . = env_offset;*/
+/*    common/environment.o(.text)*/
+
+    *(.text)
+    *(.fixup)
+    *(.got1)
+  }
+  _etext = .;
+  PROVIDE (etext = .);
+  .rodata    :
+  {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >>2;
+  __fixup_entries = (. - _FIXUP_TABLE_)>>2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
diff -uNr u-boot-1.1.2/copy.sh u-boot-emetec-1.1.2/copy.sh
--- u-boot-1.1.2/copy.sh	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/copy.sh	2005-03-17 23:26:42.000000000 +0200
@@ -0,0 +1,2 @@
+cp u-boot.bin /home/admin/uboot/uboot_v6.bin
+cp u-boot.srec /home/admin/uboot/uboot_v6.srec
diff -uNr u-boot-1.1.2/cpu/ppc4xx/405gp_enet.c u-boot-emetec-1.1.2/cpu/ppc4xx/405gp_enet.c
--- u-boot-1.1.2/cpu/ppc4xx/405gp_enet.c	2004-07-02 17:36:35.000000000 +0300
+++ u-boot-emetec-1.1.2/cpu/ppc4xx/405gp_enet.c	2005-05-06 18:07:02.000000000 +0300
@@ -133,7 +133,7 @@
 /*-----------------------------------------------------------------------------+
  * Prototypes and externals.
  *-----------------------------------------------------------------------------*/
-static void enet_rcv (struct eth_device *dev, unsigned long malisr);
+static void  enet_rcv (struct eth_device *dev, unsigned long malisr);
 
 int enetInt (struct eth_device *dev);
 static void mal_err (struct eth_device *dev, unsigned long isr,
@@ -190,11 +190,15 @@
 	unsigned short reg_short;
 
 	EMAC_405_HW_PST hw_p = dev->priv;
+	
+	puts ("Test 1\n");
 	/* before doing anything, figure out if we have a MAC address */
 	/* if not, bail */
 	if (memcmp (dev->enetaddr, "\0\0\0\0\0\0", 6) == 0)
 		return -1;
 
+	puts ("Test 2\n");
+		
 	msr = mfmsr ();
 	mtmsr (msr & ~(MSR_EE));	/* disable interrupts */
 
@@ -1023,6 +1027,8 @@
 #else
 		emac0_dev = dev;
 #endif
+		// print device name
+		printf("%s\n", dev->name);
 
 	}			/* end for each supported device */
 
diff -uNr u-boot-1.1.2/cpu/pxa/config.mk u-boot-emetec-1.1.2/cpu/pxa/config.mk
--- u-boot-1.1.2/cpu/pxa/config.mk	2007-04-20 00:01:06.000000000 +0300
+++ u-boot-emetec-1.1.2/cpu/pxa/config.mk	2003-05-23 15:36:21.000000000 +0300
@@ -23,6 +23,6 @@
 #
 
 PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
-	-msoft-float
+	-mshort-load-bytes -msoft-float
 
 PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4 -mtune=strongarm1100
diff -uNr u-boot-1.1.2/include/configs/EMETEC405.h u-boot-emetec-1.1.2/include/configs/EMETEC405.h
--- u-boot-1.1.2/include/configs/EMETEC405.h	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/include/configs/EMETEC405.h	2005-05-25 10:08:39.000000000 +0300
@@ -0,0 +1,349 @@
+/*
+ * (C) Copyright 2001-2003
+ * Stefan Roese, esd gmbh germany, stefan.roese@esd-electronics.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * board/config.h - configuration options, board specific
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define FLASH_8MB		1
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_405EP		1	/* This is a PPC405 CPU		*/
+#define CONFIG_4xx		1	/* ...member of PPC4xx family	*/
+#define CONFIG_EMETEC405	1	/* ...on a EMETEC405 board		*/
+
+#define CONFIG_BOARD_EARLY_INIT_F 1	/* call board_early_init_f()	*/
+#define CONFIG_MISC_INIT_R	1	/* call misc_init_r()		*/
+
+#define CONFIG_SYS_CLK_FREQ	25000000 /* external frequency to pll	*/
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BOOTDELAY	3	/* autoboot after 3 seconds	*/
+
+#undef	CONFIG_BOOTARGS
+#undef  CONFIG_BOOTCOMMAND
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"ramargs=setenv bootargs console=ttyS0,115200 "	\
+		"root=/dev/ram rw\0"					\
+	"flash_mem=run ramargs;"					\
+		"bootm $(kernel_addr) $(ramdisk_addr)\0"		\
+	"kernel_addr=ffC00000\0"					\
+	"ramdisk_addr=ffCE0000\0"					\
+	""
+#define CONFIG_BOOTCOMMAND	"run flash_mem"
+
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+#define CONFIG_MII		1	/* MII PHY management		*/
+#define CONFIG_PHY_ADDR		0	/* PHY address			*/
+
+#define CONFIG_COMMANDS	      ( CONFIG_CMD_DFL	| \
+				CFG_CMD_NET	| \
+				CFG_CMD_DHCP	| \
+				CFG_CMD_IRQ	| \
+				CFG_CMD_ELF	| \
+				CFG_CMD_I2C	| \
+				CFG_CMD_PING	| \
+				CFG_CMD_EEPROM	)
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#undef	CONFIG_WATCHDOG			/* watchdog disabled		*/
+
+#define CONFIG_SDRAM_BANK0	1	/* init onboard SDRAM bank 0	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP			/* undef to save memory		*/
+#define CFG_PROMPT	"=> "		/* Monitor Command Prompt	*/
+
+#undef	CFG_HUSH_PARSER			/* use "hush" command parser	*/
+#ifdef	CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2	"> "
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CBSIZE	1024		/* Console I/O Buffer Size	*/
+#else
+#define CFG_CBSIZE	256		/* Console I/O Buffer Size	*/
+#endif
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS	16		/* max number of command args	*/
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_DEVICE_NULLDEV	1	/* include nulldev device	*/
+
+#define CFG_CONSOLE_INFO_QUIET	1	/* don't print console @ startup*/
+
+#define CFG_MEMTEST_START	0x0400000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
+
+#undef	CFG_EXT_SERIAL_CLOCK	        /* no external serial clock used */
+#define CFG_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
+#define CFG_BASE_BAUD	    691200
+
+/* The following table includes the supported baudrates */
+#define CFG_BAUDRATE_TABLE	\
+	{ 300, 600, 1200, 2400, 4800, 9600, 19200, 38400,     \
+	 57600, 115200, 230400, 460800, 921600 }
+
+#define CFG_LOAD_ADDR	0x100000	/* default load address */
+#define CFG_EXTBDINFO	1		/* To use extended board_into (bd_t) */
+
+#define CFG_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+#define CONFIG_VERSION_VARIABLE 1	/* include version env variable */
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffer on 405 emac */
+
+/* Ethernet stuff */
+#define CONFIG_ENV_OVERWRITE 		/* Let the user to change the Ethernet MAC addresses */
+#define CONFIG_ETHADDR		00:50:C2:1E:AF:FE
+
+#define CONFIG_IPADDR		192.168.0.50
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_SERVERIP		192.168.0.1
+
+/*-----------------------------------------------------------------------
+ * PCI stuff
+ *-----------------------------------------------------------------------
+ */
+#define PCI_HOST_ADAPTER 0		// configure as pci adapter
+#define PCI_HOST_FORCE	1		// configure as pci host
+#define PCI_HOST_AUTO	2		// detected via arbiter enable
+
+#define CONFIG_PCI			// include pci support
+#define CONFIG_PCI_HOST PCI_HOST_FORCE	// select pci host function
+#define CONFIG_PCI_PNP			// do pci plug-and-play
+
+
+#define CFG_PCI_SUBSYS_VENDORID 0x0000		// PCI Vendor ID: IBM
+#define CFG_PCI_SUBSYS_DEVICEID 0x0000		// PCI Device ID: 405GP
+#define CFG_PCI_PTM1LA		0x00000000	// point to sdram
+#define CFG_PCI_PTM1MS		0x80000001	// 2GB, enable hard-wired to 1
+#define CFG_PCI_PTM1PCI 	0x00000000      // Host: use this pci address
+#define CFG_PCI_PTM2LA		0x00000000	// disabled
+#define CFG_PCI_PTM2MS		0x00000000	// disabled
+#define CFG_PCI_PTM2PCI 	0x00000000      // Host: use this pci address
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * (Set up by the startup code)
+ * Please note that CFG_SDRAM_BASE _must_ start at 0
+ */
+ 
+/*
+ * Flash configuration (8,16 or 32 MB)
+ * TEXT base always at 0xFFF00000
+ * ENV_ADDR always at  0xFFF40000
+ * FLASH_BASE at 0xFE000000 for 32 MB
+ *               0xFF000000 for 16 MB
+ *               0xFF800000 for  8 MB
+ *               0xFFC00000 for  4 MB
+ */
+ 
+#define CFG_SDRAM_BASE		0x00000000
+#define CFG_FLASH_BASE		0xFFFC0000
+#define CFG_MONITOR_BASE	CFG_FLASH_BASE
+#define CFG_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Monitor	*/
+#define CFG_MALLOC_LEN		(256 * 1024)	/* Reserve 256 kB for malloc()	*/
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ		(8 << 20)	/* Initial Memory map for Linux */
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip	*/
+
+#define CFG_FLASH_ERASE_TOUT	120000	/* Timeout for Flash Erase (in ms)	*/
+#define CFG_FLASH_WRITE_TOUT	1000	/* Timeout for Flash Write (in ms)	*/
+
+#define CFG_FLASH_WORD_SIZE	unsigned short	/* flash word size (width)	*/
+#define CFG_FLASH_ADDR0		0x5555	/* 1st address for flash config cycles	*/
+#define CFG_FLASH_ADDR1		0x2AAA	/* 2nd address for flash config cycles	*/
+/*
+ * The following defines are added for buggy IOP480 byte interface.
+ * All other boards should use the standard values (CPCI405 etc.)
+ */
+#define CFG_FLASH_READ0		0x0000	/* 0 is standard			*/
+#define CFG_FLASH_READ1		0x0001	/* 1 is standard			*/
+#define CFG_FLASH_READ2		0x0002	/* 2 is standard			*/
+
+#define CFG_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+
+/*
+#define	CFG_ENV_IS_IN_FLASH	1
+//Address and size of Primary Environment Sector
+#define CFG_ENV_ADDR		0xFFFFA000
+#define CFG_ENV_SIZE		0x2000
+*/
+
+/*-----------------------------------------------------------------------
+ * Environment Variable setup
+ */
+#define CFG_ENV_IS_IN_EEPROM	1	// use EEPROM for environment vars
+#define CFG_ENV_OFFSET		0x100	// environment starts at the beginning of the EEPROM
+#define CFG_ENV_SIZE		0x700	// 2048 bytes may be used for env vars
+
+/*-----------------------------------------------------------------------
+ * I2C EEPROM (CAT24WC16) for environment
+ */
+#define CONFIG_HARD_I2C			// I2c with hardware support
+#define CFG_I2C_SPEED		400000	// I2C speed and slave address
+#define CFG_I2C_SLAVE		0x7F
+
+#define CFG_I2C_EEPROM_ADDR	0x50	// EEPROM CAT28WC08
+#define CFG_I2C_EEPROM_ADDR_LEN 1	// Bytes of address
+
+#define CFG_I2C_EEPROM_ADDR_OVERFLOW	0x07
+#define CFG_EEPROM_PAGE_WRITE_BITS 4	// The Catalyst CAT24WC08 has
+					// 16 byte page write mode using
+					// last 4 bits of the address
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	10   // and takes up to 10 msec
+#define CFG_EEPROM_PAGE_WRITE_ENABLE
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384	/* For IBM 405 CPUs, older 405 ppc's	*/
+					/* have only 8kB, 16kB is save here	*/
+#define CFG_CACHELINE_SIZE	32	/* ...			*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	/* log base 2 of the above value	*/
+#endif
+
+/*
+ * Init Memory Controller:
+ *
+ * BR0/1 and OR0/1 (FLASH)
+ */
+
+#if FLASH_8MB == 1
+#define FLASH_BASE0_PRELIM	0xFF800000	/* FLASH bank #0	*/
+#else
+#define FLASH_BASE0_PRELIM	0xFFC00000	/* FLASH bank #0	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * External Bus Controller (EBC) Setup
+ */
+
+/* Memory Bank 0 (Flash Bank 0)  initialization			*/
+#if FLASH_8MB == 1
+#define CFG_EBC_PB0AP		0x92015480
+#define CFG_EBC_PB0CR		0xFFC5B000  /* BAS=0xFFC,BS=8MB,BU=R/W,BW=16bit */
+#else
+#define CFG_EBC_PB0AP		0x92015480
+#define CFG_EBC_PB0CR		0xFFC5A000  /* BAS=0xFFC,BS=4MB,BU=R/W,BW=16bit */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Definitions for initial stack pointer and data area (in data cache)
+ */
+/* use on chip memory ( OCM ) for temperary stack until sdram is tested */
+#define CFG_TEMP_STACK_OCM	  1
+
+/* On Chip Memory location */
+#define CFG_OCM_DATA_ADDR	0xF8000000
+#define CFG_OCM_DATA_SIZE	0x1000
+#define CFG_INIT_RAM_ADDR	CFG_OCM_DATA_ADDR /* inside of SDRAM		*/
+#define CFG_INIT_RAM_END	CFG_OCM_DATA_SIZE /* End of used area in RAM	*/
+
+#define CFG_GBL_DATA_SIZE      128  /* size in bytes reserved for initial data */
+#define CFG_GBL_DATA_OFFSET    (CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+/*-----------------------------------------------------------------------
+ * Definitions for GPIO setup (PPC405EP specific)
+ *
+ * GPIO0[0]	- External Bus Controller BLAST output
+ * GPIO0[1-9]	- Instruction trace outputs -> GPIO
+ * GPIO0[10-13] - External Bus Controller CS_1 - CS_4 outputs
+ * GPIO0[14-16] - External Bus Controller ABUS3-ABUS5 outputs -> GPIO
+ * GPIO0[17-23] - External Interrupts IRQ0 - IRQ6 inputs
+ * GPIO0[24-27] - UART0 control signal inputs/outputs
+ * GPIO0[28-29] - UART1 data signal input/output
+ * GPIO0[30-31] - EMAC0 and EMAC1 reject packet inputs
+ */
+#define CFG_GPIO0_OSRH		0x40000550
+#define CFG_GPIO0_OSRL		0x00000110
+#define CFG_GPIO0_ISR1H		0x00000000
+#define CFG_GPIO0_ISR1L		0x15555445
+#define CFG_GPIO0_TSRH		0x00000000
+#define CFG_GPIO0_TSRL		0x00000000
+#define CFG_GPIO0_TCR		0xF7FE0014
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH	*/
+#define BOOTFLAG_WARM	0x02		/* Software reboot			*/
+
+#define PLL_CPUDIV_1               0x00000000
+#define PLL_PLBDIV_2               0x00010000
+#define PLL_OPBDIV_2               0x00001000
+
+#define PLL_EXTBUSDIV_4            0x00000200
+
+#define PLL_MALDIV_1               0x00000000
+#define PLL_PCIDIV_2               0x00000001
+#define PLL_PCIDIV_4               0x00000003
+
+#define PLL_FBKDIV_8               0x00800000
+
+#define PLL_FWDDIVA_4              0x00040000
+#define PLL_FWDDIVB_4              0x00004000
+#define PLL_TUNE_15_M_40           0x0000023E     /* 14 <  M <= 40              */
+#define PLL_TUNE_VCO_LOW           0x00000000     /* 500MHz <= VCO <=  800MHz   */
+
+#define PLLMR0_200_100_50_25 (PLL_CPUDIV_1 | PLL_PLBDIV_2 |  \
+			      PLL_OPBDIV_2 | PLL_EXTBUSDIV_4 |  \
+			      PLL_MALDIV_1 | PLL_PCIDIV_4)
+#define PLLMR1_200_100_50_25 (PLL_FBKDIV_8  |  \
+			      PLL_FWDDIVA_4 | PLL_FWDDIVB_4 |  \
+			      PLL_TUNE_15_M_40 | PLL_TUNE_VCO_LOW)
+/*
+ * Default speed selection (cpu_plb_opb_ebc) in mhz.
+ * This value will be set if iic boot eprom is disabled.
+ */
+#define PLLMR0_DEFAULT   PLLMR0_200_100_50_25
+#define PLLMR1_DEFAULT   PLLMR1_200_100_50_25
+
+#endif	/* __CONFIG_H */
diff -uNr u-boot-1.1.2/include/configs/EMETEC405.h.old u-boot-emetec-1.1.2/include/configs/EMETEC405.h.old
--- u-boot-1.1.2/include/configs/EMETEC405.h.old	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/include/configs/EMETEC405.h.old	2005-03-17 23:00:33.000000000 +0200
@@ -0,0 +1,349 @@
+/*
+ * (C) Copyright 2001-2003
+ * Stefan Roese, esd gmbh germany, stefan.roese@esd-electronics.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * board/config.h - configuration options, board specific
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_405EP		1	/* This is a PPC405 CPU		*/
+#define CONFIG_4xx		1	/* ...member of PPC4xx family	*/
+#define CONFIG_EMETEC405	1	/* ...on a EMETEC405 board		*/
+
+#define CONFIG_BOARD_EARLY_INIT_F 1	/* call board_early_init_f()	*/
+#define CONFIG_MISC_INIT_R	1	/* call misc_init_r()		*/
+
+#define CONFIG_SYS_CLK_FREQ	25000000 /* external frequency to pll	*/
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BOOTDELAY	3	/* autoboot after 3 seconds	*/
+
+#undef	CONFIG_BOOTARGS
+#undef  CONFIG_BOOTCOMMAND
+
+#define CONFIG_PREBOOT                  /* enable preboot variable      */
+
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+#define CONFIG_MII		1	/* MII PHY management		*/
+#define CONFIG_PHY_ADDR		0	/* PHY address			*/
+#define CONFIG_LXT971_NO_SLEEP  1       /* disable sleep mode in LXT971 */
+
+/*
+#define CONFIG_PHY_CLK_FREQ	EMAC_STACR_CLK_66MHZ // 66 MHz OPB clock
+*/
+
+#define CONFIG_COMMANDS	      ( CONFIG_CMD_DFL	| \
+				CFG_CMD_DHCP	| \
+				CFG_CMD_IRQ	| \
+				CFG_CMD_ELF	| \
+				CFG_CMD_I2C	| \
+				CFG_CMD_MII	| \
+				CFG_CMD_PING	| \
+				CFG_CMD_EEPROM	)
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#undef	CONFIG_WATCHDOG			/* watchdog disabled		*/
+
+#define CONFIG_SDRAM_BANK0	1	/* init onboard SDRAM bank 0	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP			/* undef to save memory		*/
+#define CFG_PROMPT	"=> "		/* Monitor Command Prompt	*/
+
+#undef	CFG_HUSH_PARSER			/* use "hush" command parser	*/
+#ifdef	CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2	"> "
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CBSIZE	1024		/* Console I/O Buffer Size	*/
+#else
+#define CFG_CBSIZE	256		/* Console I/O Buffer Size	*/
+#endif
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS	16		/* max number of command args	*/
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_DEVICE_NULLDEV	1	/* include nulldev device	*/
+
+#define CFG_CONSOLE_INFO_QUIET	1	/* don't print console @ startup*/
+
+#define CFG_MEMTEST_START	0x0400000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
+
+#undef	CFG_EXT_SERIAL_CLOCK	       /* no external serial clock used */
+#define CFG_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
+#define CFG_BASE_BAUD	    691200
+#undef	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
+
+/* The following table includes the supported baudrates */
+#define CFG_BAUDRATE_TABLE	\
+	{ 300, 600, 1200, 2400, 4800, 9600, 19200, 38400,     \
+	 57600, 115200, 230400, 460800, 921600 }
+
+#define CFG_LOAD_ADDR	0x100000	/* default load address */
+#define CFG_EXTBDINFO	1		/* To use extended board_into (bd_t) */
+
+#define CFG_HZ		1000		/* decrementer freq: 1 ms ticks */
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+#define CONFIG_VERSION_VARIABLE 1	/* include version env variable */
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffer on 405 emac */
+
+/* Ethernet stuff */
+#define CONFIG_ENV_OVERWRITE /* Let the user to change the Ethernet MAC addresses */
+#define CONFIG_ETHADDR	00:50:C2:1E:AF:FE
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR 00:50:C2:1E:AF:FD
+
+#define CONFIG_IPADDR		192.168.0.50
+#define CONFIG_IP1ADDR		192.168.0.51
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_SERVERIP		192.168.0.1
+
+/*-----------------------------------------------------------------------
+ * PCI stuff
+ *-----------------------------------------------------------------------
+ */
+#define PCI_HOST_ADAPTER 0		/* configure as pci adapter	*/
+#define PCI_HOST_FORCE	1		/* configure as pci host	*/
+#define PCI_HOST_AUTO	2		/* detected via arbiter enable	*/
+
+#undef	CONFIG_PCI			/* include pci support		*/
+#define CONFIG_PCI_HOST PCI_HOST_HOST	/* select pci host function	*/
+#undef	CONFIG_PCI_PNP			/* do pci plug-and-play		*/
+					/* resource configuration	*/
+
+#undef	CONFIG_PCI_SCAN_SHOW		/* print pci devices @ startup	*/
+
+#define CFG_PCI_SUBSYS_VENDORID 0x12FE	/* PCI Vendor ID: esd gmbh	*/
+#define CFG_PCI_SUBSYS_DEVICEID 0x0405	/* PCI Device ID: CPCI-405	*/
+#define CFG_PCI_CLASSCODE	0x0b20	/* PCI Class Code: Processor/PPC*/
+#define CFG_PCI_PTM1LA	0x00000000	/* point to sdram		*/
+#define CFG_PCI_PTM1MS	0xfc000001	/* 64MB, enable hard-wired to 1 */
+#define CFG_PCI_PTM1PCI 0x00000000	/* Host: use this pci address	*/
+#define CFG_PCI_PTM2LA	0xffc00000	/* point to flash		*/
+#define CFG_PCI_PTM2MS	0xffc00001	/* 4MB, enable			*/
+#define CFG_PCI_PTM2PCI 0x04000000	/* Host: use this pci address	*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * (Set up by the startup code)
+ * Please note that CFG_SDRAM_BASE _must_ start at 0
+ */
+#define CFG_SDRAM_BASE		0x00000000
+#define CFG_FLASH_BASE		0xFFFC0000
+#define CFG_MONITOR_BASE	CFG_FLASH_BASE
+#define CFG_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Monitor	*/
+#define CFG_MALLOC_LEN		(256 * 1024)	/* Reserve 256 kB for malloc()	*/
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ		(8 << 20)	/* Initial Memory map for Linux */
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip	*/
+
+#define CFG_FLASH_ERASE_TOUT	120000	/* Timeout for Flash Erase (in ms)	*/
+#define CFG_FLASH_WRITE_TOUT	1000	/* Timeout for Flash Write (in ms)	*/
+
+#define CFG_FLASH_WORD_SIZE	unsigned short	/* flash word size (width)	*/
+#define CFG_FLASH_ADDR0		0x5555	/* 1st address for flash config cycles	*/
+#define CFG_FLASH_ADDR1		0x2AAA	/* 2nd address for flash config cycles	*/
+/*
+ * The following defines are added for buggy IOP480 byte interface.
+ * All other boards should use the standard values (CPCI405 etc.)
+ */
+#define CFG_FLASH_READ0		0x0000	/* 0 is standard			*/
+#define CFG_FLASH_READ1		0x0001	/* 1 is standard			*/
+#define CFG_FLASH_READ2		0x0002	/* 2 is standard			*/
+
+#define CFG_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+
+#if 0 /* test-only */
+#define CFG_JFFS2_FIRST_BANK	0	    /* use for JFFS2 */
+#define CFG_JFFS2_NUM_BANKS	1	    /* ! second bank contains U-Boot */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Environment Variable setup
+ */
+#define CFG_ENV_IS_IN_EEPROM	1	/* use EEPROM for environment vars */
+#define CFG_ENV_OFFSET		0x100	/* environment starts at the beginning of the EEPROM */
+#define CFG_ENV_SIZE		0x700	/* 2048 bytes may be used for env vars*/
+				   /* total size of a CAT24WC16 is 2048 bytes */
+
+#define CFG_NVRAM_BASE_ADDR	0xF0000500		/* NVRAM base address	*/
+#define CFG_NVRAM_SIZE		242			/* NVRAM size		*/
+
+/*-----------------------------------------------------------------------
+ * I2C EEPROM (CAT24WC16) for environment
+ */
+#define CONFIG_HARD_I2C			/* I2c with hardware support */
+#define CFG_I2C_SPEED		400000	/* I2C speed and slave address */
+#define CFG_I2C_SLAVE		0x7F
+
+#define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM CAT28WC08		*/
+#define CFG_I2C_EEPROM_ADDR_LEN 1	/* Bytes of address		*/
+/* mask of address bits that overflow into the "EEPROM chip address"	*/
+#define CFG_I2C_EEPROM_ADDR_OVERFLOW	0x07
+#define CFG_EEPROM_PAGE_WRITE_BITS 4	/* The Catalyst CAT24WC08 has	*/
+					/* 16 byte page write mode using*/
+					/* last 4 bits of the address	*/
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	10   /* and takes up to 10 msec */
+#define CFG_EEPROM_PAGE_WRITE_ENABLE
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384	/* For IBM 405 CPUs, older 405 ppc's	*/
+					/* have only 8kB, 16kB is save here	*/
+#define CFG_CACHELINE_SIZE	32	/* ...			*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	/* log base 2 of the above value	*/
+#endif
+
+/*
+ * Init Memory Controller:
+ *
+ * BR0/1 and OR0/1 (FLASH)
+ */
+
+#define FLASH_BASE0_PRELIM	0xFFC00000	/* FLASH bank #0	*/
+
+/*-----------------------------------------------------------------------
+ * External Bus Controller (EBC) Setup
+ */
+
+/* Memory Bank 0 (Flash Bank 0, NOR-FLASH) initialization			*/
+#define CFG_EBC_PB0AP		0x92015480
+#define CFG_EBC_PB0CR		0xFFC5A000  /* BAS=0xFFC,BS=4MB,BU=R/W,BW=16bit */
+
+#define DUART0_BA	0xF0000000	    /* DUART Base Address		*/
+#define DUART1_BA	0xF0000008	    /* DUART Base Address		*/
+#define DUART2_BA	0xF0000010	    /* DUART Base Address		*/
+#define DUART3_BA	0xF0000018	    /* DUART Base Address		*/
+
+/*-----------------------------------------------------------------------
+ * FPGA stuff
+ */
+#define CFG_FPGA_SPARTAN2	1	    /* using Xilinx Spartan 2 now    */
+#define CFG_FPGA_MAX_SIZE	128*1024    /* 128kByte is enough for XC2S50E*/
+
+/* FPGA program pin configuration */
+#define CFG_FPGA_PRG		0x04000000  /* FPGA program pin (ppc output) */
+#define CFG_FPGA_CLK		0x02000000  /* FPGA clk pin (ppc output)     */
+#define CFG_FPGA_DATA		0x01000000  /* FPGA data pin (ppc output)    */
+#define CFG_FPGA_INIT		0x00010000  /* FPGA init pin (ppc input)     */
+#define CFG_FPGA_DONE		0x00008000  /* FPGA done pin (ppc input)     */
+
+/*-----------------------------------------------------------------------
+ * Definitions for initial stack pointer and data area (in data cache)
+ */
+/* use on chip memory ( OCM ) for temperary stack until sdram is tested */
+#define CFG_TEMP_STACK_OCM	  1
+
+/* On Chip Memory location */
+#define CFG_OCM_DATA_ADDR	0xF8000000
+#define CFG_OCM_DATA_SIZE	0x1000
+#define CFG_INIT_RAM_ADDR	CFG_OCM_DATA_ADDR /* inside of SDRAM		*/
+#define CFG_INIT_RAM_END	CFG_OCM_DATA_SIZE /* End of used area in RAM	*/
+
+#define CFG_GBL_DATA_SIZE      128  /* size in bytes reserved for initial data */
+#define CFG_GBL_DATA_OFFSET    (CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+/*-----------------------------------------------------------------------
+ * Definitions for GPIO setup (PPC405EP specific)
+ *
+ * GPIO0[0]	- External Bus Controller BLAST output
+ * GPIO0[1-9]	- Instruction trace outputs -> GPIO
+ * GPIO0[10-13] - External Bus Controller CS_1 - CS_4 outputs
+ * GPIO0[14-16] - External Bus Controller ABUS3-ABUS5 outputs -> GPIO
+ * GPIO0[17-23] - External Interrupts IRQ0 - IRQ6 inputs
+ * GPIO0[24-27] - UART0 control signal inputs/outputs
+ * GPIO0[28-29] - UART1 data signal input/output
+ * GPIO0[30-31] - EMAC0 and EMAC1 reject packet inputs
+ */
+#define CFG_GPIO0_OSRH		0x40000550
+#define CFG_GPIO0_OSRL		0x00000110
+#define CFG_GPIO0_ISR1H		0x00000000
+#define CFG_GPIO0_ISR1L		0x15555445
+#define CFG_GPIO0_TSRH		0x00000000
+#define CFG_GPIO0_TSRL		0x00000000
+#define CFG_GPIO0_TCR		0xF7FE0014
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH	*/
+#define BOOTFLAG_WARM	0x02		/* Software reboot			*/
+
+#define PLL_CPUDIV_1               0x00000000
+#define PLL_PLBDIV_2               0x00010000
+#define PLL_OPBDIV_2               0x00001000
+#define PLL_EXTBUSDIV_3            0x00000100
+#define PLL_MALDIV_1               0x00000000
+#define PLL_PCIDIV_4               0x00000003
+
+#define PLL_FBKDIV_8               0x00800000
+#define PLL_FWDDIVA_4              0x00040000
+#define PLL_FWDDIVB_4              0x00004000
+#define PLL_TUNE_15_M_40           0x0000023E     /* 14 <  M <= 40              */
+#define PLL_TUNE_VCO_LOW           0x00000000     /* 500MHz <= VCO <=  800MHz   */
+
+#define PLLMR0_200_100_50_25 (PLL_CPUDIV_1 | PLL_PLBDIV_2 |  \
+			      PLL_OPBDIV_2 | PLL_EXTBUSDIV_3 |  \
+			      PLL_MALDIV_1 | PLL_PCIDIV_4)
+#define PLLMR1_200_100_50_25 (PLL_FBKDIV_8  |  \
+			      PLL_FWDDIVA_4 | PLL_FWDDIVB_4 |  \
+			      PLL_TUNE_15_M_40 | PLL_TUNE_VCO_LOW)
+/*
+ * Default speed selection (cpu_plb_opb_ebc) in mhz.
+ * This value will be set if iic boot eprom is disabled.
+ */
+#define PLLMR0_DEFAULT   PLLMR0_200_100_50_25
+#define PLLMR1_DEFAULT   PLLMR1_200_100_50_25
+
+#endif	/* __CONFIG_H */
diff -uNr u-boot-1.1.2/include/configs/HUB405.h u-boot-emetec-1.1.2/include/configs/HUB405.h
--- u-boot-1.1.2/include/configs/HUB405.h	2004-12-31 11:32:53.000000000 +0200
+++ u-boot-emetec-1.1.2/include/configs/HUB405.h	2005-03-11 22:19:12.000000000 +0200
@@ -35,7 +35,7 @@
 
 #define CONFIG_405EP		1	/* This is a PPC405 CPU		*/
 #define CONFIG_4xx		1	/* ...member of PPC4xx family	*/
-#define CONFIG_HUB405		1	/* ...on a HUB405 board		*/
+#define CONFIG_EMETEC405	1	/* ...on a EMETEC405 board		*/
 
 #define CONFIG_BOARD_EARLY_INIT_F 1	/* call board_early_init_f()	*/
 #define CONFIG_MISC_INIT_R	1	/* call misc_init_r()		*/
diff -uNr u-boot-1.1.2/include/flash.h u-boot-emetec-1.1.2/include/flash.h
--- u-boot-1.1.2/include/flash.h	2004-12-16 20:01:48.000000000 +0200
+++ u-boot-emetec-1.1.2/include/flash.h	2005-05-25 10:04:56.000000000 +0300
@@ -229,7 +229,11 @@
 
 #define STM_ID_x800AB	0x005B005B	/* M29W800AB ID (8M = 512K x 16 )	*/
 #define STM_ID_29W320DT 0x22CA22CA	/* M29W320DT ID (32 M, top boot sector) */
-#define STM_ID_29W320DB 0x22CB22CB	/* M29W320DB ID (32 M, bottom boot sect)	*/
+#define STM_ID_29W320DB 0x22CB22CB	/* M29W320DB ID (32 M, bottom boot sect)*/
+
+#define STM_ID_29W640DT 0x22DE22DE	/* M29W640DT ID (64 M, top boot sector) */
+#define STM_ID_29W640DB 0x22DF22DF	/* M29W640DB ID (64 M, bottom boot sect)*/
+
 #define STM_ID_29W040B	0x00E300E3	/* M29W040B ID (4M = 512K x 8)	*/
 
 #define INTEL_ID_28F016S    0x66a066a0	/* 28F016S[VS] ID (16M = 512k x 16)	*/
@@ -328,6 +332,8 @@
 #define FLASH_STM800AB	0x0051		/* STM M29WF800AB  (  8M = 512K x 16 )	*/
 #define FLASH_STMW320DT 0x0052		/* STM M29W320DT   (32 M, top boot sector)	*/
 #define FLASH_STMW320DB 0x0053		/* STM M29W320DB   (32 M, bottom boot sect)*/
+#define FLASH_STMW640DT 0x0054		/* STM M29W640DT   (64 M, top boot sector)	*/
+#define FLASH_STMW640DB 0x0055		/* STM M29W640DB   (64 M, bottom boot sect)*/
 #define FLASH_STM320DB	0x00CB		/* STM M29W320DB (4M = 64K x 64, bottom)*/
 #define FLASH_STM800DT	0x00D7		/* STM M29W800DT (1M = 64K x 16, top)	*/
 #define FLASH_STM800DB	0x005B		/* STM M29W800DB (1M = 64K x 16, bottom)*/
diff -uNr u-boot-1.1.2/include/net.h u-boot-emetec-1.1.2/include/net.h
--- u-boot-1.1.2/include/net.h	2004-10-10 00:56:21.000000000 +0300
+++ u-boot-emetec-1.1.2/include/net.h	2005-04-27 23:16:40.000000000 +0300
@@ -331,9 +331,9 @@
 #define NETLOOP_SUCCESS		3
 #define NETLOOP_FAIL		4
 
-#ifdef CONFIG_NET_MULTI
+/* #ifdef CONFIG_NET_MULTI */
 extern int		NetRestartWrap;		/* Tried all network devices	*/
-#endif
+/* #endif */
 
 typedef enum { BOOTP, RARP, ARP, TFTP, DHCP, PING, DNS, NFS, CDP, NETCONS } proto_t;
 
diff -uNr u-boot-1.1.2/lib_ppc/board.c u-boot-emetec-1.1.2/lib_ppc/board.c
--- u-boot-1.1.2/lib_ppc/board.c	2004-12-31 11:32:54.000000000 +0200
+++ u-boot-emetec-1.1.2/lib_ppc/board.c	2005-04-27 23:03:33.000000000 +0300
@@ -970,7 +970,8 @@
 	nand_init();		/* go init the NAND */
 #endif
 
-#if (CONFIG_COMMANDS & CFG_CMD_NET) && defined(CONFIG_NET_MULTI)
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET) /* && defined(CONFIG_NET_MULTI) */
 	WATCHDOG_RESET ();
 	puts ("Net:   ");
 	eth_initialize (bd);
diff -uNr u-boot-1.1.2/loadftp.sh u-boot-emetec-1.1.2/loadftp.sh
--- u-boot-1.1.2/loadftp.sh	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/loadftp.sh	2005-04-25 21:30:54.000000000 +0300
@@ -0,0 +1 @@
+cp u-boot.bin /home/ftp/uboot.bin
diff -uNr u-boot-1.1.2/loadwww.sh u-boot-emetec-1.1.2/loadwww.sh
--- u-boot-1.1.2/loadwww.sh	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-emetec-1.1.2/loadwww.sh	2005-03-12 13:06:19.000000000 +0200
@@ -0,0 +1,2 @@
+#!/bin/bash
+rsync -vzr --rsh='ssh -l admin -p 5522' /home/admin/uboot/ admin@mhaber.net:/home/admin/uboot
diff -uNr u-boot-1.1.2/net/eth.c u-boot-emetec-1.1.2/net/eth.c
--- u-boot-1.1.2/net/eth.c	2004-12-16 19:49:38.000000000 +0200
+++ u-boot-emetec-1.1.2/net/eth.c	2005-05-06 18:04:08.000000000 +0300
@@ -25,7 +25,7 @@
 #include <command.h>
 #include <net.h>
 
-#if (CONFIG_COMMANDS & CFG_CMD_NET) && defined(CONFIG_NET_MULTI)
+#if (CONFIG_COMMANDS & CFG_CMD_NET) /* && defined(CONFIG_NET_MULTI) */
 
 #ifdef CFG_GT_6426x
 extern int gt6426x_eth_initialize(bd_t *bis);
@@ -126,10 +126,13 @@
 #ifdef CONFIG_DB64460
 	mv6446x_eth_initialize(bis);
 #endif
+
 #if defined(CONFIG_405GP) || defined(CONFIG_405EP) || \
   ( defined(CONFIG_440) && !defined(CONFIG_NET_MULTI) )
 	ppc_4xx_eth_initialize(bis);
+	eth_number=1;
 #endif
+
 #if defined(CONFIG_440) && defined(CONFIG_NET_MULTI)
 	ppc_440x_eth_initialize(bis);
 #endif
@@ -197,6 +200,7 @@
 	rtl8169_initialize(bis);
 #endif
 
+#if defined(CONFIG_NET_MULTI)
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
 	} else {
@@ -248,7 +252,6 @@
 			dev = dev->next;
 		} while(dev != eth_devices);
 
-#ifdef CONFIG_NET_MULTI
 		/* update current ethernet name */
 		if (eth_current) {
 			char *act = getenv("ethact");
@@ -256,14 +259,14 @@
 				setenv("ethact", eth_current->name);
 		} else
 			setenv("ethact", NULL);
-#endif
-
 		putc ('\n');
 	}
+#endif
 
 	return eth_number;
 }
 
+#ifdef CONFIG_NET_MULTI
 void eth_set_enetaddr(int num, char *addr) {
 	struct eth_device *dev;
 	unsigned char enetaddr[6];
@@ -362,21 +365,20 @@
 
 	eth_current = eth_current->next;
 
-#ifdef CONFIG_NET_MULTI
+//#ifdef CONFIG_NET_MULTI
 	/* update current ethernet name */
 	{
 		char *act = getenv("ethact");
 		if (act == NULL || strcmp(act, eth_current->name) != 0)
 			setenv("ethact", eth_current->name);
 	}
-#endif
+//#endif
 
 	if (first_failed == eth_current) {
 		NetRestartWrap = 1;
 	}
 }
 
-#ifdef CONFIG_NET_MULTI
 void eth_set_current(void)
 {
 	char *act;
@@ -397,10 +399,11 @@
 
 	setenv("ethact", eth_current->name);
 }
-#endif
 
 char *eth_get_name (void)
 {
 	return (eth_current ? eth_current->name : "unknown");
 }
 #endif
+
+#endif
diff -uNr u-boot-1.1.2/net/net.c u-boot-emetec-1.1.2/net/net.c
--- u-boot-1.1.2/net/net.c	2004-10-12 01:51:14.000000000 +0300
+++ u-boot-emetec-1.1.2/net/net.c	2005-04-27 23:34:20.000000000 +0300
@@ -126,11 +126,11 @@
 			{ 0x01, 0x00, 0x0c, 0xcc, 0xcc, 0xcc };
 #endif
 int		NetState;		/* Network loop state			*/
-#ifdef CONFIG_NET_MULTI
+/* #ifdef CONFIG_NET_MULTI */
 int		NetRestartWrap = 0;	/* Tried all network devices		*/
 static int	NetRestarted = 0;	/* Network loop restarted		*/
 static int	NetDevExists = 0;	/* At least one device configured	*/
-#endif
+/* #endif */
 
 /* XXX in both little & big endian machines 0xFFFF == ntohs(-1) */
 ushort		NetOurVLAN = 0xFFFF;		/* default is without VLAN	*/
diff -uNr u-boot-1.1.2/patches/arm_flags.patch u-boot-emetec-1.1.2/patches/arm_flags.patch
--- u-boot-1.1.2/patches/arm_flags.patch	2007-04-20 00:01:06.000000000 +0300
+++ u-boot-emetec-1.1.2/patches/arm_flags.patch	1970-01-01 02:00:00.000000000 +0200
@@ -1,15 +0,0 @@
-
-#
-# Patch managed by http://www.holgerschurig.de/patcher.html
-#
-
---- u-boot-1.1.2/cpu/pxa/config.mk~armflags
-+++ u-boot-1.1.2/cpu/pxa/config.mk
-@@ -23,6 +23,6 @@
- #
- 
- PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
--	-mshort-load-bytes -msoft-float
-+	-msoft-float
- 
- PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4 -mtune=strongarm1100
diff -uNr u-boot-1.1.2/patches/series u-boot-emetec-1.1.2/patches/series
--- u-boot-1.1.2/patches/series	2007-04-20 00:01:06.000000000 +0300
+++ u-boot-emetec-1.1.2/patches/series	1970-01-01 02:00:00.000000000 +0200
@@ -1 +0,0 @@
-arm_flags.patch -p1
diff -uNr u-boot-1.1.2/lib_ppc/board.c new-uboot-1.1.2/lib_ppc/board.c
--- u-boot-1.1.2/lib_ppc/board.c	2005-04-27 23:03:33.000000000 +0300
+++ new-uboot-1.1.2/lib_ppc/board.c	2007-04-20 00:55:16.000000000 +0300
@@ -347,6 +347,7 @@
 
 	bd_t *bd;
 	ulong len, addr, addr_sp;
+        ulong *s;
 	gd_t *id;
 	init_fnc_t **init_fnc_ptr;
 #ifdef CONFIG_PRAM
@@ -466,8 +467,10 @@
 	 */
 	addr_sp -= 16;
 	addr_sp &= ~0xF;
-	*((ulong *) addr_sp)-- = 0;
-	*((ulong *) addr_sp)-- = 0;
+        s = (ulong *)addr_sp;
+        *s-- = 0;
+        *s-- = 0;
+        addr_sp = (ulong)s;
 	debug ("Stack Pointer at: %08lx\n", addr_sp);
 
 	/*
diff -uNr u-boot-1.1.2/net/net.c new-uboot-1.1.2/net/net.c
--- u-boot-1.1.2/net/net.c	2005-04-27 23:34:20.000000000 +0300
+++ new-uboot-1.1.2/net/net.c	2007-04-20 01:00:26.000000000 +0300
@@ -1491,14 +1491,17 @@
 unsigned
 NetCksum(uchar * ptr, int len)
 {
-	ulong	xsum;
 
-	xsum = 0;
-	while (len-- > 0)
-		xsum += *((ushort *)ptr)++;
-	xsum = (xsum & 0xffff) + (xsum >> 16);
-	xsum = (xsum & 0xffff) + (xsum >> 16);
-	return (xsum & 0xffff);
+        ulong   xsum;
+        ushort *p = (ushort *)ptr;
+
+        xsum = 0;
+        while (len-- > 0)
+                xsum += *p++;
+        xsum = (xsum & 0xffff) + (xsum >> 16);
+        xsum = (xsum & 0xffff) + (xsum >> 16);
+        return (xsum & 0xffff);
+
 }
 
 int
diff -uNr u-boot-1.1.2/net/tftp.c new-uboot-1.1.2/net/tftp.c
--- u-boot-1.1.2/net/tftp.c	2004-04-16 00:48:55.000000000 +0300
+++ new-uboot-1.1.2/net/tftp.c	2005-12-16 18:39:27.000000000 +0200
@@ -58,7 +58,7 @@
 static char *tftp_filename;
 
 #ifdef CFG_DIRECT_FLASH_TFTP
-extern flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+extern flash_info_t flash_info[];
 #endif
 
 static __inline__ void
@@ -78,7 +78,7 @@
 	}
 
 	if (rc) { /* Flash is destination for this packet */
-		rc = flash_write ((uchar *)src, (ulong)(load_addr+offset), len);
+		rc = flash_write ((char *)src, (ulong)(load_addr+offset), len);
 		if (rc) {
 			flash_perror (rc);
 			NetState = NETLOOP_FAIL;
@@ -106,6 +106,7 @@
 	volatile uchar *	pkt;
 	volatile uchar *	xp;
 	int			len = 0;
+	volatile ushort *s;
 
 	/*
 	 *	We will always be sending some sort of packet, so
@@ -117,7 +118,9 @@
 
 	case STATE_RRQ:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_RRQ);
+		s = (ushort *)pkt;
+		*s++ = htons(TFTP_RRQ);
+		pkt = (uchar *)s;
 		strcpy ((char *)pkt, tftp_filename);
 		pkt += strlen(tftp_filename) + 1;
 		strcpy ((char *)pkt, "octet");
@@ -135,15 +138,19 @@
 	case STATE_DATA:
 	case STATE_OACK:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_ACK);
-		*((ushort *)pkt)++ = htons(TftpBlock);
+		s = (ushort *)pkt;
+		*s++ = htons(TFTP_ACK);
+		*s++ = htons(TftpBlock);
+		pkt = (uchar *)s;
 		len = pkt - xp;
 		break;
 
 	case STATE_TOO_LARGE:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_ERROR);
-		*((ushort *)pkt)++ = htons(3);
+		s = (ushort *)pkt;
+		*s++ = htons(TFTP_ERROR);
+		*s++ = htons(3);
+		pkt = (uchar *)s;
 		strcpy ((char *)pkt, "File too large");
 		pkt += 14 /*strlen("File too large")*/ + 1;
 		len = pkt - xp;
@@ -151,8 +158,10 @@
 
 	case STATE_BAD_MAGIC:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_ERROR);
-		*((ushort *)pkt)++ = htons(2);
+		s = (ushort *)pkt;
+		*s++ = htons(TFTP_ERROR);
+		*s++ = htons(2);
+		pkt = (uchar *)s;
 		strcpy ((char *)pkt, "File has bad magic");
 		pkt += 18 /*strlen("File has bad magic")*/ + 1;
 		len = pkt - xp;
@@ -167,6 +176,7 @@
 TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
 {
 	ushort proto;
+	ushort *s;
 
 	if (dest != TftpOurPort) {
 		return;
@@ -180,7 +190,9 @@
 	}
 	len -= 2;
 	/* warning: don't use increment (++) in ntohs() macros!! */
-	proto = *((ushort *)pkt)++;
+	s = (ushort *)pkt;
+	proto = *s++;
+	pkt = (uchar *)s;
 	switch (ntohs(proto)) {
 
 	case TFTP_RRQ:
@@ -301,14 +313,16 @@
 void
 TftpStart (void)
 {
-	if (BootFile[0] == '\0') {
-		IPaddr_t OurIP = ntohl(NetOurIP);
+#ifdef CONFIG_TFTP_PORT
+	char *ep;             /* Environment pointer */
+#endif
 
+	if (BootFile[0] == '\0') {
 		sprintf(default_filename, "%02lX%02lX%02lX%02lX.img",
-			OurIP & 0xFF,
-			(OurIP >>  8) & 0xFF,
-			(OurIP >> 16) & 0xFF,
-			(OurIP >> 24) & 0xFF	);
+			NetOurIP & 0xFF,
+			(NetOurIP >>  8) & 0xFF,
+			(NetOurIP >> 16) & 0xFF,
+			(NetOurIP >> 24) & 0xFF	);
 		tftp_filename = default_filename;
 
 		printf ("*** Warning: no boot file name; using '%s'\n",
@@ -354,7 +368,16 @@
 	TftpServerPort = WELL_KNOWN_PORT;
 	TftpTimeoutCount = 0;
 	TftpState = STATE_RRQ;
+	/* Use a pseudo-random port unless a specific port is set */
 	TftpOurPort = 1024 + (get_timer(0) % 3072);
+#ifdef CONFIG_TFTP_PORT
+	if ((ep = getenv("tftpdstp")) != NULL) {
+		TftpServerPort = simple_strtol(ep, NULL, 10);
+	}
+	if ((ep = getenv("tftpsrcp")) != NULL) {
+		TftpOurPort= simple_strtol(ep, NULL, 10);
+	}
+#endif
 	TftpBlock = 0;
 
 	/* zero out server ether in case the server ip has changed */
diff -uNr u-boot-1.1.2/board/emetec405/flash.c new-uboot-1.1.2/board/emetec405/flash.c
--- u-boot-1.1.2/board/emetec405/flash.c        2007-04-20 00:40:26.000000000 +0300
+++ new-uboot-1.1.2/board/emetec405/flash.c     2007-04-20 00:41:11.000000000 +0300
@@ -31,6 +31,7 @@
  */
 static ulong flash_get_size (vu_long * addr, flash_info_t * info);
 static void flash_get_offsets (ulong base, flash_info_t * info);
+static int write_word (flash_info_t *info, ulong dest, ulong data);
 
 /*-----------------------------------------------------------------------
  */
