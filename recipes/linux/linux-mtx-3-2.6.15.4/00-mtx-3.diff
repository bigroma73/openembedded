diff -Nur linux-2.6.15.4-orig/arch/arm/Kconfig linux-2.6.15.4/arch/arm/Kconfig
--- linux-2.6.15.4-orig/arch/arm/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/arch/arm/Kconfig	2006-08-09 14:22:58.000000000 +0200
@@ -215,6 +215,21 @@
 	help
 	  This enables support for systems based on the Agilent AAEC-2000
 
+config MACH_AT91SAM9261EK
+        bool "Atmel AT91SAM9261-EK board"
+        help
+          Say Y here if you intend to run this kernel on AT91SAM9261-EK.
+
+config MACH_AT91SAM9260EK
+        bool "Atmel AT91SAM9260-EK board"
+        help
+          Say Y here if you intend to run this kernel on AT91SAM9260-EK.
+
+config MACH_NADIA2VB
+        bool "Atmel NADIA2-VB board"
+        help
+          Say Y here if you intend to run this kernel on NADIA2-VB.
+
 endchoice
 
 source "arch/arm/mach-clps711x/Kconfig"
@@ -728,6 +743,10 @@
 
 source "drivers/char/Kconfig"
 
+if MACH_AT91SAM9261EK || MACH_AT91SAM9260EK || MACH_NADIA2VB
+source "drivers/spi/Kconfig"
+endif
+
 source "drivers/i2c/Kconfig"
 
 source "drivers/hwmon/Kconfig"
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/board-ek.c linux-2.6.15.4/arch/arm/mach-at91sam9260/board-ek.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/board-ek.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/board-ek.c	2006-08-09 10:53:02.000000000 +0200
@@ -0,0 +1,89 @@
+/*
+ * linux/arch/arm/mach-at91sam9260/board-ek.c
+ *
+ *  Copyright (C) 2005 SAN People
+ *
+ *  Epson S1D framebuffer glue code is:
+ *     Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/time.h>
+#include <asm/arch/board.h>
+
+
+extern void __init at91sam9260_init_irq(unsigned int priority[NR_IRQS]);
+extern void __init at91_gpio_irq_setup(unsigned banks);
+
+static void __init ek_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91sam9260_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(AT91_NR_PIO);
+}
+
+extern void __init at91sam9260_map_io(void);
+
+static void __init ek_map_io(void)
+{
+	at91sam9260_map_io();
+
+	/* Initialize clocks: 18.432 MHz crystal */
+	//at91_clock_init(AT91C_MASTER_CLOCK);
+
+}
+
+#if 0
+static struct at91_udc_data __initdata ek_udc_data = {
+	.vbus_pin	= AT91_PIN_PB29,
+	.pullup_pin	= AT91_PIN_PB30,
+};
+
+static void __init ek_board_init(void)
+{
+	/* USB Device */
+	at91_add_device_udc(&ek_udc_data);
+}
+#endif
+
+MACHINE_START(AT91SAM9260EK, "ATMEL AT91SAM9260")
+        .phys_ram       = AT91_SDRAM_BASE,
+        .phys_io        = AT91C_BASE_AIC,
+        .io_pg_offst    = ((AT91C_VA_BASE_SYS) >> 18) & 0xfffc,
+        .boot_params    = AT91_SDRAM_BASE + 0x100,
+        .map_io         = ek_map_io,
+        .init_irq       = ek_init_irq,
+	.timer		= &at91sam9260_timer,
+MACHINE_END
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/core.c linux-2.6.15.4/arch/arm/mach-at91sam9260/core.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/core.c	2006-08-09 10:53:03.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/core.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ * Revision 	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/time.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/sizes.h>
+#include <asm/page.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <asm/arch/time.h>
+#include <asm/arch/pmc.h>
+
+extern void __init at91sam9260_init_irq(void);
+
+
+/*
+ * System peripheral registers mapped at virtual address.
+ */
+
+static struct map_desc at91sam9260_io_desc[] __initdata = {
+	{ 
+		.virtual = AT91C_VA_BASE_SYS,
+		.pfn = __phys_to_pfn(AT91C_BASE_AIC),
+		.length = SZ_4K,
+		.type = MT_DEVICE
+	},
+	{ 
+		.virtual = AT91C_VA_BASE_EBI,
+		.pfn = __phys_to_pfn(AT91C_BASE_EBI),
+		.length = SZ_4K,
+		.type = MT_DEVICE
+	},
+	{ 
+		.virtual = AT91C_VA_BASE_UDP,
+		.pfn = __phys_to_pfn(AT91_BASE_UDP),
+		.length = SZ_16K,
+		.type = MT_DEVICE
+	}
+};
+
+
+void __init at91sam9260_map_io(void)
+{
+	iotable_init(at91sam9260_io_desc, ARRAY_SIZE(at91sam9260_io_desc));
+}
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/devices.c linux-2.6.15.4/arch/arm/mach-at91sam9260/devices.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/devices.c	2006-08-09 10:53:06.000000000 +0200
@@ -0,0 +1,234 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/devices.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ * Revision 	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/sizes.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91sam9260_usart.h>
+#include <asm/arch/at91sam9260_emac.h>
+#include <asm/arch/at91sam9260_spi.h>
+#include <asm/arch/at91sam9260_uhp.h>
+#include <asm/arch/board.h>
+#include <asm/arch/emac.h>
+#define SZ_512	0x00000200
+#define SZ_256	0x00000100
+#define SZ_16	0x00000010
+
+/* A generic dma mask must be set inorder for DMA relying devices to work */
+static u64 global_dmamask = 0xffffffffUL;
+
+static struct __initdata at91_pioline dbgu_data[] = {
+	{"DRXD", PIOB, 14, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"DTXD", PIOB, 15, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{0, 0, 0, 0, 0, 0},
+};
+
+static struct resource dbgu_resources[] = {
+	{
+		.start	= AT91C_BASE_DBGU,
+		.end	= AT91C_BASE_DBGU + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, 
+        {
+                .start  = AT91C_ID_SYS,
+                .end    = AT91C_ID_SYS,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device dbgu_device = {
+	.name		= "usart",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dbgu_resources),
+	.dev		= {
+				.platform_data	= &dbgu_data,
+	},
+	.resource	= dbgu_resources,
+};
+
+static struct at91_pioline macb_pio[] = {
+    {"ERXDV",  PIOA, 17, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETXCK",  PIOA, 19, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ECRS" ,  PIOA, 28, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETX0" ,  PIOA, 12, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETX1" ,  PIOA, 13, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ERX0",   PIOA, 14, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ERX1",   PIOA, 15, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ERXER",  PIOA, 18, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETXER",  PIOA, 22, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETXEN",  PIOA, 16, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"EMDC",   PIOA, 20, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"EMDIO",  PIOA, 21, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+
+//	{"E_F100", PIOE, 31, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"MDINTR", PIOC, 12, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+
+static struct __initdata at91_eth_pdata macb_data = {
+  .phy_id = 0,
+  .pio_data = macb_pio,
+};
+
+
+static struct resource usb_ohci_resource[] = {
+	/* order *IS* significant */
+	{
+		.start	= AT91C_BASE_UHP,
+		.end	= AT91C_BASE_UHP + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AT91C_ID_UHP,
+		.end	= AT91C_ID_UHP,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device usb_ohci_device = {
+	.name		= "usb-ohci",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &global_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= usb_ohci_resource,
+	.num_resources	= ARRAY_SIZE(usb_ohci_resource),
+};
+
+static struct resource macb_resource[] = {
+	/* order *IS* significant */
+	{
+		.start	= AT91C_BASE_EMAC,
+		.end	= AT91C_BASE_EMAC + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AT91C_ID_EMAC,
+		.end	= AT91C_ID_EMAC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device macb_device = {
+	.name		= "macb",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &global_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data          = &macb_data,
+	},
+	.resource	= macb_resource,
+	.num_resources	= ARRAY_SIZE(macb_resource),
+};
+
+
+static struct __initdata at91_pioline spi0_data[] = {
+        {"MISO0", PIOA,  0, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"MOSI0", PIOA,  1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"SPCK0", PIOA,  2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {0, 0, 0, 0, 0, 0},
+};
+
+static struct resource spi0_resources[] = {
+        {
+                .start = AT91C_BASE_SPI0,
+                .end   = AT91C_BASE_SPI0 + SZ_16K - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        {
+                .start = AT91C_ID_SPI0,
+                .end   = AT91C_ID_SPI0,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device spi0_device = {
+        .name           = "spi",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(spi0_resources),
+        .dev            = {
+                                .platform_data  = &spi0_data,
+        },
+        .resource       = spi0_resources,
+};
+
+static struct __initdata at91_pioline spi1_data[] = {
+        {"MISO1", PIOB, 0, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"MOSI1", PIOB, 1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"SPCK1", PIOB, 2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {0, 0, 0, 0, 0, 0},
+};
+
+static struct resource spi1_resources[] = {
+        {
+                .start = AT91C_BASE_SPI1,
+                .end   = AT91C_BASE_SPI1 + SZ_16K - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        {
+                .start = AT91C_ID_SPI1,
+                .end   = AT91C_ID_SPI1,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device spi1_device = {
+        .name           = "spi",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(spi1_resources),
+        .dev            = {
+                                .platform_data  = &spi1_data,
+        },
+        .resource       = spi1_resources,
+};
+
+static struct platform_device *at91sam9260_devices[] __initdata = {
+	&dbgu_device,
+	&macb_device,
+	&usb_ohci_device,
+	&spi0_device,
+    &spi1_device,
+/*
+	&usart0_device,
+	&usart1_device,
+	&usart2_device,
+	&usb_ohci_device,
+*/
+};
+
+static int __init at91sam9260_device_init(void)
+{
+//	at91_add_device_udc();
+	return platform_add_devices(at91sam9260_devices, ARRAY_SIZE(at91sam9260_devices));
+}
+
+arch_initcall(at91sam9260_device_init);
+
+const struct platform_device *platform_get_device(const char *name, int id)
+{
+	int i;
+  
+	for (i = 0; i < ARRAY_SIZE(at91sam9260_devices); i++) {
+		if ((at91sam9260_devices[i]->id == id) && 
+		    (strcmp(at91sam9260_devices[i]->name, name) == 0))
+			return at91sam9260_devices[i];
+	} 
+	return NULL;
+}
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/gpio.c linux-2.6.15.4/arch/arm/mach-at91sam9260/gpio.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/gpio.c	2006-08-09 17:55:29.000000000 +0200
@@ -0,0 +1,328 @@
+
+
+/*
+ * linux/arch/arm/mach-at91sam9261/gpio.c
+ *
+ * Copyright (C) 2005  M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/at91sam9260_pio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pio.h>
+#include <asm/arch/pmc.h>
+
+#define AT91_PIOA       0x400
+#define AT91_PIOB       0x600
+#define AT91_PIOC       0x800
+
+static const u32 pio_controller_offset[4] = {
+        AT91_PIOA,
+        AT91_PIOB,
+        AT91_PIOC,
+};
+
+
+/*--------------------------------------------------------------------------*/
+
+/* Not all hardware capabilities are exposed through these calls; they
+ * only encapsulate the most common features and modes.  (So if you
+ * want to change signals in groups, do it directly.)
+ *
+ * Bootloaders will usually handle some of the pin multiplexing setup.
+ * The intent is certainly that by the time Linux is fully booted, all
+ * pins should have been fully initialized.  These setup calls should
+ * only be used by board setup routines, or possibly in driver probe().
+ *
+ * For bootloaders doing all that setup, these calls could be inlined
+ * as NOPs so Linux won't duplicate any setup code
+ */
+
+
+/*
+ * mux the pin to the corresponding internal peripheral role.
+ */
+
+
+void at91_gpio_periph_enable (unsigned int pio_va_base, 
+			      unsigned char pin, 
+			      unsigned char peripheral, 
+			      unsigned char use_pullup, 
+			      unsigned char use_filter) 
+{
+	unsigned int mask = pin_to_mask(pin);
+
+	writel(mask, (pio_va_base + PIO_IDR));	
+
+	if(use_pullup)
+		writel(mask, (pio_va_base + PIO_PPUER));
+	else
+		writel(mask, (pio_va_base + PIO_PPUDR));
+
+	switch (peripheral) 
+	{
+		case 1:
+			writel(mask, (pio_va_base + PIO_BSR));
+		break;
+		case 0:
+		default:
+			writel(mask, (pio_va_base + PIO_ASR));
+		break;
+	}
+
+	/* The Peripheral controls the pin (pio disabled) */
+	writel(mask, (pio_va_base + PIO_PDR));
+}
+
+
+EXPORT_SYMBOL(at91_gpio_periph_enable);
+
+void at91_gpio_configure (unsigned int pio_va_base, 
+			  unsigned char pin, 
+			  unsigned char in_out, 
+			  unsigned char use_pullup, 
+			  unsigned char use_filter) 
+{
+        unsigned int mask = pin_to_mask(pin);
+	
+	/* The PIO controls the pin (periph disabled) */
+	writel(mask, (pio_va_base + PIO_PER));
+
+	if(in_out) { /* the pin is an input */
+        	writel(mask, (pio_va_base + PIO_ODR));
+	}
+	else {       /* the pin is an output */
+        	writel(mask, (pio_va_base + PIO_OER));
+	}
+
+        if(use_pullup)
+                writel(mask, (pio_va_base + PIO_PPUER));
+        else
+                writel(mask, (pio_va_base + PIO_PPUDR));
+}
+
+
+EXPORT_SYMBOL(at91_gpio_configure);
+
+void at91_gpio_set_level (unsigned int pio_va_base, unsigned int pin, unsigned int level)
+{
+        unsigned int mask = pin_to_mask(pin);
+
+	// This is just a sanity action to force a pin 
+	// to output before driving it.
+        writel(mask, pio_va_base + PIO_PER);
+	writel(mask, pio_va_base + PIO_OER);
+	
+	if (level)
+	  writel(mask, pio_va_base + PIO_SODR);
+	else // pin should be cleared
+	  writel(mask, pio_va_base + PIO_CODR);
+
+}
+
+
+EXPORT_SYMBOL(at91_gpio_set_level);
+
+unsigned int at91_gpio_get_level (unsigned int pio_va_base, unsigned int pin)
+{
+        unsigned int mask = pin_to_mask(pin);
+
+
+	// This is just a sanity action to force a pin 
+	// to input before reading it.
+        writel(mask, pio_va_base + PIO_PER);
+	writel(mask, pio_va_base + PIO_ODR);
+
+	return (readl(pio_va_base + PIO_PDSR) & mask);
+}
+
+
+EXPORT_SYMBOL(at91_gpio_get_level);
+
+
+int at91_device_pio_setup (struct at91_pioline *pPin) {
+
+	if(!pPin) {
+		printk(KERN_ERR "Define the PIO muxing of this device first !!\n");
+		return -ENODEV;
+	}
+
+	/* Sets all the pio muxing of the corresponding device as defined in its platform_data struct */
+	while (pPin->pin_name)
+	{
+		if ((pPin->pio_ctrl_id != AT91C_ID_PIOA) &&
+		    (pPin->pio_ctrl_id != AT91C_ID_PIOB) &&
+		    (pPin->pio_ctrl_id != AT91C_ID_PIOC)) {
+			printk(KERN_ERR "Bad PIO controler ID %u, correct values are {%u, %u ,%u}\n", 
+			       pPin->pio_ctrl_id, AT91C_ID_PIOA, AT91C_ID_PIOB, AT91C_ID_PIOC);
+			return -ENODEV;
+		}
+		if (pPin->type == TYPE_PERIPH) // PIN is in PERIPH mode
+			at91_gpio_periph_enable(pPin->pio_ctrl_va_base, pPin->pin_num, pPin->direction, pPin->use_pullup, pPin->use_filter);
+		else // PIN is in PIO mode
+			at91_gpio_configure(pPin->pio_ctrl_va_base, pPin->pin_num, pPin->direction, pPin->use_pullup, pPin->use_filter);
+		pPin++;
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(at91_device_pio_setup);
+
+static inline void __iomem *pin_to_controller(unsigned pin)
+{
+        void __iomem *sys_base = (void __iomem *) AT91C_VA_BASE_SYS;
+
+        pin -= PIN_BASE;
+        pin /= 32;
+        return sys_base + pio_controller_offset[pin];
+
+        return NULL;
+}
+
+static inline unsigned pin_to_mask_o(unsigned pin)
+{
+        pin -= PIN_BASE;
+        return 1 << (pin % 32);
+}
+
+/*
+ * read the pin's value (works even if it's not muxed as a gpio).
+ */
+int at91_get_gpio_value(unsigned pin)
+{
+        void __iomem    *pio = pin_to_controller(pin);
+        unsigned        mask = pin_to_mask_o(pin);
+        u32             pdsr;
+
+        if (!pio)
+                return -EINVAL;
+        pdsr = __raw_readl(pio + PIO_PDSR);
+        return (pdsr & mask) != 0;
+}
+EXPORT_SYMBOL(at91_get_gpio_value);
+
+/*--------------------------------------------------------------------------*/
+
+
+/* Several AIC controller irqs are dispatched through this GPIO handler.
+ * To use any AT91_PIN_* as an externally triggered IRQ, first call
+ * at91_set_gpio_input() then maybe enable its glitch filter.
+ * Then just request_irq() with the pin ID; it works like any ARM IRQ
+ * handler, though it always triggers on rising and falling edges.
+ *
+ * Alternatively, certain pins may be used directly as IRQ0..IRQ6 after
+ * configuring them with at91_set_a_periph() or at91_set_b_periph().
+ * IRQ0..IRQ6 should be configurable, e.g. level vs edge triggering.
+ */
+
+static void gpio_irq_mask(unsigned pin)
+{
+        void __iomem    *pio = pin_to_controller(pin);
+        unsigned        mask = pin_to_mask_o(pin);
+
+        if (pio)
+                __raw_writel(mask, pio + PIO_IDR);
+}
+
+static void gpio_irq_unmask(unsigned pin)
+{
+        void __iomem    *pio = pin_to_controller(pin);
+        unsigned        mask = pin_to_mask_o(pin);
+
+	printk("gpio_irq_unmask %d %x\n", (int) pin, (int) pio);
+        if (pio)
+                __raw_writel(mask, pio + PIO_IER);
+}
+
+static int gpio_irq_type(unsigned pin, unsigned type)
+{
+        return (type == IRQT_BOTHEDGE) ? 0 : -EINVAL;
+}
+
+static struct irqchip gpio_irqchip = {
+        .mask           = gpio_irq_mask,
+        .unmask         = gpio_irq_unmask,
+        .set_type       = gpio_irq_type,
+};
+
+static void gpio_irq_handler(unsigned irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+        unsigned        pin;
+        struct irqdesc  *gpio;
+        void __iomem    *pio;
+        u32             isr;
+
+        pio = (void __force __iomem *) desc->chipdata;
+
+        /* temporarily mask (level sensitive) parent IRQ */
+        desc->chip->ack(irq);
+        for (;;) {
+                isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+                if (!isr)
+                        break;
+
+                pin = (unsigned) desc->data;
+                gpio = &irq_desc[pin];
+
+                while (isr) {
+                        if (isr & 1)
+                                gpio->handle(pin, gpio, regs);
+                        pin++;
+                        gpio++;
+                        isr >>= 1;
+                }
+        }
+        desc->chip->unmask(irq);
+        /* now it may re-trigger */
+}
+
+/* call this from board-specific init_irq */
+void __init at91_gpio_irq_setup(unsigned banks)
+{
+        unsigned        pioc, pin, id;
+
+        if (banks > 4)
+                banks = 4;
+        for (pioc = 0, pin = PIN_BASE, id = AT91_ID_PIOA;
+                        pioc < banks;
+                        pioc++, id++) {
+                void __iomem    *controller;
+                unsigned        i;
+
+                controller = (void __iomem *) AT91C_VA_BASE_SYS + pio_controller_offset[pioc];
+                __raw_writel(~0, controller + PIO_IDR);
+
+                set_irq_data(id, (void *) pin);
+                set_irq_chipdata(id, (void __force *) controller);
+
+                for (i = 0; i < 32; i++, pin++) {
+                        set_irq_chip(pin, &gpio_irqchip);
+                        set_irq_handler(pin, do_simple_IRQ);
+                        set_irq_flags(pin, IRQF_VALID);
+                }
+
+                set_irq_chained_handler(id, gpio_irq_handler);
+		printk("set_irq_chained_handler %d\n", id);
+
+                /* enable the PIO peripheral clock */
+		at91_enable_periph_clock(id);
+                //at91_sys_write(AT91_PMC_PCER, 1 << id);
+        }
+        pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, banks);
+}
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/gpio_tgt.c linux-2.6.15.4/arch/arm/mach-at91sam9260/gpio_tgt.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/gpio_tgt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/gpio_tgt.c	2006-08-09 10:53:17.000000000 +0200
@@ -0,0 +1,365 @@
+/*
+ * linux/arch/arm/mach-at91sam9260/gpio.c
+ *
+ * Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/gpio_tgt.h>
+#include <asm/arch/at91sam9260_sys.h>
+
+
+
+static inline unsigned pin_to_controller(unsigned pin)
+{
+	return  (pin - PIN_BASE) / 32;
+}
+
+static inline unsigned pin_to_mask(unsigned pin)
+{
+	return 1 << ((pin - PIN_BASE) % 32);
+}
+
+
+/*--------------------------------------------------------------------------*/
+
+/* Not all hardware capabilities are exposed through these calls; they
+ * only encapsulate the most common features and modes.  (So if you
+ * want to change signals in groups, do it directly.)
+ *
+ * Bootloaders will usually handle some of the pin multiplexing setup.
+ * The intent is certainly that by the time Linux is fully booted, all
+ * pins should have been fully initialized.  These setup calls should
+ * only be used by board setup routines, or possibly in driver probe().
+ *
+ * For bootloaders doing all that setup, these calls could be inlined
+ * as NOPs so Linux won't duplicate any setup code
+ */
+
+
+/*
+ * mux the pin to the "A" internal peripheral role.
+ */
+int __init_or_module at91_set_A_periph(unsigned pin, int use_pullup)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write(use_pullup ? PIO_PPUER(pio) : PIO_PPUDR(pio), mask);
+	at91_sys_write(PIO_ASR(pio), mask);
+	at91_sys_write(PIO_PDR(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_A_periph);
+
+
+/*
+ * mux the pin to the "B" internal peripheral role.
+ */
+int __init_or_module at91_set_B_periph(unsigned pin, int use_pullup)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write((use_pullup ? PIO_PPUER(pio) : PIO_PPUDR(pio)), mask);
+	at91_sys_write(PIO_BSR(pio), mask);
+	at91_sys_write(PIO_PDR(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_B_periph);
+
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral), and
+ * configure it for an input.
+ */
+int __init_or_module at91_set_gpio_input(unsigned pin, int use_pullup)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write((use_pullup ? PIO_PPUER(pio) : PIO_PPUDR(pio)), mask);
+	at91_sys_write(PIO_ODR(pio), mask);
+	at91_sys_write(PIO_PER(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_input);
+
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral),
+ * and configure it for an output.
+ */
+int __init_or_module at91_set_gpio_output(unsigned pin, int value)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write(PIO_PPUDR(pio), mask);
+	at91_sys_write((value ? PIO_SODR(pio) : PIO_CODR(pio)), mask);
+	at91_sys_write(PIO_OER(pio), mask);
+	at91_sys_write(PIO_PER(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_output);
+
+
+/*
+ * enable/disable the glitch filter; mostly used with IRQ handling.
+ */
+int __init_or_module at91_set_deglitch(unsigned pin, int is_on)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+	at91_sys_write((is_on ? PIO_IFER(pio) : PIO_IFDR(pio)), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_deglitch);
+
+/*
+ * enable/disable the multi-driver; This is only valid for output and
+ * allows the output pin to run as an open collector output.
+ */
+int __init_or_module at91_set_multi_drive(unsigned pin, int is_on)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write((is_on ? PIO_MDER(pio) : PIO_MDDR(pio)), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_multi_drive);
+
+/*--------------------------------------------------------------------------*/
+
+
+/*
+ * assuming the pin is muxed as a gpio output, set its value.
+ */
+int at91_set_gpio_value(unsigned pin, int value)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+	at91_sys_write((value ? PIO_SODR(pio) : PIO_CODR(pio)), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_value);
+
+
+/*
+ * read the pin's value (works even if it's not muxed as a gpio).
+ */
+int at91_get_gpio_value(unsigned pin)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+	u32		pdsr;
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+	pdsr = at91_sys_read(PIO_PDSR(pio));
+	return (pdsr & mask) != 0;
+}
+EXPORT_SYMBOL(at91_get_gpio_value);
+
+/*
+ * Configure PIO in periph mode according to the platform informations
+ */
+#ifdef 0
+int at91_device_pio_setup (struct at91_pioline *pio_desc)
+{
+        unsigned        pio, pin = 0;
+
+        if(!pio_desc) {
+                printk(KERN_ERR "Define the PIO muxing of this device first !!\n");
+                return 0;
+        }
+
+        /* Sets all the pio muxing of the corresponding device as defined in its platform_data struct */
+        while (pio_desc->pin_name) {
+                pio = pin_to_controller( pio_desc->pin_num);
+                if (pio >= AT91_NR_PIO)
+                        printk(KERN_ERR "Bad pin number %u for pio %s in platform description\n",
+                                pio_desc->pin_num, pio_desc->pin_name);
+                else if (pio_desc->type == ATM_PIO_PERIPH_A)
+                        at91_set_A_periph(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_PULLUP) ? 1 : 0);
+                else if (pio_desc->type == ATM_PIO_PERIPH_B)
+                        at91_set_B_periph(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_PULLUP) ? 1 : 0);
+                else if (pio_desc->type == ATM_PIO_INPUT) {
+                        at91_set_deglitch(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_DEGLITCH)? 1 : 0);
+                        at91_set_gpio_input(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_PULLUP) ? 1 : 0);
+                }
+                else if(pio_desc->type == ATM_PIO_OUTPUT) {
+                        at91_set_multi_drive(pio_desc->pin_num, (pio_desc->attribute & ATM_PIO_OPENDRAIN) ? 1 : 0);
+                        at91_set_gpio_output(pio_desc->pin_num, pio_desc->dft_value);
+                }
+                else
+                         printk(KERN_ERR "Bad pin type %u for pio %s in platform description\n",
+                                 pio_desc->pin_num, pio_desc->pin_name);
+                ++pin;
+                ++pio_desc;
+        }
+        return pin;
+}
+
+EXPORT_SYMBOL(at91_device_pio_setup);
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+
+/* Several AIC controller irqs are dispatched through this GPIO handler.
+ * To use any AT91_PIN_* as an externally triggered IRQ, first call
+ * at91_set_gpio_input() then maybe enable its glitch filter.
+ * Then just request_irq() with the pin ID; it works like any ARM IRQ
+ * handler, though it always triggers on rising and falling edges.
+ *
+ * Alternatively, certain pins may be used directly as IRQ0..IRQ6 after
+ * configuring them with at91_set_a_periph() or at91_set_b_periph().
+ * IRQ0..IRQ6 should be configurable, e.g. level vs edge triggering.
+ */
+
+static void gpio_irq_mask(unsigned pin)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio < AT91_NR_PIO)
+		at91_sys_write(PIO_IDR(pio), mask);
+}
+
+static void gpio_irq_unmask(unsigned pin)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio < AT91_NR_PIO)
+		at91_sys_write(PIO_IER(pio), mask);
+}
+
+static int gpio_irq_type(unsigned pin, unsigned type)
+{
+	return (type == IRQT_BOTHEDGE) ? 0 : -EINVAL;
+}
+
+static struct irqchip gpio_irqchip = {
+	.mask		= gpio_irq_mask,
+	.unmask		= gpio_irq_unmask,
+	.set_type	= gpio_irq_type,
+};
+
+static void gpio_irq_handler(unsigned irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+	unsigned	pin;
+	struct irqdesc	*gpio;
+	unsigned	pio;
+	u32		isr;
+
+	pio = (unsigned __force) desc->chipdata;
+
+	/* temporarily mask (level sensitive) parent IRQ */
+	desc->chip->ack(irq);
+	for (;;) {
+		isr = at91_sys_read(PIO_ISR(pio)) & at91_sys_read(PIO_IMR(pio));
+		if (!isr)
+			break;
+
+		pin = (unsigned) desc->data;
+		gpio = &irq_desc[pin];
+
+		while (isr) {
+			if (isr & 1) {
+				if (unlikely(gpio->disable_depth)) {
+					/*
+					 * The core ARM interrupt handler lazily disables IRQs so
+					 * another IRQ must be generated before it actually gets
+					 * here to be disabled on the GPIO controller.
+					 */
+					gpio_irq_mask(pin);
+				}
+				else {
+					gpio->handle(pin, gpio, regs);
+				}
+			}
+			pin++;
+			gpio++;
+			isr >>= 1;
+		}
+	}
+	desc->chip->unmask(irq);
+	/* now it may re-trigger */
+}
+
+/* call this from board-specific init_irq */
+void __init at91_gpio_irq_setup(unsigned banks)
+{
+	unsigned	pioc, pin, id;
+
+	if (banks > AT91_NR_PIO)
+		banks = AT91_NR_PIO;
+	for (pioc = 0, pin = PIN_BASE, id = AT91_ID_PIOA;
+			pioc < banks;
+			pioc++, id++) {
+		unsigned	pio = pin_to_controller(pin);
+		unsigned	i;
+
+		at91_sys_write(PIO_IDR(pio), ~0);
+
+		set_irq_data(id, (void *) pin);
+		set_irq_chipdata(id, (void __force *) pioc);
+
+		for (i = 0; i < 32; i++, pin++) {
+			set_irq_chip(pin, &gpio_irqchip);
+			set_irq_handler(pin, do_simple_IRQ);
+			set_irq_flags(pin, IRQF_VALID);
+		}
+
+		set_irq_chained_handler(id, gpio_irq_handler);
+
+		/* enable the PIO peripheral clock */
+		at91_sys_write(PMC_PCER, 1 << id);
+	}
+	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, banks);
+}
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/irq.c linux-2.6.15.4/arch/arm/mach-at91sam9260/irq.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/irq.c	2006-08-09 10:53:08.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+ * linux/arch/arm/mach-at91sam9260/irq.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+
+#define readreg_aic(offset)             readl(AT91C_VA_BASE_AIC + offset)
+#define writereg_aic(value, offset)     writel(value, (AT91C_VA_BASE_AIC + offset))
+
+/* Interrupt configuration */
+static volatile unsigned int at91sam9260_irq_smr[] __initdata = {
+	(AT91_SMR_FIQ),		/*0 FIQ */
+	(AT91_SMR_SYS),		/*1 System Peripherals */
+	(AT91_SMR_PIOA),	/*2 PIO A */
+	(AT91_SMR_PIOB),	/*3 PIO B */
+	(AT91_SMR_PIOC),	/*4 PIO C */
+	0,					/*5   */
+	(AT91_SMR_US0),		/*6 USART 0 */
+	(AT91_SMR_US1),		/*7 USART 1 */
+	(AT91_SMR_US2),		/*8 USART 2 */
+	(AT91_SMR_MCI),		/*9 Multimedia Card */
+	(AT91_SMR_UDP),		/*10 USB Device */
+	(AT91_SMR_TWI),		/*11 Two-wire interface */
+	(AT91_SMR_SPI0),	/*12 SPI 0 */
+	(AT91_SMR_SPI1),	/*13 SPI 1 */
+	(AT91_SMR_SSC0),	/*14 Sync Serial 0 */
+	0,					/*15 */
+	0,					/*16 */
+	(AT91_SMR_TC0),		/*17 TC 0 */
+	(AT91_SMR_TC1),		/*18 TC 1 */
+	(AT91_SMR_TC2),		/*19 TC 2 */
+	(AT91_SMR_UHP),		/*20 USB Host */
+	(AT91_SMR_EMAC),	/*21 EMAC */
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	(AT91_SMR_IRQ0),	/* IRQ 0 */
+	(AT91_SMR_IRQ1),	/* IRQ 1 */
+	(AT91_SMR_IRQ2),	/* IRQ 2 */
+};
+
+static void at91sam9260_mask_irq(unsigned int irq)
+{
+	/* Disable interrupt on AIC */
+	writereg_aic(1 << irq, AIC_IDCR);
+}
+
+static void at91sam9260_unmask_irq(unsigned int irq)
+{
+	/* Enable interrupt on AIC */
+	writereg_aic(1 << irq, AIC_IECR);
+}
+
+static struct irqchip at91sam9260_irq_chip = {
+	.ack	  = at91sam9260_mask_irq,
+	.mask	  = at91sam9260_mask_irq,
+	.unmask = at91sam9260_unmask_irq,
+};
+
+void at91sam9260_clear_irq(unsigned int irq)
+{
+	/* Clear an interrupt on AIC */
+	writereg_aic(1 << irq, AIC_ICCR);
+}
+
+void __init at91sam9260_init_irq(void)
+{
+	int i;
+
+	/*
+	 * The IVR is used by macro get_irqnr_and_base to read and verify.
+	 * The irq number is NR_IRQS when a spurious interrupt has occured.
+	 */
+	for (i = 0; i < NR_AIC_IRQS; i++) {
+		/* Put irq number in Source Vector Register: */
+		writereg_aic(i, (AIC_SVR + (i<<2)));
+		/* Store the Source Mode Register as defined in table above */
+		writereg_aic(at91sam9260_irq_smr[i], (AIC_SMR + (i<<2)));
+		set_irq_chip(i, &at91sam9260_irq_chip);
+		set_irq_handler(i, do_level_IRQ);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+    
+		/* Perform 8 End Of Interrupt Command to make sure AIC will not Lock out nIRQ */
+		if (i < 8)
+			writereg_aic(readreg_aic(AIC_EOICR), AIC_EOICR);
+	}
+  
+	/* 
+	 * Spurious Interrupt ID in Spurious Vector Register is NR_IRQS
+	 * When there is no current interrupt, the IRQ Vector Register reads the value stored in AIC_SPU
+	 */
+	writereg_aic(NR_AIC_IRQS, AIC_SPU);
+  
+	/* No debugging in AIC: Debug (Protect) Control Register */
+	writereg_aic(0, AIC_DCR);
+  
+	/* Disable and clear all interrupts initially */
+	writereg_aic(0xFFFFFFFF, AIC_IDCR);
+	writereg_aic(0xFFFFFFFF, AIC_ICCR);
+}
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/Makefile linux-2.6.15.4/arch/arm/mach-at91sam9260/Makefile
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/Makefile	2006-08-09 10:53:09.000000000 +0200
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Common support
+obj-y			:= board-ek.o core.o irq.o time.o gpio.o devices.o pmc.o
+obj-m			:=
+obj-n			:=
+obj-			:=
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/Makefile.boot linux-2.6.15.4/arch/arm/mach-at91sam9260/Makefile.boot
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/Makefile.boot	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/Makefile.boot	2006-08-09 10:53:10.000000000 +0200
@@ -0,0 +1,11 @@
+# Note: the following conditions must always be true:
+#   ZRELADDR == virt_to_phys(TEXTADDR)
+#   PARAMS_PHYS must be within 4MB of ZRELADDR
+#   INITRD_PHYS must be in RAM
+
+zreladdr-y      := 0x20008000
+params_phys-y	:= 0x20000100
+initrd_phys-y	:= 0x20410000
+
+#params_phys-y   := 0x00000100
+#initrd_phys-y   := 0x00800000
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/pmc.c linux-2.6.15.4/arch/arm/mach-at91sam9260/pmc.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/pmc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/pmc.c	2006-08-09 17:49:52.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/pmc.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/hardware.h>
+
+#define readreg_pmc(offset)             readl(AT91C_VA_BASE_PMC + offset)
+#define writereg_pmc(value, offset)     writel(value, (AT91C_VA_BASE_PMC + offset))
+
+
+void at91_disable_periph_clock(unsigned int irq)
+{
+	/* Disable the corresponding peripheral clock */
+	writereg_pmc(1 << irq, PMC_PCDR);
+}
+EXPORT_SYMBOL(at91_disable_periph_clock);
+
+void at91_enable_periph_clock(unsigned int irq)
+{
+	/* Enable the corresponding peripheral clock */
+	writereg_pmc(1 << irq, PMC_PCER);
+}
+EXPORT_SYMBOL(at91_enable_periph_clock);
+ 
+void at91_disable_system_clock(unsigned int mask)
+{
+	/* Disable the corresponding system clock */
+	writereg_pmc(mask, PMC_SCDR);
+}
+EXPORT_SYMBOL(at91_disable_system_clock);
+
+void at91_enable_system_clock(unsigned int mask)
+{
+	/* Enable the corresponding system clock */
+	writereg_pmc(mask, PMC_SCER);
+}
+EXPORT_SYMBOL(at91_enable_system_clock);
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/time.c linux-2.6.15.4/arch/arm/mach-at91sam9260/time.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9260/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9260/time.c	2006-08-09 10:53:12.000000000 +0200
@@ -0,0 +1,105 @@
+/*
+ * linux/arch/arm/mach-at91sam9260/time.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ * Revision	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+#include <linux/device.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <asm/arch/time.h>
+
+#define readreg_pitc(offset)            readl(AT91C_VA_BASE_PITC + offset)
+#define writereg_pitc(value, offset)    writel(value, (AT91C_VA_BASE_PITC + offset))
+
+#define READ_PIT_CPIV(x)  ((x) & AT91C_PITC_CPIV)
+#define READ_PIT_PICNT(x) (((x) & AT91C_PITC_PICNT) >> 20)
+
+
+/*
+ * Returns number of microseconds since last timer interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeofday()
+ *  'LATCH' is hwclock ticks (see CLOCK_TICK_RATE in timex.h) per jiffy.
+ *  'tick' is usecs per jiffy (linux/timex.h).
+ */
+static unsigned long at91sam9260_gettimeoffset(void)
+{
+	unsigned long nb_us = ((READ_PIT_CPIV(readreg_pitc(PITC_PIIR)) * 1000000) / CLOCK_TICK_RATE) + ((READ_PIT_PICNT(readreg_pitc(PITC_PIIR)) * 1000000)/HZ);
+	return (nb_us);
+}
+
+/*
+ * IRQ handler for the timer.
+ */
+static irqreturn_t at91sam9260_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	volatile unsigned int nb_ticks;
+
+	if (readreg_pitc(PITC_PISR) & AT91C_PITC_PITS) {	/* This is a shared interrupt */
+		write_seqlock(&xtime_lock);
+    
+		/* Get number to ticks performed before interrupt and clear PIT interrupt */
+		nb_ticks = READ_PIT_PICNT(readreg_pitc(PITC_PIVR));
+    
+		do {
+			timer_tick(regs);
+			nb_ticks--;
+		} while(nb_ticks);
+    
+		write_sequnlock(&xtime_lock);
+    
+		return IRQ_HANDLED;
+	} else {
+		return IRQ_NONE;		/* not handled */
+	};
+}
+
+static struct irqaction at91sam9260_timer_irq = {
+	.name	= "AT91SAM9260 Timer",
+	.flags	= SA_SHIRQ | SA_INTERRUPT | SA_TIMER,
+	.handler= at91sam9260_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt.
+ */
+void __init at91sam9260_timer_init(void)
+{
+	/* Enable timer */
+	writereg_pitc(AT91C_PITC_PITEN, PITC_PIMR);
+
+	/* Clear any pending interrupts */
+	readreg_pitc(PITC_PIVR);
+    
+	/* Set Period Interval timer and enable its interrupt */
+	writereg_pitc((readreg_pitc(PITC_PIMR) | ((LATCH & AT91C_PITC_CPIV) | AT91C_PITC_PITIEN)), PITC_PIMR);
+  
+	/* Make IRQs happen for the system timer. */
+	setup_irq(AT91C_ID_SYS, &at91sam9260_timer_irq);
+  
+	/* Change the kernel's 'tick' value to 10009 usec. (the default is 10000) */
+	tick_usec = (LATCH * 1000000) / CLOCK_TICK_RATE;
+
+	return;
+}
+
+struct sys_timer at91sam9260_timer = {
+	.init   = at91sam9260_timer_init,
+	.offset = at91sam9260_gettimeoffset,
+};
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/board-ek.c linux-2.6.15.4/arch/arm/mach-at91sam9261/board-ek.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/board-ek.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/board-ek.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,89 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/board-ek.c
+ *
+ *  Copyright (C) 2005 SAN People
+ *
+ *  Epson S1D framebuffer glue code is:
+ *     Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/time.h>
+#include <asm/arch/board.h>
+
+
+extern void __init at91sam9261_init_irq(unsigned int priority[NR_IRQS]);
+extern void __init at91_gpio_irq_setup(unsigned banks);
+
+static void __init ek_init_irq(void)
+{
+	/* Initialize AIC controller */
+	at91sam9261_init_irq(NULL);
+
+	/* Set up the GPIO interrupts */
+	at91_gpio_irq_setup(AT91_NR_PIO);
+}
+
+extern void __init at91sam9261_map_io(void);
+
+static void __init ek_map_io(void)
+{
+	at91sam9261_map_io();
+
+	/* Initialize clocks: 18.432 MHz crystal */
+	//at91_clock_init(AT91C_MASTER_CLOCK);
+
+}
+
+#if 0
+static struct at91_udc_data __initdata ek_udc_data = {
+	.vbus_pin	= AT91_PIN_PB29,
+	.pullup_pin	= AT91_PIN_PB30,
+};
+
+static void __init ek_board_init(void)
+{
+	/* USB Device */
+	at91_add_device_udc(&ek_udc_data);
+}
+#endif
+
+MACHINE_START(AT91SAM9261EK, "ATMEL AT91SAM9261")
+        .phys_ram       = AT91_SDRAM_BASE,
+        .phys_io        = AT91C_BASE_AIC,
+        .io_pg_offst    = ((AT91C_VA_BASE_SYS) >> 18) & 0xfffc,
+        .boot_params    = AT91_SDRAM_BASE + 0x100,
+        .map_io         = ek_map_io,
+        .init_irq       = ek_init_irq,
+	.timer		= &at91sam9261_timer,
+MACHINE_END
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/core.c linux-2.6.15.4/arch/arm/mach-at91sam9261/core.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/core.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/core.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ * Revision 	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/time.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/sizes.h>
+#include <asm/page.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <asm/arch/time.h>
+#include <asm/arch/pmc.h>
+
+extern void __init at91sam9261_init_irq(void);
+
+
+/*
+ * System peripheral registers mapped at virtual address.
+ */
+
+static struct map_desc at91sam9261_io_desc[] __initdata = {
+	{ 
+		.virtual = AT91C_VA_BASE_SYS,
+		.pfn = __phys_to_pfn(AT91C_BASE_AIC),
+		.length = SZ_4K,
+		.type = MT_DEVICE
+	},
+	{ 
+		.virtual = AT91C_VA_BASE_EBI,
+		.pfn = __phys_to_pfn(AT91C_BASE_EBI),
+		.length = SZ_4K,
+		.type = MT_DEVICE
+	},
+	{ 
+		.virtual = AT91C_VA_BASE_UDP,
+		.pfn = __phys_to_pfn(AT91_BASE_UDP),
+		.length = SZ_16K,
+		.type = MT_DEVICE
+	}
+};
+
+
+void __init at91sam9261_map_io(void)
+{
+	iotable_init(at91sam9261_io_desc, ARRAY_SIZE(at91sam9261_io_desc));
+}
+
+/*
+MACHINE_START(AT91SAM9261EK, "ATMEL AT91SAM9261")
+        .phys_ram       = AT91_SDRAM_BASE,
+        .phys_io        = AT91C_BASE_AIC,
+        .io_pg_offst    = ((AT91C_VA_BASE_SYS) >> 18) & 0xfffc,
+        .boot_params    = 0x00000000,
+        .map_io         = at91sam9261_map_io,
+        .init_irq       = at91sam9261_init_irq,
+	.timer		= &at91sam9261_timer,
+//	.init_machine = at91sam9261_init_machine,
+MACHINE_END
+*/
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/devices.c linux-2.6.15.4/arch/arm/mach-at91sam9261/devices.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/devices.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,516 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/devices.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ * Revision 	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/sizes.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91sam9261_usart.h>
+#include <asm/arch/at91sam9261_spi.h>
+#include <asm/arch/at91sam9261_lcdc.h>
+#include <asm/arch/at91sam9261_uhp.h>
+#include <asm/arch/board.h>
+
+#define SZ_512	0x00000200
+#define SZ_256	0x00000100
+#define SZ_16	0x00000010
+
+/* A generic dma mask must be set inorder for DMA relying devices to work */
+static u64 global_dmamask = 0xffffffffUL;
+
+static struct __initdata at91_pioline dbgu_data[] = {
+	{"DRXD", PIOA,  9, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"DTXD", PIOA, 10, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{0, 0, 0, 0, 0, 0},
+};
+
+static struct resource dbgu_resources[] = {
+	{
+		.start	= AT91C_BASE_DBGU,
+		.end	= AT91C_BASE_DBGU + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, 
+        {
+                .start  = AT91C_ID_SYS,
+                .end    = AT91C_ID_SYS,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device dbgu_device = {
+	.name		= "usart",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dbgu_resources),
+	.dev		= {
+				.platform_data	= &dbgu_data,
+	},
+	.resource	= dbgu_resources,
+};
+
+static struct __initdata at91_pioline usart0_data[] = {
+	{"TXD0", PIOC,  8, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RXD0", PIOC,  9, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"SCK0", PIOC, 10, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"CTS0", PIOC, 11, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RTS0", PIOA, 23, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{0, 0, 0, 0, 0, 0},
+};
+
+static struct resource usart0_resources[] = {
+	{
+		.start	= AT91C_BASE_US0,
+		.end	= AT91C_BASE_US0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+        {
+                .start  = AT91C_ID_US0,
+                .end    = AT91C_ID_US0,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usart0_device = {
+	.name		= "usart",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(usart0_resources),
+	.dev		= {
+				.platform_data	= &usart0_data,
+	},
+	.resource	= usart0_resources,
+};
+
+static struct __initdata at91_pioline usart1_data[] = {
+	{"TXD1", PIOC, 12, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RXD1", PIOC, 13, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+#ifndef CONFIG_TFT_AT91
+	{"SCK1", PIOA, 11, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+        {"RTS1", PIOA, 12, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+        {"CTS1", PIOA, 13, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+#endif
+	{0, 0, 0, 0, 0, 0},
+};
+
+static struct resource usart1_resources[] = {
+	{
+		.start	= AT91C_BASE_US1,
+		.end	= AT91C_BASE_US1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+        {
+                .start  = AT91C_ID_US1,
+                .end    = AT91C_ID_US1,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usart1_device = {
+	.name		= "usart",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(usart1_resources),
+	.dev		= {
+				.platform_data	= &usart1_data,
+	},
+	.resource	= usart1_resources,
+};
+
+static struct __initdata at91_pioline usart2_data[] = {
+	{"TXD2", PIOC, 14, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RXD2", PIOC, 15, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"SCK2", PIOA, 14, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RTS2", PIOA, 15, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"CTS2", PIOA, 16, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{0, 0, 0, 0, 0, 0},
+};
+
+static struct resource usart2_resources[] = {
+	{
+		.start	= AT91C_BASE_US2,
+		.end	= AT91C_BASE_US2 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+        {
+                .start  = AT91C_ID_US2,
+                .end    = AT91C_ID_US2,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usart2_device = {
+	.name		= "usart",
+	.id		= 3,
+	.num_resources	= ARRAY_SIZE(usart2_resources),
+	.dev		= {
+				.platform_data	= &usart2_data,
+	},
+	.resource	= usart2_resources,
+};
+
+static struct __initdata at91_pioline spi0_data[] = {
+        {"MISO0", PIOA,  0, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"MOSI0", PIOA,  1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"SPCK0", PIOA,  2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {0, 0, 0, 0, 0, 0},
+};
+
+static struct resource spi0_resources[] = {
+        {
+                .start = AT91C_BASE_SPI0,
+                .end   = AT91C_BASE_SPI0 + SZ_16K - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        {
+                .start = AT91C_ID_SPI0,
+                .end   = AT91C_ID_SPI0,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device spi0_device = {
+        .name           = "spi",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(spi0_resources),
+        .dev            = {
+                                .platform_data  = &spi0_data,
+        },
+        .resource       = spi0_resources,
+};
+
+static struct __initdata at91_pioline spi1_data[] = {
+        {"MISO1", PIOB, 30, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"MOSI1", PIOB, 31, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"SPCK1", PIOB, 29, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {0, 0, 0, 0, 0, 0},
+};
+
+static struct resource spi1_resources[] = {
+        {
+                .start = AT91C_BASE_SPI1,
+                .end   = AT91C_BASE_SPI1 + SZ_16K - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        {
+                .start = AT91C_ID_SPI1,
+                .end   = AT91C_ID_SPI1,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device spi1_device = {
+        .name           = "spi",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(spi1_resources),
+        .dev            = {
+                                .platform_data  = &spi1_data,
+        },
+        .resource       = spi1_resources,
+};
+
+static struct __initdata at91_pioline lcdc_data[] = {
+	{"LCDHSYNC", PIOB,  1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDDOTCK", PIOB,  2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDDEN"  , PIOB,  3, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDCC"   , PIOB,  4, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD2"   , PIOB,  7, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD3"   , PIOB,  8, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD4"   , PIOB,  9, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD5"   , PIOB, 10, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD6"   , PIOB, 11, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD7"   , PIOB, 12, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD10"  , PIOB, 15, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD11"  , PIOB, 16, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD12"  , PIOB, 17, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD13"  , PIOB, 18, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD14"  , PIOB, 19, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD15"  , PIOB, 20, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD18"  , PIOB, 23, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD19"  , PIOB, 24, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD20"  , PIOB, 25, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD21"  , PIOB, 26, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD22"  , PIOB, 27, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD23"  , PIOB, 28, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"POWCTRL" , PIOA, 12, TYPE_PIO   , OUTPUT_MODE, NO_PULL_UP, NO_GLITCH_FLT},
+	{0, 0, 0, 0, 0, 0},
+};
+
+static struct resource lcdc_resources[] = {
+	{
+		.start      = AT91C_BASE_LCDC,
+		.end        = AT91C_BASE_LCDC + SZ_4K - 1,
+		.flags      = IORESOURCE_MEM,
+	}, 
+	{
+		.start      = AT91C_ID_LCDC,
+		.end        = AT91C_ID_LCDC,
+		.flags      = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device lcdc_device = {
+	.name           = "sidsa-lcdc",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(lcdc_resources),
+	.resource       = lcdc_resources,
+	.dev            = {
+		.dma_mask          = &global_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &lcdc_data,
+	},
+};
+
+/* External Touch screen controller. */
+static struct __initdata at91_pioline tsc_data[] = {
+        {"BUSY",    PIOA, 11, TYPE_PIO, INPUT_MODE, NO_PULL_UP, NO_GLITCH_FLT},
+        {"NPENIRQ", PIOC,  2, TYPE_PIO, INPUT_MODE, PULLED_UP,  NO_GLITCH_FLT},
+        {0, 0, 0, 0, 0, 0},
+};
+/* It only has an irq line.*/
+static struct resource tsc_resources[] = {
+	{
+		.start = AT91C_ID_IRQ0,
+		.end   = AT91C_ID_IRQ0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tsc_device = {
+	.name           = "ts",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(tsc_resources),
+        .dev            = {
+                                .platform_data  = &tsc_data,
+        },
+	.resource       = tsc_resources,
+};
+
+
+static struct resource usb_ohci_resource[] = {
+	/* order *IS* significant */
+	{
+		.start	= AT91C_BASE_UHP,
+		.end	= AT91C_BASE_UHP + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AT91C_ID_UHP,
+		.end	= AT91C_ID_UHP,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device usb_ohci_device = {
+	.name		= "usb-ohci",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &global_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= usb_ohci_resource,
+	.num_resources	= ARRAY_SIZE(usb_ohci_resource),
+};
+
+
+#ifdef CONFIG_USB_GADGET_AT91
+
+
+static struct at91_udc_data __initdata ek_udc_data = {
+	.vbus_pin	= AT91_PIN_PB29,
+	.pullup_pin	= AT91_PIN_PB30,
+};
+
+static struct resource at91_udc_resources[] = {
+        {
+                .start  = AT91_BASE_UDP,
+                .end    = AT91_BASE_UDP + SZ_16K - 1,
+                .flags  = IORESOURCE_MEM,
+        }
+};
+
+static struct platform_device at91sam9261_udc_device = {
+        .name           = "at91_udc",
+        .id             = -1,
+        .dev            = {
+                                .platform_data          =  &ek_udc_data,
+        },
+        .resource       = at91_udc_resources,
+        .num_resources  = ARRAY_SIZE(at91_udc_resources),
+};
+
+void __init at91_add_device_udc(void)
+{
+        struct at91_udc_data *data = at91sam9261_udc_device.dev.platform_data;
+
+        if (data->vbus_pin) {
+		at91_gpio_configure(AT91C_VA_BASE_PIOB, 29, 1, 0, 0);
+        }
+        if (data->pullup_pin) {
+		at91_gpio_configure(AT91C_VA_BASE_PIOB, 30, 0, 0, 0);
+        }
+	at91_enable_periph_clock(AT91C_ID_PIOB);
+
+        platform_device_register(&at91sam9261_udc_device);
+}
+
+#else
+void __init at91_add_device_udc(void) {}
+#endif
+
+#ifdef CONFIG_DM9000
+#include <linux/dm9000.h>
+
+#define AT91C_EBI_CS2 ((char *)      0x30000000) // EBI Chip Select 2 base address
+/* --------------------------------------------------------------------
+ *  DM9000 ethernet device
+ * -------------------------------------------------------------------- */
+static struct resource dm9000_resource[] = {
+        [0] = { 
+                .start = AT91C_EBI_CS2,
+                .end   = AT91C_EBI_CS2 + 3,
+                .flags = IORESOURCE_MEM
+        },      
+        [1] = {
+                .start = AT91C_EBI_CS2 + 0x44,
+                .end   = AT91C_EBI_CS2 + 0xFF,
+                .flags = IORESOURCE_MEM
+        },
+        [2] = {
+                .start = AT91_PIN_PC11,
+                .end   = AT91_PIN_PC11,
+                .flags = IORESOURCE_IRQ
+        }
+
+};
+
+
+/* for the moment we limit ourselves to 16bit IO until some
+ * better IO routines can be written and tested
+*/
+
+/* for the moment we limit ourselves to 16bit IO until some
+ * better IO routines can be written and tested
+*/
+
+struct dm9000_plat_data dm9000_platdata = {
+        .flags          = DM9000_PLATF_16BITONLY,
+};
+
+static struct platform_device dm9000_device = {
+        .name           = "dm9000",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(dm9000_resource),
+        .resource       = dm9000_resource,
+        .dev            = {
+                .platform_data = &dm9000_platdata,
+        }
+};
+// SMC Chip Select 2 Timmings for DM9000 (davicom).
+// These timmings were calculated for MASTER_CLOCK = 100000000 
+// according to DM9000 timmings. Refer to SMC user interface 
+// in AT91SAM9261 datasheet to learn how to regenerate these
+// values in case MASTER_CLOCK changes.
+
+#define AT91C_DM9000_NWE_SETUP          (2 << 0)                
+#define AT91C_DM9000_NCS_WR_SETUP       (0 << 8)                
+#define AT91C_DM9000_NRD_SETUP          (2 << 16)               
+#define AT91C_DM9000_NCS_RD_SETUP       (0 << 24)               
+
+#define AT91C_DM9000_NWE_PULSE          (4 << 0)                
+#define AT91C_DM9000_NCS_WR_PULSE       (8 << 8)                
+#define AT91C_DM9000_NRD_PULSE          (4 << 16)               
+#define AT91C_DM9000_NCS_RD_PULSE       (8 << 24)               
+
+#define AT91C_DM9000_NWE_CYCLE          (16 << 0)               
+#define AT91C_DM9000_NRD_CYCLE          (16 << 16)              
+
+#define AT91C_DM9000_TDF                (1 << 16)           
+static void __init at91_add_device_dm9000()
+{
+  printk("at91_add_device_dm9000 SMC  & PIO initialisation %08x\n", AT91C_VA_BASE_EBI + SYS_SMC);
+
+  //Configure SMC CS2 for DM9000
+  writel( (AT91C_DM9000_NWE_SETUP | AT91C_DM9000_NCS_WR_SETUP |
+                                AT91C_DM9000_NRD_SETUP | AT91C_DM9000_NCS_RD_SETUP), AT91C_VA_BASE_EBI + SMC_SETUP2);
+
+  writel( (AT91C_DM9000_NWE_PULSE | AT91C_DM9000_NCS_WR_PULSE | AT91C_DM9000_NRD_PULSE | AT91C_DM9000_NCS_RD_PULSE),  AT91C_VA_BASE_EBI + SMC_PULSE2);
+
+  writel( (AT91C_DM9000_NWE_CYCLE | AT91C_DM9000_NRD_CYCLE), AT91C_VA_BASE_EBI + SMC_CYCLE2);
+
+//#ifdef DM9000_PLATF_16BITONLY
+  writel( (SMC_READMODE | SMC_WRITEMODE | SMC_NWAITM_NWAIT_DISABLE |
+                               SMC_BAT_BYTE_WRITE | SMC_DBW_WIDTH_SIXTEEN_BITS | AT91C_DM9000_TDF), AT91C_VA_BASE_EBI + SMC_CTRL2);
+  printk("AT91_SMC->SMC_SETUP2 = %08x\n", readl(AT91C_VA_BASE_EBI + SMC_SETUP2));
+  printk("AT91_SMC->SMC_PULSE2 = %08x\n", readl(AT91C_VA_BASE_EBI + SMC_PULSE2));
+  printk("AT91_SMC->SMC_CYCLE2 = %08x\n", readl(AT91C_VA_BASE_EBI + SMC_CYCLE2));
+//#else
+ // AT91_SMC->SMC_CTRL2 = (AT91C_SMC_READMODE | AT91C_SMC_WRITEMODE | AT91C_SMC_NWAITM_NWAIT_ENABLE_READY |
+//                             AT91C_SMC_DBW_WIDTH_EIGTH_BITS | AT91C_DM9000_TDF);
+//#endif
+
+  //Configure NWAIT signal
+  //AT91F_PIO_CfgPeriph(AT91C_BASE_PIOC,AT91C_PC2_NWAIT,0);
+
+  //Configure Reset signal in output
+  at91_gpio_configure(AT91C_VA_BASE_PIOC, 10, 0, 0, 0);
+  //at91_set_gpio_output(AT91_PIN_PC10, 0);
+
+  //Configure Interrupt pin in input, no pull-up
+  at91_gpio_configure(AT91C_VA_BASE_PIOC, 11, 1, 0, 0);
+  //at91_set_gpio_input(AT91_PIN_PC11, 0);
+
+  // Enable clock for SMC and PIOC
+  at91_enable_periph_clock(AT91C_ID_PIOC);
+
+  platform_device_register(&dm9000_device);
+}
+#else
+static void __init at91_add_device_dm9000() {}
+#endif /* CONFIG_DM9000 */
+
+
+
+static struct platform_device *at91sam9261_devices[] __initdata = {
+	&dbgu_device,
+	&usart0_device,
+	&usart1_device,
+	&usart2_device,
+        &spi0_device,
+//        &spi1_device,
+        &lcdc_device,
+	&usb_ohci_device,
+	&tsc_device,
+};
+
+static int __init at91sam9261_device_init(void)
+{
+	at91_add_device_udc();
+	at91_add_device_dm9000();
+	return platform_add_devices(at91sam9261_devices, ARRAY_SIZE(at91sam9261_devices));
+}
+
+arch_initcall(at91sam9261_device_init);
+
+const struct platform_device *platform_get_device(const char *name, int id)
+{
+	int i;
+  
+	for (i = 0; i < ARRAY_SIZE(at91sam9261_devices); i++) {
+		if ((at91sam9261_devices[i]->id == id) && 
+		    (strcmp(at91sam9261_devices[i]->name, name) == 0))
+			return at91sam9261_devices[i];
+	} 
+	return NULL;
+}
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/gpio.c linux-2.6.15.4/arch/arm/mach-at91sam9261/gpio.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/gpio.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,327 @@
+
+
+/*
+ * linux/arch/arm/mach-at91sam9261/gpio.c
+ *
+ * Copyright (C) 2005  M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/at91sam9261_pio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pio.h>
+
+#define AT91_PIOA       0x400
+#define AT91_PIOB       0x600
+#define AT91_PIOC       0x800
+
+static const u32 pio_controller_offset[4] = {
+        AT91_PIOA,
+        AT91_PIOB,
+        AT91_PIOC,
+};
+
+
+/*--------------------------------------------------------------------------*/
+
+/* Not all hardware capabilities are exposed through these calls; they
+ * only encapsulate the most common features and modes.  (So if you
+ * want to change signals in groups, do it directly.)
+ *
+ * Bootloaders will usually handle some of the pin multiplexing setup.
+ * The intent is certainly that by the time Linux is fully booted, all
+ * pins should have been fully initialized.  These setup calls should
+ * only be used by board setup routines, or possibly in driver probe().
+ *
+ * For bootloaders doing all that setup, these calls could be inlined
+ * as NOPs so Linux won't duplicate any setup code
+ */
+
+
+/*
+ * mux the pin to the corresponding internal peripheral role.
+ */
+
+
+void at91_gpio_periph_enable (unsigned int pio_va_base, 
+			      unsigned char pin, 
+			      unsigned char peripheral, 
+			      unsigned char use_pullup, 
+			      unsigned char use_filter) 
+{
+	unsigned int mask = pin_to_mask(pin);
+
+	writel(mask, (pio_va_base + PIO_IDR));	
+
+	if(use_pullup)
+		writel(mask, (pio_va_base + PIO_PPUER));
+	else
+		writel(mask, (pio_va_base + PIO_PPUDR));
+
+	switch (peripheral) 
+	{
+		case 1:
+			writel(mask, (pio_va_base + PIO_BSR));
+		break;
+		case 0:
+		default:
+			writel(mask, (pio_va_base + PIO_ASR));
+		break;
+	}
+
+	/* The Peripheral controls the pin (pio disabled) */
+	writel(mask, (pio_va_base + PIO_PDR));
+}
+
+
+EXPORT_SYMBOL(at91_gpio_periph_enable);
+
+void at91_gpio_configure (unsigned int pio_va_base, 
+			  unsigned char pin, 
+			  unsigned char in_out, 
+			  unsigned char use_pullup, 
+			  unsigned char use_filter) 
+{
+        unsigned int mask = pin_to_mask(pin);
+	
+	/* The PIO controls the pin (periph disabled) */
+	writel(mask, (pio_va_base + PIO_PER));
+
+	if(in_out) { /* the pin is an input */
+        	writel(mask, (pio_va_base + PIO_ODR));
+	}
+	else {       /* the pin is an output */
+        	writel(mask, (pio_va_base + PIO_OER));
+	}
+
+        if(use_pullup)
+                writel(mask, (pio_va_base + PIO_PPUER));
+        else
+                writel(mask, (pio_va_base + PIO_PPUDR));
+}
+
+
+EXPORT_SYMBOL(at91_gpio_configure);
+
+void at91_gpio_set_level (unsigned int pio_va_base, unsigned int pin, unsigned int level)
+{
+        unsigned int mask = pin_to_mask(pin);
+
+	// This is just a sanity action to force a pin 
+	// to output before driving it.
+        writel(mask, pio_va_base + PIO_PER);
+	writel(mask, pio_va_base + PIO_OER);
+	
+	if (level)
+	  writel(mask, pio_va_base + PIO_SODR);
+	else // pin should be cleared
+	  writel(mask, pio_va_base + PIO_CODR);
+
+}
+
+
+EXPORT_SYMBOL(at91_gpio_set_level);
+
+unsigned int at91_gpio_get_level (unsigned int pio_va_base, unsigned int pin)
+{
+        unsigned int mask = pin_to_mask(pin);
+
+
+	// This is just a sanity action to force a pin 
+	// to input before reading it.
+        writel(mask, pio_va_base + PIO_PER);
+	writel(mask, pio_va_base + PIO_ODR);
+
+	return (readl(pio_va_base + PIO_PDSR) & mask);
+}
+
+
+EXPORT_SYMBOL(at91_gpio_get_level);
+
+
+int at91_device_pio_setup (struct at91_pioline *pPin) {
+
+	if(!pPin) {
+		printk(KERN_ERR "Define the PIO muxing of this device first !!\n");
+		return -ENODEV;
+	}
+
+	/* Sets all the pio muxing of the corresponding device as defined in its platform_data struct */
+	while (pPin->pin_name)
+	{
+		if ((pPin->pio_ctrl_id != AT91C_ID_PIOA) &&
+		    (pPin->pio_ctrl_id != AT91C_ID_PIOB) &&
+		    (pPin->pio_ctrl_id != AT91C_ID_PIOC)) {
+			printk(KERN_ERR "Bad PIO controler ID %u, correct values are {%u, %u ,%u}\n", 
+			       pPin->pio_ctrl_id, AT91C_ID_PIOA, AT91C_ID_PIOB, AT91C_ID_PIOC);
+			return -ENODEV;
+		}
+		if (pPin->type == TYPE_PERIPH) // PIN is in PERIPH mode
+			at91_gpio_periph_enable(pPin->pio_ctrl_va_base, pPin->pin_num, pPin->direction, pPin->use_pullup, pPin->use_filter);
+		else // PIN is in PIO mode
+			at91_gpio_configure(pPin->pio_ctrl_va_base, pPin->pin_num, pPin->direction, pPin->use_pullup, pPin->use_filter);
+		pPin++;
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(at91_device_pio_setup);
+
+static inline void __iomem *pin_to_controller(unsigned pin)
+{
+        void __iomem *sys_base = (void __iomem *) AT91C_VA_BASE_SYS;
+
+        pin -= PIN_BASE;
+        pin /= 32;
+        return sys_base + pio_controller_offset[pin];
+
+        return NULL;
+}
+
+static inline unsigned pin_to_mask_o(unsigned pin)
+{
+        pin -= PIN_BASE;
+        return 1 << (pin % 32);
+}
+
+/*
+ * read the pin's value (works even if it's not muxed as a gpio).
+ */
+int at91_get_gpio_value(unsigned pin)
+{
+        void __iomem    *pio = pin_to_controller(pin);
+        unsigned        mask = pin_to_mask_o(pin);
+        u32             pdsr;
+
+        if (!pio)
+                return -EINVAL;
+        pdsr = __raw_readl(pio + PIO_PDSR);
+        return (pdsr & mask) != 0;
+}
+EXPORT_SYMBOL(at91_get_gpio_value);
+
+/*--------------------------------------------------------------------------*/
+
+
+/* Several AIC controller irqs are dispatched through this GPIO handler.
+ * To use any AT91_PIN_* as an externally triggered IRQ, first call
+ * at91_set_gpio_input() then maybe enable its glitch filter.
+ * Then just request_irq() with the pin ID; it works like any ARM IRQ
+ * handler, though it always triggers on rising and falling edges.
+ *
+ * Alternatively, certain pins may be used directly as IRQ0..IRQ6 after
+ * configuring them with at91_set_a_periph() or at91_set_b_periph().
+ * IRQ0..IRQ6 should be configurable, e.g. level vs edge triggering.
+ */
+
+static void gpio_irq_mask(unsigned pin)
+{
+        void __iomem    *pio = pin_to_controller(pin);
+        unsigned        mask = pin_to_mask_o(pin);
+
+        if (pio)
+                __raw_writel(mask, pio + PIO_IDR);
+}
+
+static void gpio_irq_unmask(unsigned pin)
+{
+        void __iomem    *pio = pin_to_controller(pin);
+        unsigned        mask = pin_to_mask_o(pin);
+
+	printk("gpio_irq_unmask %d %x\n", pin, pio);
+        if (pio)
+                __raw_writel(mask, pio + PIO_IER);
+}
+
+static int gpio_irq_type(unsigned pin, unsigned type)
+{
+        return (type == IRQT_BOTHEDGE) ? 0 : -EINVAL;
+}
+
+static struct irqchip gpio_irqchip = {
+        .mask           = gpio_irq_mask,
+        .unmask         = gpio_irq_unmask,
+        .set_type       = gpio_irq_type,
+};
+
+static void gpio_irq_handler(unsigned irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+        unsigned        pin;
+        struct irqdesc  *gpio;
+        void __iomem    *pio;
+        u32             isr;
+
+        pio = (void __force __iomem *) desc->chipdata;
+
+        /* temporarily mask (level sensitive) parent IRQ */
+        desc->chip->ack(irq);
+        for (;;) {
+                isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+                if (!isr)
+                        break;
+
+                pin = (unsigned) desc->data;
+                gpio = &irq_desc[pin];
+
+                while (isr) {
+                        if (isr & 1)
+                                gpio->handle(pin, gpio, regs);
+                        pin++;
+                        gpio++;
+                        isr >>= 1;
+                }
+        }
+        desc->chip->unmask(irq);
+        /* now it may re-trigger */
+}
+
+/* call this from board-specific init_irq */
+void __init at91_gpio_irq_setup(unsigned banks)
+{
+        unsigned        pioc, pin, id;
+
+        if (banks > 4)
+                banks = 4;
+        for (pioc = 0, pin = PIN_BASE, id = AT91_ID_PIOA;
+                        pioc < banks;
+                        pioc++, id++) {
+                void __iomem    *controller;
+                unsigned        i;
+
+                controller = (void __iomem *) AT91C_VA_BASE_SYS + pio_controller_offset[pioc];
+                __raw_writel(~0, controller + PIO_IDR);
+
+                set_irq_data(id, (void *) pin);
+                set_irq_chipdata(id, (void __force *) controller);
+
+                for (i = 0; i < 32; i++, pin++) {
+                        set_irq_chip(pin, &gpio_irqchip);
+                        set_irq_handler(pin, do_simple_IRQ);
+                        set_irq_flags(pin, IRQF_VALID);
+                }
+
+                set_irq_chained_handler(id, gpio_irq_handler);
+		printk("set_irq_chained_handler %d\n", id);
+
+                /* enable the PIO peripheral clock */
+		at91_enable_periph_clock(id);
+                //at91_sys_write(AT91_PMC_PCER, 1 << id);
+        }
+        pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, banks);
+}
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/gpio_tgt.c linux-2.6.15.4/arch/arm/mach-at91sam9261/gpio_tgt.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/gpio_tgt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/gpio_tgt.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,365 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/gpio.c
+ *
+ * Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/gpio_tgt.h>
+#include <asm/arch/at91sam9261_sys.h>
+
+
+
+static inline unsigned pin_to_controller(unsigned pin)
+{
+	return  (pin - PIN_BASE) / 32;
+}
+
+static inline unsigned pin_to_mask(unsigned pin)
+{
+	return 1 << ((pin - PIN_BASE) % 32);
+}
+
+
+/*--------------------------------------------------------------------------*/
+
+/* Not all hardware capabilities are exposed through these calls; they
+ * only encapsulate the most common features and modes.  (So if you
+ * want to change signals in groups, do it directly.)
+ *
+ * Bootloaders will usually handle some of the pin multiplexing setup.
+ * The intent is certainly that by the time Linux is fully booted, all
+ * pins should have been fully initialized.  These setup calls should
+ * only be used by board setup routines, or possibly in driver probe().
+ *
+ * For bootloaders doing all that setup, these calls could be inlined
+ * as NOPs so Linux won't duplicate any setup code
+ */
+
+
+/*
+ * mux the pin to the "A" internal peripheral role.
+ */
+int __init_or_module at91_set_A_periph(unsigned pin, int use_pullup)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write(use_pullup ? PIO_PPUER(pio) : PIO_PPUDR(pio), mask);
+	at91_sys_write(PIO_ASR(pio), mask);
+	at91_sys_write(PIO_PDR(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_A_periph);
+
+
+/*
+ * mux the pin to the "B" internal peripheral role.
+ */
+int __init_or_module at91_set_B_periph(unsigned pin, int use_pullup)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write((use_pullup ? PIO_PPUER(pio) : PIO_PPUDR(pio)), mask);
+	at91_sys_write(PIO_BSR(pio), mask);
+	at91_sys_write(PIO_PDR(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_B_periph);
+
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral), and
+ * configure it for an input.
+ */
+int __init_or_module at91_set_gpio_input(unsigned pin, int use_pullup)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write((use_pullup ? PIO_PPUER(pio) : PIO_PPUDR(pio)), mask);
+	at91_sys_write(PIO_ODR(pio), mask);
+	at91_sys_write(PIO_PER(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_input);
+
+
+/*
+ * mux the pin to the gpio controller (instead of "A" or "B" peripheral),
+ * and configure it for an output.
+ */
+int __init_or_module at91_set_gpio_output(unsigned pin, int value)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write(PIO_IDR(pio), mask);
+	at91_sys_write(PIO_PPUDR(pio), mask);
+	at91_sys_write((value ? PIO_SODR(pio) : PIO_CODR(pio)), mask);
+	at91_sys_write(PIO_OER(pio), mask);
+	at91_sys_write(PIO_PER(pio), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_output);
+
+
+/*
+ * enable/disable the glitch filter; mostly used with IRQ handling.
+ */
+int __init_or_module at91_set_deglitch(unsigned pin, int is_on)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+	at91_sys_write((is_on ? PIO_IFER(pio) : PIO_IFDR(pio)), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_deglitch);
+
+/*
+ * enable/disable the multi-driver; This is only valid for output and
+ * allows the output pin to run as an open collector output.
+ */
+int __init_or_module at91_set_multi_drive(unsigned pin, int is_on)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+
+	at91_sys_write((is_on ? PIO_MDER(pio) : PIO_MDDR(pio)), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_multi_drive);
+
+/*--------------------------------------------------------------------------*/
+
+
+/*
+ * assuming the pin is muxed as a gpio output, set its value.
+ */
+int at91_set_gpio_value(unsigned pin, int value)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+	at91_sys_write((value ? PIO_SODR(pio) : PIO_CODR(pio)), mask);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_gpio_value);
+
+
+/*
+ * read the pin's value (works even if it's not muxed as a gpio).
+ */
+int at91_get_gpio_value(unsigned pin)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+	u32		pdsr;
+
+	if (pio >= AT91_NR_PIO)
+		return -EINVAL;
+	pdsr = at91_sys_read(PIO_PDSR(pio));
+	return (pdsr & mask) != 0;
+}
+EXPORT_SYMBOL(at91_get_gpio_value);
+
+/*
+ * Configure PIO in periph mode according to the platform informations
+ */
+#ifdef 0
+int at91_device_pio_setup (struct at91_pioline *pio_desc)
+{
+        unsigned        pio, pin = 0;
+
+        if(!pio_desc) {
+                printk(KERN_ERR "Define the PIO muxing of this device first !!\n");
+                return 0;
+        }
+
+        /* Sets all the pio muxing of the corresponding device as defined in its platform_data struct */
+        while (pio_desc->pin_name) {
+                pio = pin_to_controller( pio_desc->pin_num);
+                if (pio >= AT91_NR_PIO)
+                        printk(KERN_ERR "Bad pin number %u for pio %s in platform description\n",
+                                pio_desc->pin_num, pio_desc->pin_name);
+                else if (pio_desc->type == ATM_PIO_PERIPH_A)
+                        at91_set_A_periph(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_PULLUP) ? 1 : 0);
+                else if (pio_desc->type == ATM_PIO_PERIPH_B)
+                        at91_set_B_periph(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_PULLUP) ? 1 : 0);
+                else if (pio_desc->type == ATM_PIO_INPUT) {
+                        at91_set_deglitch(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_DEGLITCH)? 1 : 0);
+                        at91_set_gpio_input(pio_desc->pin_num,
+                                (pio_desc->attribute & ATM_PIO_PULLUP) ? 1 : 0);
+                }
+                else if(pio_desc->type == ATM_PIO_OUTPUT) {
+                        at91_set_multi_drive(pio_desc->pin_num, (pio_desc->attribute & ATM_PIO_OPENDRAIN) ? 1 : 0);
+                        at91_set_gpio_output(pio_desc->pin_num, pio_desc->dft_value);
+                }
+                else
+                         printk(KERN_ERR "Bad pin type %u for pio %s in platform description\n",
+                                 pio_desc->pin_num, pio_desc->pin_name);
+                ++pin;
+                ++pio_desc;
+        }
+        return pin;
+}
+
+EXPORT_SYMBOL(at91_device_pio_setup);
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+
+/* Several AIC controller irqs are dispatched through this GPIO handler.
+ * To use any AT91_PIN_* as an externally triggered IRQ, first call
+ * at91_set_gpio_input() then maybe enable its glitch filter.
+ * Then just request_irq() with the pin ID; it works like any ARM IRQ
+ * handler, though it always triggers on rising and falling edges.
+ *
+ * Alternatively, certain pins may be used directly as IRQ0..IRQ6 after
+ * configuring them with at91_set_a_periph() or at91_set_b_periph().
+ * IRQ0..IRQ6 should be configurable, e.g. level vs edge triggering.
+ */
+
+static void gpio_irq_mask(unsigned pin)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio < AT91_NR_PIO)
+		at91_sys_write(PIO_IDR(pio), mask);
+}
+
+static void gpio_irq_unmask(unsigned pin)
+{
+	unsigned	pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (pio < AT91_NR_PIO)
+		at91_sys_write(PIO_IER(pio), mask);
+}
+
+static int gpio_irq_type(unsigned pin, unsigned type)
+{
+	return (type == IRQT_BOTHEDGE) ? 0 : -EINVAL;
+}
+
+static struct irqchip gpio_irqchip = {
+	.mask		= gpio_irq_mask,
+	.unmask		= gpio_irq_unmask,
+	.set_type	= gpio_irq_type,
+};
+
+static void gpio_irq_handler(unsigned irq, struct irqdesc *desc, struct pt_regs *regs)
+{
+	unsigned	pin;
+	struct irqdesc	*gpio;
+	unsigned	pio;
+	u32		isr;
+
+	pio = (unsigned __force) desc->chipdata;
+
+	/* temporarily mask (level sensitive) parent IRQ */
+	desc->chip->ack(irq);
+	for (;;) {
+		isr = at91_sys_read(PIO_ISR(pio)) & at91_sys_read(PIO_IMR(pio));
+		if (!isr)
+			break;
+
+		pin = (unsigned) desc->data;
+		gpio = &irq_desc[pin];
+
+		while (isr) {
+			if (isr & 1) {
+				if (unlikely(gpio->disable_depth)) {
+					/*
+					 * The core ARM interrupt handler lazily disables IRQs so
+					 * another IRQ must be generated before it actually gets
+					 * here to be disabled on the GPIO controller.
+					 */
+					gpio_irq_mask(pin);
+				}
+				else {
+					gpio->handle(pin, gpio, regs);
+				}
+			}
+			pin++;
+			gpio++;
+			isr >>= 1;
+		}
+	}
+	desc->chip->unmask(irq);
+	/* now it may re-trigger */
+}
+
+/* call this from board-specific init_irq */
+void __init at91_gpio_irq_setup(unsigned banks)
+{
+	unsigned	pioc, pin, id;
+
+	if (banks > AT91_NR_PIO)
+		banks = AT91_NR_PIO;
+	for (pioc = 0, pin = PIN_BASE, id = AT91_ID_PIOA;
+			pioc < banks;
+			pioc++, id++) {
+		unsigned	pio = pin_to_controller(pin);
+		unsigned	i;
+
+		at91_sys_write(PIO_IDR(pio), ~0);
+
+		set_irq_data(id, (void *) pin);
+		set_irq_chipdata(id, (void __force *) pioc);
+
+		for (i = 0; i < 32; i++, pin++) {
+			set_irq_chip(pin, &gpio_irqchip);
+			set_irq_handler(pin, do_simple_IRQ);
+			set_irq_flags(pin, IRQF_VALID);
+		}
+
+		set_irq_chained_handler(id, gpio_irq_handler);
+
+		/* enable the PIO peripheral clock */
+		at91_sys_write(PMC_PCER, 1 << id);
+	}
+	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, banks);
+}
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/irq.c linux-2.6.15.4/arch/arm/mach-at91sam9261/irq.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/irq.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/irq.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+
+#define readreg_aic(offset)             readl(AT91C_VA_BASE_AIC + offset)
+#define writereg_aic(value, offset)     writel(value, (AT91C_VA_BASE_AIC + offset))
+
+/* Interrupt configuration */
+static volatile unsigned int at91sam9261_irq_smr[] __initdata = {
+	(AT91_SMR_FIQ),		/* FIQ */
+	(AT91_SMR_SYS),		/* System Peripherals */
+	(AT91_SMR_PIOA),	/* PIO A */
+	(AT91_SMR_PIOB),	/* PIO B */
+	(AT91_SMR_PIOC),	/* PIO C */
+	0,
+	(AT91_SMR_US0),		/* USART 0 */
+	(AT91_SMR_US1),		/* USART 1 */
+	(AT91_SMR_US2),		/* USART 2 */
+	(AT91_SMR_MCI),		/* Multimedia Card */
+	(AT91_SMR_UDP),		/* USB Device */
+	(AT91_SMR_TWI),		/* Two-wire interface */
+	(AT91_SMR_SPI0),	/* SPI 0 */
+	(AT91_SMR_SPI1),	/* SPI 1 */
+	(AT91_SMR_SSC0),	/* Sync Serial 0 */
+	(AT91_SMR_SSC1),	/* Sync Serial 1 */
+	(AT91_SMR_SSC2),	/* Sync Serial 2 */
+	(AT91_SMR_TC0),		/* TC 0 */
+	(AT91_SMR_TC1),		/* TC 1 */
+	(AT91_SMR_TC2),		/* TC 2 */
+	(AT91_SMR_UHP),		/* USB Host */
+	(AT91_SMR_LCDC),	/* LCDC */
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	(AT91_SMR_IRQ0),	/* IRQ 0 */
+	(AT91_SMR_IRQ1),	/* IRQ 1 */
+	(AT91_SMR_IRQ2),	/* IRQ 2 */
+};
+
+static void at91sam9261_mask_irq(unsigned int irq)
+{
+	/* Disable interrupt on AIC */
+	writereg_aic(1 << irq, AIC_IDCR);
+}
+
+static void at91sam9261_unmask_irq(unsigned int irq)
+{
+	/* Enable interrupt on AIC */
+	writereg_aic(1 << irq, AIC_IECR);
+}
+
+static struct irqchip at91sam9261_irq_chip = {
+	.ack	  = at91sam9261_mask_irq,
+	.mask	  = at91sam9261_mask_irq,
+	.unmask = at91sam9261_unmask_irq,
+};
+
+void at91sam9261_clear_irq(unsigned int irq)
+{
+	/* Clear an interrupt on AIC */
+	writereg_aic(1 << irq, AIC_ICCR);
+}
+
+void __init at91sam9261_init_irq(void)
+{
+	int i;
+
+	/*
+	 * The IVR is used by macro get_irqnr_and_base to read and verify.
+	 * The irq number is NR_IRQS when a spurious interrupt has occured.
+	 */
+	for (i = 0; i < NR_AIC_IRQS; i++) {
+		/* Put irq number in Source Vector Register: */
+		writereg_aic(i, (AIC_SVR + (i<<2)));
+		/* Store the Source Mode Register as defined in table above */
+		writereg_aic(at91sam9261_irq_smr[i], (AIC_SMR + (i<<2)));
+		set_irq_chip(i, &at91sam9261_irq_chip);
+		set_irq_handler(i, do_level_IRQ);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+    
+		/* Perform 8 End Of Interrupt Command to make sure AIC will not Lock out nIRQ */
+		if (i < 8)
+			writereg_aic(readreg_aic(AIC_EOICR), AIC_EOICR);
+	}
+  
+	/* 
+	 * Spurious Interrupt ID in Spurious Vector Register is NR_IRQS
+	 * When there is no current interrupt, the IRQ Vector Register reads the value stored in AIC_SPU
+	 */
+	writereg_aic(NR_AIC_IRQS, AIC_SPU);
+  
+	/* No debugging in AIC: Debug (Protect) Control Register */
+	writereg_aic(0, AIC_DCR);
+  
+	/* Disable and clear all interrupts initially */
+	writereg_aic(0xFFFFFFFF, AIC_IDCR);
+	writereg_aic(0xFFFFFFFF, AIC_ICCR);
+}
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/Makefile linux-2.6.15.4/arch/arm/mach-at91sam9261/Makefile
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/Makefile	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Common support
+obj-y			:= board-ek.o core.o irq.o time.o gpio.o devices.o pmc.o
+obj-m			:=
+obj-n			:=
+obj-			:=
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/Makefile.boot linux-2.6.15.4/arch/arm/mach-at91sam9261/Makefile.boot
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/Makefile.boot	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/Makefile.boot	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,11 @@
+# Note: the following conditions must always be true:
+#   ZRELADDR == virt_to_phys(TEXTADDR)
+#   PARAMS_PHYS must be within 4MB of ZRELADDR
+#   INITRD_PHYS must be in RAM
+
+zreladdr-y      := 0x20008000
+params_phys-y	:= 0x20000100
+initrd_phys-y	:= 0x20410000
+
+#params_phys-y   := 0x00000100
+#initrd_phys-y   := 0x00800000
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/pmc.c linux-2.6.15.4/arch/arm/mach-at91sam9261/pmc.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/pmc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/pmc.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/pmc.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/hardware.h>
+
+#define readreg_pmc(offset)             readl(AT91C_VA_BASE_PMC + offset)
+#define writereg_pmc(value, offset)     writel(value, (AT91C_VA_BASE_PMC + offset))
+
+
+void at91_disable_periph_clock(unsigned int irq)
+{
+	/* Disable the corresponding peripheral clock */
+	writereg_pmc(1 << irq, PMC_PCDR);
+}
+
+void at91_enable_periph_clock(unsigned int irq)
+{
+	/* Enable the corresponding peripheral clock */
+	writereg_pmc(1 << irq, PMC_PCER);
+}
+
+void at91_disable_system_clock(unsigned int mask)
+{
+	/* Disable the corresponding system clock */
+	writereg_pmc(mask, PMC_SCDR);
+}
+
+void at91_enable_system_clock(unsigned int mask)
+{
+	/* Enable the corresponding system clock */
+	writereg_pmc(mask, PMC_SCER);
+}
+
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/time.c linux-2.6.15.4/arch/arm/mach-at91sam9261/time.c
--- linux-2.6.15.4-orig/arch/arm/mach-at91sam9261/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-at91sam9261/time.c	2006-08-09 10:44:57.000000000 +0200
@@ -0,0 +1,105 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/time.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ * Revision	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+#include <linux/device.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <asm/arch/time.h>
+
+#define readreg_pitc(offset)            readl(AT91C_VA_BASE_PITC + offset)
+#define writereg_pitc(value, offset)    writel(value, (AT91C_VA_BASE_PITC + offset))
+
+#define READ_PIT_CPIV(x)  ((x) & AT91C_PITC_CPIV)
+#define READ_PIT_PICNT(x) (((x) & AT91C_PITC_PICNT) >> 20)
+
+
+/*
+ * Returns number of microseconds since last timer interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeofday()
+ *  'LATCH' is hwclock ticks (see CLOCK_TICK_RATE in timex.h) per jiffy.
+ *  'tick' is usecs per jiffy (linux/timex.h).
+ */
+static unsigned long at91sam9261_gettimeoffset(void)
+{
+	unsigned long nb_us = ((READ_PIT_CPIV(readreg_pitc(PITC_PIIR)) * 1000000) / CLOCK_TICK_RATE) + ((READ_PIT_PICNT(readreg_pitc(PITC_PIIR)) * 1000000)/HZ);
+	return (nb_us);
+}
+
+/*
+ * IRQ handler for the timer.
+ */
+static irqreturn_t at91sam9261_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	volatile unsigned int nb_ticks;
+
+	if (readreg_pitc(PITC_PISR) & AT91C_PITC_PITS) {	/* This is a shared interrupt */
+		write_seqlock(&xtime_lock);
+    
+		/* Get number to ticks performed before interrupt and clear PIT interrupt */
+		nb_ticks = READ_PIT_PICNT(readreg_pitc(PITC_PIVR));
+    
+		do {
+			timer_tick(regs);
+			nb_ticks--;
+		} while(nb_ticks);
+    
+		write_sequnlock(&xtime_lock);
+    
+		return IRQ_HANDLED;
+	} else {
+		return IRQ_NONE;		/* not handled */
+	};
+}
+
+static struct irqaction at91sam9261_timer_irq = {
+	.name	= "AT91SAM9261 Timer",
+	.flags	= SA_SHIRQ | SA_INTERRUPT | SA_TIMER,
+	.handler= at91sam9261_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt.
+ */
+void __init at91sam9261_timer_init(void)
+{
+	/* Enable timer */
+	writereg_pitc(AT91C_PITC_PITEN, PITC_PIMR);
+
+	/* Clear any pending interrupts */
+	readreg_pitc(PITC_PIVR);
+    
+	/* Set Period Interval timer and enable its interrupt */
+	writereg_pitc((readreg_pitc(PITC_PIMR) | ((LATCH & AT91C_PITC_CPIV) | AT91C_PITC_PITIEN)), PITC_PIMR);
+  
+	/* Make IRQs happen for the system timer. */
+	setup_irq(AT91C_ID_SYS, &at91sam9261_timer_irq);
+  
+	/* Change the kernel's 'tick' value to 10009 usec. (the default is 10000) */
+	tick_usec = (LATCH * 1000000) / CLOCK_TICK_RATE;
+
+	return;
+}
+
+struct sys_timer at91sam9261_timer = {
+	.init   = at91sam9261_timer_init,
+	.offset = at91sam9261_gettimeoffset,
+};
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/core.c linux-2.6.15.4/arch/arm/mach-nadia2/core.c
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/core.c	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * linux/arch/arm/mach-at91sam9261/core.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ * Revision 	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/time.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <asm/arch/time.h>
+#include <asm/arch/pmc.h>
+
+
+#define MAINTAINER(n)
+
+
+extern void __init nadia2_init_irq(void);
+
+
+/*
+ * System peripheral registers mapped at virtual address.
+ */
+
+static struct map_desc nadia2_io_desc[] __initdata = {
+	{ 
+		.virtual = AT91C_VA_BASE_SYS,
+		.pfn = __phys_to_pfn(AT91C_BASE_SYS),
+		.length = SZ_8K,
+		.type = MT_DEVICE
+	}
+};
+
+
+void __init nadia2_map_io(void)
+{
+	iotable_init(nadia2_io_desc, ARRAY_SIZE(nadia2_io_desc));
+}
+
+MACHINE_START(NADIA2VB, "ATMEL NADIA2")
+	MAINTAINER("M. Amine SAYA, ATMEL Rousset")
+        .phys_ram       = AT91_SDRAM_BASE,
+        .phys_io        = AT91C_BASE_SYS,
+        .io_pg_offst    = ((AT91C_VA_BASE_SYS) >> 18) & 0xfffc,
+        .boot_params    = 0x00000000,
+        .map_io         = nadia2_map_io,
+        .init_irq       = nadia2_init_irq,
+	.timer		= &nadia2_timer,
+//	.init_machine = nadia2_init_machine,
+MACHINE_END
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/devices.c linux-2.6.15.4/arch/arm/mach-nadia2/devices.c
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/devices.c	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,448 @@
+/*
+ * linux/arch/arm/mach-nadia2/devices.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/sizes.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/nadia2_usart.h>
+#include <asm/arch/nadia2_spi.h>
+#include <asm/arch/nadia2_lcdc.h>
+#include <asm/arch/nadia2_ac97c.h>
+#include <asm/arch/nadia2_uhp.h>
+#include <asm/arch/emac.h>
+
+
+#define SZ_512	0x00000200
+#define SZ_256	0x00000100
+#define SZ_16	0x00000010
+
+
+/* A generic dma mask must be set inorder for DMA relying devices to work */
+static u64 global_dmamask = 0xffffffffUL;
+
+static struct __initdata at91_pioline dbgu_pio[] = {
+	{"DRXD", PIOC,  30, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"DTXD", PIOC, 31, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+static struct resource dbgu_resources[] = {
+	{
+		.start	= AT91C_BASE_DBGU,
+		.end	= AT91C_BASE_DBGU + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, 
+        {
+                .start  = AT91C_ID_SYS,
+                .end    = AT91C_ID_SYS,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device dbgu_device = {
+	.name		= "usart",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dbgu_resources),
+	.dev		= {
+
+
+
+				.platform_data	= &dbgu_pio,
+	},
+	.resource	= dbgu_resources,
+};
+
+static struct __initdata at91_pioline usart0_pio[] = {
+	{"TXD0", PIOA, 26, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RXD0", PIOA, 27, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RTS0", PIOA, 28, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"CTS0", PIOA, 29, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"SCK0", PIOA, 30, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+static struct resource usart0_resources[] = {
+	{
+		.start	= AT91C_BASE_US0,
+		.end	= AT91C_BASE_US0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+        {
+                .start  = AT91C_ID_US0,
+                .end    = AT91C_ID_US0,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usart0_device = {
+	.name		= "usart",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(usart0_resources),
+	.dev		= {
+				.platform_data	= &usart0_pio,
+	},
+	.resource	= usart0_resources,
+};
+
+static struct __initdata at91_pioline usart1_pio[] = {
+	{"TXD1", PIOD, 0, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RXD1", PIOD, 1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RTS1", PIOD, 7, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"CTS1", PIOD, 8, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"SCK1", PIOD, 10, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+static struct resource usart1_resources[] = {
+	{
+		.start	= AT91C_BASE_US1,
+		.end	= AT91C_BASE_US1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+        {
+                .start  = AT91C_ID_US1,
+                .end    = AT91C_ID_US1,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usart1_device = {
+	.name		= "usart",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(usart1_resources),
+	.dev		= {
+				.platform_data	= &usart1_pio,
+	},
+	.resource	= usart1_resources,
+};
+
+static struct __initdata at91_pioline usart2_pio[] = {
+	{"TXD2", PIOD, 2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RXD2", PIOD, 3, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RTS2", PIOD, 5, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"CTS2", PIOD, 6, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"SCK2", PIOD, 9, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+static struct resource usart2_resources[] = {
+	{
+		.start	= AT91C_BASE_US2,
+		.end	= AT91C_BASE_US2 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+        {
+                .start  = AT91C_ID_US2,
+                .end    = AT91C_ID_US2,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usart2_device = {
+	.name		= "usart",
+	.id		= 3,
+	.num_resources	= ARRAY_SIZE(usart2_resources),
+	.dev		= {
+				.platform_data	= &usart2_pio,
+	},
+	.resource	= usart2_resources,
+};
+
+static struct __initdata at91_pioline spi0_pio[] = {
+        {"MISO0", PIOA,  0, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"MOSI0", PIOA,  1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"SPCK0", PIOA,  2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {NULL, 0, 0, 0, 0, 0},
+};
+
+static struct resource spi0_resources[] = {
+        {
+                .start = AT91C_BASE_SPI0,
+                .end   = AT91C_BASE_SPI0 + SZ_16K - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        {
+                .start = AT91C_ID_SPI0,
+                .end   = AT91C_ID_SPI0,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device spi0_device = {
+        .name           = "spi",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(spi0_resources),
+        .dev            = {
+                                .platform_data  = &spi0_pio,
+        },
+        .resource       = spi0_resources,
+};
+
+static struct __initdata at91_pioline spi1_pio[] = {
+        {"MISO1", PIOB, 30, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"MOSI1", PIOB, 31, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {"SPCK1", PIOB, 29, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+        {NULL, 0, 0, 0, 0, 0},
+};
+
+static struct resource spi1_resources[] = {
+        {
+                .start = AT91C_BASE_SPI1,
+                .end   = AT91C_BASE_SPI1 + SZ_16K - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        {
+                .start = AT91C_ID_SPI1,
+                .end   = AT91C_ID_SPI1,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device spi1_device = {
+        .name           = "spi",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(spi1_resources),
+        .dev            = {
+                                .platform_data  = &spi1_pio,
+        },
+        .resource       = spi1_resources,
+};
+
+static struct __initdata at91_pioline lcdc_pio[] = {
+	{"LCDHSYNC", PIOC,  1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDDOTCK", PIOC,  2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDDEN"  , PIOC,  3, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDCC"   , PIOB,  9, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD2"   , PIOC,  6, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD3"   , PIOC,  7, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD4"   , PIOC,  8, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD5"   , PIOC,  9, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD6"   , PIOC, 10, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD7"   , PIOC, 11, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD10"  , PIOC, 14, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD11"  , PIOC, 15, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD12"  , PIOC, 16, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD13"  , PIOC, 12, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD14"  , PIOC, 18, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD15"  , PIOC, 19, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD18"  , PIOC, 22, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD19"  , PIOC, 23, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD20"  , PIOC, 24, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD21"  , PIOC, 17, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD22"  , PIOC, 26, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"LCDD23"  , PIOC, 27, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"POWCTRL" , PIOD, 12, TYPE_PIO   , OUTPUT_MODE, NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+static struct resource lcdc_resources[] = {
+	{
+		.start      = AT91C_BASE_LCDC,
+		.end        = AT91C_BASE_LCDC + SZ_4K - 1,
+		.flags      = IORESOURCE_MEM,
+	}, 
+	{
+		.start      = AT91C_ID_LCDC,
+		.end        = AT91C_ID_LCDC,
+		.flags      = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device lcdc_device = {
+	.name           = "sidsa-lcdc",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(lcdc_resources),
+	.resource       = lcdc_resources,
+	.dev            = {
+		.dma_mask          = &global_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &lcdc_pio,
+	},
+};
+
+
+static struct __initdata at91_pioline ac97c_pio[] = {
+	{"AC97FS", PIOB, 0, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"AC97CK", PIOB, 1, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"AC97TX", PIOB, 2, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"AC97RX", PIOB, 3, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"RESET" , PIOA, 13, TYPE_PIO  , OUTPUT_MODE, NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+
+static struct resource ac97c_resources[] = {
+	{
+		.start      = AT91C_BASE_AC97C,
+		.end        = AT91C_BASE_AC97C + SZ_4K - 1,
+		.flags      = IORESOURCE_MEM,
+	}, 
+	{
+		.start      = AT91C_ID_AC97C,
+		.end        = AT91C_ID_AC97C,
+		.flags      = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ac97c_device = {
+	.name           = "ac97c",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(ac97c_resources),
+	.resource       = ac97c_resources,
+	.dev            = {
+		.dma_mask          = &global_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &ac97c_pio,
+	},
+};
+
+
+static struct resource usb_ohci_resource[] = {
+	/* order *IS* significant */
+	{
+		.start	= AT91C_BASE_UHP,
+		.end	= AT91C_BASE_UHP + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AT91C_ID_UHP,
+		.end	= AT91C_ID_UHP,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device usb_ohci_device = {
+	.name		= "usb-ohci",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &global_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= usb_ohci_resource,
+	.num_resources	= ARRAY_SIZE(usb_ohci_resource),
+};
+
+
+static struct at91_pioline macb_pio[] = {
+        {"ERXDV", PIOC, 25, TYPE_PERIPH, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETXCK", PIOE, 21, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ECRS" , PIOE, 22, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETX0" , PIOE, 23, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETX1" , PIOE, 24, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ERX0",  PIOE, 25, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ERX1",  PIOE, 26, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ERXER", PIOE, 27, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"ETXEN", PIOE, 28, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"EMDC",  PIOE, 29, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"EMDIO", PIOE, 30, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"E_F100", PIOE, 31, TYPE_PERIPH, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT},
+	{"MDINTR",PIOA, 31, TYPE_PIO   , INPUT_MODE,  NO_PULL_UP, NO_GLITCH_FLT},
+	{NULL, 0, 0, 0, 0, 0},
+};
+
+
+static struct __initdata at91_eth_pdata macb_data = {
+  .phy_id = 0,
+  .pio_data = macb_pio,
+};
+
+
+static struct resource macb_resource[] = {
+	/* order *IS* significant */
+	{
+		.start	= AT91C_BASE_EMAC,
+		.end	= AT91C_BASE_EMAC + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AT91C_ID_EMAC,
+		.end	= AT91C_ID_EMAC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device macb_device = {
+	.name		= "macb",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &global_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data          = &macb_data,
+	},
+	.resource	= macb_resource,
+	.num_resources	= ARRAY_SIZE(macb_resource),
+};
+
+/*
+// External Touch screen controller.
+static struct __initdata at91_pioline tsc_pio[] = {
+        {"BUSY",    PIOA, 11, TYPE_PIO, INPUT_MODE, NO_PULL_UP, NO_GLITCH_FLT},
+        {"NPENIRQ", PIOC,  2, TYPE_PIO, INPUT_MODE, PULLED_UP,  NO_GLITCH_FLT},
+        {NULL, 0, 0, 0, 0, 0},
+};
+// It only has an irq line.
+static struct resource tsc_resources[] = {
+	{
+		.start = AT91C_ID_IRQ0,
+		.end   = AT91C_ID_IRQ0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tsc_device = {
+	.name           = "tsc",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(tsc_resources),
+        .dev            = {
+                                .platform_data  = &tsc_pio,
+        },
+	.resource       = tsc_resources,
+};
+*/
+
+static struct platform_device *nadia2vb_devices[] __initdata = {
+	&dbgu_device,
+	&usart0_device,
+	&usart1_device,
+	&usart2_device,
+        &spi0_device,
+        &spi1_device,
+        &lcdc_device,
+	&ac97c_device,
+	&usb_ohci_device,
+	&macb_device,
+	//	&tsc_device,
+};
+
+static int __init nadia2_device_init(void)
+{
+	return platform_add_devices(nadia2vb_devices, ARRAY_SIZE(nadia2vb_devices));
+}
+
+arch_initcall(nadia2_device_init);
+
+const struct platform_device *platform_get_device(const char *name, int id)
+{
+	int i;
+  
+	for (i = 0; i < ARRAY_SIZE(nadia2vb_devices); i++) {
+		if ((nadia2vb_devices[i]->id == id) && 
+		    (strcmp(nadia2vb_devices[i]->name, name) == 0))
+			return nadia2vb_devices[i];
+	} 
+	return NULL;
+}
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/gpio.c linux-2.6.15.4/arch/arm/mach-nadia2/gpio.c
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/gpio.c	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,169 @@
+/*
+ * linux/arch/arm/mach-nadia2/gpio.c
+ *
+ * Copyright (C) 2005  M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+
+
+/*--------------------------------------------------------------------------*/
+
+/* Not all hardware capabilities are exposed through these calls; they
+ * only encapsulate the most common features and modes.  (So if you
+ * want to change signals in groups, do it directly.)
+ *
+ * Bootloaders will usually handle some of the pin multiplexing setup.
+ * The intent is certainly that by the time Linux is fully booted, all
+ * pins should have been fully initialized.  These setup calls should
+ * only be used by board setup routines, or possibly in driver probe().
+ *
+ * For bootloaders doing all that setup, these calls could be inlined
+ * as NOPs so Linux won't duplicate any setup code
+ */
+
+
+/*
+ * mux the pin to the corresponding internal peripheral role.
+ */
+
+
+void at91_gpio_periph_enable (unsigned int pio_va_base, 
+			      unsigned char pin, 
+			      unsigned char peripheral, 
+			      unsigned char use_pullup, 
+			      unsigned char use_filter) 
+{
+	unsigned int mask = pin_to_mask(pin);
+
+	writel(mask, (pio_va_base + PIO_IDR));	
+
+	if(use_pullup)
+		writel(mask, (pio_va_base + PIO_PPUER));
+	else
+		writel(mask, (pio_va_base + PIO_PPUDR));
+
+	switch (peripheral) 
+	{
+		case 1:
+			writel(mask, (pio_va_base + PIO_BSR));
+		break;
+		case 0:
+		default:
+			writel(mask, (pio_va_base + PIO_ASR));
+		break;
+	}
+
+	/* The Peripheral controls the pin (pio disabled) */
+	writel(mask, (pio_va_base + PIO_PDR));
+}
+
+
+EXPORT_SYMBOL(at91_gpio_periph_enable);
+
+void at91_gpio_configure (unsigned int pio_va_base, 
+			  unsigned char pin, 
+			  unsigned char in_out, 
+			  unsigned char use_pullup, 
+			  unsigned char use_filter) 
+{
+        unsigned int mask = pin_to_mask(pin);
+	
+	/* The PIO controls the pin (periph disabled) */
+	writel(mask, (pio_va_base + PIO_PER));
+
+	if(in_out) { /* the pin is an input */
+        	writel(mask, (pio_va_base + PIO_ODR));
+	}
+	else {       /* the pin is an output */
+        	writel(mask, (pio_va_base + PIO_OER));
+	}
+
+        if(use_pullup)
+                writel(mask, (pio_va_base + PIO_PPUER));
+        else
+                writel(mask, (pio_va_base + PIO_PPUDR));
+}
+
+
+EXPORT_SYMBOL(at91_gpio_configure);
+
+void at91_gpio_set_level (unsigned int pio_va_base, unsigned int pin, unsigned int level)
+{
+        unsigned int mask = pin_to_mask(pin);
+
+	// This is just a sanity action to force a pin 
+	// to output before driving it.
+        writel(mask, pio_va_base + PIO_PER);
+	writel(mask, pio_va_base + PIO_OER);
+	
+	if (level)
+	  writel(mask, pio_va_base + PIO_SODR);
+	else // pin should be cleared
+	  writel(mask, pio_va_base + PIO_CODR);
+
+}
+
+
+EXPORT_SYMBOL(at91_gpio_set_level);
+
+unsigned int at91_gpio_get_level (unsigned int pio_va_base, unsigned int pin)
+{
+        unsigned int mask = pin_to_mask(pin);
+
+
+	// This is just a sanity action to force a pin 
+	// to input before reading it.
+        writel(mask, pio_va_base + PIO_PER);
+	writel(mask, pio_va_base + PIO_ODR);
+
+	return (readl(pio_va_base + PIO_PDSR) & mask);
+}
+
+
+EXPORT_SYMBOL(at91_gpio_get_level);
+
+
+int at91_device_pio_setup (struct at91_pioline *pPin) {
+
+	if(!pPin) {
+		printk(KERN_ERR "Define the PIO muxing of this device first !!\n");
+		return -ENODEV;
+	}
+
+	/* Sets all the pio muxing of the corresponding device as defined in its platform_data struct */
+	while (pPin->pin_name)
+	{
+		if ((pPin->pio_ctrl_id != AT91C_ID_PIOA) &&
+		    (pPin->pio_ctrl_id != AT91C_ID_PIOB) &&
+		    (pPin->pio_ctrl_id != AT91C_ID_PIOCDE)) {
+			printk(KERN_ERR "Bad PIO controler ID %u, correct values are {%u, %u ,%u}\n", 
+			       pPin->pio_ctrl_id, AT91C_ID_PIOA, AT91C_ID_PIOB, AT91C_ID_PIOCDE);
+			return -ENODEV;
+		}
+		if (pPin->type == TYPE_PERIPH) // PIN is in PERIPH mode
+			at91_gpio_periph_enable(pPin->pio_ctrl_va_base, pPin->pin_num, pPin->direction, pPin->use_pullup, pPin->use_filter);
+		else // PIN is in PIO mode
+			at91_gpio_configure(pPin->pio_ctrl_va_base, pPin->pin_num, pPin->direction, pPin->use_pullup, pPin->use_filter);
+		pPin++;
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(at91_device_pio_setup);
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/irq.c linux-2.6.15.4/arch/arm/mach-nadia2/irq.c
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/irq.c	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,128 @@
+/*
+ * linux/arch/arm/mach-nadia2/irq.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+
+
+
+#define readreg_aic(offset)             readl(AT91C_VA_BASE_AIC + offset)
+#define writereg_aic(value, offset)     writel(value, AT91C_VA_BASE_AIC + offset)
+
+
+/* Interrupt configuration */
+static volatile unsigned int nadia2_irq_smr[] __initdata = {
+	(AT91_SMR_FIQ),		// FIQ 
+	(AT91_SMR_SYS),		// System Peripherals 
+	(AT91_SMR_PIOA),	// PIO A 
+	(AT91_SMR_PIOB),	// PIO B 
+	(AT91_SMR_PIOCDE),	// PIO C,D,E 
+	(AT91_SMR_AES),         // AES 
+	0,
+	(AT91_SMR_US0),		// USART 0 
+	(AT91_SMR_US1),		// USART 1 
+	(AT91_SMR_US2),		// USART 2 
+	(AT91_SMR_MCI0),	// Multimedia Card 
+	(AT91_SMR_MCI1),	// Multimedia Card 
+	(AT91_SMR_CAN),	        // Controller Area Network 
+	(AT91_SMR_TWI),	        // Two Wire Interface 
+	(AT91_SMR_SPI0),	// SPI 0 
+	(AT91_SMR_SPI1),	// SPI 1 
+	(AT91_SMR_SSC0),	// Sync Serial 0 
+	(AT91_SMR_SSC1),	// Sync Serial 1 
+	(AT91_SMR_AC97C),	// AC97 Controller
+	(AT91_SMR_TC012),	// TC 0,1,2 
+	(AT91_SMR_PWMC),	// Pulse Width Modulation Controller 
+	(AT91_SMR_EMAC),	// MACB 
+	(AT91_SMR_GPSE_KBDI),	// GPSE or KBDI 
+	(AT91_SMR_2DGE),	// 2D Graphics Controller 
+	(AT91_SMR_UDP),		// USB Device 
+	(AT91_SMR_ISI),		// Image Sensor Interface 
+	(AT91_SMR_LCDC),	// LCD Controller 
+	(AT91_SMR_DMAC),	// DMA Controller 
+	(AT91_SMR_OTG),	        // USB OTG Controller 
+	(AT91_SMR_UHP),         // USB Host Controller
+	(AT91_SMR_IRQ0),        // External IRQ0
+	(AT91_SMR_IRQ1),        // External IRQ1
+};
+
+
+
+static void nadia2_mask_irq(unsigned int irq)
+{
+	/* Disable interrupt on AIC */
+	writereg_aic(1 << irq, AIC_IDCR);
+}
+
+static void nadia2_unmask_irq(unsigned int irq)
+{
+	/* Enable interrupt on AIC */
+	writereg_aic(1 << irq, AIC_IECR);
+}
+
+static struct irqchip nadia2_irq_chip = {
+	.ack	  = nadia2_mask_irq,
+	.mask	  = nadia2_mask_irq,
+	.unmask = nadia2_unmask_irq,
+};
+
+void at91_clear_irq(unsigned int irq)
+{
+	/* Clear an interrupt on AIC */
+	writereg_aic(1 << irq, AIC_ICCR);
+}
+
+void __init nadia2_init_irq(void)
+{
+	int i;
+
+	/*
+	 * The IVR is used by macro get_irqnr_and_base to read and verify.
+	 * The irq number is NR_IRQS when a spurious interrupt has occured.
+	 */
+	for (i = 0; i < NR_IRQS; i++) {
+		/* Put irq number in Source Vector Register: */
+		writereg_aic(i, (AIC_SVR + (i<<2)));
+		/* Store the Source Mode Register as defined in table above */
+		writereg_aic(nadia2_irq_smr[i], (AIC_SMR + (i<<2)));
+		set_irq_chip(i, &nadia2_irq_chip);
+		set_irq_handler(i, do_level_IRQ);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+    
+		/* Perform 8 End Of Interrupt Command to make sure AIC will not Lock out nIRQ */
+		if (i < 8)
+			writereg_aic(readreg_aic(AIC_EOICR), AIC_EOICR);
+	}
+  
+	/* 
+	 * Spurious Interrupt ID in Spurious Vector Register is NR_IRQS
+	 * When there is no current interrupt, the IRQ Vector Register reads the value stored in AIC_SPU
+	 */
+	writereg_aic(NR_IRQS, AIC_SPU);
+  
+	/* No debugging in AIC: Debug (Protect) Control Register */
+	writereg_aic(0, AIC_DCR);
+  
+	/* Disable and clear all interrupts initially */
+	writereg_aic(0xFFFFFFFF, AIC_IDCR);
+	writereg_aic(0xFFFFFFFF, AIC_ICCR);
+}
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/Makefile linux-2.6.15.4/arch/arm/mach-nadia2/Makefile
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/Makefile	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Common support
+obj-y			:= core.o irq.o time.o gpio.o devices.o pmc.o
+obj-m			:=
+obj-n			:=
+obj-			:=
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/Makefile.boot linux-2.6.15.4/arch/arm/mach-nadia2/Makefile.boot
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/Makefile.boot	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/Makefile.boot	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,11 @@
+# Note: the following conditions must always be true:
+#   ZRELADDR == virt_to_phys(TEXTADDR)
+#   PARAMS_PHYS must be within 4MB of ZRELADDR
+#   INITRD_PHYS must be in RAM
+
+zreladdr-y      := 0x20008000
+params_phys-y	:= 0x20000100
+initrd_phys-y	:= 0x20410000
+
+#params_phys-y   := 0x00000100
+#initrd_phys-y   := 0x00800000
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/pmc.c linux-2.6.15.4/arch/arm/mach-nadia2/pmc.c
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/pmc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/pmc.c	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ * linux/arch/arm/mach-nadia2/pmc.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/hardware.h>
+
+
+
+#define readreg_pmc(offset)             readl(AT91C_VA_BASE_SYS + offset)
+#define writereg_pmc(value, offset)     writel(value, AT91C_VA_BASE_SYS + offset)
+
+
+void at91_disable_periph_clock(unsigned int irq)
+{
+	/* Disable the corresponding peripheral clock */
+	writereg_pmc(1 << irq, SYS_PMC_PCDR);
+}
+
+void at91_enable_periph_clock(unsigned int irq)
+{
+	/* Enable the corresponding peripheral clock */
+	writereg_pmc(1 << irq, SYS_PMC_PCER);
+}
+
+void at91_disable_system_clock(unsigned int mask)
+{
+	/* Disable the corresponding system clock */
+	writereg_pmc(mask, SYS_PMC_SCDR);
+}
+
+void at91_enable_system_clock(unsigned int mask)
+{
+	/* Enable the corresponding system clock */
+	writereg_pmc(mask, SYS_PMC_SCER);
+}
+
+
diff -Nur linux-2.6.15.4-orig/arch/arm/mach-nadia2/time.c linux-2.6.15.4/arch/arm/mach-nadia2/time.c
--- linux-2.6.15.4-orig/arch/arm/mach-nadia2/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mach-nadia2/time.c	2006-08-09 10:44:56.000000000 +0200
@@ -0,0 +1,109 @@
+/*
+ * linux/arch/arm/mach-nadia2/time.c
+ *
+ * Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+#include <linux/device.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <asm/arch/time.h>
+#include <asm/arch/nadia2_pitc.h>
+
+
+#define readreg_pitc(offset)            readl(AT91C_VA_BASE_PITC + offset)
+#define writereg_pitc(value, offset)    writel(value, AT91C_VA_BASE_PITC + offset)
+
+
+
+#define READ_PIT_CPIV(x)  ((x) & AT91C_PITC_CPIV)
+#define READ_PIT_PICNT(x) (((x) & AT91C_PITC_PICNT) >> 20)
+
+
+/*
+ * Returns number of microseconds since last timer interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeofday()
+ *  'LATCH' is hwclock ticks (see CLOCK_TICK_RATE in timex.h) per jiffy.
+ *  'tick' is usecs per jiffy (linux/timex.h).
+ */
+static unsigned long nadia2_gettimeoffset(void)
+{
+	unsigned long nb_us = ((READ_PIT_CPIV(readreg_pitc(PITC_PIIR)) * 1000000) / CLOCK_TICK_RATE) + ((READ_PIT_PICNT(readreg_pitc(PITC_PIIR)) * 1000000)/HZ);
+	return (nb_us);
+}
+
+/*
+ * IRQ handler for the timer.
+ */
+static irqreturn_t nadia2_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	volatile unsigned int nb_ticks;
+
+	if (readreg_pitc(PITC_PISR) & AT91C_PITC_PITS) {	/* This is a shared interrupt */
+		write_seqlock(&xtime_lock);
+    
+		/* Get number to ticks performed before interrupt and clear PIT interrupt */
+		nb_ticks = READ_PIT_PICNT(readreg_pitc(PITC_PIVR));
+    
+		do {
+			timer_tick(regs);
+			nb_ticks--;
+		} while(nb_ticks);
+    
+		write_sequnlock(&xtime_lock);
+    
+		return IRQ_HANDLED;
+	} else {
+		return IRQ_NONE;		/* not handled */
+	};
+}
+
+static struct irqaction nadia2_timer_irq = {
+	.name	= "NADIA2 Timer",
+	.flags	= SA_SHIRQ | SA_INTERRUPT | SA_TIMER,
+	.handler= nadia2_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt.
+ */
+void __init nadia2_timer_init(void)
+{
+	/* Enable timer */
+	writereg_pitc(AT91C_PITC_PITEN, PITC_PIMR);
+
+	/* Clear any pending interrupts */
+	readreg_pitc(PITC_PIVR);
+    
+	/* Set Period Interval timer and enable its interrupt */
+	writereg_pitc((readreg_pitc(PITC_PIMR) | ((LATCH & AT91C_PITC_CPIV) | AT91C_PITC_PITIEN)), PITC_PIMR);
+  
+	/* Make IRQs happen for the system timer. */
+	setup_irq(AT91C_ID_SYS, &nadia2_timer_irq);
+  
+	/* Change the kernel's 'tick' value to 10009 usec. (the default is 10000) */
+	tick_usec = (LATCH * 1000000) / CLOCK_TICK_RATE;
+
+	return;
+}
+
+struct sys_timer nadia2_timer = {
+	.init   = nadia2_timer_init,
+	.offset = nadia2_gettimeoffset,
+};
+
diff -Nur linux-2.6.15.4-orig/arch/arm/Makefile linux-2.6.15.4/arch/arm/Makefile
--- linux-2.6.15.4-orig/arch/arm/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/arch/arm/Makefile	2006-08-09 10:54:04.000000000 +0200
@@ -102,6 +102,9 @@
  machine-$(CONFIG_ARCH_H720X)	   := h720x
  machine-$(CONFIG_ARCH_AAEC2000)   := aaec2000
  machine-$(CONFIG_ARCH_REALVIEW)   := realview
+ machine-$(CONFIG_MACH_AT91SAM9261EK)   := at91sam9261
+ machine-$(CONFIG_MACH_AT91SAM9260EK)   := at91sam9260
+ machine-$(CONFIG_MACH_NADIA2VB)   := nadia2
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
diff -Nur linux-2.6.15.4-orig/arch/arm/mm/Kconfig linux-2.6.15.4/arch/arm/mm/Kconfig
--- linux-2.6.15.4-orig/arch/arm/mm/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/arch/arm/mm/Kconfig	2006-08-09 14:26:11.000000000 +0200
@@ -121,8 +121,8 @@
 # ARM926T
 config CPU_ARM926T
 	bool "Support ARM926T processor"
-	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || MACH_REALVIEW_EB
-	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX
+	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || MACH_REALVIEW_EB || MACH_AT91SAM9261EK || MACH_NADIA2VB ||  MACH_AT91SAM9260EK
+	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || MACH_AT91SAM9261EK || MACH_NADIA2VB || MACH_AT91SAM9260EK 
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_CACHE_VIVT
diff -Nur linux-2.6.15.4-orig/arch/arm/tools/mach-types linux-2.6.15.4/arch/arm/tools/mach-types
--- linux-2.6.15.4-orig/arch/arm/tools/mach-types	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/arch/arm/tools/mach-types	2006-08-09 10:52:37.000000000 +0200
@@ -910,3 +910,4 @@
 nadia2vb		MACH_NADIA2VB		NADIA2VB		897
 r1000			MACH_R1000		R1000			898
 hw90250			MACH_HW90250		HW90250			899
+at91sam9260ek		MACH_AT91SAM9260EK	AT91SAM9260EK		1099
diff -Nur linux-2.6.15.4-orig/arch/ppc/Makefile linux-2.6.15.4/arch/ppc/Makefile
--- linux-2.6.15.4-orig/arch/ppc/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/arch/ppc/Makefile	2006-08-09 10:44:57.000000000 +0200
@@ -132,14 +132,18 @@
 
 checkbin:
 	@if test "$(GCC_VERSION)" = "0304" ; then \
-		if ! /bin/echo mftb 5 | $(AS) -v -mppc -many -o $(TOUT) >/dev/null 2>&1 ; then \
+		if /bin/echo mftb 5 | $(AS) -v -mppc -many -o $(TOUT) >/dev/null 2>&1 ; then \
+			echo "" >/dev/null 2>&1 ; \
+		else \
 			echo -n '*** ${VERSION}.${PATCHLEVEL} kernels no longer build '; \
 			echo 'correctly with gcc-3.4 and your version of binutils.'; \
 			echo '*** Please upgrade your binutils or downgrade your gcc'; \
 			false; \
 		fi ; \
 	fi
-	@if ! /bin/echo dssall | $(AS) -many -o $(TOUT) >/dev/null 2>&1 ; then \
+	@if /bin/echo dssall | $(AS) -many -o $(TOUT) >/dev/null 2>&1 ; then \
+		echo "" >/dev/null 2>&1 ; \
+	else \
 		echo -n '*** ${VERSION}.${PATCHLEVEL} kernels no longer build ' ; \
 		echo 'correctly with old versions of binutils.' ; \
 		echo '*** Please upgrade your binutils to 2.12.1 or newer' ; \
diff -Nur linux-2.6.15.4-orig/Documentation/at91rm9261ekbuild.xml linux-2.6.15.4/Documentation/at91rm9261ekbuild.xml
--- linux-2.6.15.4-orig/Documentation/at91rm9261ekbuild.xml	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/Documentation/at91rm9261ekbuild.xml	2006-08-09 10:45:08.000000000 +0200
@@ -0,0 +1,29 @@
+<?xml version="1.0" standalone="no"?>
+<bsp>
+  <shortname>at91rm9261ek</shortname>
+  <name>at91rm9261ek</name>
+  <cpu>armv5l</cpu>
+  <arch>arm</arch>
+  <crosscompile>armv5l-linux-</crosscompile>
+  <tsrel>kernel-2.6.15-ts.at91rm9261ek.1</tsrel>
+  <configfiles
+    location="at91rm9261ektsconf"
+    ext=".kfg"
+    helpext=".help.xml">
+  </configfiles>
+  <nativefstarget
+    build="uImage"
+    image="arch/arm/boot/uImage">
+  </nativefstarget>
+  <initrdtarget
+    build=""
+    image=""
+    initrddir=""
+    initrdimgname=""
+    size="">
+  </initrdtarget>
+  <jffs
+    eblksz=""
+    extra="">
+  </jffs>
+</bsp>
diff -Nur linux-2.6.15.4-orig/Documentation/at91rm9261ektsconf/defconfig.help.xml linux-2.6.15.4/Documentation/at91rm9261ektsconf/defconfig.help.xml
--- linux-2.6.15.4-orig/Documentation/at91rm9261ektsconf/defconfig.help.xml	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/Documentation/at91rm9261ektsconf/defconfig.help.xml	2006-08-09 10:45:14.000000000 +0200
@@ -0,0 +1 @@
+Default kernel configuration file for at91rm9261ek
diff -Nur linux-2.6.15.4-orig/Documentation/at91rm9261ektsconf/defconfig.kfg linux-2.6.15.4/Documentation/at91rm9261ektsconf/defconfig.kfg
--- linux-2.6.15.4-orig/Documentation/at91rm9261ektsconf/defconfig.kfg	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/Documentation/at91rm9261ektsconf/defconfig.kfg	2006-08-09 10:45:14.000000000 +0200
@@ -0,0 +1,1036 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15.4
+# Tue Mar 28 11:33:23 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+CONFIG_MACH_AT91SAM9261EK=y
+# CONFIG_MACH_NADIA2VB is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=64M console=ttyS0,115200 root=/dev/nfs rw ip=bootp"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK is not set
+# CONFIG_NF_CONNTRACK is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_DATAFLASH_AT91=y
+# CONFIG_DATAFLASH_DEBUG is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=40960
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=240
+CONFIG_INPUT_TSDEV_SCREEN_Y=320
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_ADS7843E_AT91=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AT91=y
+CONFIG_SERIAL_AT91_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+
+#
+# SPI Hardware Bus support
+#
+CONFIG_SPI_AT91=y
+
+#
+# SPI Hardware device support
+#
+CONFIG_TSC_SPI_AT91=y
+# CONFIG_TSC_SPI_DEBUG is not set
+# CONFIG_SPI_DEBUG_CORE is not set
+# CONFIG_SPI_DEBUG_BUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_SIDSA=y
+CONFIG_FB_TCM=y
+# CONFIG_FB_SDRAM is not set
+CONFIG_TFT_AT91=y
+CONFIG_FB_SIDSA_DEFAULT_BPP=16
+# CONFIG_FB_SIDSA_DEBUG is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_AT91=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+CONFIG_USB_GADGET_AT91=y
+CONFIG_USB_AT91=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+CONFIG_USB_G_SERIAL=y
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=850
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_WRITEBUFFER is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Nur linux-2.6.15.4-orig/drivers/input/touchscreen/at91_ads7843e_ts.c linux-2.6.15.4/drivers/input/touchscreen/at91_ads7843e_ts.c
--- linux-2.6.15.4-orig/drivers/input/touchscreen/at91_ads7843e_ts.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/input/touchscreen/at91_ads7843e_ts.c	2006-08-09 10:45:25.000000000 +0200
@@ -0,0 +1,305 @@
+/*
+ *  drivers/input/touchscreen/at91_ads7843e_ts.c
+ *
+ *  Touchscreen driver for AT91SAM9261 toush screen
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/spi.h>
+
+#include <asm/platform.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pmc.h>
+
+#include "at91_ads7843e_ts.h"
+
+
+// TODO : handle the drag and drop action by adding a timer in at91_ads7843e_ts_work that
+//        captures values until pen is up.
+static void at91_ads7843e_ts_work(void *data)
+{
+        struct ts_device *ts_dev = (struct ts_device *) data;
+	unsigned char cmd;
+	volatile unsigned long x_pos, y_pos;
+
+	/*
+	 * This is a work around to make linux avoid penirq up position.
+	 * This should be fixed by putting IRQ0 as an external interrupt 
+	 * and not as an internal one. To be continued.
+	 */
+	//status = readl(&AT91_SYS->PIOC_PDSR);
+	if (readl(AT91C_VA_BASE_PIOC + PIO_PDSR) & pin_to_mask(2)) {
+	        ts_dev->tc.pressure = 0;
+		ts_dev->pendown = PEN_UP; 
+		goto out_work_handler;
+	}
+
+	/* Sanity check*/
+	if (ts_dev->pendown == PEN_UP)
+		ts_dev->pendown = PEN_DOWN;
+	else
+		goto out_work_handler;
+
+	/* Switch to full power mode*/
+	cmd = (1 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START | ADS_CTRL_PD0 | ADS_CTRL_PD1;
+	at91_tsc_spi_sendrecv(cmd);
+
+	/* Get X position*/
+	cmd = (1 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START | ADS_CTRL_PD0 | ADS_CTRL_PD1;
+	y_pos = at91_tsc_spi_sendrecv(cmd);
+
+	/* Get Y position*/
+	cmd = (5 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START | ADS_CTRL_PD0 | ADS_CTRL_PD1;
+	x_pos = at91_tsc_spi_sendrecv(cmd);
+
+	printk(KERN_DEBUG "x_pos : %lu\ty_pos : %lu\n", x_pos, y_pos);
+
+	/* Restore Power-down for ADS7843*/
+	cmd = (1 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START;
+	at91_tsc_spi_sendrecv(cmd);
+
+	cmd = (5 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START;
+	at91_tsc_spi_sendrecv(cmd);
+
+	/* Clear any pending interrupts*/
+	at91sam9261_clear_irq(ts_dev->irq);
+
+	if (x_pos == 0 || y_pos == 0)
+		goto out_work_handler;
+
+	ts_dev->tc.pressure = (PRESSURE_MIN + PRESSURE_MAX)/2;
+
+	/* Store position*/
+	input_report_abs(&ts_dev->input, ABS_X, x_pos);
+	input_report_abs(&ts_dev->input, ABS_Y, y_pos);
+	
+out_work_handler:
+	/* Report PEN position*/
+	input_report_abs(&ts_dev->input, ABS_PRESSURE, ts_dev->tc.pressure);
+	input_report_key(&ts_dev->input, BTN_TOUCH, (ts_dev->pendown != PEN_UP) ? 1 : 0);
+
+	/* Send positions to input layer */
+	input_sync(&ts_dev->input);
+	enable_irq(ts_dev->irq);
+}
+
+static irqreturn_t at91_ads7843e_ts_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct ts_device *ts_dev = (struct ts_device *) dev_id;
+
+	disable_irq_nosync(irq);
+	schedule_delayed_work(&ts_dev->work, HZ / 20);
+
+	return IRQ_HANDLED;
+}
+
+static void at91_init_input(struct device *dev, struct ts_device *ts_dev)
+{
+	/* Init Input device in ts_dev*/
+	//init_input_dev(&ts_dev->input);
+	ts_dev->input = *input_allocate_device();
+
+	ts_dev->input.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	ts_dev->input.keybit[LONG(BTN_TOUCH)] = BIT(BTN_TOUCH);
+
+	input_set_abs_params(&ts_dev->input, ABS_X, X_AXIS_MIN, X_AXIS_MAX, 0, 0);
+	input_set_abs_params(&ts_dev->input, ABS_Y, Y_AXIS_MIN, Y_AXIS_MAX, 0, 0);
+	input_set_abs_params(&ts_dev->input, ABS_PRESSURE, PRESSURE_MIN, PRESSURE_MAX, 0, 0);
+  
+	strncpy(ts_dev->phys, "ts/input0", 14);
+  
+	ts_dev->input.private = ts_dev;
+	ts_dev->input.name = "SAM926x Touchscreen";
+	ts_dev->input.dev = dev;
+	ts_dev->input.phys = ts_dev->phys;
+	ts_dev->input.id.bustype = BUS_HOST;
+	ts_dev->input.id.vendor = 0x0001;
+	ts_dev->input.id.product = 0x0002;
+	ts_dev->input.id.version = 0x0100;
+
+	input_register_device(&ts_dev->input);
+}
+
+static void at91_init_ads7843e(void)
+{
+	/* Initiaize ADS7843 Difference Reference mode */
+	at91_tsc_spi_sendrecv((1 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START);
+	at91_tsc_spi_sendrecv((5 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START);
+}
+
+
+#ifdef CONFIG_PM
+static int at91_ads7843e_ts_suspend(struct device *dev, pm_message_t state, u32 level)
+{
+	if (level == SUSPEND_POWER_DOWN) {
+		struct ts_device *ts_dev = dev_get_drvdata(dev);
+
+		/* Disable interrupt*/
+		disable_irq_nosync(ts_dev->irq);
+		
+		/* Disable PMC clock for PIOC*/
+		at91_disable_periph_clock(AT91C_ID_PIOC);
+
+		/* Remove work queue from shared queue.*/
+		while(!cancel_delayed_work(&ts_dev->work));
+		
+		/* Update ts_dev state*/
+		ts_dev->power_mode = PWR_MODE_SUSPEND;
+		ts_dev->pendown = PEN_UP;
+
+		/* Power down the touch screen controller if it is not.*/
+		at91_tsc_spi_sendrecv((1 << ADS_CTRL_SWITCH_SHIFT) | ADS_CTRL_START);
+	}
+
+	return 0;
+}
+
+
+static int at91_ads7843e_ts_resume(struct device *dev, u32 level)
+{
+	if (level == RESUME_POWER_ON) {
+		struct ts_device *ts_dev = dev_get_drvdata(dev);
+
+		/* Enable PMC clock for PIOC*/
+		at91_enable_periph_clock(AT91C_ID_PIOC);
+
+		/* Update ts_dev state*/
+		ts_dev->power_mode = PWR_MODE_ACTIVE;
+
+		/* Enable interrupt*/
+		enable_irq(ts_dev->irq);
+	}
+
+	return 0;
+}
+
+
+#else
+#define at91_ads7843e_ts_suspend	NULL
+#define at91_ads7843e_ts_resume		NULL
+#endif
+
+
+static int __init at91_ads7843e_ts_probe(struct device *dev)
+{
+        struct platform_device *pdev = to_platform_device(dev);
+        struct ts_device *ts_dev;
+	int err;
+
+
+	/* Sanity check.*/
+	if ((platform_num_resources(pdev) < 1)
+	    || !(platform_resource_flags(pdev, 0) & IORESOURCE_IRQ)) {
+		dev_err(dev, "Cannot find necessary resources, aborting.\n");
+		return -ENODEV;
+	}
+
+	/* Alloc touch screen controller desc.*/
+	ts_dev = kmalloc(sizeof(*ts_dev), GFP_KERNEL);
+	if (!ts_dev) {
+		err = -ENOMEM;
+		goto out_free_ts_dev;
+	}
+	
+	memset(ts_dev, 0, sizeof(*ts_dev));
+
+	/* Init irq field in ts_dev*/
+	ts_dev->irq = platform_resource_start(pdev, 0);
+
+	/* Input device init*/
+	at91_init_input(dev, ts_dev);
+
+	/* Init work queue*/
+	INIT_WORK(&ts_dev->work, at91_ads7843e_ts_work, ts_dev);
+
+	/* Init ADS7843E touch screen controller*/
+	at91_init_ads7843e();
+
+	/* Enable PMC clock for PIOC*/
+	at91_enable_periph_clock(AT91C_ID_PIOC);
+	
+	/* Configure PIO for ADS7843E*/
+	at91_device_pio_setup(pdev->dev.platform_data);
+	
+	err = request_irq(ts_dev->irq, at91_ads7843e_ts_interrupt, SA_INTERRUPT, "ts", ts_dev);
+	if (err)
+		goto out_free_input_dev;
+
+	ts_dev->power_mode = PWR_MODE_ACTIVE;
+	ts_dev->pendown = PEN_UP;
+
+	/* Keep ts_dev address, it is our entry point structure*/
+	dev_set_drvdata(dev, ts_dev);
+
+	dev_info(dev, "AT91SAM9261 Touch Screen Registered\n");
+
+	return 0;
+
+out_free_input_dev:
+	input_unregister_device(&ts_dev->input);
+out_free_ts_dev:
+	kfree(ts_dev);	
+
+	return err;
+}
+
+static int at91_ads7843e_ts_remove(struct device *dev)
+{
+	struct ts_device *ts_dev = dev_get_drvdata(dev);
+
+	/* Disable PMC clock for PIOC*/
+	at91_disable_periph_clock(AT91C_ID_PIOC);
+
+	free_irq(ts_dev->irq, ts_dev);
+
+	/* Remove work queue from shared queue.*/
+	while(!cancel_delayed_work(&ts_dev->work));
+
+	input_unregister_device(&ts_dev->input);
+
+	kfree(ts_dev);
+
+	return 0;
+}
+
+static struct device_driver at91_ads7843e_ts_driver = {
+	.name		= "ts",
+	.bus		= &platform_bus_type,
+	.probe		= at91_ads7843e_ts_probe,
+	.remove		= at91_ads7843e_ts_remove,
+	.suspend	= at91_ads7843e_ts_suspend,
+	.resume		= at91_ads7843e_ts_resume,
+};
+
+static int __devinit at91_ads7843e_ts_init(void)
+{
+	return driver_register(&at91_ads7843e_ts_driver);
+}
+
+static void __exit at91_ads7843e_ts_exit(void)
+{
+	driver_unregister(&at91_ads7843e_ts_driver);
+}
+
+module_init(at91_ads7843e_ts_init);
+module_exit(at91_ads7843e_ts_exit);
+
+MODULE_AUTHOR("M. Amine SAYA, ATMEL Rousset, France");
+MODULE_DESCRIPTION("AT91SAM9261 ADS7843E TouchScreen Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.15.4-orig/drivers/input/touchscreen/at91_ads7843e_ts.h linux-2.6.15.4/drivers/input/touchscreen/at91_ads7843e_ts.h
--- linux-2.6.15.4-orig/drivers/input/touchscreen/at91_ads7843e_ts.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/input/touchscreen/at91_ads7843e_ts.h	2006-08-09 10:45:25.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * drivers/input/touchscreen/at91_ads7843e_ts.h
+ *
+ * Definitions for ADS7843E touch screen. 
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France.
+ *
+ */
+
+#ifndef _AT91_ADS7843E_TS_H
+#define _AT91_ADS7843E_TS_H
+
+
+#define PWR_MODE_ACTIVE		0
+#define PWR_MODE_SUSPEND	1
+#define PEN_UP                      2
+#define PEN_DOWN                    3
+
+#define X_AXIS_MAX		3830
+#define X_AXIS_MIN		150
+#define Y_AXIS_MAX		3830
+#define Y_AXIS_MIN		190
+#define PRESSURE_MIN		0
+#define PRESSURE_MAX		15000
+
+/* ADS784X Touch Screen Controller Controll Byte bit definitions */
+#define ADS_CTRL_PD0		(1 << 0)	/* PD0 */
+#define ADS_CTRL_PD1		(1 << 1)	/* PD1 */
+#define ADS_CTRL_DFR		(1 << 2)	/* SER/DFR */
+#define ADS_CTRL_EIGHT_BITS_MOD	(1 << 3)	/* Mode */
+#define ADS_CTRL_START		(1 << 7)	/* Start Bit */
+
+#define ADS_CTRL_SWITCH_SHIFT	 4	        /* Address setting */
+
+
+struct ts_event {
+  short pressure;
+  short x;
+  short y;
+};
+
+struct ts_device {
+  char phys[32];
+  int irq;
+  struct input_dev input;
+  struct work_struct work;
+  struct ts_event tc;
+  int pendown;
+  int power_mode;
+};
+
+
+// SPI transfer function
+extern unsigned long at91_tsc_spi_sendrecv(unsigned char);
+extern void at91sam9261_clear_irq(unsigned int);
+
+#endif  /* _AT91_ADS7843E_TS_H*/
diff -Nur linux-2.6.15.4-orig/drivers/input/touchscreen/Kconfig linux-2.6.15.4/drivers/input/touchscreen/Kconfig
--- linux-2.6.15.4-orig/drivers/input/touchscreen/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/input/touchscreen/Kconfig	2006-08-09 10:45:25.000000000 +0200
@@ -95,4 +95,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called hp680_ts_input.
 
+config TOUCHSCREEN_ADS7843E_AT91
+        tristate "ADS7843E touch screen controller driver for AT91SAM9261"
+        depends on TSC_SPI_AT91 && MACH_AT91SAM9261EK
+        help
+          Say Y here if you want to include support for ADS7843E touch screen controller
+          used in AT91SAM9261EK.
+
 endif
diff -Nur linux-2.6.15.4-orig/drivers/input/touchscreen/Makefile linux-2.6.15.4/drivers/input/touchscreen/Makefile
--- linux-2.6.15.4-orig/drivers/input/touchscreen/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/input/touchscreen/Makefile	2006-08-09 10:45:25.000000000 +0200
@@ -11,3 +11,4 @@
 obj-$(CONFIG_TOUCHSCREEN_MTOUCH) += mtouch.o
 obj-$(CONFIG_TOUCHSCREEN_MK712)	+= mk712.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)	+= hp680_ts_input.o
+obj-$(CONFIG_TOUCHSCREEN_ADS7843E_AT91)	+= at91_ads7843e_ts.o
diff -Nur linux-2.6.15.4-orig/drivers/Makefile linux-2.6.15.4/drivers/Makefile
--- linux-2.6.15.4-orig/drivers/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/Makefile	2006-08-09 10:45:35.000000000 +0200
@@ -70,3 +70,4 @@
 obj-y				+= firmware/
 obj-$(CONFIG_CRYPTO)		+= crypto/
 obj-$(CONFIG_SUPERH)		+= sh/
+obj-$(CONFIG_SPI)		+= spi/
diff -Nur linux-2.6.15.4-orig/drivers/mtd/devices/at91_dataflash.c linux-2.6.15.4/drivers/mtd/devices/at91_dataflash.c
--- linux-2.6.15.4-orig/drivers/mtd/devices/at91_dataflash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/devices/at91_dataflash.c	2006-08-10 09:48:06.000000000 +0200
@@ -0,0 +1,707 @@
+/*
+ * drivers/mtd/devices/at91_dataflash.c
+ * Atmel DataFlash driver for Atmel AT91SAM926X familly.
+ * Added changes to make dataflash driver work with the new linux 2.6 spi driver.
+ *
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France.
+ *
+ *
+ * Atmel DataFlash driver for Atmel AT91RM9200 (Thunder)
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi.h>
+
+#include <asm/sizes.h>
+#include <asm/arch/spi.h>
+
+#include "at91_dataflash.h"
+
+
+
+/* TODO : */
+// This structure is already declared in drivers/spi/busses/at91_spi.h
+// I added it here just to make it possible to get the SPI host and avoid 
+// checking dataflash devices on chip select that don't have one.
+// This should be removed as soon as we replace the completion mechanism
+// in drivers/spi/busses/at91sam9261_spi.c by a timer so we can't be deadlocked
+// if an interrupt doesn't com due to no response from dataflash chipe.
+struct at91_spi {
+	spinlock_t		lock;
+	struct list_head	xfers;
+	struct spi_adapter	adapter;
+	void			*regs;
+	int			irq;
+	struct platform_device	*pdev;
+	int			dma_status;
+	wait_queue_head_t	dma_wait;
+};
+
+#define adap_to_host(a) container_of(a, struct at91_spi, adapter)
+//#define AT91C_ID_SPI1   (13) // Serial Peripheral Interface 1
+
+/* End TODO notice */
+
+/* ......................................................................... */
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+/*
+static struct mtd_partition static_partitions[] =
+{
+	{
+		name:		"bootloader",
+		offset:		0,
+		size:		256 * 1056,		// 64 Kb
+		mask_flags:	MTD_WRITEABLE,		// read-only
+	},
+	{
+		name:		"kernel",
+		offset:		MTDPART_OFS_NXTBLK,
+		size:		1280 * 1056,		// 768 Kb
+	},
+	{
+		name:		"filesystem",
+		offset:		MTDPART_OFS_NXTBLK,
+		size:		MTDPART_SIZ_FULL,
+	}
+};
+*/
+
+static struct mtd_partition static_partitions[] =
+{
+        {
+		name:		"bootloader",
+		offset:		0,
+		size:		224 * 1056,		// 64 Kb
+		mask_flags:	MTD_WRITEABLE,		// read-only
+	},
+	{
+		name:		"filesystem",
+		offset:		MTDPART_OFS_NXTBLK,
+		size:		MTDPART_SIZ_FULL,
+	}
+};
+
+
+/*
+static struct mtd_partition static_partitions[] =
+{
+	{
+		name:		"filesystem",
+		offset:		0,
+		size:		MTDPART_SIZ_FULL,
+	}
+};
+*/
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+static const char *part_probes[] = { "cmdlinepart", NULL, };
+#endif
+
+#endif
+
+/* ......................................................................... */
+
+
+/*
+ * Perform a SPI transfer to access the DataFlash device.
+ */
+static int do_spi_transfer(struct spi_client *cl, 
+			   int nr, char* tx, int tx_len, char* rx, int rx_len,
+			   char* txnext, int txnext_len, char* rxnext, int rxnext_len)
+{
+	struct spi_xfer_desc list;
+	int ret;
+
+	list.tx_xfer_units[0].buffer = tx;	list.tx_xfer_units[0].buf_len = tx_len;
+	list.rx_xfer_units[0].buffer = rx;	list.rx_xfer_units[0].buf_len = rx_len;
+
+	list.tx_xfer_units[1].buffer = txnext;  list.tx_xfer_units[1].buf_len = txnext_len;
+	list.rx_xfer_units[1].buffer = rxnext;	list.rx_xfer_units[1].buf_len = rxnext_len;
+
+	list.nr_xfers = nr;
+
+	if ((ret = spi_set_adapter_mode(cl)))
+		return ret;
+	
+	return spi_master_xfer(cl, &list);
+}
+
+/* ......................................................................... */
+
+/*
+ * Poll the DataFlash device until it is READY.
+ */
+static void at91_dataflash_waitready(struct spi_client *cl)
+{
+	char *command = kmalloc(2, GFP_KERNEL);
+  
+	if (!command)
+		return;
+  
+	do {
+		command[0] = OP_READ_STATUS;
+		command[1] = 0;
+    
+		do_spi_transfer(cl, 1, command, 2, command, 2, NULL, 0, NULL, 0);
+	} while ((command[1] & 0x80) == 0);
+  
+	kfree(command);
+}
+
+
+/*
+ * Return the status of the DataFlash device.
+ */
+static unsigned short at91_get_dataflash_status(struct spi_client *cl)
+{
+	unsigned short status = 0xff;
+	char *command = kmalloc(2, GFP_KERNEL);
+  
+	if (!command)
+		return -ENOMEM;
+  
+	command[0] = OP_READ_STATUS;
+	command[1] = 0;
+  
+	do_spi_transfer(cl, 1, command, 2, command, 2, NULL, 0, NULL, 0);
+	status = command[1];
+  
+	kfree(command);
+	return status;
+}
+
+
+/* ......................................................................... */
+
+/*
+ * Erase blocks of flash.
+ */
+static int at91_dataflash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct dataflash_chip *df_desc = (struct dataflash_chip *) mtd->priv;
+	struct spi_client *client = &df_desc->client;
+	unsigned int pageaddr;
+	char *command;
+  
+
+#ifdef CONFIG_DATAFLASH_DEBUG
+	printk("dataflash_erase: addr=%i len=%i\n", instr->addr, instr->len);
+#endif
+  
+	/* Sanity checks */
+	if (instr->addr + instr->len > mtd->size)
+		return -EINVAL;
+	if ((instr->len % mtd->erasesize != 0) || (instr->len % df_desc->info->page_size != 0))
+		return -EINVAL;
+	if ((instr->addr % df_desc->info->page_size) != 0)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+  
+	while (instr->len > 0) {
+		/* Calculate flash page address */
+		pageaddr = (instr->addr / df_desc->info->page_size) << df_desc->info->page_offset;
+    
+		command[0] = OP_ERASE_PAGE;
+		command[1] = (pageaddr & 0x00FF0000) >> 16;
+		command[2] = (pageaddr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef CONFIG_DATAFLASH_DEBUG
+		printk("ERASE: (%x) %x %x %x [%i]\n", command[0], command[1], command[2], command[3], pageaddr);
+#endif
+    
+		/* Send command to SPI device */
+		do_spi_transfer(client, 1, command, 4, command, 4, NULL, 0, NULL, 0);
+    
+		at91_dataflash_waitready(client);		/* poll status until ready */
+    
+		instr->addr += df_desc->info->page_size;		/* next page */
+		instr->len -= df_desc->info->page_size;
+	}
+  
+	kfree(command);
+  
+	/* Inform MTD subsystem that erase is complete */
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+  
+	return 0;
+}
+
+
+/*
+ * Read from the DataFlash device.
+ *   from   : Start offset in flash device
+ *   len    : Amount to read
+ *   retlen : About of data actually read
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct dataflash_chip *df_desc = (struct dataflash_chip *) mtd->priv;
+	struct spi_client *client = &df_desc->client;
+	unsigned int addr;
+	char* command;
+
+
+#ifdef CONFIG_DATAFLASH_DEBUG
+	printk("dataflash_read: %lli .. %lli\n", from, from+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (from + len > mtd->size)
+		return -EINVAL;
+
+	/* Calculate flash page/byte address */
+	addr = (((unsigned)from / df_desc->info->page_size) << df_desc->info->page_offset) + ((unsigned)from % df_desc->info->page_size);
+
+	command = kmalloc(8, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	command[0] = OP_READ_CONTINUOUS;
+	command[1] = (addr & 0x00FF0000) >> 16;
+	command[2] = (addr & 0x0000FF00) >> 8;
+	command[3] = (addr & 0x000000FF);
+#ifdef CONFIG_DATAFLASH_DEBUG
+	printk("READ: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+
+	/* Send command to SPI device */
+	do_spi_transfer(client, 2, command, 8, command, 8, buf, len, buf, len);
+
+	*retlen = len;
+	kfree(command);
+	return 0;
+}
+
+/*
+ * Write to the DataFlash device.
+ *   to     : Start offset in flash device
+ *   len    : Amount to write
+ *   retlen : Amount of data actually written
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct dataflash_chip *df_desc = (struct dataflash_chip *) mtd->priv;
+	struct spi_client *client = &df_desc->client;
+	unsigned int pageaddr, addr, offset, writelen;
+	size_t remaining;
+	u_char *writebuf;
+	unsigned short status;
+	int res = 0;
+	char* command;
+	char* tmpbuf = NULL;
+
+
+#ifdef CONFIG_DATAFLASH_DEBUG
+	printk("dataflash_write: %lli .. %lli\n", to, to+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (to + len > mtd->size)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	pageaddr = ((unsigned)to / df_desc->info->page_size);
+	offset = ((unsigned)to % df_desc->info->page_size);
+	if (offset + len > df_desc->info->page_size)
+		writelen = df_desc->info->page_size - offset;
+	else
+		writelen = len;
+	writebuf = (u_char *)buf;
+	remaining = len;
+
+	/* Allocate temporary buffer */
+	tmpbuf = kmalloc(df_desc->info->page_size, GFP_KERNEL);
+	if (!tmpbuf) {
+		kfree(command);
+		return -ENOMEM;
+	}
+
+
+	while (remaining > 0) {
+#ifdef CONFIG_DATAFLASH_DEBUG
+		printk("write @ %i:%i len=%i\n", pageaddr, offset, writelen);
+#endif
+
+		/* (1) Transfer to Buffer1 */
+		if (writelen != df_desc->info->page_size) {
+			addr = pageaddr << df_desc->info->page_offset;
+			command[0] = OP_TRANSFER_BUF1;
+			command[1] = (addr & 0x00FF0000) >> 16;
+			command[2] = (addr & 0x0000FF00) >> 8;
+			command[3] = 0;
+#ifdef CONFIG_DATAFLASH_DEBUG
+			printk("TRANSFER: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+			do_spi_transfer(client, 1, command, 4, command, 4, NULL, 0, NULL, 0);
+			at91_dataflash_waitready(client);
+		}
+
+		/* (2) Program via Buffer1 */
+		addr = (pageaddr << df_desc->info->page_offset) + offset;
+		command[0] = OP_PROGRAM_VIA_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = (addr & 0x000000FF);
+#ifdef CONFIG_DATAFLASH_DEBUG
+		printk("PROGRAM: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(client, 2, command, 4, command, 4, writebuf, writelen, tmpbuf, writelen);
+		at91_dataflash_waitready(client);
+
+		/* (3) Compare to Buffer1 */
+		addr = pageaddr << df_desc->info->page_offset;
+		command[0] = OP_COMPARE_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef CONFIG_DATAFLASH_DEBUG
+		printk("COMPARE: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(client, 1, command, 4, command, 4, NULL, 0, NULL, 0);
+		at91_dataflash_waitready(client);
+
+		/* Get result of the compare operation */
+		status = at91_get_dataflash_status(client);
+		if ((status & 0x40) == 1) {
+			printk("at91_dataflash: Write error on page %i\n", pageaddr);
+			remaining = 0;
+			res = -EIO;
+		}
+
+		remaining = remaining - writelen;
+		pageaddr++;
+		offset = 0;
+		writebuf += writelen;
+		*retlen += writelen;
+
+		if (remaining > df_desc->info->page_size)
+			writelen = df_desc->info->page_size;
+		else
+			writelen = remaining;
+	}
+
+	kfree(tmpbuf);
+	kfree(command);
+	return res;
+}
+
+
+void at91_display_dataflashinfo(struct dataflash_info *df_info)
+{
+#ifdef CONFIG_DATAFLASH_DEBUG
+  printk("Name : %s\nSize : %x\nId : %hx\n", df_info->name, df_info->density, df_info->id);
+#endif
+}
+
+
+/* ......................................................................... */
+
+/*
+ * Initialize and register DataFlash device with MTD subsystem.
+ */
+static int at91_dataflash_add(struct dataflash_chip *df_desc)
+{
+	struct mtd_info *device;
+	struct spi_client *client;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *mtd_parts = 0;
+	int mtd_parts_nr = 0;
+#endif
+  
+	device = (struct mtd_info *) kmalloc(sizeof(*device), GFP_KERNEL);
+	if (!device)
+		return -ENOMEM;
+  
+	/*
+	device->name = (char *) kmalloc(MAX_DATAFLASH_NAME*sizeof(char), GFP_KERNEL);
+	if (!device->name)
+		return -ENOMEM;
+	*/
+	memset(device, 0, sizeof(*device));
+  
+	//strncpy(device->name, (const char *)(df_desc->info->name), MAX_DATAFLASH_NAME);
+	device->name = (char *)df_desc->info->name;
+
+	device->size = df_desc->info->nr_pages * df_desc->info->page_size;
+	device->erasesize = df_desc->info->page_size;
+	device->owner = THIS_MODULE;
+	device->type = MTD_NORFLASH;
+	device->flags = MTD_CAP_NORFLASH;
+	device->erase = at91_dataflash_erase;
+	device->read = at91_dataflash_read;
+	device->write = at91_dataflash_write;  
+	device->priv = df_desc;
+  
+	// save mtd device in client device so we can remove at detach time.
+	client = &df_desc->client;
+	dev_set_drvdata(&client->dev, device);
+
+	dev_info(&client->adapter->dev, "%s detected [spi%i] (%i bytes)\n", device->name, df_desc->client.addr, device->size);
+    
+#ifdef CONFIG_MTD_PARTITIONS
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	mtd_parts_nr = parse_mtd_partitions(device, part_probes, &mtd_parts, 0);
+#else
+	if (mtd_parts_nr <= 0) {
+		mtd_parts = static_partitions;
+		mtd_parts_nr = ARRAY_SIZE(static_partitions);
+	}
+#endif
+
+	if (mtd_parts_nr > 0) {
+#ifdef DATAFLASH_ALWAYS_ADD_DEVICE
+		add_mtd_device(device);
+#endif
+		return add_mtd_partitions(device, mtd_parts, mtd_parts_nr);
+	}
+#endif
+	return add_mtd_device(device);		/* add whole device */
+}
+
+
+static struct dataflash_info *at91_get_dataflash_info(struct spi_client *cl)
+{
+	unsigned short status;
+	int index;
+
+	status = at91_get_dataflash_status(cl);
+
+	/* Sanity check */
+	if (status == 0xff)
+		return NULL;
+
+	status &= 0x3c;
+
+#ifdef CONFIG_DATAFLASH_DEBUG
+	printk("status : %x\n", status);
+#endif
+
+	for (index = 0; index < ARRAY_SIZE(dataflash_table); index++) {
+		if (status == dataflash_table[index].id)
+			return &dataflash_table[index];
+	}
+  
+	return NULL;
+}
+
+
+void at91_add_dataflash_features(struct spi_client_params *params, 
+				 unsigned int baud_rate, unsigned int dlybs, 
+				 unsigned int dlybct, unsigned char clock_phase,
+				 unsigned char clock_polarity, unsigned char bits_per_transfer)
+{
+	params->baud_rate = baud_rate;
+	params->sck_delay = dlybs;
+	params->xfer_delay = dlybct;
+	params->clock_phase = clock_phase;
+	params->clock_polarity = clock_polarity;
+	params->bits_per_transfer = bits_per_transfer; 
+}
+
+
+static struct spi_driver at91_dataflash_driver;
+
+/*
+ * Detect a Dataflash device on a chip select
+ */
+static int at91_dataflash_detect(struct spi_adapter *adapter, int cs)
+{
+	struct dataflash_chip *dataflash;
+	struct spi_client *client;
+	struct spi_client_params params;
+
+	int ret;
+
+
+	dataflash = kmalloc(sizeof(*dataflash), GFP_KERNEL);
+	if (!dataflash)
+		goto out_put_adapter;
+  
+	memset(dataflash, 0, sizeof(*dataflash));
+  
+	client = &dataflash->client;
+
+	snprintf(client->name, SPI_NAME_SIZE, "dataflash");
+	client->id = cs;
+	client->addr = cs;
+	client->driver = &at91_dataflash_driver;
+	client->adapter = adapter;
+
+#ifdef CONFIG_DATAFLASH_DEBUG
+	printk("client->addr : %d\n", client->addr);
+#endif
+
+	// Set chip select in SPI mode register
+	//ret = spi_set_adapter_chipselect(client);
+	//if (ret)
+	//	goto out_free_client;
+  
+	if (client->addr == 3)
+		at91_add_dataflash_features(&params, AT91C_DATAFLASH_CLK_2, AT91C_DATAFLASH_DLYBS,
+						     AT91C_DATAFLASH_DLYBCT, SPI_CPHASE_SAMPLE_TRAILING,
+						     SPI_CPOL_INACTIVE_HIGH, AT91C_BITS_XFER);
+	else
+		at91_add_dataflash_features(&params, AT91C_DATAFLASH_CLK, AT91C_DATAFLASH_DLYBS,
+						     AT91C_DATAFLASH_DLYBCT, SPI_CPHASE_SAMPLE_TRAILING,
+						     SPI_CPOL_INACTIVE_HIGH, AT91C_BITS_XFER);
+  
+	ret = spi_set_client_params(client, &params);
+	if (ret)
+		goto out_free_client;
+
+	ret = spi_attach_client(client);
+	if (ret)
+		goto out_free_client;
+
+	ret = spi_cfgpio_chipselect(client);
+	if (ret)
+		goto out_detach_client;
+
+	dataflash->info = at91_get_dataflash_info(client);
+
+	if (!dataflash->info)
+		goto out_detach_client;
+
+	// Displays dataflash info when debug is enabled
+	at91_display_dataflashinfo(dataflash->info);
+
+	ret = at91_dataflash_add(dataflash);
+	if (ret)
+		goto out_detach_client;
+
+	return 0;
+
+out_detach_client :
+	spi_detach_client(client);
+out_free_client :
+	kfree(dataflash);
+out_put_adapter :
+	spi_put_adapter(adapter);
+
+	return 1;
+}
+
+
+static int at91_dataflash_attach_adapter(struct spi_adapter *adapter)
+{
+	int ret = 1;
+	//int dindex;
+	struct at91_spi *host = adap_to_host(adapter);
+
+	if (host->irq == AT91C_ID_SPI1)
+		return ret;
+  
+	/* Detect dataflash on chip select 0 of SPI0*/
+	ret *= at91_dataflash_detect(adapter, 0);
+
+	/* Detect dataflash on chip select 3 of SPI0*/
+	ret *= at91_dataflash_detect(adapter, 3);
+
+	/*
+	for(dindex = 0; dindex < adapter->max_num_slaves; dindex++)
+		ret *= at91_dataflash_detect(adapter, dindex);
+	*/
+  
+	if (ret)
+		dev_err(&adapter->dev, "No dataflash detected\n");
+  
+	return ret;
+}
+
+
+static int at91_dataflash_detach_adapter(struct spi_adapter *adapter)
+{
+	struct spi_client *client;
+	struct mtd_info *mtd_device;
+  
+	// This adapter can be shared with other driver like touch screen or something.
+	// We only detach the client that handles dataflash chips.
+	list_for_each_entry(client, &adapter->clients, list) {
+		if ((mtd_device = dev_get_drvdata(&client->dev))) {
+      
+#ifdef CONFIG_MTD_PARTITIONS
+			del_mtd_partitions(mtd_device);
+#else
+			del_mtd_device(mtd_device);
+#endif
+      
+			spi_detach_client(client);
+			kfree(mtd_device->priv);
+			kfree(mtd_device);
+		}
+	}
+  
+	return 0;
+}
+
+
+static struct spi_driver at91_dataflash_driver = {
+	.owner		= THIS_MODULE,
+	.name	        = "dataflash_driver",
+	.attach_adapter	= at91_dataflash_attach_adapter,
+	.detach_adapter = at91_dataflash_detach_adapter,
+};
+
+
+static int __init at91_dataflash_init(void)
+{
+	int ret;
+  
+	ret = spi_add_driver(&at91_dataflash_driver);
+	if (ret)
+		goto out;
+  
+	return 0;
+  
+out:
+	printk(KERN_ERR "%s: Driver initialization failed", __FILE__);
+	return ret;
+}
+
+
+static void __exit at91_dataflash_exit(void)
+{
+	spi_remove_driver(&at91_dataflash_driver);
+}
+
+
+module_init(at91_dataflash_init);
+module_exit(at91_dataflash_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Andrew Victor/M. Amine SAYA")
+MODULE_DESCRIPTION("DataFlash driver for Atmel AT91SAM9261")
diff -Nur linux-2.6.15.4-orig/drivers/mtd/devices/at91_dataflash.h linux-2.6.15.4/drivers/mtd/devices/at91_dataflash.h
--- linux-2.6.15.4-orig/drivers/mtd/devices/at91_dataflash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/devices/at91_dataflash.h	2006-08-09 10:45:27.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ * drivers/mtd/devices/at91_dataflash.h
+ *
+ * Definitions for Dataflash device. 
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France.
+ *
+ */
+
+#ifndef _AT91_DATAFLASH_H
+#define _AT91_DATAFLASH_H
+
+
+// Dataflash number of bits per transfers
+#define AT91C_BITS_XFER         8
+
+// Dataflash Clocks
+#define AT91C_DATAFLASH_CLK	33000000        // When master clock is 99,3 MHz
+#define AT91C_DATAFLASH_CLK_2	8000000         // This clock is for dataflash cards
+                                                // that aren't compliant with AT45DB321 speed.
+// Dataflash Timmings in nanoseconds
+#define AT91C_DATAFLASH_DLYBS   250
+#define AT91C_DATAFLASH_DLYBCT  250
+
+// Max dataflash name length
+#define MAX_DATAFLASH_NAME      20
+
+#undef	DATAFLASH_ALWAYS_ADD_DEVICE      /* always add whole device when using partitions? */
+
+#define OP_READ_CONTINUOUS	0xE8
+#define OP_READ_PAGE		0xD2
+#define OP_READ_BUFFER1		0xD4
+#define OP_READ_BUFFER2		0xD6
+#define OP_READ_STATUS		0xD7
+
+#define OP_ERASE_PAGE		0x81
+#define OP_ERASE_BLOCK		0x50
+
+#define OP_TRANSFER_BUF1	0x53
+#define OP_TRANSFER_BUF2	0x55
+#define OP_COMPARE_BUF1		0x60
+#define OP_COMPARE_BUF2		0x61
+
+#define OP_PROGRAM_VIA_BUF1	0x82
+#define OP_PROGRAM_VIA_BUF2	0x85
+
+
+struct dataflash_info {
+	char name[MAX_DATAFLASH_NAME];
+	unsigned int  density;
+	unsigned short id;
+	int  nr_pages;
+	int  page_size;
+	int  page_offset;
+};
+
+
+struct dataflash_chip {
+	struct spi_client client;
+	struct dataflash_info *info;
+	struct class_device class_dev;
+	struct completion released;
+};
+
+
+#define client_to_dataflashchip(a) container_of(a, struct dataflash_chip, client)
+
+struct dataflash_info dataflash_table[] = {
+	{"Atmel AT45DB011B", SZ_128K, 0x0c,   512,  264,  9},
+	{"Atmel AT45DB021B", SZ_256K, 0x14,  1025,  264,  9},
+	{"Atmel AT45DB041B", SZ_512K, 0x1c,  2048,  264,  9},
+	{"Atmel AT45DB081B", SZ_1M,   0x24,  4096,  264,  9},
+	{"Atmel AT45DB161B", SZ_2M,   0x2c,  4096,  528, 10},
+	{"Atmel AT45DB321",  SZ_4M,   0x34,  8192,  528, 10},
+	{"Atmel AT45DB642",  SZ_8M,   0x3c,  8192, 1056, 11},
+	{"Atmel AT45DB1282", SZ_16M,  0x10, 16384, 1056, 11}
+};
+
+
+#endif  /* _AT91_DATAFLASH_H */
diff -Nur linux-2.6.15.4-orig/drivers/mtd/devices/Kconfig linux-2.6.15.4/drivers/mtd/devices/Kconfig
--- linux-2.6.15.4-orig/drivers/mtd/devices/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/devices/Kconfig	2006-08-09 10:45:27.000000000 +0200
@@ -255,5 +255,14 @@
 	  LinuxBIOS or if you need to recover a DiskOnChip Millennium on which
 	  you have managed to wipe the first block.
 
+config MTD_DATAFLASH_AT91
+        bool "Atmel AT91SAM9261 dataflash driver"
+        depends on SPI_AT91
+        help
+          Suuport for Atmel dataflash chips for AT91SAM9261 microcontrollers
+
+config DATAFLASH_DEBUG
+        bool "Enable debug for dataflash AT91SAM9261 driver"
+        depends on MTD_DATAFLASH_AT91
 endmenu
 
diff -Nur linux-2.6.15.4-orig/drivers/mtd/devices/Makefile linux-2.6.15.4/drivers/mtd/devices/Makefile
--- linux-2.6.15.4-orig/drivers/mtd/devices/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/devices/Makefile	2006-08-09 10:45:27.000000000 +0200
@@ -23,3 +23,4 @@
 obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLKMTD)	+= blkmtd.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
+obj-$(CONFIG_MTD_DATAFLASH_AT91) += at91_dataflash.o
diff -Nur linux-2.6.15.4-orig/drivers/mtd/nand/at91_nand.c linux-2.6.15.4/drivers/mtd/nand/at91_nand.c
--- linux-2.6.15.4-orig/drivers/mtd/nand/at91_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/nand/at91_nand.c	2006-08-09 10:45:27.000000000 +0200
@@ -0,0 +1,220 @@
+/*
+ * drivers/at91/mtd/at91_nand.c
+ *
+ *  Copyright (C) 2003 Rick Bronson
+ *
+ *  Derived from drivers/mtd/nand/autcpu12.c
+ *	 Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
+ *
+ *  Derived from drivers/mtd/spia.c
+ *	 Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/sizes.h>
+
+#include <asm/arch/pio.h>
+
+#define AT91_NAND_MEDIA_CLE        (1 << 21)       /* our ALE is AD22 */
+#define AT91_NAND_MEDIA_ALE        (1 << 22)       /* our CLE is AD21 */
+
+#define AT91C_EBI_CS3 ((char *)      0x40000000) // EBI Chip Select 2 base address
+
+/*
+ * MTD structure for AT91 board
+ */
+
+static struct mtd_info *at91_mtd = NULL;
+
+static int at91_fio_base;
+
+#ifdef CONFIG_MTD_PARTITIONS
+#endif
+
+/*
+ * Hardware specific access to control-lines
+ */
+static void at91_hwcontrol (struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *my_nand = mtd->priv;
+
+	switch(cmd) {
+	case NAND_CTL_SETCLE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base + AT91_NAND_MEDIA_CLE);
+		break;
+	case NAND_CTL_CLRCLE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+		break;
+	case NAND_CTL_SETALE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base + AT91_NAND_MEDIA_ALE);
+		break;
+	case NAND_CTL_CLRALE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+		break;
+	case NAND_CTL_SETNCE:
+		at91_gpio_set_level(AT91C_VA_BASE_PIOC, 14, 0);
+		break;
+	case NAND_CTL_CLRNCE:
+		at91_gpio_set_level(AT91C_VA_BASE_PIOC, 14, 1);
+		break;
+	}
+}
+
+/*
+ * Read the Device Ready pin.
+ */
+static int at91_device_ready (struct mtd_info *mtd)
+{
+	return at91_gpio_get_level(AT91C_VA_BASE_PIOC, 15);
+}
+
+
+#define AT91C_SM_NWE_SETUP      (0 << 0)
+#define AT91C_SM_NCS_WR_SETUP   (0 << 8)
+#define AT91C_SM_NRD_SETUP      (0 << 16)
+#define AT91C_SM_NCS_RD_SETUP   (0 << 24)
+
+#define AT91C_SM_NWE_PULSE      (4 << 0)
+#define AT91C_SM_NCS_WR_PULSE   (6 << 8)
+#define AT91C_SM_NRD_PULSE      (3 << 16)
+#define AT91C_SM_NCS_RD_PULSE   (5 << 24)
+
+#define AT91C_SM_NWE_CYCLE      (6 << 0)
+#define AT91C_SM_NRD_CYCLE      (5 << 16)
+
+#define AT91C_SM_TDF            (1 << 16)               
+
+static int __init at91_init (void)
+{
+	struct nand_chip *my_nand;
+	unsigned int csa;
+	int err = 0;
+	unsigned int matrix_ebi_csa;
+
+	printk("at91_init\n");
+	/* Allocate memory for MTD device structure and private data */
+	at91_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip), GFP_KERNEL);
+	if (!at91_mtd) {
+		printk ("Unable to allocate AT91 NAND MTD device structure.\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* map physical adress */
+	at91_fio_base = (unsigned long) ioremap(AT91C_EBI_CS3, SZ_8M);
+	if(!at91_fio_base) {
+		printk("ioremap AT91 NAND failed\n");
+		err = -EIO;
+		goto out_mtd;
+	}
+
+	/* Get pointer to private data */
+	my_nand = (struct nand_chip *) (&at91_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) at91_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) my_nand, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	at91_mtd->priv = my_nand;
+
+	/* Set address of NAND IO lines */
+	my_nand->IO_ADDR_R = (void __iomem *)(at91_fio_base);
+	my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+	my_nand->hwcontrol = at91_hwcontrol;
+	my_nand->dev_ready = at91_device_ready;
+	my_nand->eccmode = NAND_ECC_SOFT;	/* enable ECC */
+	/* 20 us command delay time */
+	my_nand->chip_delay = 20;
+
+
+  /* Setup Smart Media, first enable the address range of CS3 in HMATRIX user interface */
+  matrix_ebi_csa = readl( AT91C_VA_BASE_EBI + MATRIX_EBICSA);
+  writel(matrix_ebi_csa | MATRIX_CS3A_SM, AT91C_VA_BASE_EBI + MATRIX_EBICSA);
+
+  //Configure SMC CS2 for DM9000
+  writel( (AT91C_SM_NWE_SETUP | AT91C_SM_NCS_WR_SETUP |
+          AT91C_SM_NRD_SETUP | AT91C_SM_NCS_RD_SETUP), AT91C_VA_BASE_EBI + SMC_SETUP3);
+
+  writel( (AT91C_SM_NWE_PULSE | AT91C_SM_NCS_WR_PULSE | AT91C_SM_NRD_PULSE | AT91C_SM_NCS_RD_PULSE),  AT91C_VA_BASE_EBI + SMC_PULSE3);
+
+  writel( (AT91C_SM_NWE_CYCLE | AT91C_SM_NRD_CYCLE), AT91C_VA_BASE_EBI + SMC_CYCLE3);
+
+/*  if ((my_nand->options & NAND_BUSWIDTH_16) == NAND_BUSWIDTH_16) { */
+       writel( (SMC_READMODE | SMC_WRITEMODE | SMC_NWAITM_NWAIT_DISABLE |
+                                      SMC_DBW_WIDTH_SIXTEEN_BITS | AT91C_SM_TDF), AT91C_VA_BASE_EBI + SMC_CTRL3);
+/*  } else {
+
+       writel( (SMC_READMODE | SMC_WRITEMODE | SMC_NWAITM_NWAIT_DISABLE |
+                                      SMC_DBW_WIDTH_EIGTH_BITS | AT91C_SM_TDF), AT91C_VA_BASE_EBI + SMC_CTRL3);
+  }                                   
+*/
+  /* Clock PIOC */
+  at91_enable_periph_clock(AT91C_ID_PIOC);
+
+  /* Configure Ready/Busy signal (PIO in input + pull-up) */
+  at91_gpio_configure(AT91C_VA_BASE_PIOC, 15, 1, 1, 0);
+  
+  /* Enable PC0=SMOE line PC1=SMWE, A21=CLE, A22=ALE */
+  at91_gpio_periph_enable(AT91C_VA_BASE_PIOC, 0, 0, 0, 0);
+  at91_gpio_periph_enable(AT91C_VA_BASE_PIOC, 1, 0, 0, 0);
+  
+  /* Enable NandFlash */
+  at91_gpio_configure(AT91C_VA_BASE_PIOC, 14, 0, 0, 0);
+
+	/* Scan to find existance of the device */
+	if (nand_scan (at91_mtd, 1)) {
+		err = -ENXIO;
+		goto out_ior;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+#else
+	err = add_mtd_device(at91_mtd);
+#endif
+	goto out;
+
+ out_cac:
+ out_ior:
+	iounmap((void *)at91_fio_base);
+ out_mtd:
+	kfree (at91_mtd);
+ out:
+	return err;
+}
+
+/*
+ * Clean up routine
+ */
+static void __exit at91_cleanup (void)
+{
+	/* Unregister partitions */
+	del_mtd_partitions(at91_mtd);
+
+	/* Unregister the device */
+	del_mtd_device (at91_mtd);
+
+	/* unmap physical adress */
+	iounmap((void *)at91_fio_base);
+
+	/* Free the MTD device structure */
+	kfree (at91_mtd);
+}
+
+module_init(at91_init);
+module_exit(at91_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Rick Bronson");
+MODULE_DESCRIPTION("Glue layer for SmartMediaCard on ATMEL AT91RM9200");
diff -Nur linux-2.6.15.4-orig/drivers/mtd/nand/at91_nand_sav.c linux-2.6.15.4/drivers/mtd/nand/at91_nand_sav.c
--- linux-2.6.15.4-orig/drivers/mtd/nand/at91_nand_sav.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/nand/at91_nand_sav.c	2006-08-09 10:45:27.000000000 +0200
@@ -0,0 +1,376 @@
+/*
+ * drivers/at91/mtd/at91_nand.c
+ *
+ *  Copyright (C) 2003 Rick Bronson
+ *
+ *  Derived from drivers/mtd/nand/autcpu12.c
+ *	 Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
+ *
+ *  Derived from drivers/mtd/spia.c
+ *	 Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/sizes.h>
+
+#include <asm/arch/pio.h>
+
+#define AT91_SMART_MEDIA_ALE (1 << 22)  /* our ALE is AD22 */
+#define AT91_SMART_MEDIA_CLE (1 << 21)  /* our CLE is AD21 */
+/*
+ * MTD structure for AT91 board
+ */
+
+static struct mtd_info *at91_mtd = NULL;
+
+static int at91_fio_base;
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+/*
+ * Define partitions for flash devices
+ */
+
+static struct mtd_partition partition_info32k[] = {
+	{
+		.name	= "AT91 NAND partition 1, kernel",
+		.offset	= 0,
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 2, filesystem",
+		.offset	= 1 * SZ_1M,
+		.size	= 16 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3a, storage",
+		.offset	= (1 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3b, storage",
+		.offset	= (2 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3c, storage",
+		.offset	= (3 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3d, storage",
+		.offset	= (4 * SZ_1M) + (16 * SZ_1M),
+		.size	= 1 * SZ_1M
+	},
+};
+
+static struct mtd_partition partition_info64k[] = {
+	{
+		.name	= "AT91 NAND partition 1, kernel",
+		.offset	= 0,
+		.size	= 1 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 2, filesystem",
+		.offset	= 1 * SZ_1M,
+		.size	= 16 * SZ_1M
+	},
+	{
+		.name	= "AT91 NAND partition 3, storage",
+		.offset	= (1 * SZ_1M) + (16 * SZ_1M),
+		.size	= 47 * SZ_1M
+	},
+};
+
+#endif
+
+/*
+ * Hardware specific access to control-lines
+ */
+#define        AT91_NAND_MEDIA_CLE        (1 << 21)       /* our ALE is AD22 */
+#define        AT91_NAND_MEDIA_ALE        (1 << 22)       /* our CLE is AD21 */
+static void at91_hwcontrol (struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *my_nand = mtd->priv;
+
+	switch(cmd) {
+	case NAND_CTL_SETCLE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base + AT91_NAND_MEDIA_CLE);
+		break;
+	case NAND_CTL_CLRCLE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+		break;
+	case NAND_CTL_SETALE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base + AT91_NAND_MEDIA_ALE);
+		break;
+	case NAND_CTL_CLRALE:
+		my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+		break;
+	case NAND_CTL_SETNCE:
+		at91_gpio_set_level(AT91C_VA_BASE_PIOC, 14, 0);
+		break;
+	case NAND_CTL_CLRNCE:
+		at91_gpio_set_level(AT91C_VA_BASE_PIOC, 14, 1);
+		break;
+	}
+}
+
+static void at91_nand_command_largepage (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+{
+	register struct nand_chip *my_nand = mtd->priv;
+
+	/* Begin command latch cycle */
+	register unsigned long NAND_IO_ADDR = (unsigned long)(my_nand->IO_ADDR_W + AT91_SMART_MEDIA_CLE);
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command == NAND_CMD_READ1) {
+		command = NAND_CMD_READ0;
+		column += 256;
+	} else if (command == NAND_CMD_READOOB) {
+		command = NAND_CMD_READ0;
+		column += 2048;
+	}
+	writeb (command, NAND_IO_ADDR);
+
+	/* Set ALE and clear CLE to start address cycle */
+	NAND_IO_ADDR = at91_fio_base;
+
+	if (column != -1 || page_addr != -1)
+		NAND_IO_ADDR += AT91_NAND_MEDIA_ALE;
+
+	/* Serially input address */
+	if (column != -1) {
+		writeb (column, NAND_IO_ADDR);
+		writeb ((unsigned char) ((column >> 8) & 0x0f), NAND_IO_ADDR);
+	}
+	if (page_addr != -1) {
+		writeb ((unsigned char) (page_addr & 0xff), NAND_IO_ADDR);
+		writeb ((unsigned char) ((page_addr >> 8) & 0xff), NAND_IO_ADDR);
+	}
+
+	if (command == NAND_CMD_READ0) {
+		NAND_IO_ADDR = (unsigned long)(my_nand->IO_ADDR_W + AT91_NAND_MEDIA_CLE);
+		writeb (0x30, NAND_IO_ADDR);
+	}
+
+	/* wait until command is processed */
+	while (!my_nand->dev_ready(mtd))
+		;
+}
+
+/*
+ * Send command to NAND device
+ */
+static void at91_nand_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+{
+	register struct nand_chip *my_nand = mtd->priv;
+
+	/* Begin command latch cycle */
+	register unsigned long NAND_IO_ADDR = (unsigned long)(my_nand->IO_ADDR_W + AT91_NAND_MEDIA_CLE);
+
+	if (mtd->oobblock > 512 && command != NAND_CMD_READID) {
+		at91_nand_command_largepage(mtd, command, column, page_addr);
+		return;
+	}
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command != NAND_CMD_SEQIN)
+		writeb (command, NAND_IO_ADDR);
+	else {
+		if (mtd->oobblock == 256 && column >= 256) {
+			column -= 256;
+			writeb (NAND_CMD_RESET, NAND_IO_ADDR);
+			writeb (NAND_CMD_READOOB, NAND_IO_ADDR);
+			writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+		}
+		else
+			if (mtd->oobblock == 512 && column >= 256) {
+				if (column < 512) {
+					column -= 256;
+					writeb (NAND_CMD_READ1, NAND_IO_ADDR);
+					writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+				} else {
+					column -= 512;
+					writeb (NAND_CMD_READOOB, NAND_IO_ADDR);
+					writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+				}
+			} else {
+				writeb (NAND_CMD_READ0, NAND_IO_ADDR);
+				writeb (NAND_CMD_SEQIN, NAND_IO_ADDR);
+			}
+	}
+
+	/* Set ALE and clear CLE to start address cycle */
+	NAND_IO_ADDR = at91_fio_base;
+
+	if (column != -1 || page_addr != -1)
+		NAND_IO_ADDR += AT91_SMART_MEDIA_ALE;
+
+	/* Serially input address */
+	if (column != -1)
+		writeb (column, NAND_IO_ADDR);
+	if (page_addr != -1) {
+		writeb ((unsigned char) (page_addr & 0xff), NAND_IO_ADDR);
+		writeb ((unsigned char) ((page_addr >> 8) & 0xff), NAND_IO_ADDR);
+		/* One more address cycle for higher density devices */
+		if (mtd->size & 0x0c000000) {
+			writeb ((unsigned char) ((page_addr >> 16) & 0x0f), NAND_IO_ADDR);
+		}
+	}
+
+	/* wait until command is processed */
+	while (!my_nand->dev_ready(mtd))
+		;
+}
+
+/*
+ * Read the Device Ready pin.
+ */
+static int at91_device_ready (struct mtd_info *mtd)
+{
+	return at91_gpio_set_level(AT91C_VA_BASE_PIOC, 15);
+}
+/*
+ * Main initialization routine
+ */
+#define AT91C_SM_NWE_SETUP      (0 << 0)
+#define AT91C_SM_NCS_WR_SETUP   (0 << 8)
+#define AT91C_SM_NRD_SETUP      (0 << 16)
+#define AT91C_SM_NCS_RD_SETUP   (0 << 24)
+
+#define AT91C_SM_NWE_PULSE      (4 << 0)
+#define AT91C_SM_NCS_WR_PULSE   (6 << 8)
+#define AT91C_SM_NRD_PULSE      (3 << 16)
+#define AT91C_SM_NCS_RD_PULSE   (5 << 24)
+
+#define AT91C_SM_NWE_CYCLE      (6 << 0)
+#define AT91C_SM_NRD_CYCLE      (5 << 16)
+
+#define AT91C_SM_TDF            (1 << 16)               
+
+static void __init at91_add_device_nand()
+{
+  printk("at91_add_device_nand SMC  & PIO initialisation %08x\n", AT91C_VA_BASE_EBI + SYS_SMC);
+
+  //Configure SMC CS2 for DM9000
+
+}
+static int __init at91_init (void)
+{
+	struct nand_chip *my_nand;
+	unsigned int csa;
+	int err = 0;
+
+	/* Allocate memory for MTD device structure and private data */
+	at91_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip), GFP_KERNEL);
+	if (!at91_mtd) {
+		printk ("Unable to allocate AT91 NAND MTD device structure.\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* map physical adress */
+	at91_fio_base = (unsigned long) ioremap(AT91C_EBI_CS2, SZ_8K);
+	if(!at91_fio_base) {
+		printk("ioremap AT91 NAND failed\n");
+		err = -EIO;
+		goto out_mtd;
+	}
+
+	/* Get pointer to private data */
+	my_nand = (struct nand_chip *) (&at91_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) at91_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) my_nand, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	at91_mtd->priv = my_nand;
+
+	/* Set address of NAND IO lines */
+	my_nand->IO_ADDR_R = (void __iomem *)(at91_fio_base);
+	my_nand->IO_ADDR_W = (void __iomem *)(at91_fio_base);
+	my_nand->hwcontrol = at91_hwcontrol;
+	my_nand->dev_ready = at91_device_ready;
+	my_nand->cmdfunc = at91_nand_command;	/* we need our own */
+	my_nand->eccmode = NAND_ECC_SOFT;	/* enable ECC */
+	/* 20 us command delay time */
+	my_nand->chip_delay = 20;
+
+
+	/* Scan to find existance of the device */
+	if (nand_scan (at91_mtd, 1)) {
+		err = -ENXIO;
+		goto out_ior;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/* Register the partitions */
+	switch(at91_mtd->size)
+	{
+	case SZ_32M:
+		err = add_mtd_partitions(at91_mtd, partition_info32k,
+				ARRAY_SIZE (partition_info32k));
+		break;
+	case SZ_64M:
+		err = add_mtd_partitions(at91_mtd, partition_info64k,
+				ARRAY_SIZE (partition_info64k));
+		break;
+	default:
+		printk ("Unsupported SmartMedia device\n");
+		err = -ENXIO;
+		goto out_cac;
+	}
+#else
+	err = add_mtd_device(at91_mtd);
+#endif
+	goto out;
+
+ out_cac:
+ out_ior:
+	iounmap((void *)at91_fio_base);
+ out_mtd:
+	kfree (at91_mtd);
+ out:
+	return err;
+}
+
+/*
+ * Clean up routine
+ */
+static void __exit at91_cleanup (void)
+{
+	/* Unregister partitions */
+	del_mtd_partitions(at91_mtd);
+
+	/* Unregister the device */
+	del_mtd_device (at91_mtd);
+
+	/* unmap physical adress */
+	iounmap((void *)at91_fio_base);
+
+	/* Free the MTD device structure */
+	kfree (at91_mtd);
+}
+
+module_init(at91_init);
+module_exit(at91_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Rick Bronson");
+MODULE_DESCRIPTION("Glue layer for SmartMediaCard on ATMEL AT91RM9200");
diff -Nur linux-2.6.15.4-orig/drivers/mtd/nand/Kconfig linux-2.6.15.4/drivers/mtd/nand/Kconfig
--- linux-2.6.15.4-orig/drivers/mtd/nand/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/nand/Kconfig	2006-08-09 10:45:27.000000000 +0200
@@ -191,4 +191,11 @@
 	  The simulator may simulate verious NAND flash chips for the
 	  MTD nand layer.
  
+config MTD_NAND_AT91
+        bool "AT91 NAND Access (Smart Media)"
+        depends on MTD_NAND && MACH_AT91SAM9261EK
+        help
+          Enables Access to the Smart Media Card interface on the AT91SAM9261
+
+
 endmenu
diff -Nur linux-2.6.15.4-orig/drivers/mtd/nand/Makefile linux-2.6.15.4/drivers/mtd/nand/Makefile
--- linux-2.6.15.4-orig/drivers/mtd/nand/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/mtd/nand/Makefile	2006-08-09 10:45:27.000000000 +0200
@@ -18,5 +18,6 @@
 obj-$(CONFIG_MTD_NAND_RTC_FROM4)	+= rtc_from4.o
 obj-$(CONFIG_MTD_NAND_SHARPSL)		+= sharpsl.o
 obj-$(CONFIG_MTD_NAND_NANDSIM)		+= nandsim.o
+obj-$(CONFIG_MTD_NAND_AT91)             += at91_nand.o
 
 nand-objs = nand_base.o nand_bbt.o
diff -Nur linux-2.6.15.4-orig/drivers/net/arm/at91_macb.c linux-2.6.15.4/drivers/net/arm/at91_macb.c
--- linux-2.6.15.4-orig/drivers/net/arm/at91_macb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/net/arm/at91_macb.c	2006-08-10 11:07:41.000000000 +0200
@@ -0,0 +1,1308 @@
+/* 
+ * drivers/arm/at91-macb.c 
+ *
+ * Copyright (C) 2005  M. Amine SAYA, Atmel Rousset, France.
+ * Ethernet MACB driver for SAM926X familly (NADIA2)
+ * 
+ *
+ * Copyright (C) 2004 Atmel Norway
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/platform.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/emac.h>
+
+#include "at91_macb.h"
+
+
+
+#define AT91C_EMAC_TX_FLAGS  (AT91C_EMAC_TUNDR | AT91C_EMAC_TCOMP)
+#define AT91C_EMAC_RX_FLAGS  (AT91C_EMAC_RCOMP | AT91C_EMAC_ROVR | AT91C_EMAC_RXUBR)
+
+
+#define TX_RING_GAP(priv)						\
+	(TX_RING_SIZE - DEF_TX_RING_PENDING)
+
+#define TX_BUFFS_AVAIL(priv)					\
+	(((priv)->tx_tail <= (priv)->tx_head) ?			\
+	 (priv)->tx_tail + DEF_TX_RING_PENDING - (priv)->tx_head :	\
+	 (priv)->tx_tail - (priv)->tx_head - TX_RING_GAP(priv))
+
+#define NEXT_TX(n)      ( ((n) + 1) % TX_RING_SIZE )
+#define NEXT_RX(n)      ( ((n) + 1) % RX_RING_SIZE )
+
+/* minimum number of free TX descriptors before waking up TX process */
+#define MACB_TX_WAKEUP_THRESH   (TX_RING_SIZE / 2)
+
+
+
+#ifdef DEBUG
+#define WINDOW_PRINT_LIMIT  20
+static void dump_buffer(char *buff, int size)
+{
+        int index, remain = size;
+	
+	while(remain > 0) {
+	  for (index = 0; index < min(remain, WINDOW_PRINT_LIMIT); index++) {
+	    printk("%02x", buff[index]);
+	  }
+	  
+	  printk("\n");
+	  remain -= WINDOW_PRINT_LIMIT;
+	}
+}
+#endif
+
+static inline unsigned char str2hexnum(unsigned char c)
+{
+        if (c >= '0' && c <= '9')
+                return (c - '0');
+        if (c >= 'a' && c <= 'f')
+                return ((c - 'a') + 10);
+        if (c >= 'A' && c <= 'F')
+                return ((c - 'A') + 10);
+        return 0; 
+}
+
+static inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+        int i;
+
+        for(i = 0; i < 6; i++) {
+                unsigned char num;
+
+                if((*str == '.') || (*str == ':'))
+                        str++;
+                num = str2hexnum(*str++) << 4;
+                num |= (str2hexnum(*str++));
+                ea[i] = num;
+        }
+}
+
+static void macb_enable_mdio(struct macb_priv *priv)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	reg = macb_readl(priv, EMAC_NCR);
+	reg |= AT91C_EMAC_MPE;
+	macb_writel(priv, EMAC_NCR, reg);
+	macb_writel(priv, EMAC_IER, AT91C_EMAC_MFD);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+
+static void macb_disable_mdio(struct macb_priv *priv)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	reg = macb_readl(priv, EMAC_NCR);
+	reg &= ~AT91C_EMAC_MPE;
+	macb_writel(priv, EMAC_NCR, reg);
+	macb_writel(priv, EMAC_IDR, AT91C_EMAC_MFD);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+
+static int at91_macb_mdio_read(struct net_device *ndev, int phy_id,
+				int reg_addr)
+{
+        struct macb_priv *priv = netdev_priv(ndev);
+	u32 reg;
+	int value;
+	
+	down(&priv->mdio_sem);
+	
+	macb_enable_mdio(priv);
+	reg = AT91C_MAN_CODE | AT91C_MAN_SOF | AT91C_MAN_READ;
+	reg |= (phy_id & 0x1f) << 23;
+	reg |= (reg_addr & 0x1f) << 18;
+	macb_writel(priv, EMAC_MAN, reg);
+	wait_for_completion(&priv->mdio_complete);
+
+	value = macb_readl(priv, EMAC_MAN) & 0xffff;
+	macb_disable_mdio(priv);
+
+	up(&priv->mdio_sem);
+
+	dev_dbg(&priv->pdev->dev, "mdio_read %02x:%02x <- %04x\n",
+		phy_id, reg_addr, value);
+
+	return value;
+}
+
+
+static void at91_macb_mdio_write(struct net_device *ndev, int phy_id,
+				 int reg_addr, int data)
+{
+        struct macb_priv *priv = netdev_priv(ndev);
+	u32 reg;
+
+	
+	dev_dbg(&priv->pdev->dev, "mdio_write %02x:%02x <- %04x\n",
+		phy_id, reg_addr, data);
+
+	down(&priv->mdio_sem);
+	
+	macb_enable_mdio(priv);
+	reg = AT91C_MAN_CODE | AT91C_MAN_SOF | AT91C_MAN_WRITE;
+	reg |= (phy_id & 0x1f) << 23;
+	reg |= (reg_addr & 0x1f) << 18;
+	reg |= data & 0xffff;
+	macb_writel(priv, EMAC_MAN, reg);
+	wait_for_completion(&priv->mdio_complete);
+
+	macb_disable_mdio(priv);
+
+	up(&priv->mdio_sem);
+}
+
+
+static void at91_macb_set_media(struct macb_priv *priv, int media)
+{
+        u32 reg;
+
+	spin_lock_irq(&priv->lock);
+
+	reg = macb_readl(priv, EMAC_NCFGR);
+	reg &= ~(AT91C_EMAC_SPD | AT91C_EMAC_FD);
+
+	if (media & (ADVERTISE_100HALF | ADVERTISE_100FULL))
+		reg |= AT91C_EMAC_SPD;
+
+	if (priv->mii.full_duplex)
+		reg |= AT91C_EMAC_FD;
+
+	macb_writel(priv, EMAC_NCFGR, reg);
+
+	spin_unlock_irq(&priv->lock);
+}
+
+
+static void at91_macb_probe_carrier(struct macb_priv *priv)
+{
+        struct mii_if_info *mii = &priv->mii;
+	unsigned int new_carrier;
+	int advertise, lpa, media, duplex;
+
+
+	// if forced media, nothing to do
+	if (mii->force_media)
+	  return;
+
+	/* check current link status */
+	new_carrier = (unsigned int) mii_link_ok(mii);
+
+	/* no carrier, nothing much to do */
+	if (!new_carrier) {
+		netif_carrier_off(mii->dev);
+		printk(KERN_INFO "%s: link down\n", mii->dev->name);
+		return;
+	}
+
+	/*
+	 * we have carrier, see who's on the other end
+	 */
+	netif_carrier_on(mii->dev);
+
+	/* get MII advertise and LPA values */
+	if (mii->advertising)
+		advertise = mii->advertising;
+	else {
+		advertise = mii->mdio_read(mii->dev, mii->phy_id, MII_ADVERTISE);
+		mii->advertising = advertise;
+	}
+
+	lpa = mii->mdio_read(mii->dev, mii->phy_id, MII_LPA);
+
+	/* figure out media and duplex from advertise and LPA values */
+	media = mii_nway_result(lpa & advertise);
+	duplex = (media & ADVERTISE_FULL) ? 1 : 0;
+
+	dev_dbg(&priv->pdev->dev, "%s: link up, %sMbps, %s-duplex, lpa 0x%04X\n",
+		       mii->dev->name,
+		       media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ? "100" : "10",
+		       duplex ? "full" : "half", lpa);
+
+	mii->full_duplex = duplex;
+
+	/* Let the MAC know about the new link state */
+	at91_macb_set_media(priv, media);
+}
+
+
+static void at91_macb_check_carrier(struct macb_priv *priv)
+{
+        struct mii_if_info *mii = &priv->mii;
+	unsigned int old_carrier, new_carrier;
+	int advertise, lpa, media, duplex;
+
+
+	// if forced media, nothing to do
+	if (mii->force_media)
+	  return;
+
+	/* check current and old link status */
+	old_carrier = netif_carrier_ok(mii->dev) ? 1 : 0;
+	new_carrier = (unsigned int) mii_link_ok(mii);
+
+	/* if carrier state did not change, assume nothing else did */
+	if (old_carrier == new_carrier) {
+	  dev_dbg(&priv->pdev->dev, "Carrier state didn't change\n");
+	  return;
+	}
+
+	/* no carrier, nothing much to do */
+	if (!new_carrier) {
+		netif_carrier_off(mii->dev);
+		printk(KERN_INFO "%s: link down\n", mii->dev->name);
+		return;
+	}
+
+	/*
+	 * we have carrier, see who's on the other end
+	 */
+	netif_carrier_on(mii->dev);
+	printk(KERN_INFO "%s: link up\n", mii->dev->name);
+
+	/* get MII advertise and LPA values */
+	if (mii->advertising)
+		advertise = mii->advertising;
+	else {
+		advertise = mii->mdio_read(mii->dev, mii->phy_id, MII_ADVERTISE);
+		mii->advertising = advertise;
+	}
+
+	lpa = mii->mdio_read(mii->dev, mii->phy_id, MII_LPA);
+
+	/* figure out media and duplex from advertise and LPA values */
+	media = mii_nway_result(lpa & advertise);
+	duplex = (media & ADVERTISE_FULL) ? 1 : 0;
+
+	dev_dbg(&priv->pdev->dev, "%s: link up, %sMbps, %s-duplex, lpa 0x%04X\n",
+		       mii->dev->name,
+		       media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ? "100" : "10",
+		       duplex ? "full" : "half", lpa);
+
+	mii->full_duplex = duplex;
+
+	/* Let the MAC know about the new link state */
+	at91_macb_set_media(priv, media);
+}
+
+
+static void at91_macb_phy_task(void *arg)
+{
+        struct macb_priv *priv = (struct macb_priv *) arg;
+
+	at91_macb_check_carrier(priv);
+}
+
+
+static void at91_macb_update_stats(struct macb_priv *priv)
+{
+	u32 reg = EMAC_PFR;
+	u32 *p = &priv->hw_stats.rx_pause_frames;
+	u32 *end = &priv->hw_stats.rx_length_mismatch + 1;
+
+	for(; p < end; p++, reg += 4)
+		*p += macb_readl(priv, reg);
+}
+
+
+static void at91_macb_timer(unsigned long arg)
+{
+        struct macb_priv *priv = (struct macb_priv *) arg;
+
+	/* mii_check_media might sleep (very likely, actually) */
+	schedule_work(&priv->phy_task);
+	
+	at91_macb_update_stats(priv);
+
+	// The timer and the work queue use should disappear as we are going
+	// to implement the interrupt handler for the PHY.
+	priv->timer.expires = jiffies + HZ;
+	add_timer(&priv->timer);
+}
+
+
+static void get_macb_hw_addr(struct macb_priv *priv)
+{
+        u32 bottom;
+        u16 top;
+
+	bottom = macb_readl(priv, EMAC_SA1L);
+	*((u32 *)priv->ndev->dev_addr) = le32_to_cpu(bottom);
+
+	top = (u16) macb_readl(priv, EMAC_SA1H);
+	*((u16 *)(priv->ndev->dev_addr + 4)) = le16_to_cpu(top);
+}
+
+
+static void set_macb_hw_addr(struct macb_priv *priv)
+{
+        u32 bottom;
+        u16 top;
+	
+	bottom = cpu_to_le32(*((u32 *)priv->ndev->dev_addr));
+	macb_writel(priv, EMAC_SA1L, bottom);
+
+	top = cpu_to_le16(*((u16 *)(priv->ndev->dev_addr + 4)));
+	macb_writel(priv, EMAC_SA1H, top);
+}
+
+
+static int at91_macb_set_hw_addr(struct net_device *ndev, void *ska)
+{
+        struct macb_priv *priv = netdev_priv(ndev);
+	struct sockaddr *addr = ska;
+
+	
+	if (netif_running(ndev))
+	  return -EBUSY;
+
+	memcpy(ndev->dev_addr, addr->sa_data, ndev->addr_len);
+
+	set_macb_hw_addr(priv);
+
+	return 0;
+}
+
+
+static int at91_macb_start_xmit(struct sk_buff *skb,
+				struct net_device *ndev)
+{
+        struct macb_priv *priv = netdev_priv(ndev);
+	unsigned int entry;
+	dma_addr_t mapping;
+	u32 ctrl;
+
+	spin_lock_irq(&priv->lock);
+	
+
+	// Check if there is room in the tx ring
+	if (TX_BUFFS_AVAIL(priv) < 1) {
+	  netif_stop_queue(ndev);
+	  spin_unlock_irq(&priv->lock);
+
+	  dev_err(&priv->pdev->dev,
+		  "BUG! Tx Ring full when queue awake!\n");
+	  dev_dbg(&priv->pdev->dev, "tx_head = %u, tx_tail = %u\n",
+		  priv->tx_head, priv->tx_tail);
+	
+	  return 1;
+	}
+	
+	entry = priv->tx_head;
+
+#ifdef CONFIG_MACB_TCM
+	mapping = priv->tx_ring[entry].addr;
+
+	// Copy skb data in TCM buffer
+	memcpy((char *)priv->tx_buffers + entry * TX_BUFFER_SIZE,
+	       skb->data, skb->len);
+#else
+	dev_dbg(&priv->pdev->dev, "Allocated ring entry %u\n", entry);
+	mapping = dma_map_single(&priv->pdev->dev, skb->data,
+				 skb->len, DMA_TO_DEVICE);
+#endif
+
+	priv->tx_skb[entry].skb = skb;
+	priv->tx_skb[entry].mapping = mapping;
+	dev_dbg(&priv->pdev->dev, "Mapped skb data %p to DMA addr %08lx\n",
+		skb->data, (unsigned long)mapping);
+	
+	BUG_ON(skb->ip_summed == CHECKSUM_HW);
+
+	ctrl = (skb->len & TXBUF_FRMLEN_MASK);
+	ctrl |= TXBUF_FRAME_END;
+	if (entry == (TX_RING_SIZE - 1))
+	  ctrl |= TXBUF_WRAP;
+	
+	wmb();
+
+#ifndef CONFIG_MACB_TCM
+	priv->tx_ring[entry].addr = mapping;
+#endif
+	priv->tx_ring[entry].ctrl = ctrl;
+
+	entry = NEXT_TX(entry);
+	priv->tx_head = entry;
+	
+	macb_writel(priv, EMAC_NCR,
+		    macb_readl(priv, EMAC_NCR) | AT91C_EMAC_TSTART);
+	
+
+	/*
+	if (TX_BUFFS_AVAIL(priv) < 1)
+	  netif_stop_queue(ndev);
+	*/
+
+	spin_unlock_irq(&priv->lock);
+        
+	ndev->trans_start = jiffies;
+
+	return 0;
+}
+
+
+static void at91_macb_tx(struct macb_priv *priv)
+{
+        unsigned int head, tail;
+        volatile u32 status;
+
+
+	status = macb_readl(priv, EMAC_TSR);
+
+	dev_dbg(&priv->pdev->dev, "macb_tx status = %02lx\n",
+		(unsigned long)status);
+
+	if (status & AT91C_EMAC_UND) {
+	  printk(KERN_ERR "%s: TX underrun, resetting buffers\n",
+		 priv->ndev->name);
+	  priv->tx_head = priv->tx_tail = 0;
+	  macb_writel(priv, EMAC_TSR, AT91C_EMAC_UND);
+	}
+
+	if (!(status & AT91C_EMAC_COMP)) {
+	  dev_warn(&priv->pdev->dev,
+		   "No TX buffers complete, status = %02lx\n",
+		   (unsigned long)status);
+	  return;
+	}
+	
+	macb_writel(priv, EMAC_TSR, AT91C_EMAC_COMP);
+
+	head = priv->tx_head;
+	for (tail = priv->tx_tail; tail != head; tail = NEXT_TX(tail)) {
+	  struct ring_info *ri = &priv->tx_skb[tail];
+	  struct sk_buff *skb = ri->skb;
+	  u32 ctrl;
+
+	  BUG_ON(skb == NULL);
+
+	  rmb();
+	  ctrl = priv->tx_ring[tail].ctrl;
+
+	  // A buffer is not released by TX DMA, stop processing
+	  if (!(ctrl & TXBUF_USED))
+	    break;
+
+	  
+	  dev_dbg(&priv->pdev->dev, "skb %u (data %p) TX complete\n",
+		  tail, skb->data);
+
+#ifndef CONFIG_MACB_TCM
+	  dma_unmap_single(&priv->pdev->dev, ri->mapping, skb->len, DMA_TO_DEVICE);
+#endif
+	  priv->stats.tx_packets++;
+	  priv->stats.tx_bytes += skb->len;
+	  ri->skb = NULL;
+	  dev_kfree_skb_irq(skb);
+	}
+
+	priv->tx_tail = tail;
+	
+	// If netif queue is stopped, wake it up
+	if (netif_queue_stopped(priv->ndev) && 
+	    TX_BUFFS_AVAIL(priv) > MACB_TX_WAKEUP_THRESH)
+	  netif_wake_queue(priv->ndev);
+}
+
+
+static irqreturn_t at91_macb_interrupt(int irq, void* dev_id, struct pt_regs* regs)
+{
+        struct net_device *ndev = (struct net_device *) dev_id;
+	struct macb_priv *priv = netdev_priv(ndev);
+        volatile u32 status;
+
+	
+	status = macb_readl(priv, EMAC_ISR);
+
+	if (unlikely(!status))
+	  return IRQ_NONE;
+
+	spin_lock(&priv->lock);
+
+	/* close possible race with dev_close */
+	if (unlikely(!netif_running(ndev))) {
+	  macb_writel(priv, EMAC_IDR, ~0UL);
+	  spin_unlock(&priv->lock);
+	  return IRQ_HANDLED;
+	}
+
+	if (status & AT91C_EMAC_MFD)
+	  complete(&priv->mdio_complete);
+
+	if (status & AT91C_EMAC_RX_FLAGS) {
+	  if (likely(netif_rx_schedule_prep(ndev))) {
+	    /*
+	     * There's no point taking any more interrupts
+	     * until we have processed the buffers
+	     */
+	    macb_writel(priv, EMAC_IDR, AT91C_EMAC_RX_FLAGS);
+	    dev_dbg(&priv->pdev->dev, "scheduling RX softirq\n");
+	    __netif_rx_schedule(ndev);
+	  }
+	}
+	
+	if (status & AT91C_EMAC_TX_FLAGS)
+	  at91_macb_tx(priv);
+	
+	spin_unlock(&priv->lock);	
+	
+	if (status & AT91C_EMAC_HRESP) {
+	  /*
+	   * TODO: Reset the hardware, and maybe move the printk
+	   * to a lower-priority context as well (work queue?)
+	   */
+	  printk(KERN_ERR "%s: AHB bus error: HRESP not OK\n",
+		 ndev->name);
+	}
+	
+	return IRQ_HANDLED;
+}
+
+
+static void at91_macb_free_dma(struct macb_priv *priv)
+{
+#ifdef CONFIG_MACB_TCM
+        int size;
+#endif
+
+
+        if (priv->tx_skb) {
+		kfree(priv->tx_skb);
+		priv->tx_skb = NULL;
+	}
+
+	if (priv->rx_ring) {
+#ifdef CONFIG_MACB_TCM
+	        // priv->rx_ring is in TCM memory
+	        iounmap((void *)priv->rx_ring);
+#else
+		// priv->rx_ring is in sdram
+		dma_free_coherent(&priv->pdev->dev, RX_RING_BYTES,
+				  (void*) priv->rx_ring, priv->rx_ring_dma);
+#endif
+		priv->rx_ring = NULL;
+	}
+
+	if (priv->rx_buffers) {
+#ifdef CONFIG_MACB_TCM
+       	        // priv->rx_buffers is in TCM
+	        iounmap(priv->rx_buffers);
+#else
+		// priv->rx_buffers is in sdram
+		dma_free_coherent(&priv->pdev->dev,
+				  RX_RING_SIZE * RX_BUFFER_SIZE,
+				  priv->rx_buffers, priv->rx_buffers_dma);
+#endif
+		priv->rx_buffers = NULL;
+	}
+
+	if (priv->tx_ring) {
+#ifdef CONFIG_MACB_TCM
+	        // priv->tx_ring is in TCM memory
+	        iounmap((void *)priv->tx_ring);
+#else
+		// priv->tx_ring is in sdram
+		dma_free_coherent(&priv->pdev->dev, TX_RING_BYTES,
+				  (void*) priv->tx_ring, priv->tx_ring_dma);
+#endif
+		priv->tx_ring = NULL;
+	}
+
+	if (priv->tx_buffers) {
+#ifdef CONFIG_MACB_TCM
+       	        // priv->rx_buffers is in TCM
+	        iounmap(priv->tx_buffers);
+#else
+		// priv->rx_buffers is in sdram
+		dma_free_coherent(&priv->pdev->dev,
+				  RX_RING_SIZE * RX_BUFFER_SIZE,
+				  priv->tx_buffers, priv->tx_buffers_dma);
+#endif
+		priv->tx_buffers = NULL;
+	}
+
+#ifdef CONFIG_MACB_TCM
+	size = RX_RING_BYTES + RX_RING_SIZE * RX_BUFFER_SIZE;
+	size += TX_RING_BYTES + TX_RING_SIZE * TX_BUFFER_SIZE;
+
+	// Release TCM region
+	release_mem_region(AT91C_IRAM_BASE, size);
+#endif
+}
+
+
+#ifdef CONFIG_MACB_TCM
+static int at91_macb_alloc_tcm(struct macb_priv *priv)
+{
+        int size;
+
+
+	size = RX_DMA_SIZE + TX_DMA_SIZE;
+
+	// TCM might be used by the LCDC driver so we put a sanity check.
+	if (request_mem_region(AT91C_IRAM_BASE, size, "macb") == NULL) {
+	  printk(KERN_WARNING "Cannot request TCM memory, already used\n\r");
+	  return -EBUSY;
+	}
+
+	size = RX_RING_BYTES;
+	priv->rx_ring_dma = (dma_addr_t) AT91C_IRAM_BASE;
+	priv->rx_ring = ioremap(priv->rx_ring_dma, size);
+	if (!priv->rx_ring)
+	  return -ENOMEM;
+
+	size = RX_RING_SIZE * RX_BUFFER_SIZE;
+	priv->rx_buffers_dma = priv->rx_ring_dma + RX_RING_BYTES;
+	priv->rx_buffers = ioremap(priv->rx_buffers_dma, size);
+	if (!priv->rx_buffers)
+	  return -ENOMEM;
+	
+	size = TX_RING_BYTES;
+	priv->tx_ring_dma = (dma_addr_t) AT91C_IRAM_BASE + RX_DMA_SIZE;
+	priv->tx_ring = ioremap(priv->tx_ring_dma, size);
+	if (!priv->tx_ring)
+	  return -ENOMEM;
+
+	size = TX_RING_SIZE * TX_BUFFER_SIZE;
+	priv->tx_buffers_dma = priv->tx_ring_dma + TX_RING_BYTES;
+	priv->tx_buffers = ioremap(priv->tx_buffers_dma, size);
+	if (!priv->tx_buffers)
+	  return -ENOMEM;	
+	
+	return 0;
+}
+#else
+static int at91_macb_alloc_sdram(struct macb_priv *priv)
+{
+        int size;
+
+        size = RX_RING_BYTES;
+        priv->rx_ring = dma_alloc_coherent(&priv->pdev->dev, size,
+					   &priv->rx_ring_dma, GFP_KERNEL);
+	if (!priv->rx_ring)
+	  return -ENOMEM;
+	
+	dev_dbg(&priv->pdev->dev,
+		"Allocated RX ring of %d bytes at %08lx (mapped %p)\n",
+		size, (unsigned long)priv->rx_ring_dma, priv->rx_ring);
+	
+	size = TX_RING_BYTES;
+	priv->tx_ring = dma_alloc_coherent(&priv->pdev->dev, size,
+					   &priv->tx_ring_dma, GFP_KERNEL);
+	if (!priv->tx_ring)
+	  return -ENOMEM;
+	
+	dev_dbg(&priv->pdev->dev,
+		"Allocated TX ring of %d bytes at %08lx (mapped %p)\n",
+		size, (unsigned long)priv->tx_ring_dma, priv->tx_ring);
+	
+	size = RX_RING_SIZE * RX_BUFFER_SIZE;
+	priv->rx_buffers = dma_alloc_coherent(&priv->pdev->dev, size,
+					      &priv->rx_buffers_dma, GFP_KERNEL);
+	if (!priv->rx_buffers)
+	  return -ENOMEM;
+	
+	priv->tx_buffers = NULL;
+	
+	/*
+	size = TX_RING_SIZE * TX_BUFFER_SIZE;
+	priv->tx_buffers = dma_alloc_coherent(&priv->pdev->dev, size,
+					      &priv->tx_buffers_dma, GFP_KERNEL);
+	if (!priv->tx_buffers)
+	  return -ENOMEM;	
+	*/
+
+	dev_dbg(&priv->pdev->dev,
+		"Allocated RX buffers of %d bytes at %08lx (mapped %p)\n",
+		size, (unsigned long)priv->rx_buffers_dma, priv->rx_buffers);
+
+
+	return 0;
+}
+#endif
+
+static int at91_macb_alloc_dma(struct macb_priv *priv)
+{
+        int size;
+
+	size = TX_RING_SIZE * sizeof(struct ring_info);
+	priv->tx_skb = kmalloc(size, GFP_KERNEL);
+	if (!priv->tx_skb)
+		goto out_err;
+
+#ifdef  CONFIG_MACB_TCM
+	if (at91_macb_alloc_tcm(priv))	  
+#else
+	if (at91_macb_alloc_sdram(priv))
+#endif
+	    goto out_err;
+
+	return 0;
+
+out_err:
+	at91_macb_free_dma(priv);
+
+	return -ENOMEM;
+}
+
+
+static void at91_macb_init_dma(struct macb_priv *priv)
+{
+        int index;
+        dma_addr_t addr;
+
+	addr = priv->rx_buffers_dma;
+	for (index = 0; index < RX_RING_SIZE; index++) {
+	  priv->rx_ring[index].addr = addr;
+	  priv->rx_ring[index].ctrl = 0;
+	  
+	  addr += RX_BUFFER_SIZE;
+	}
+
+	priv->rx_ring[RX_RING_SIZE -1].addr |= RXADDR_WRAP;
+
+#ifdef CONFIG_MACB_TCM
+	addr = priv->tx_buffers_dma;
+	for (index = 0; index < TX_RING_SIZE; index++) {
+	  priv->tx_ring[index].addr = addr;
+	  priv->tx_ring[index].ctrl = TXBUF_USED;
+
+	  addr += TX_BUFFER_SIZE;
+	}
+#else
+	for (index = 0; index < TX_RING_SIZE; index++) {
+	  priv->tx_ring[index].addr = 0;
+	  priv->tx_ring[index].ctrl = TXBUF_USED;
+	}	
+#endif     
+
+	priv->tx_ring[TX_RING_SIZE -1].ctrl |= TXBUF_WRAP;
+
+	priv->rx_tail = priv->tx_tail = priv->tx_head = 0;
+}
+
+
+static void at91_macb_reset_hw(struct macb_priv *priv)
+{
+        wmb();
+
+	// Check if our network is running and stop it.
+	if (netif_running(priv->ndev))
+	  netif_stop_queue(priv->ndev);
+	
+	// Disable transmit and receive
+	macb_writel(priv, EMAC_NCR, 0);
+
+	// Clear stats register
+	macb_writel(priv, EMAC_NCR, AT91C_EMAC_CLRSTAT);
+
+	// Clear Pending interrupts and TRX status flags
+	(void)macb_readl(priv, EMAC_ISR);
+	macb_writel(priv, EMAC_TSR, 0xFFFFFFFF);
+	macb_writel(priv, EMAC_RSR, 0xFFFFFFFF);
+
+	// Disable all interrupts
+	macb_writel(priv, EMAC_IDR, 0xFFFFFFFF);
+}
+
+
+static void at91_macb_init_hw(struct macb_priv *priv)
+{
+        u32 value;
+    char *pmac;
+    char ethaddr[6];
+
+	// Enable MACB clock
+        at91_macb_clock_enable();
+	
+	// Reset MACB
+	at91_macb_reset_hw(priv);
+	
+	// Set hardware address
+    if (((pmac = strstr(saved_command_line, "ethaddr")) != NULL) && ((pmac = strstr(pmac, "=")) != NULL)) {
+        str2eaddr(ethaddr, pmac + 1);
+        memcpy(priv->ndev->dev_addr, ethaddr, 6);
+    }
+    // Get bootloader MAC address 
+    else {
+        get_macb_hw_addr(priv);
+    }
+    
+	set_macb_hw_addr(priv);
+	
+	// Set RMII mode and enable transceiver input clock
+	value = AT91C_EMAC_RMII | AT91C_EMAC_CLKEN;
+	macb_writel(priv, EMAC_USRIO, value);
+	
+	// Configure MACB
+	value = AT91C_EMAC_BIG | AT91C_EMAC_RBOF_OFFSET_2;
+
+	if (priv->ndev->flags & IFF_PROMISC)
+	  value |= AT91C_EMAC_CAF;
+
+	if (!(priv->ndev->flags & IFF_BROADCAST))
+	  value |= AT91C_EMAC_NBC;
+
+	// Set MDIO clock
+#if (AT91C_MASTER_CLOCK < 80000000)
+	value |= AT91C_EMAC_CLK_HCLK_32; 
+#else
+	value |= AT91C_EMAC_CLK_HCLK_64;
+#endif
+	
+	macb_writel(priv, EMAC_NCFGR, value);
+
+	// Set DMA pointers
+	macb_writel(priv, EMAC_TBQP, priv->tx_ring_dma);
+	macb_writel(priv, EMAC_RBQP, priv->rx_ring_dma);
+
+	// Enable receive and transmit
+	value = AT91C_EMAC_TE | AT91C_EMAC_RE;
+	macb_writel(priv, EMAC_NCR, value);	
+
+	// Enable interrupts
+	value = (AT91C_EMAC_TX_FLAGS| AT91C_EMAC_RX_FLAGS | 
+		 AT91C_EMAC_HRESP);	
+	macb_writel(priv, EMAC_IER, value);
+}
+
+
+static int at91_macb_open(struct net_device *ndev)
+{
+        struct macb_priv *priv = netdev_priv(ndev);
+	int err = 0;
+	
+	// Alloc DMA buffers
+	err = at91_macb_alloc_dma(priv);
+	if (err)
+	  return err;
+
+	err = request_irq(ndev->irq, at91_macb_interrupt, 
+			  SA_SAMPLE_RANDOM, ndev->name, ndev);
+	if (err)
+	  goto out;
+
+	at91_macb_init_dma(priv);
+	at91_macb_init_hw(priv);
+	at91_macb_probe_carrier(priv);
+	netif_start_queue(ndev);
+
+	init_timer(&priv->timer);
+	priv->timer.expires = jiffies + 10 * HZ;
+	priv->timer.data = (unsigned long)priv;
+	priv->timer.function = at91_macb_timer;
+	add_timer(&priv->timer);
+	
+	return 0;
+
+ out:
+	at91_macb_free_dma(priv);
+	return err;
+}
+
+
+static int at91_macb_stop(struct net_device *ndev)
+{
+        struct macb_priv *priv = netdev_priv(ndev);
+	unsigned long flags;
+
+        netif_stop_queue(ndev);
+
+	spin_lock_irqsave(&priv->lock, flags);	
+	del_timer(&priv->timer);
+	netif_carrier_off(ndev);
+	at91_macb_reset_hw(priv);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	at91_macb_free_dma(priv);
+        at91_macb_clock_disable();
+
+	return 0;
+}
+
+
+static int at91_macb_rx_frame(struct macb_priv *priv, unsigned int begin, 
+			      unsigned int end)
+{
+        unsigned int len, frag, rx_len = 0;
+	u32 offset_bytes;
+        struct sk_buff *skb;
+      
+	dev_dbg(&priv->pdev->dev, "macb_rx_frame frags %u - %u\n",
+		begin, end);
+	
+	len = priv->rx_ring[end].ctrl & RXBUF_FRMLEN_MASK;
+	offset_bytes = priv->rx_ring[end].ctrl & RXBUF_OFFSET_BYTES_MASK;
+	offset_bytes >>= 12;
+	
+	len += offset_bytes;
+	skb = alloc_skb(len, GFP_ATOMIC);
+	if (skb == NULL) {
+	  priv->stats.rx_dropped++;
+	  for (frag = begin; ; frag = NEXT_RX(frag)) {
+	    priv->rx_ring[frag].addr &= ~RXADDR_USED;
+	    if (frag == end)
+	      break;
+	  }
+
+	  wmb();
+	  return 1;
+	}
+
+	//skb_reserve(skb, offset_bytes);
+	skb->dev = priv->ndev;
+	skb->ip_summed = CHECKSUM_NONE;
+	skb_put(skb, len);
+
+	for (frag = begin; ; frag = NEXT_RX(frag)) {
+	  unsigned int frag_len = RX_BUFFER_SIZE;
+
+	  if (rx_len + frag_len > len) {
+	    BUG_ON(frag != end);
+	    frag_len = len - rx_len;
+	  }
+
+	  memcpy(skb->data + rx_len, priv->rx_buffers + (RX_BUFFER_SIZE * frag), frag_len);
+	  rx_len += RX_BUFFER_SIZE;
+	  priv->rx_ring[frag].addr &= ~RXADDR_USED;
+	  wmb();
+	  
+	  if (frag == end)
+	    break;
+	}
+	
+	// Remove offset bytes
+	(unsigned char *)skb_pull(skb, offset_bytes);
+
+	skb->protocol = eth_type_trans(skb, priv->ndev);
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += skb->len;
+	priv->ndev->last_rx = jiffies;
+	netif_receive_skb(skb);	      
+	
+        return 0;
+}
+
+
+// Mark DMA descriptors from begin up to and not including end as unused
+static void at91_discard_frame(struct macb_priv *priv, unsigned int begin, 
+			       unsigned int end)
+{
+        unsigned int frag;
+
+	for (frag = begin; frag != end; frag = NEXT_RX(frag))
+	  priv->rx_ring[frag].addr &= ~RXADDR_USED;
+
+	wmb();
+}
+
+
+static int at91_macb_rx(struct macb_priv *priv, int budget)
+{
+        unsigned int tail = priv->rx_tail;
+	int received = 0, first_frag = -1;
+	
+
+	for(; budget > 0; tail = NEXT_RX(tail)) {
+	  u32 addr, ctrl;
+
+	  rmb();
+	  addr = priv->rx_ring[tail].addr;
+	  ctrl = priv->rx_ring[tail].ctrl;
+
+	  dev_dbg(&priv->pdev->dev, "rx frag %u: %08lx, %08lx\n",
+		  (int) tail, (unsigned long)addr, (unsigned long )ctrl);
+	  
+	  // No new packets were received since last check
+	  if (!(addr & RXADDR_USED))
+
+	    break;
+
+	  //printk(KERN_DEBUG "%s : at91_macb_rx : %d\n\r", priv->ndev->name, 1);
+
+	  if (ctrl & RXBUF_FRAME_START) {
+	    //printk(KERN_DEBUG "%s : at91_macb_rx : %d\n\r", priv->ndev->name, 2);
+	    if (first_frag != -1)
+	      at91_discard_frame(priv, first_frag, tail);
+	    first_frag = tail;
+	  }
+
+	  
+	  if (ctrl & RXBUF_FRAME_END) {
+	    int dropped;
+	    
+	    BUG_ON(first_frag == -1);
+	    //printk(KERN_DEBUG "%s : at91_macb_rx : %d\n\r", priv->ndev->name, 3);
+	    dropped = at91_macb_rx_frame(priv, first_frag, tail);
+	    first_frag = -1;
+	    if (!dropped) {
+	      received++;
+	      budget--;
+	    }
+	  }
+	}
+
+	if (first_frag != -1)
+	  priv->rx_tail = first_frag;
+	else 
+	  priv->rx_tail = tail;
+
+	return received;
+}
+
+
+static int at91_macb_poll(struct net_device *ndev, int *budget)
+{
+        struct macb_priv *priv = (struct macb_priv *) netdev_priv(ndev);
+	int ret = 0, rx_packets, quota = min(ndev->quota, *budget);
+	volatile u32 status;
+
+
+	status = macb_readl(priv, EMAC_RSR);
+
+	dev_dbg(&priv->pdev->dev, "poll: status = %08lx, budget = %d, dev->quota = %d\n",
+		(unsigned long)status, *budget, ndev->quota);
+
+	if (!(status & AT91C_EMAC_REC)) {
+	  dev_warn(&priv->pdev->dev,
+		   "No RX buffers complete, status = %02lx\n",
+		   (unsigned long)status);
+	  netif_rx_complete(ndev);
+	  goto out;
+	}
+
+	rx_packets = at91_macb_rx(priv, quota);
+	ndev->quota -= rx_packets;
+	*budget -= rx_packets;
+	if (rx_packets < quota) {
+	  netif_rx_complete(ndev);
+	  ret = 0;
+	} else {
+	  dev_warn(&priv->pdev->dev, "Budget exhausted\n");
+	  ret = 1;	  
+	}
+
+ out:
+	macb_writel(priv, EMAC_IER, AT91C_EMAC_RX_FLAGS);
+	
+	return ret;
+}
+
+
+static struct net_device_stats *at91_macb_get_stats(struct net_device *ndev)
+{
+	struct macb_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *nstat = &priv->stats;
+	struct macb_hw_stats *hwstat = &priv->hw_stats;
+
+	/* Convert HW stats into netdevice stats */
+	nstat->rx_errors = (hwstat->rx_fcs_errors +
+			    hwstat->rx_align_errors +
+			    hwstat->rx_resource_errors +
+			    hwstat->rx_overruns +
+			    hwstat->rx_oversize_pkts +
+			    hwstat->rx_jabbers +
+			    hwstat->rx_undersize_pkts +
+			    hwstat->sqe_test_errors +
+			    hwstat->rx_length_mismatch);
+	nstat->tx_errors = (hwstat->tx_late_cols +
+			    hwstat->tx_excessive_cols +
+			    hwstat->tx_underruns +
+			    hwstat->tx_carrier_errors);
+	nstat->collisions = (hwstat->tx_single_cols +
+			     hwstat->tx_multiple_cols +
+			     hwstat->tx_excessive_cols);
+	nstat->rx_length_errors = (hwstat->rx_oversize_pkts +
+				   hwstat->rx_jabbers +
+				   hwstat->rx_undersize_pkts +
+				   hwstat->rx_length_mismatch);
+	nstat->rx_over_errors = hwstat->rx_resource_errors;
+	nstat->rx_crc_errors = hwstat->rx_fcs_errors;
+	nstat->rx_frame_errors = hwstat->rx_align_errors;
+	nstat->rx_fifo_errors = hwstat->rx_overruns;
+	/* XXX: What does "missed" mean? */
+	nstat->tx_aborted_errors = hwstat->tx_excessive_cols;
+	nstat->tx_carrier_errors = hwstat->tx_carrier_errors;
+	nstat->tx_fifo_errors = hwstat->tx_underruns;
+	/* Don't know about heartbeat or window errors... */
+
+	return nstat;
+}
+
+
+static int __devinit at91_macb_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct at91_eth_pdata  *board = (struct at91_eth_pdata  *) dev->platform_data;
+	struct net_device *ndev;
+	struct macb_priv *priv;
+	int err = 0;
+	u32 revision;
+
+
+	// Sanity checks
+	if ((platform_num_resources(pdev) < 2)
+	    || !(platform_resource_flags(pdev, 0) & IORESOURCE_MEM)
+	    || !(platform_resource_flags(pdev, 1) & IORESOURCE_IRQ)
+	    || (board == NULL)) {
+	  dev_err(dev, "Cannot find MACB resources.\n");
+	  return -ENODEV;
+	}
+
+	ndev = alloc_etherdev(sizeof(struct macb_priv));
+	if (ndev == NULL) {
+	  dev_err(dev, "Cannot allocate net_device structure.\n");
+	  return -ENOMEM;
+	}
+
+	SET_MODULE_OWNER(ndev);
+	SET_NETDEV_DEV(ndev, dev);
+
+	ndev->base_addr = platform_resource_start(pdev, 0);
+	ndev->irq = platform_resource_start(pdev, 1);
+	ndev->open = at91_macb_open;
+	ndev->stop = at91_macb_stop;
+	ndev->hard_start_xmit = at91_macb_start_xmit;
+	ndev->get_stats = at91_macb_get_stats;
+	ndev->set_mac_address = at91_macb_set_hw_addr;
+	ndev->poll = at91_macb_poll;
+	ndev->weight = 64;
+
+	priv = (struct macb_priv *) netdev_priv(ndev);
+
+	INIT_WORK(&priv->phy_task, at91_macb_phy_task, priv);	
+	spin_lock_init(&priv->lock);
+	init_MUTEX(&priv->mdio_sem);
+	init_completion(&priv->mdio_complete);
+       	
+	priv->mmio = ioremap(platform_resource_start(pdev, 0),
+			     platform_resource_len(pdev, 0));
+	if (priv->mmio == NULL) {
+	  err = -ENOMEM;
+	  dev_err(dev, "Unable to remap MACB I/O space\n");
+	  goto out;
+	}
+
+	priv->pdev = pdev;
+	priv->ndev = ndev;
+
+	// Set mii_if_info fields in macb_priv
+	priv->mii.dev = ndev;
+	priv->mii.mdio_read = at91_macb_mdio_read;
+	priv->mii.mdio_write = at91_macb_mdio_write;
+	priv->mii.phy_id = board->phy_id;
+	priv->mii.phy_id_mask = 0x1f;
+	priv->mii.reg_num_mask = 0x1f;
+
+	// Get hw address from MACB (the static one or the one set by the bootloader)
+	get_macb_hw_addr(priv);
+		
+	// Configure PIO lines for MACB
+	at91_device_pio_setup(board->pio_data);
+	
+	err = register_netdev(ndev);
+	if (err) {
+	  dev_err(dev, "Unable to register network device : %s\n", 
+		  ndev->name);
+	  goto fail0;
+	}
+	  
+	dev_set_drvdata(dev, ndev);
+	
+	revision = macb_readl(priv, EMAC_REV);
+	printk(KERN_INFO "%s: ATMEL MACB rev %u.%u at 0x%08lx irq %d\n", ndev->name,
+	       (revision >> 8) & 0xff, revision & 0xff,
+	       ndev->base_addr, ndev->irq);
+	
+	return 0;
+
+ fail0:
+	iounmap(priv->mmio);
+ out:
+	free_netdev(ndev);
+	return err;
+}
+
+
+static int __devexit at91_macb_remove(struct device *dev)
+{
+        struct net_device *ndev = dev_get_drvdata(dev);
+	
+	unregister_netdev(ndev);
+	free_netdev(ndev);
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+
+static struct device_driver at91_macb_driver = {
+	.name		= "macb",
+	.bus		= &platform_bus_type,
+	.probe		= at91_macb_probe,
+	.remove		= __devexit_p(at91_macb_remove),
+};
+
+static int __init at91_macb_init(void)
+{
+	return driver_register(&at91_macb_driver);
+}
+
+static void __exit at91_macb_exit(void)
+{
+	driver_unregister(&at91_macb_driver);
+}
+
+module_init(at91_macb_init);
+module_exit(at91_macb_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for Atmel Ethernet MACB");
+MODULE_AUTHOR("Atmel Rousset, France");
diff -Nur linux-2.6.15.4-orig/drivers/net/arm/at91_macb.h linux-2.6.15.4/drivers/net/arm/at91_macb.h
--- linux-2.6.15.4-orig/drivers/net/arm/at91_macb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/net/arm/at91_macb.h	2006-08-09 10:45:25.000000000 +0200
@@ -0,0 +1,136 @@
+#ifndef _AT91_MACB_H
+#define _AT91_MACB_H
+
+
+struct dma_desc {
+        u32 addr;
+        u32 ctrl;
+};
+
+
+#define RX_BUFFER_SIZE	        128		/* 128 rounded up */
+#define RX_RING_SIZE	        240		/* max number of receive buffers */
+#define RX_RING_BYTES           (RX_RING_SIZE * sizeof(struct dma_desc))
+#define RX_DMA_SIZE             RX_RING_BYTES + RX_RING_SIZE * RX_BUFFER_SIZE
+
+#define TX_BUFFER_SIZE	        1536	        /* 1536 rounded up */
+#define TX_RING_SIZE	        10		/* max number of transmit descriptors*/
+#define TX_RING_BYTES           (TX_RING_SIZE * sizeof(struct dma_desc))
+#define TX_DMA_SIZE             TX_RING_BYTES + TX_RING_SIZE * TX_BUFFER_SIZE
+
+#define DEF_TX_RING_PENDING	(TX_RING_SIZE - 1)
+
+
+#define RXADDR_USED		0x00000001
+#define RXADDR_WRAP		0x00000002
+
+#define RXBUF_FRMLEN_MASK	0x00000fff
+#define RXBUF_OFFSET_BYTES_MASK	0x00003000
+#define RXBUF_FRAME_START	0x00004000
+#define RXBUF_FRAME_END		0x00008000
+#define RXBUF_TYPEID_MATCH	0x00400000
+#define RXBUF_ADDR4_MATCH	0x00800000
+#define RXBUF_ADDR3_MATCH	0x01000000
+#define RXBUF_ADDR2_MATCH	0x02000000
+#define RXBUF_ADDR1_MATCH	0x04000000
+#define RXBUF_BROADCAST		0x80000000
+
+#define TXBUF_FRMLEN_MASK	0x000007ff
+#define TXBUF_FRAME_END		0x00008000
+#define TXBUF_NOCRC		0x00010000
+#define TXBUF_EXHAUSTED		0x08000000
+#define TXBUF_UNDERRUN		0x10000000
+#define TXBUF_MAXRETRY		0x20000000
+#define TXBUF_WRAP		0x40000000
+#define TXBUF_USED		0x80000000
+
+
+
+#define AT91C_MAN_CODE          (2 << 16)
+#define AT91C_MAN_READ          (2 << 28)
+#define AT91C_MAN_WRITE         (1 << 28)
+#define AT91C_MAN_SOF           (1 << 30)
+
+
+
+/*
+ * Hardware-collected statistics. Used when updating the network
+ * device stats by a periodic timer.
+ */
+struct macb_hw_stats {
+	u32	rx_pause_frames;
+	u32	tx_ok;
+	u32	tx_single_cols;
+	u32	tx_multiple_cols;
+	u32	rx_ok;
+	u32	rx_fcs_errors;
+	u32	rx_align_errors;
+	u32	tx_deferred;
+	u32	tx_late_cols;
+	u32	tx_excessive_cols;
+	u32	tx_underruns;
+	u32	tx_carrier_errors;
+	u32	rx_resource_errors;
+	u32	rx_overruns;
+	u32	rx_symbol_errors;
+	u32	rx_oversize_pkts;
+	u32	rx_jabbers;
+	u32	rx_undersize_pkts;
+	u32	sqe_test_errors;
+	u32	rx_length_mismatch;
+};
+
+
+
+struct ring_info {
+	struct sk_buff		*skb;
+	dma_addr_t		mapping;
+};
+
+struct macb_priv {
+        struct net_device_stats          stats;
+        struct macb_hw_stats             hw_stats;      
+
+        void                             *mmio;
+
+        unsigned int                     tx_head, tx_tail;
+        volatile struct dma_desc         *tx_ring;
+        struct ring_info                 *tx_skb;
+	dma_addr_t		         tx_ring_dma;
+        void                             *tx_buffers;
+        dma_addr_t		         tx_buffers_dma;    // this is needed when using TCM memory as a
+                                                            // frame buffer
+        unsigned int                     rx_tail;
+        volatile struct dma_desc         *rx_ring;
+	dma_addr_t		         rx_ring_dma;
+        void                             *rx_buffers;
+	dma_addr_t		         rx_buffers_dma;
+
+        spinlock_t                       lock;
+
+	struct semaphore	         mdio_sem;
+	struct completion	         mdio_complete;
+        struct mii_if_info               mii;
+        
+        // TODO : remove timer and work queue as soon as
+        // we can manage pios interrupts in gpio layer
+        struct timer_list	         timer;
+	struct work_struct	         phy_task;
+
+        struct platform_device           *pdev;
+        struct net_device                *ndev;
+};
+
+
+static inline u32 macb_readl(struct macb_priv *priv, u32 reg)
+{
+	return readl(priv->mmio + reg);
+}
+
+static inline void macb_writel(struct macb_priv *priv, u32 reg, u32 value)
+{
+	writel(value, priv->mmio + reg);
+}
+
+
+#endif /* _AT91_MACB_H */
diff -Nur linux-2.6.15.4-orig/drivers/net/arm/Kconfig linux-2.6.15.4/drivers/net/arm/Kconfig
--- linux-2.6.15.4-orig/drivers/net/arm/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/net/arm/Kconfig	2006-08-09 11:06:05.000000000 +0200
@@ -44,3 +44,19 @@
 	  will generate a suitable hw address based on the board serial
 	  number (MTD support is required for this). Otherwise you will
 	  need to set a suitable hw address using ifconfig.
+
+config AT91_MACB
+	tristate "ATMEL MACB support for SAM926X familly (NADIA2)"
+	depends on NET_ETHERNET && ARM && MACH_AT91SAM9260EK
+	help
+	  If you have ATMEL MACB ethernet device embedded in SAM926X familly
+
+
+
+config MACB_TCM
+	tristate "Put MACB DMA buffers in TCM memory"
+	depends on AT91_MACB
+	
+config MACB_DEBUG
+	tristate "Enable DEBUG mode for MACB driver"
+	depends on AT91_MACB
\ No newline at end of file
diff -Nur linux-2.6.15.4-orig/drivers/net/arm/Makefile linux-2.6.15.4/drivers/net/arm/Makefile
--- linux-2.6.15.4-orig/drivers/net/arm/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/net/arm/Makefile	2006-08-09 10:45:25.000000000 +0200
@@ -8,3 +8,8 @@
 obj-$(CONFIG_ARM_ETHERH)	+= etherh.o
 obj-$(CONFIG_ARM_ETHER3)	+= ether3.o
 obj-$(CONFIG_ARM_ETHER1)	+= ether1.o
+obj-$(CONFIG_AT91_MACB)         += at91_macb.o
+
+ifeq ($(CONFIG_MACB_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
\ No newline at end of file
diff -Nur linux-2.6.15.4-orig/drivers/net/dm9000.c linux-2.6.15.4/drivers/net/dm9000.c
--- linux-2.6.15.4-orig/drivers/net/dm9000.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/net/dm9000.c	2006-08-09 10:45:17.000000000 +0200
@@ -564,6 +564,17 @@
 	for (i = 0; i < 6; i++)
 		ndev->dev_addr[i] = db->srom[i];
 
+	{
+		/* Hardcode MAC address */
+		i = 0;
+		ndev->dev_addr[i++] = 0x00;
+		ndev->dev_addr[i++] = 0x02;
+		ndev->dev_addr[i++] = 0x34;
+		ndev->dev_addr[i++] = 0x56;
+		ndev->dev_addr[i++] = 0x78;
+		ndev->dev_addr[i++] = 0x19;
+	}
+
 	if (!is_valid_ether_addr(ndev->dev_addr))
 		printk("%s: Invalid ethernet MAC address.  Please "
 		       "set using ifconfig\n", ndev->name);
diff -Nur linux-2.6.15.4-orig/drivers/serial/Kconfig linux-2.6.15.4/drivers/serial/Kconfig
--- linux-2.6.15.4-orig/drivers/serial/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/serial/Kconfig	2006-08-09 11:07:40.000000000 +0200
@@ -270,6 +270,24 @@
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_AT91
+        tristate "AT91SAM926X and NADIA2 serial port support"
+        depends on ARM && (MACH_AT91SAM9261EK || MACH_NADIA2VB || MACH_AT91SAM9260EK )
+        select SERIAL_CORE 
+        help 
+          This enables the driver for the on-chip UARTs of the SAM926X familly
+	  (AT91SAM9261EK and NADIA2VB)
+          processor.
+
+config SERIAL_AT91_CONSOLE
+        bool "Support for console on AT91SAM926X and NADIA2 serial port"
+        depends on SERIAL_AT91=y
+        select SERIAL_CORE_CONSOLE
+        help
+          Say Y here if you wish to use a UART on the SAM926X familly (AT91SAM9261EK and
+	  NADIA2VB) as the system console (the system console is the device which receives 
+	  all kernel messages and warnings and which allows logins in single user mode).
+
 config SERIAL_CLPS711X
 	tristate "CLPS711X serial port support"
 	depends on ARM && ARCH_CLPS711X
diff -Nur linux-2.6.15.4-orig/drivers/serial/Makefile linux-2.6.15.4/drivers/serial/Makefile
--- linux-2.6.15.4-orig/drivers/serial/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/serial/Makefile	2006-08-09 10:45:17.000000000 +0200
@@ -57,3 +57,4 @@
 obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
 obj-$(CONFIG_SERIAL_VR41XX) += vr41xx_siu.o
 obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
+obj-$(CONFIG_SERIAL_AT91)  += serial_at91sam926x.o
diff -Nur linux-2.6.15.4-orig/drivers/serial/serial_at91sam926x.c linux-2.6.15.4/drivers/serial/serial_at91sam926x.c
--- linux-2.6.15.4-orig/drivers/serial/serial_at91sam926x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/serial/serial_at91sam926x.c	2006-08-09 10:45:17.000000000 +0200
@@ -0,0 +1,914 @@
+/*
+ *  linux/drivers/serial/at91sam926x_serial.c
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *  Driver for AT91SAMM9261 Serial ports in linux 2.6 fashion
+ *  Revision	  2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ *
+ *  Driver for Atmel AT91RM9200 Serial ports
+ *
+ *  Copyright (c) Rick Bronson
+ *
+ *  Based on drivers/char/serial_sa1100.c, by Deep Blue Solutions Ltd.
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/tty_flip.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/platform.h>
+#include <asm/sizes.h>
+#include <asm/mach/serial_at91.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/pmc.h>
+#include <asm/arch/usart.h>
+
+#if defined(CONFIG_SERIAL_AT91_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#include <linux/sysrq.h>
+#endif
+
+#include <linux/serial_core.h>
+
+
+//#define SERIAL_AT91_MAJOR	204	
+//#define MINOR_START		154
+#define SERIAL_AT91_MAJOR	TTY_MAJOR	
+#define MINOR_START		64
+#define SERIAL_AT91_NAME	"ttyS"
+//#define SERIAL_AT91_NAME	"ttyAT"
+	
+#define AT91_ISR_PASS_LIMIT	256
+
+#define UART_PUT_CR(port,v)	writel(v, ((port)->membase + US_CR))
+#define UART_GET_MR(port)	readl((port)->membase + US_MR)
+#define UART_PUT_MR(port,v)	writel(v, ((port)->membase + US_MR))
+#define UART_PUT_IER(port,v)	writel(v, ((port)->membase + US_IER))
+#define UART_PUT_IDR(port,v)	writel(v, ((port)->membase + US_IDR))
+#define UART_GET_IMR(port)	readl((port)->membase + US_IMR)
+#define UART_GET_CSR(port)	readl((port)->membase + US_CSR)
+#define UART_GET_CHAR(port)	readl((port)->membase + US_RHR)
+#define UART_PUT_CHAR(port,v)	writel(v, ((port)->membase + US_THR))
+#define UART_GET_BRGR(port)	readl((port)->membase + US_BRGR)
+#define UART_PUT_BRGR(port,v)	writel(v, ((port)->membase + US_BRGR))
+#define UART_PUT_RTOR(port,v)	writel(v, ((port)->membase + US_RTOR))
+
+/* PDC registers */
+#define UART_PUT_PTCR(port,v)	writel(v, ((port)->membase + US_PTCR))
+#define UART_PUT_RPR(port,v)	writel(v, ((port)->membase + US_RPR))
+#define UART_PUT_RCR(port,v)	writel(v, ((port)->membase + US_RCR))
+#define UART_GET_RCR(port)	readl((port)->membase + US_RCR)
+#define UART_PUT_RNPR(port,v)	writel(v, ((port)->membase + US_RNPR))
+#define UART_PUT_RNCR(port,v)	writel(v, ((port)->membase + US_RNCR))
+
+
+extern int at91_device_pio_setup (struct at91_pioline* pPin);
+
+static int (*at91_open)(struct uart_port *);
+static void (*at91_close)(struct uart_port *);
+
+#ifdef SUPPORT_SYSRQ
+static struct console at91_console;
+#endif
+
+/*
+ * Return TIOCSER_TEMT when transmitter FIFO and Shift register is empty.
+ */
+static u_int at91_tx_empty(struct uart_port *port)
+{
+	return (UART_GET_CSR(port) & AT91C_US_TXEMPTY) ? TIOCSER_TEMT : 0;
+}
+
+/*
+ * Set state of the modem control output lines
+ */
+static void at91_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+	unsigned int control = 0;
+
+	if (mctrl & TIOCM_RTS)
+		control |= AT91C_US_RTSEN;
+	else
+		control |= AT91C_US_RTSDIS;
+  
+	if (mctrl & TIOCM_DTR)
+		control |= AT91C_US_DTREN;
+	else
+		control |=  AT91C_US_DTRDIS;
+  
+	UART_PUT_CR(port,control);
+}
+
+/*
+ * Get state of the modem control input lines
+ */
+static u_int at91_get_mctrl(struct uart_port *port)
+{
+	unsigned int status, ret = 0;
+
+	status = UART_GET_CSR(port);
+	if (status & AT91C_US_DCD)
+		ret |= TIOCM_CD;
+	if (status & AT91C_US_CTS)
+		ret |= TIOCM_CTS;
+	if (status & AT91C_US_DSR)
+		ret |= TIOCM_DSR;
+	if (status & AT91C_US_RI)
+		ret |= TIOCM_RI;
+
+	return ret;
+}
+
+/*
+ * Stop transmitting.
+ */
+static void at91_stop_tx(struct uart_port *port)
+{
+	UART_PUT_IDR(port, AT91C_US_TXRDY);
+	port->read_status_mask &= ~AT91C_US_TXRDY;
+}
+
+
+/*
+ * Start transmitting.
+ */
+static void at91_start_tx(struct uart_port *port)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	port->read_status_mask |= AT91C_US_TXRDY;
+	UART_PUT_IER(port, AT91C_US_TXRDY);
+	local_irq_restore(flags);
+
+}
+
+/*
+ * Stop receiving - port is in process of being closed.
+ */
+static void at91_stop_rx(struct uart_port *port)
+{
+	UART_PUT_IDR(port, AT91C_US_RXRDY);
+}
+
+/*
+ * Enable modem status interrupts
+ */
+static void at91_enable_ms(struct uart_port *port)
+{
+	UART_PUT_IER(port, AT91C_US_RIIC | AT91C_US_DSRIC | AT91C_US_DCDIC | AT91C_US_CTSIC);
+}
+
+/*
+ * Control the transmission of a break signal
+ */
+static void at91_break_ctl(struct uart_port *port, int break_state)
+{
+	if (break_state != 0)
+		UART_PUT_CR(port, AT91C_US_STTBRK);	/* start break */
+	else
+		UART_PUT_CR(port, AT91C_US_STPBRK);	/* stop break */
+}
+/*
+ * Characters received (called from interrupt handler)
+ */
+static void at91_rx_chars(struct uart_port *port, struct pt_regs *regs)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int status, ch, flg, ignored = 0;
+
+	status = UART_GET_CSR(port) & port->read_status_mask;
+	while (status & (AT91C_US_RXRDY)) {
+		ch = UART_GET_CHAR(port);
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		port->icount.rx++;
+
+		flg = TTY_NORMAL;
+
+		if (status & (AT91C_US_PARE | AT91C_US_FRAME | AT91C_US_OVRE)) {
+			/* Error handling code */	
+		        UART_PUT_CR(port, AT91C_US_RSTSTA);  /* clear error */
+		        
+			if (status & (AT91C_US_PARE))
+		                port->icount.parity++;
+		        else if (status & (AT91C_US_FRAME))
+		                port->icount.frame++;
+		        if (status & (AT91C_US_OVRE))
+		                port->icount.overrun++;
+
+		        if (status & port->ignore_status_mask) {
+                		if (++ignored > 100)
+		                        goto out;
+     			         goto ignore_char;
+        		}
+
+		        status &= port->read_status_mask;
+
+       			UART_PUT_CR(port, AT91C_US_RSTSTA);  /* clear error */
+		        if (status & AT91C_US_PARE)
+                		flg = TTY_PARITY;
+		        else if (status & AT91C_US_FRAME)
+                		flg = TTY_FRAME;
+
+			#ifdef SUPPORT_SYSRQ
+			        port->sysrq = 0;
+			#endif
+		}
+		else if (uart_handle_sysrq_char(port, ch, regs))
+			goto ignore_char;
+
+		uart_insert_char(port, status, AT91C_US_OVRE, ch, flg);
+	ignore_char:
+		status = UART_GET_CSR(port) & port->read_status_mask;
+	}
+out:
+	tty_flip_buffer_push(tty);
+	return;
+}
+
+/*
+ * Transmit characters (called from interrupt handler)
+ */
+static void at91_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+
+	if (port->x_char) {
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		at91_stop_tx(port);
+		return;
+	}
+
+	while (UART_GET_CSR(port) & AT91C_US_TXRDY) {
+		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		at91_stop_tx(port);
+}
+
+/*
+ * Interrupt handler
+ */
+static irqreturn_t at91_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	unsigned int status, pending, pass_counter = 0;
+
+	status = UART_GET_CSR(port);
+	pending = status & port->read_status_mask;
+	if (pending) {
+		do {
+			if (pending & AT91C_US_RXRDY)
+				at91_rx_chars(port, regs);
+
+			/* Clear the relevent break bits */
+			if (pending & AT91C_US_RXBRK) {
+				UART_PUT_CR(port, AT91C_US_RSTSTA);
+				port->icount.brk++;
+				uart_handle_break(port);
+			}
+
+			// TODO: All reads to CSR will clear these interrupts!
+			if (pending & AT91C_US_RIIC) port->icount.rng++;
+			if (pending & AT91C_US_DSRIC) port->icount.dsr++;
+			if (pending & AT91C_US_DCDIC) {
+				port->icount.dcd++;
+				uart_handle_dcd_change(port, status & AT91C_US_DCD);
+			}
+			if (pending & AT91C_US_CTSIC) {
+				port->icount.cts++;
+				uart_handle_cts_change(port, status & AT91C_US_CTS);
+			}
+			if (pending & (AT91C_US_RIIC | AT91C_US_DSRIC | AT91C_US_DCDIC | AT91C_US_CTSIC))
+				wake_up_interruptible(&port->info->delta_msr_wait);
+
+			if (pending & AT91C_US_TXRDY)
+				at91_tx_chars(port);
+			if (pass_counter++ > AT91_ISR_PASS_LIMIT)
+				break;
+
+			status = UART_GET_CSR(port);
+			pending = status & port->read_status_mask;
+		} while (pending);
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * Perform initialization and enable port for reception
+ */
+static int at91_startup(struct uart_port *port)
+{
+	int retval;
+
+         /* 
+         * Ensure that no interrupts are enabled otherwise when 
+         * request_irq() is called we could get stuck trying to 
+         * handle an unexpected interrupt
+         */
+	UART_PUT_IDR(port, -1);
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(port->irq, at91_interrupt, SA_SHIRQ, "at91_serial", port);
+	if (retval) {
+		printk("at91_serial: at91_startup - Can't get irq\n");
+		return retval;
+	}
+	/*
+	 * If there is a specific "open" function (to register
+	 * control line interrupts)
+	 */
+	if (at91_open) {
+		retval = at91_open(port);
+		if (retval) {
+			free_irq(port->irq, port);
+			return retval;
+		}
+	}
+  
+	port->read_status_mask = AT91C_US_RXRDY | AT91C_US_TXRDY | AT91C_US_OVRE
+			    | AT91C_US_FRAME | AT91C_US_PARE | AT91C_US_RXBRK;
+
+	/*
+	 * Finally, clear and enable interrupts
+	 */
+	UART_PUT_CR(port, AT91C_US_RSTSTA | AT91C_US_RSTRX);
+	UART_PUT_CR(port, AT91C_US_TXEN | AT91C_US_RXEN);  /* enable xmit & rcvr */
+	UART_PUT_IER(port, AT91C_US_RXRDY);  /* do receive only */
+	return 0;
+}
+
+/*
+ * Disable the port
+ */
+static void at91_shutdown(struct uart_port *port)
+{
+	/*
+	 * Disable all interrupts, port and break condition.
+	 */
+	UART_PUT_CR(port, AT91C_US_RSTSTA);
+	UART_PUT_IDR(port, -1L);
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(port->irq, port);
+  
+	/*
+	 * If there is a specific "close" function (to unregister
+	 * control line interrupts)
+	 */
+	if (at91_close)
+		at91_close(port);
+}
+
+/*
+ * Power / Clock management.
+ */
+static void at91_serial_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+	switch (state) {
+		case 0:
+		/*
+		 * Enable the peripheral clock for this serial port.
+		 * This is called on uart_open() or a resume event.
+		 */
+			at91_enable_periph_clock(port->irq);
+		break;
+		case 3:
+		/*
+		 * Disable the peripheral clock for this serial port.
+		 * This is called on uart_close() or a suspend event.
+		 */
+			if (port->irq != AT91C_ID_SYS)			/* is this a shared clock? */
+				at91_disable_periph_clock(port->irq);
+		break;
+		default:
+			printk(KERN_ERR "at91_serial: unknown pm %d\n", state);
+	}
+}
+
+static struct uart_ops at91_pops;		/* forward declaration */
+
+/*
+ * Change the port parameters
+ */
+static void at91_set_termios(struct uart_port *port, struct termios * termios, struct termios * old)
+{
+	unsigned long flags;
+	unsigned int mode, imr, quot, baud;
+	
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
+	quot = uart_get_divisor(port, baud);
+
+	/* Get current mode register */
+	mode = UART_GET_MR(port) & ~(AT91C_US_CHRL | AT91C_US_NBSTOP | AT91C_US_PAR);
+
+	/* byte size */
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		mode |= AT91C_US_CHRL_5_BITS;
+		break;
+	case CS6:
+		mode |= AT91C_US_CHRL_6_BITS;
+		break;
+	case CS7:
+		mode |= AT91C_US_CHRL_7_BITS;
+		break;
+	default:
+		mode |= AT91C_US_CHRL_8_BITS;
+		break;
+	}
+
+	/* stop bits */
+	if (termios->c_cflag & CSTOPB)
+		mode |= AT91C_US_NBSTOP_2_BIT;
+
+	/* parity */
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & CMSPAR) {			/* Mark or Space parity */
+			if (termios->c_cflag & PARODD)
+				mode |= AT91C_US_PAR_MARK;
+			else
+				mode |= AT91C_US_PAR_SPACE;
+		}
+		else if (termios->c_cflag & PARODD)
+			mode |= AT91C_US_PAR_ODD;
+		else
+			mode |= AT91C_US_PAR_EVEN;
+	}
+	else
+		mode |= AT91C_US_PAR_NONE;
+
+	spin_lock_irqsave(&port->lock, flags);
+        imr = UART_GET_IMR(port);       /* get interrupt mask */
+        UART_PUT_IDR(port, -1);         /* disable all interrupts */
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask |= AT91C_US_OVRE;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= AT91C_US_FRAME | AT91C_US_PARE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= AT91C_US_RXBRK;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= (AT91C_US_FRAME | AT91C_US_PARE);
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= AT91C_US_RXBRK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= AT91C_US_OVRE;
+	}
+
+	/* TODO: Ignore all characters if CREAD is set. */
+
+	/* disable receiver and transmitter */
+	UART_PUT_CR(port, AT91C_US_TXDIS | AT91C_US_RXDIS);
+
+	/* set the parity, stop bits and data size */
+	UART_PUT_MR(port, mode);
+
+	/* set the baud rate */
+	UART_PUT_BRGR(port, quot);
+	UART_PUT_CR(port, AT91C_US_TXEN | AT91C_US_RXEN);
+
+	/* restore interrupts */
+	UART_PUT_IER(port, imr);
+	spin_unlock_irqrestore(&port->lock, flags);
+	/* CTS flow-control and modem-status interrupts */
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		at91_pops.enable_ms(port);
+}
+
+/*
+ * Return string describing the specified port
+ */
+static const char *at91_type(struct uart_port *port)
+{
+	return (port->type == PORT_AT91) ? "AT91_SERIAL" : NULL;
+}
+
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void at91_release_port(struct uart_port *port)
+{
+	if (port->line != AT91C_CONSOLE)
+		iounmap(port->membase);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int at91_request_port(struct uart_port *port)
+{
+	if (port->flags & UPF_IOREMAP) {
+		if (port->line != AT91C_CONSOLE)
+			port->membase = ioremap(port->mapbase, SZ_16K);
+	}
+  
+	return 0;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void at91_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		if (at91_request_port(port) == 0)
+			port->type = PORT_AT91;
+	}
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int at91_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_AT91)
+		ret = -EINVAL;
+	if (port->irq != ser->irq)
+		ret = -EINVAL;
+	if (ser->io_type != SERIAL_IO_MEM)
+		ret = -EINVAL;
+	if (port->uartclk / 16 != ser->baud_base)
+		ret = -EINVAL;
+	if ((void *)port->mapbase != ser->iomem_base)
+		ret = -EINVAL;
+	if (port->iobase != ser->port)
+		ret = -EINVAL;
+	if (ser->hub6 != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops at91_pops = {
+	.tx_empty	= at91_tx_empty,
+	.set_mctrl	= at91_set_mctrl,
+	.get_mctrl	= at91_get_mctrl,
+	.stop_tx	= at91_stop_tx,
+	.start_tx	= at91_start_tx,
+	.stop_rx	= at91_stop_rx,
+	.enable_ms	= at91_enable_ms,
+	.break_ctl	= at91_break_ctl,
+	.startup	= at91_startup,
+	.shutdown	= at91_shutdown,
+	.set_termios	= at91_set_termios,
+	.type		= at91_type,
+	.release_port	= at91_release_port,
+	.request_port	= at91_request_port,
+	.config_port 	= at91_config_port,
+	.verify_port 	= at91_verify_port,
+	.pm		= at91_serial_pm,
+};
+
+
+static void __devinit at91_init_port(struct uart_port *port, const struct platform_device *dev)
+{
+	BUG_ON(dev->num_resources < 2);
+	BUG_ON(!(dev->resource[0].flags & IORESOURCE_MEM));
+	BUG_ON(!(dev->resource[1].flags & IORESOURCE_IRQ));
+  
+	//spin_lock_init(&port->lock);
+  
+	port->mapbase  = dev->resource[0].start;
+	port->irq      = dev->resource[1].start;
+  
+	port->uartclk  = AT91C_MASTER_CLOCK;
+	port->iotype   = SERIAL_IO_MEM;
+	port->flags    = UPF_BOOT_AUTOCONF | UPF_IOREMAP;
+	port->ops      = &at91_pops;
+	port->fifosize = 1;
+	port->line     = dev->id; 
+  
+	// Configure PIOs for every port
+	at91_device_pio_setup(dev->dev.platform_data);
+}
+
+
+void __init at91_register_uart_fns(struct at91_port_fns *fns)
+{
+	if (fns->enable_ms)
+		at91_pops.enable_ms = fns->enable_ms;
+	if (fns->get_mctrl)
+		at91_pops.get_mctrl = fns->get_mctrl;
+	if (fns->set_mctrl)
+		at91_pops.set_mctrl = fns->set_mctrl;
+	at91_open          = fns->open;
+	at91_close         = fns->close;
+	at91_pops.pm       = fns->pm;
+	at91_pops.set_wake = fns->set_wake;
+}
+
+
+static struct uart_port at91_ports[AT91C_NR_UART];
+
+#ifdef CONFIG_SERIAL_AT91_CONSOLE
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void at91_console_write(struct console *console, const char *s, u_int count)
+{
+	struct uart_port *port = &at91_ports[console->index];
+	unsigned int status, i, imr;
+  
+	/*
+	 *	First, save IMR and then disable interrupts
+	 */
+	imr = UART_GET_IMR(port);	/* get interrupt mask */
+	UART_PUT_IDR(port, AT91C_US_RXRDY | AT91C_US_TXRDY);
+  
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			status = UART_GET_CSR(port);
+		} while (!(status & AT91C_US_TXRDY));
+		UART_PUT_CHAR(port, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = UART_GET_CSR(port);
+			} while (!(status & AT91C_US_TXRDY));
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+  
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore IMR
+	 */
+	do {
+		status = UART_GET_CSR(port);
+	} while (!(status & AT91C_US_TXRDY));
+	UART_PUT_IER(port, imr);	/* set interrupts back the way they were */
+}
+
+
+/*
+ * If the port was already initialised (eg, by a boot loader), try to determine
+ * the current setup.
+ */
+static void __init at91_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	unsigned int mr, quot;
+
+// TODO: CR is a write-only register
+//	unsigned int cr;
+//
+//	cr = UART_GET_CR(port) & (AT91C_US_RXEN | AT91C_US_TXEN);
+//	if (cr == (AT91C_US_RXEN | AT91C_US_TXEN)) {
+//		/* ok, the port was enabled */
+//
+//		mr = UART_GET_MR(port) & AT91C_US_PAR;
+//
+//		*parity = 'n';
+//		if (mr == AT91C_US_PAR_EVEN)
+//			*parity = 'e';
+//		else if (mr == AT91C_US_PAR_ODD)
+//			*parity = 'o';
+//	}
+
+	mr = UART_GET_MR(port) & AT91C_US_CHRL;
+	if (mr == AT91C_US_CHRL_8_BITS)
+		*bits = 8;
+	else
+		*bits = 7;
+
+	quot = UART_GET_BRGR(port);
+	*baud = port->uartclk / (16 * (quot));
+}
+
+static int __init at91_console_setup(struct console *console, char *options)
+{
+	const struct platform_device *dev;
+	struct uart_port *uport;
+	int baud = AT91C_CONSOLE_DEFAULT_BAUDRATE;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+  
+	if (console->index >= AT91C_NR_UART) {
+		printk(KERN_ERR "Bad console index %u, There are only %u ports\n", console->index,AT91C_NR_UART);
+		return -ENODEV;
+	}
+  
+	dev = platform_get_device("usart", console->index);
+	if (!dev)
+		return -ENXIO;
+  
+	uport = &at91_ports[console->index];
+
+	at91_init_port(uport, dev);
+
+	uport->membase = (unsigned char *) AT91C_VA_BASE_DBGU;
+
+	/*
+	 * Enable the serial console, in-case bootloader did not do it.
+	 */
+	at91_enable_periph_clock(uport->irq);	/* enable clock */
+  
+	UART_PUT_IDR(uport, -1L);	/* disable interrupts */
+  
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		at91_console_get_options(uport, &baud, &parity, &bits);
+  
+	return uart_set_options(uport, console, baud, parity, bits, flow);
+}
+
+extern struct uart_driver at91_uart;
+
+static struct console at91_console = {
+	.name	= SERIAL_AT91_NAME,
+	.write	= at91_console_write,
+	.device	= uart_console_device,
+	.setup	= at91_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= AT91C_CONSOLE,
+	.data		= &at91_uart,
+};
+
+#define AT91_CONSOLE_DEVICE	&at91_console
+
+static int  __init at91_console_init(void)
+{
+	register_console(&at91_console);
+	return 0;
+}
+
+console_initcall(at91_console_init);
+
+#else
+#define AT91_CONSOLE_DEVICE	NULL
+#endif
+
+static struct uart_driver at91_uart = {
+	.driver_name	= SERIAL_AT91_NAME,
+	.dev_name	= SERIAL_AT91_NAME,
+	.devfs_name	= SERIAL_AT91_NAME,
+	.major		= SERIAL_AT91_MAJOR,
+	.minor		= MINOR_START,
+	.nr		= AT91C_NR_UART,
+	.cons		= AT91_CONSOLE_DEVICE,
+};
+
+static int at91_serial_suspend(struct device *_dev, pm_message_t state)
+{
+	struct uart_port *uport = dev_get_drvdata(_dev);
+	int retval = 0;
+  
+	if (uport)
+		retval = uart_suspend_port(&at91_uart, uport);
+  
+	return retval;
+}
+
+static int at91_serial_resume(struct device *_dev)
+{
+	struct uart_port *uport = dev_get_drvdata(_dev);
+	int retval = 0;
+  
+	if (uport)
+		retval = uart_resume_port(&at91_uart, uport);
+  
+	return retval;
+}
+
+
+static int __devinit at91_serial_probe(struct device *_dev)
+{
+	struct platform_device *pdev = to_platform_device(_dev);
+	struct uart_port *uport;
+	int retval;
+  
+	if (pdev->id >= AT91C_NR_UART) {
+		printk(KERN_WARNING "Bad port number %u, There are only %u ports\n",pdev->id, AT91C_NR_UART);
+		return -ENODEV;
+	}
+  
+	uport = &at91_ports[pdev->id];
+  
+	at91_init_port(uport, pdev);
+
+	retval = uart_add_one_port(&at91_uart, uport);
+
+	if (!retval)
+		dev_set_drvdata(_dev, uport);
+
+	return retval;
+}
+
+
+static int __devexit at91_serial_remove(struct device *_dev)
+{
+	struct uart_port *uport = dev_get_drvdata(_dev);
+	int retval = 0;
+  
+	dev_set_drvdata(_dev, NULL);
+  
+	if (uport) {
+		retval = uart_remove_one_port(&at91_uart, uport);
+		kfree(uport);
+	}
+  
+	return retval;
+}
+
+
+static struct device_driver at91_serial_driver = {
+	.name	= "usart",
+	.bus	= &platform_bus_type,
+	.probe	= at91_serial_probe,
+	.remove	= __devexit_p(at91_serial_remove),
+	.suspend= at91_serial_suspend,
+	.resume	= at91_serial_resume,
+};
+
+
+static int __init at91_serial_init(void)
+{    
+	int ret;
+  
+	ret = uart_register_driver(&at91_uart);
+  
+	if (!ret) {
+		ret = driver_register(&at91_serial_driver);
+		if (ret)
+			uart_unregister_driver(&at91_uart);
+	}
+  
+	return ret;
+}
+
+
+static void __exit at91_serial_exit(void)
+{
+	driver_unregister(&at91_serial_driver);
+	uart_unregister_driver(&at91_uart);
+}
+
+
+module_init(at91_serial_init);
+module_exit(at91_serial_exit);
+
+MODULE_AUTHOR("Rick Bronson/M. Amine SAYA");
+MODULE_DESCRIPTION("AT91 generic serial port driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.15.4-orig/drivers/serial/serial_core.c linux-2.6.15.4/drivers/serial/serial_core.c
--- linux-2.6.15.4-orig/drivers/serial/serial_core.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/serial/serial_core.c	2006-08-09 10:45:17.000000000 +0200
@@ -1975,7 +1975,7 @@
 	case UPIO_MEM32:
 	case UPIO_AU:
 		snprintf(address, sizeof(address),
-			 "MMIO 0x%lx", port->mapbase);
+			 "MMIO 0x%lx", ((port->mapbase) ? port->mapbase : ((unsigned long) port->membase)));
 		break;
 	default:
 		strlcpy(address, "*unknown*", sizeof(address));
diff -Nur linux-2.6.15.4-orig/drivers/spi/busses/at91sam926x_spi.c linux-2.6.15.4/drivers/spi/busses/at91sam926x_spi.c
--- linux-2.6.15.4-orig/drivers/spi/busses/at91sam926x_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/busses/at91sam926x_spi.c	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,652 @@
+/*
+ * Driver for Atmel SPI Interfaces
+ *
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/spi.h>
+
+#include <asm/io.h>
+#include <asm/sizes.h>
+#include <asm/hardware.h>
+#include <asm/platform.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/spi.h>
+#include <asm/arch/pmc.h>
+
+#include "at91_spi.h"
+
+#define CHAR_PER_LINE   20
+
+#define SPI_PUT_CR(host,v)		writel(v, ((host)->regs + SPI_CR))
+#define SPI_GET_MR(host)		readl((host)->regs + SPI_MR)
+#define SPI_PUT_MR(host,v)		writel(v, ((host)->regs + SPI_MR))
+#define SPI_GET_RDR(host)		readl((host)->regs + SPI_RDR)
+#define SPI_GET_SR(host)		readl((host)->regs + SPI_SR)
+#define SPI_PUT_IER(host,v)		writel(v, ((host)->regs + SPI_IER))
+#define SPI_PUT_IDR(host,v)		writel(v, ((host)->regs + SPI_IDR))
+#define SPI_GET_IMR(host)		readl((host)->regs + SPI_IMR)
+#define SPI_GET_CSRx(host,addr)		readl((host)->regs + SPI_CSR + (addr<<2))
+#define SPI_PUT_CSRx(host,addr,v)	writel(v, ((host)->regs + SPI_CSR + (addr<<2)))
+/* SPI DMA Registers */
+#define SPI_GET_RPR(host)		readl((host)->regs + SPI_RPR)
+#define SPI_PUT_RPR(host,v)		writel(v, ((host)->regs + SPI_RPR))
+#define SPI_GET_RCR(host)		readl((host)->regs + SPI_RCR)
+#define SPI_PUT_RCR(host,v)		writel(v, ((host)->regs + SPI_RCR))
+#define SPI_GET_TPR(host)		readl((host)->regs + SPI_TPR)
+#define SPI_PUT_TPR(host,v)		writel(v, ((host)->regs + SPI_TPR))
+#define SPI_GET_TCR(host)		readl((host)->regs + SPI_TCR)
+#define SPI_PUT_TCR(host,v)		writel(v, ((host)->regs + SPI_TCR))
+#define SPI_GET_RNCR(host)		readl((host)->regs + SPI_RNCR)
+#define SPI_PUT_RNCR(host,v)		writel(v, ((host)->regs + SPI_RNCR))
+#define SPI_GET_RNPR(host)		readl((host)->regs + SPI_RNPR)
+#define SPI_PUT_RNPR(host,v)		writel(v, ((host)->regs + SPI_RNPR))
+#define SPI_GET_TNCR(host)		readl((host)->regs + SPI_TNCR)
+#define SPI_PUT_TNCR(host,v)		writel(v, ((host)->regs + SPI_TNCR))
+#define SPI_GET_TNPR(host)		readl((host)->regs + SPI_TNPR)
+#define SPI_PUT_TNPR(host,v)		writel(v, ((host)->regs + SPI_TNPR))
+#define SPI_PUT_PTCR(host,v)		writel(v, ((host)->regs + SPI_PTCR))
+
+extern int at91_device_pio_setup (struct at91_pioline* pPin);
+
+void dump(char *buffer, int size) 
+{
+	int index, jndex, lines, tmp_size = size;
+	char *tmp = buffer;
+
+	lines = size / CHAR_PER_LINE;
+
+	for(jndex = 0; jndex < lines; jndex++) {
+		for(index = 0; index < CHAR_PER_LINE; index++) {
+			printk("%x ", *tmp);
+			tmp++;
+		}
+    		printk("\n");
+		tmp_size -= CHAR_PER_LINE;
+	}
+
+	for(index = 0; index < tmp_size; index++) {
+		printk("%x ", *tmp);
+		tmp++;
+	}
+  
+	printk("\n");
+}
+
+static void at91_dump_buffers(struct spi_xfer_desc *xfer_desc) 
+{
+#ifdef DEBUG
+	int index;
+  
+	for(index = 0; index < xfer_desc->nr_xfers; index++)
+		dump(xfer_desc->tx_xfer_units[index].buffer, xfer_desc->tx_xfer_units[index].buf_len);
+#endif
+}
+
+static irqreturn_t at91_spi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct at91_spi *host = (struct at91_spi *)dev_id;
+	struct spi_xfer *xfer;
+	struct spi_xfer_desc *xfer_desc;
+	u32 status, mask, pending;
+  
+	status = SPI_GET_SR(host);
+  
+	mask= SPI_GET_IMR(host);
+  
+	pending = status & mask;
+  
+	if (unlikely(!pending))
+		return IRQ_NONE;
+  
+	/*spin_lock(&host->lock);*/
+  
+	if (pending & AT91C_SPI_ENDRX) {    
+		BUG_ON(list_empty(&host->xfers));
+		xfer = list_entry(host->xfers.next, struct spi_xfer, list);
+		xfer->status_flags = status;
+		xfer_desc = xfer->curr_xfer_desc;
+    
+		dma_unmap_single(&host->pdev->dev, xfer->rxbuf_phys, xfer_desc->rx_xfer_units[0].buf_len, DMA_FROM_DEVICE);
+		dma_unmap_single(&host->pdev->dev, xfer->txbuf_phys, xfer_desc->tx_xfer_units[0].buf_len, DMA_TO_DEVICE);
+    
+		xfer->rxbuf_phys = xfer->next_rxbuf_phys;
+		xfer->txbuf_phys = xfer->next_txbuf_phys;
+    
+		xfer_desc->curr_xfer = xfer_desc->curr_xfer + 1;
+    
+		if (xfer_desc->curr_xfer == xfer_desc->nr_xfers) {
+			/* Disable ENDRX inerrupt*/
+			SPI_PUT_IDR(host, AT91C_SPI_ENDRX);
+      
+			/* Disable transmitter and receiver channels*/
+			SPI_PUT_IDR(host, (AT91C_PDC_RXTDIS | AT91C_PDC_TXTDIS));
+      
+			/* Raise chip select because we used CSAAT*/
+			SPI_PUT_CR(host, AT91C_SPI_LASTXFER);
+
+			complete(&xfer->complete);
+			list_del(&xfer->list);
+      
+			/*
+			 * It seems like ENDRX gets stuck if both buffers are
+			 * empty...
+			 */
+			/*if (list_empty(&host->xfers))
+				writel(AT91C_SPI_ENDRX, &(((AT91PS_SPI)host->regs)->SPI_IDR));*/
+      
+			host->dma_status++;
+			wake_up_interruptible(&host->dma_wait);
+      
+		} else if (xfer_desc->curr_xfer + 1 == xfer_desc->nr_xfers) {
+			xfer->next_rxbuf_phys = 0;
+			xfer->next_txbuf_phys = 0;
+			SPI_PUT_RNCR(host, 0);
+			SPI_PUT_TNCR(host, 0);
+		} else {
+			int xfer_index = xfer_desc->curr_xfer + 1;
+
+			xfer->next_rxbuf_phys = dma_map_single(&host->pdev->dev, xfer_desc->rx_xfer_units[xfer_index].buffer, xfer_desc->tx_xfer_units[xfer_index].buf_len, DMA_FROM_DEVICE);
+			if (!xfer->next_rxbuf_phys)
+				return IRQ_NONE;
+			xfer->next_txbuf_phys = dma_map_single(&host->pdev->dev, xfer_desc->tx_xfer_units[xfer_index].buffer, xfer_desc->tx_xfer_units[xfer_index].buf_len, DMA_TO_DEVICE);
+			if (!xfer->next_txbuf_phys) {
+				dma_unmap_single(&host->pdev->dev, xfer->next_rxbuf_phys, xfer_desc->rx_xfer_units[xfer_index].buf_len, DMA_FROM_DEVICE);
+				return IRQ_NONE;
+#ifdef DEBUG	
+				printk("xfer->next_rxbuf_phys : %x\txfer->next_txbuf_phys : %x\n", xfer->next_rxbuf_phys, xfer->next_txbuf_phys);
+#endif
+			}
+
+			SPI_PUT_RNPR(host, xfer->next_rxbuf_phys);
+			SPI_PUT_TNPR(host, xfer->next_txbuf_phys);
+			SPI_PUT_RNCR(host, xfer_desc->rx_xfer_units[xfer_index].buf_len);
+			SPI_PUT_TNCR(host, xfer_desc->tx_xfer_units[xfer_index].buf_len);
+		}
+	}
+
+	/*spin_unlock(&host->lock);*/
+
+	return IRQ_HANDLED;
+}
+
+/*static int at91_spi_master_xfer(struct spi_client *client, char *buf, int count)*/
+static int at91_spi_master_xfer(struct spi_client *client, struct spi_xfer_desc *xfer_desc)
+{
+	struct spi_adapter *adap = client->adapter;
+	struct at91_spi *host = adap_to_host(adap);
+	struct spi_xfer xfer;
+	int ret = 0;
+  
+	/*dev_dbg(&adap->dev, "SPI master xfer: %d bytes to addr %d\n",
+		 count, client->addr);*/
+  
+	BUG_ON(client->addr >= adap->max_num_slaves);
+  
+	if (!xfer_desc->nr_xfers)
+		return ret;
+
+	xfer.rxbuf_phys = dma_map_single(&host->pdev->dev, xfer_desc->rx_xfer_units[0].buffer, xfer_desc->rx_xfer_units[0].buf_len, DMA_FROM_DEVICE);
+	if (!xfer.rxbuf_phys)
+		return -ENOMEM;
+  
+	xfer.txbuf_phys = dma_map_single(&host->pdev->dev, xfer_desc->tx_xfer_units[0].buffer, xfer_desc->tx_xfer_units[0].buf_len, DMA_TO_DEVICE);
+	if (!xfer.txbuf_phys) {
+		dma_unmap_single(&host->pdev->dev, xfer.rxbuf_phys, xfer_desc->rx_xfer_units[0].buf_len, DMA_FROM_DEVICE);
+		return -ENOMEM;
+	}
+
+#ifdef DEBUG
+	printk("xfer.rxbuf_phys : %x\txfer.txbuf_phys : %x\n", xfer.rxbuf_phys, xfer.txbuf_phys);
+#endif
+ 
+	if (xfer_desc->nr_xfers > 1) {
+		xfer.next_rxbuf_phys = dma_map_single(&host->pdev->dev, xfer_desc->rx_xfer_units[1].buffer, xfer_desc->rx_xfer_units[1].buf_len, DMA_FROM_DEVICE);
+		if (!xfer.next_rxbuf_phys) {
+			dma_unmap_single(&host->pdev->dev, xfer.rxbuf_phys, xfer_desc->rx_xfer_units[0].buf_len, DMA_FROM_DEVICE);
+			dma_unmap_single(&host->pdev->dev, xfer.txbuf_phys, xfer_desc->tx_xfer_units[0].buf_len, DMA_TO_DEVICE);
+			return -ENOMEM;
+		}
+
+		xfer.next_txbuf_phys = dma_map_single(&host->pdev->dev, xfer_desc->tx_xfer_units[1].buffer, xfer_desc->tx_xfer_units[1].buf_len, DMA_TO_DEVICE);
+		if (!xfer.next_txbuf_phys) {
+			dma_unmap_single(&host->pdev->dev, xfer.rxbuf_phys, xfer_desc->rx_xfer_units[0].buf_len, DMA_FROM_DEVICE);
+			dma_unmap_single(&host->pdev->dev, xfer.txbuf_phys, xfer_desc->tx_xfer_units[0].buf_len, DMA_TO_DEVICE);
+			dma_unmap_single(&host->pdev->dev, xfer.next_rxbuf_phys, xfer_desc->rx_xfer_units[1].buf_len, DMA_FROM_DEVICE);
+			return -ENOMEM;
+		}
+#ifdef DEBUG
+		printk("xfer.next_rxbuf_phys : %x\txfer.next_txbuf_phys : %x\n", xfer.next_rxbuf_phys, xfer.next_txbuf_phys);
+#endif
+	}
+  
+	init_completion(&xfer.complete);
+  
+	/* The old critical section protection used to be here.*/
+	xfer_desc->curr_xfer = 0;
+	xfer.curr_xfer_desc = xfer_desc;
+	list_add_tail(&xfer.list, &host->xfers);
+
+	/* This a debug line.*/
+	at91_dump_buffers(xfer_desc);
+
+	SPI_PUT_RPR(host, xfer.rxbuf_phys);
+	SPI_PUT_TPR(host, xfer.txbuf_phys);
+	SPI_PUT_RCR(host, xfer_desc->rx_xfer_units[0].buf_len);
+	SPI_PUT_TCR(host, xfer_desc->tx_xfer_units[0].buf_len);
+
+#ifdef DEBUG
+	printk("host->regs->SPI_RPR : %x\thost->regs->SPI_TPR : %x\n", SPI_GET_RPR(host), SPI_GET_TPR(host));
+#endif
+	if (xfer_desc->nr_xfers > 1) {
+		SPI_PUT_RNPR(host, xfer.next_rxbuf_phys);
+		SPI_PUT_TNPR(host, xfer.next_txbuf_phys);
+		SPI_PUT_RNCR(host, xfer_desc->rx_xfer_units[1].buf_len);
+		SPI_PUT_TNCR(host, xfer_desc->tx_xfer_units[1].buf_len);
+#ifdef DEBUG
+		printk("host->regs->SPI_RNPR : %x\thost->regs->SPI_TNPR : %x\n", SPI_GET_RNPR(host), SPI_GET_TNPR(host));
+#endif
+	} else {
+		SPI_PUT_RNCR(host, 0);
+		SPI_PUT_TNCR(host, 0);
+	} 
+  
+	/*spin_unlock_irq(&host->lock);*/
+
+	SPI_PUT_PTCR(host, (AT91C_PDC_RXTEN | AT91C_PDC_TXTEN));
+	SPI_PUT_IER(host, AT91C_SPI_ENDRX);
+  
+	/* We should change completion by a timer to avoid deadlock if dataflash is present
+	   but doesn't answer.*/
+	wait_for_completion(&xfer.complete);
+
+	dev_dbg(&adap->dev, "SPI xfer complete, status: %08lx\n", (unsigned long)xfer.status_flags);
+  
+	return ret;
+}
+
+
+static int at91_spi_set_client_params(struct spi_client *client,
+				      struct spi_client_params *params)
+{
+	struct spi_adapter *adap = client->adapter;
+	struct at91_spi *host;
+	unsigned long long tmp;
+	u32 csr, scbr, dlybs, dlybct;
+	int N = 1;
+
+#ifdef DEBUG
+	printk("  Setting client params for slave addr %u:\n", client->addr);
+#endif
+
+	if (client->addr >= adap->max_num_slaves)
+		return -EINVAL;
+  
+	if (params->baud_rate == 0)
+		return -EINVAL;
+  
+	scbr = (AT91C_MASTER_CLOCK + params->baud_rate / 2) / params->baud_rate;
+
+	if (scbr > 255) {
+		scbr = ((AT91C_MASTER_CLOCK / 32) + (params->baud_rate / 2)) / params->baud_rate;
+		if (scbr > 255)
+			return -EINVAL;
+    
+		client->speed = LOW_SPEED;
+	} else
+		client->speed = HIGH_SPEED;
+  
+#ifdef DEBUG
+	printk("  baud rate  %u => scbr   %lu\n", params->baud_rate, (unsigned long)scbr);
+#endif
+
+	/* We are using a low speed device, Activating FDIV in mode register is necessary*/
+	if (client->speed == LOW_SPEED)
+		N = 32;
+
+	tmp = (AT91C_MASTER_CLOCK * (unsigned long long)params->sck_delay);
+	do_div(tmp, N);
+	tmp += 999999999ULL;
+	do_div(tmp, 1000000000);
+
+#ifdef DEBUG
+	printk("  sck_delay  %u => dlybs  %lu\n", params->sck_delay, (unsigned long)tmp);
+#endif
+
+	if (tmp > 255)
+		return -EINVAL;
+
+	dlybs = tmp;
+  
+	if (params->xfer_delay) {
+		tmp = (AT91C_MASTER_CLOCK * (unsigned long long)params->xfer_delay);
+		do_div(tmp, N);
+		tmp += 999999999ULL;
+		do_div(tmp, 1000000000);		
+		tmp += 31;
+		do_div(tmp,32);
+	} else
+		tmp = 0;
+#ifdef DEBUG
+	printk("  xfer_delay %u => dlybct %lu\n", params->xfer_delay, (unsigned long)tmp);
+#endif
+
+	if (tmp > 255)
+		return -EINVAL;
+	if (!tmp)
+		tmp++;
+
+	dlybct = tmp;
+  
+	dev_dbg(&adap->dev, "  bits_per_transfer: %d\n",
+	(int)params->bits_per_transfer);
+	dev_dbg(&adap->dev, "  clock_polarity: %d\n",
+	(int)params->clock_polarity);
+	dev_dbg(&adap->dev, "  clock_phase: %d\n",
+	(int)params->clock_phase);
+  
+	csr = (scbr << 8) | (dlybs << 16) | (dlybct << 24);
+	if (params->bits_per_transfer < 8 || params->bits_per_transfer > 16)
+		return -EINVAL;
+  
+	csr |= (params->bits_per_transfer - 8) << 4;
+	csr |= AT91C_SPI_CSAAT;
+	if (params->clock_polarity != SPI_CPOL_INACTIVE_LOW)
+		csr |= AT91C_SPI_CPOL;
+	if (params->clock_phase != SPI_CPHASE_SAMPLE_TRAILING)
+		csr |= AT91C_SPI_NCPHA;
+  
+	host = adap_to_host(adap);
+  
+	SPI_PUT_CSRx(host, client->addr, csr);
+  
+#ifdef DEBUG  
+	printk("csr[%d] : %x\n", client->addr, SPI_GET_CSRx(host, client->addr));
+#endif
+
+	client->params = *params;
+  
+	return 0;
+}
+
+static int at91_spi_set_adapter_mode(struct spi_client *client)
+{
+	struct spi_adapter *adap = client->adapter;
+	struct at91_spi *host = adap_to_host(adap);
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned int spi_mr, pcs;
+	int ret = 0;
+
+	if ((adap->max_num_slaves == 0) || (client->addr >= adap->max_num_slaves)
+					|| (client->addr < 0))
+		return -EINVAL;
+
+	pcs = 0x1 << client->addr;
+	pcs = ~(pcs << 16);
+
+	spi_mr = SPI_GET_MR(host) | AT91C_SPI_PCS;
+	spi_mr &= pcs;
+
+	/* If the device is low speed, activate FDIV in SPI mode register.*/
+	if (client->speed == LOW_SPEED)
+		spi_mr |= AT91C_SPI_FDIV;
+	else
+		spi_mr &= ~AT91C_SPI_FDIV;
+
+#ifdef DEBUG
+	printk("mr : %x\n", spi_mr);
+#endif
+
+	/* This a critical section. It should be protected during the whole 
+	   transfer.*/
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&host->dma_wait, &wait);
+	spin_lock_irq(&host->lock);
+	while (!host->dma_status) {
+		spin_unlock_irq(&host->lock);
+		schedule();
+		spin_lock_irq(&host->lock);
+		if (signal_pending(current)) {
+			ret = -ERESTARTSYS;
+			break;
+		}
+	}
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&host->dma_wait, &wait);
+  
+	if (ret) {
+		spin_unlock_irq(&host->lock);
+		return ret;
+	}
+  
+	/*
+	 * Ok, we have at least one DMA buffer ready. Write to
+	 * secondary buffer. If the primary buffer is available, the
+	 * PDC will automatically load it and zero out the secondary
+	 * buffer counters.
+	 */
+	host->dma_status--;
+  
+	spin_unlock_irq(&host->lock);
+
+	SPI_PUT_MR(host, spi_mr);
+
+	/* This added to patch SPI behavior due to an integration problem.
+	   This should be removed for coming versions of AT91SAM926X.*/
+	SPI_GET_RDR(host);
+
+#ifdef DEBUG
+	printk("mr : %x\n", SPI_GET_MR(host));
+#endif
+
+	return 0;
+}
+
+static void at91_spi_cfgpio_chipselect(struct spi_client *client) 
+{
+	struct spi_adapter *adap = client->adapter;
+	struct at91_spi *host = adap_to_host(adap);
+  
+	if (host->irq == AT91C_ID_SPI0) {
+		switch(client->addr) {
+			case 0:
+				AT91F_CfgPIO_SPI0_CS0();
+			break;
+			case 1:
+				AT91F_CfgPIO_SPI0_CS1();
+			break;
+			case 2:
+				AT91F_CfgPIO_SPI0_CS2();
+			break;
+			case 3:
+				AT91F_CfgPIO_SPI0_CS3();
+			break;
+			default :
+				AT91F_CfgPIO_SPI0_CS0();
+			break;
+		}
+	}
+  
+	if (host->irq == AT91C_ID_SPI1) {
+		switch(client->addr) {
+			case 0:
+				AT91F_CfgPIO_SPI1_CS0();
+			break;
+			case 1:
+				AT91F_CfgPIO_SPI1_CS1();
+			break;
+			case 2:
+				AT91F_CfgPIO_SPI1_CS2();
+			break;
+			case 3:
+				AT91F_CfgPIO_SPI1_CS3();
+			break;
+			default :
+				AT91F_CfgPIO_SPI1_CS0();
+			break;
+		}
+	}
+}
+
+
+/* Create at91_spi pointers for SPI0 and SPI1*/
+static struct at91_spi *at91_spi_ports[AT91C_NR_SPI];
+
+
+static int __devinit at91_spi_probe(struct device *_dev)
+{
+	struct platform_device *pdev = to_platform_device(_dev);
+	struct at91_spi *host;
+	struct spi_adapter *adap;
+	unsigned long default_mr; //default_csr;
+	int err = 0;
+  
+	if ((platform_num_resources(pdev) < 2)
+	    || !(platform_resource_flags(pdev, 0) & IORESOURCE_MEM)
+	    || !(platform_resource_flags(pdev, 1) & IORESOURCE_IRQ)) {
+		dev_err(_dev, "Cannot find necessary resources, aborting.\n");
+		return -ENODEV;
+	}
+  
+	at91_spi_ports[pdev->id] = (struct at91_spi *) kmalloc(sizeof(struct at91_spi), GFP_KERNEL);
+	if(!at91_spi_ports[pdev->id])
+		return -ENOMEM;
+	memset(at91_spi_ports[pdev->id], 0, sizeof(struct at91_spi));
+  
+	host = at91_spi_ports[pdev->id];
+	adap = &host->adapter;
+  
+	adap->owner = THIS_MODULE;
+	adap->max_num_slaves = NR_SPI_SLAVES;
+	adap->master_xfer = at91_spi_master_xfer;
+	adap->set_client_params = at91_spi_set_client_params;
+	adap->set_adapter_mode = at91_spi_set_adapter_mode;
+	adap->configure_chipselect_pio = at91_spi_cfgpio_chipselect;
+
+	spin_lock_init(&host->lock);
+	INIT_LIST_HEAD(&host->xfers);
+	host->pdev = pdev;
+
+	host->dma_status = MAX_SPI_XFERS;
+
+	init_waitqueue_head(&host->dma_wait);
+	host->irq = platform_resource_start(pdev, 1);
+	host->regs = ioremap(platform_resource_start(pdev, 0), platform_resource_len(pdev, 0));
+	if (!host->regs)
+		goto out_free_host;
+  
+	err = request_irq(host->irq, at91_spi_interrupt, 0, pdev->dev.bus_id, host);
+	if (err)
+		goto out_unmap;
+  
+	dev_info(&pdev->dev,"AT91 SPI Interface at 0x%08lx irq : %lu\n\r", platform_resource_start(pdev, 0),
+									   platform_resource_start(pdev, 1));
+	/* Configure PIOs for every port */
+        at91_device_pio_setup(pdev->dev.platform_data);
+  
+	/* Enable periph clock in PMC*/
+	at91_enable_periph_clock(host->irq);
+
+	SPI_PUT_CR(host, AT91C_SPI_SWRST);
+
+	default_mr = (AT91C_SPI_MSTR | AT91C_SPI_MODFDIS);
+	SPI_PUT_MR(host, default_mr);
+  
+	SPI_PUT_CR(host, AT91C_SPI_SPIEN);
+
+	/* This added to patch SPI behavior due to an integration problem.
+	   This should be removed for coming versions of AT91SAM926X.*/
+	SPI_GET_RDR(host);
+
+	dev_set_drvdata(_dev, host);
+  
+	err = spi_add_adapter(adap);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to register with the SPI core\n");
+		goto out_free_irq;
+	}
+  
+	return 0;
+  
+out_free_irq:
+	free_irq(host->irq, host);
+out_unmap:
+	iounmap(host->regs);
+out_free_host:
+	kfree(at91_spi_ports[pdev->id]);
+  
+	return err;
+}
+
+static int __devexit at91_spi_remove(struct device *_dev)
+{
+	struct at91_spi *host = dev_get_drvdata(_dev);
+  
+	spi_put_adapter(&host->adapter);
+
+	dev_set_drvdata(_dev, NULL);
+
+	/* Diable SPI*/
+	SPI_PUT_CR(host, AT91C_SPI_SPIDIS);
+
+	free_irq(host->irq, host);
+  
+	iounmap(host->regs);  
+
+	/* Disable periph clock in PMC*/
+	at91_disable_periph_clock(host->irq);
+
+	kfree(host);
+  
+	return 0;
+}
+
+static struct device_driver at91_spi_driver = {
+	.name		= "spi",
+	.bus		= &platform_bus_type,
+	.probe		= at91_spi_probe,
+	.remove		= __devexit_p(at91_spi_remove),
+};
+
+static int __init at91_spi_init(void)
+{
+	return driver_register(&at91_spi_driver);
+}
+
+static void __exit at91_spi_exit(void)
+{
+	driver_unregister(&at91_spi_driver);
+}
+
+module_init(at91_spi_init);
+module_exit(at91_spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Atmel Norway");
+MODULE_DESCRIPTION("Driver for Atmel SPI interfaces");
diff -Nur linux-2.6.15.4-orig/drivers/spi/busses/at91_spi.h linux-2.6.15.4/drivers/spi/busses/at91_spi.h
--- linux-2.6.15.4-orig/drivers/spi/busses/at91_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/busses/at91_spi.h	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,92 @@
+/*
+ * Driver for Atmel SPI Interfaces
+ *
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+#ifndef _AT91_SPI_H
+#define _AT91_SPI_H
+
+
+#define NR_SPI_SLAVES  	        4
+#define SPI_MAJOR	        153
+
+// Defines the number of atomic SPI senc/receive actions
+#define MAX_SPI_XFERS           1
+
+
+struct spi_xfer {
+	u32 status_flags;
+	struct spi_xfer_desc *curr_xfer_desc;
+	dma_addr_t rxbuf_phys, txbuf_phys;
+	dma_addr_t next_rxbuf_phys, next_txbuf_phys;
+	struct list_head list;
+	struct completion complete;
+};
+
+
+struct at91_spi {
+	spinlock_t		lock;
+	struct list_head	xfers;
+	struct spi_adapter	adapter;
+	void			*regs;
+	int			irq;
+	struct platform_device	*pdev;
+	int			dma_status;
+	wait_queue_head_t	dma_wait;
+};
+
+#define adap_to_host(a) container_of(a, struct at91_spi, adapter)
+
+/* SPI 0 Chip Select configurations */
+static inline void AT91F_CfgPIO_SPI0_CS0(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA,  3, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+static inline void AT91F_CfgPIO_SPI0_CS1(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA,  4, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+static inline void AT91F_CfgPIO_SPI0_CS2(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA, 28, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+static inline void AT91F_CfgPIO_SPI0_CS3(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA,  6, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+/* SPI 1 Chip Select configurations */
+static inline void AT91F_CfgPIO_SPI1_CS0(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOB, 28, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+static inline void AT91F_CfgPIO_SPI1_CS1(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOB, 27, PERIPH_A, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+static inline void AT91F_CfgPIO_SPI1_CS2(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA, 25, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+static inline void AT91F_CfgPIO_SPI1_CS3(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA, 26, PERIPH_B, NO_PULL_UP, NO_GLITCH_FLT);
+}
+
+#endif /* _AT91_SPI_H */
diff -Nur linux-2.6.15.4-orig/drivers/spi/busses/Kconfig linux-2.6.15.4/drivers/spi/busses/Kconfig
--- linux-2.6.15.4-orig/drivers/spi/busses/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/busses/Kconfig	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,18 @@
+#
+# SPI bus interface configuration
+#
+
+menu "SPI Hardware Bus support"
+
+config SPI_AT91
+	tristate "SAM926X familly (AT91SAM9261 and NADIA2) SPI"
+	depends on SPI
+	help
+	  If you say yes to this option, support will be included for the
+	  Atmel SPI interface present on many AVR32- and ARM-based parts
+	  from Atmel (i.e. the AT32 and AT91 series).
+
+	  This driver can also be built as a module. If so, the module
+	  will be called at91sam926x_spi.
+
+endmenu
diff -Nur linux-2.6.15.4-orig/drivers/spi/busses/Makefile linux-2.6.15.4/drivers/spi/busses/Makefile
--- linux-2.6.15.4-orig/drivers/spi/busses/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/busses/Makefile	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,9 @@
+#
+# Makefile for the SPI bus drivers.
+#
+
+obj-$(CONFIG_SPI_AT91)		+= at91sam926x_spi.o
+
+ifeq ($(CONFIG_SPI_DEBUG_BUS),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff -Nur linux-2.6.15.4-orig/drivers/spi/devices/at91_tsc_spi.c linux-2.6.15.4/drivers/spi/devices/at91_tsc_spi.c
--- linux-2.6.15.4-orig/drivers/spi/devices/at91_tsc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/devices/at91_tsc_spi.c	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,263 @@
+/*
+ * drivers/spi/devices/at91_tsc_spi.c
+ * Atmel Touchscreen driver for Atmel AT91SAM926X (Nadia X) familly.
+ * Added changes to make touchscreen driver work with the new linux 2.6 spi driver.
+ *
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France.
+ *
+ *
+ * Adapted from Atmel DataFlash driver for Atmel AT91RM9200 (Thunder)
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spi.h>
+
+#include <asm/sizes.h>
+
+#include <asm/arch/spi.h>
+
+#include "at91_tsc_spi.h"
+
+
+
+/* TODO : */
+// This structure is already declared in drivers/spi/busses/at91_spi.h
+// I added it here just to make it possible to get the SPI host and avoid 
+// checking dataflash devices on chip select that don't have one.
+// This should be removed as soon as we replace the completion mechanism
+// in drivers/spi/busses/at91sam9261_spi.c by a timer so we can't be deadlocked
+// if an interrupt doesn't come due to no response from dataflash chip.
+struct at91_spi {
+	spinlock_t		lock;
+	struct list_head	xfers;
+	struct spi_adapter	adapter;
+	void			*regs;
+	int			irq;
+	struct platform_device	*pdev;
+	int			dma_status;
+	wait_queue_head_t	dma_wait;
+};
+
+
+#define adap_to_host(a) container_of(a, struct at91_spi, adapter)
+
+// This holds the address of the structure embedding client
+static struct tsc_device *tsc_dev = NULL;
+
+/* End of TODO notice */
+/*--------------------------------------------------------------------*/
+
+
+/*
+ * Perform a basic SPI transfer using PDMA.
+ */
+static int do_tsc_spi_transfer(struct spi_client *cl, 
+			       char* tx, int tx_len, char* rx, int rx_len)
+{
+	struct spi_xfer_desc list;
+  
+	list.tx_xfer_units[0].buffer = tx;	list.tx_xfer_units[0].buf_len = tx_len;
+	list.rx_xfer_units[0].buffer = rx;	list.rx_xfer_units[0].buf_len = rx_len;
+  
+	list.tx_xfer_units[1].buffer = NULL;  list.tx_xfer_units[1].buf_len = 0;
+	list.rx_xfer_units[1].buffer = NULL;	list.rx_xfer_units[1].buf_len = 0;
+  
+	list.nr_xfers = 1;
+  
+	return spi_master_xfer(cl, &list);
+}
+
+
+/*
+ * Transfer a buffer through SPI
+ */
+static int at91_tsc_spi_transfer(char *buffer, int len)
+{
+	struct spi_client *client;
+	int ret = 0;
+
+	if (!tsc_dev)
+		return 1;
+
+	client = &tsc_dev->client;
+
+	// Set chip select in SPI mode register
+	if ((ret = spi_set_adapter_mode(client)))
+		 return ret;
+  
+	return do_tsc_spi_transfer(client, buffer, len, buffer, len);
+}
+
+
+/*
+ * Transfer one single byte through SPI, fulfills touch screen driver needs.
+ */
+unsigned long at91_tsc_spi_sendrecv(unsigned char data_byte)
+{
+	unsigned char *cmd = kmalloc(4*sizeof(char), GFP_KERNEL); 
+	unsigned long status;
+	int ret = 0;
+
+	memset(cmd, 0, 3*sizeof(char));
+
+	cmd[0] = data_byte;
+  
+	if ((ret = at91_tsc_spi_transfer(cmd, 3)))
+		return ret;
+
+	//status = *((unsigned long *)cmd);
+	status = (((unsigned int)cmd[1]) << 8) | ((unsigned int)cmd[2]);
+	status = status >> 3;
+
+	kfree(cmd);
+  
+	return status;
+}
+
+
+void at91_add_spi_device_features(struct spi_client_params *params, 
+				 unsigned int baud_rate, unsigned int dlybs, 
+				 unsigned int dlybct, unsigned char clock_phase,
+				 unsigned char clock_polarity, unsigned char bits_per_transfer)
+{
+	params->baud_rate = baud_rate;
+	params->sck_delay = dlybs;
+	params->xfer_delay = dlybct;
+	params->clock_phase = clock_phase;
+	params->clock_polarity = clock_polarity;
+	params->bits_per_transfer = bits_per_transfer; 
+}
+
+
+static struct spi_driver at91_tsc_spi_driver;
+
+/*
+ * Detect a touch screen controller on a chip select
+ */
+static int at91_tsc_spi_init(struct spi_adapter *adapter, int cs)
+{
+	struct spi_client *client;
+	struct spi_client_params params;
+	int ret;
+
+	tsc_dev = kmalloc(sizeof(*tsc_dev), GFP_KERNEL);
+	if (!tsc_dev)
+		goto out_put_adapter;
+  
+	memset(tsc_dev, 0, sizeof(*tsc_dev));
+
+	client = &tsc_dev->client;
+  
+	snprintf(client->name, SPI_NAME_SIZE, "Touch Screen");
+	client->id = cs;
+	client->addr = cs;
+	client->driver = &at91_tsc_spi_driver;
+	client->adapter = adapter;
+    
+	// Set chip select in SPI mode register
+	//ret = spi_set_adapter_chipselect(client);
+	//if (ret)
+	//  goto out_free_client;
+  
+	at91_add_spi_device_features(&params, AT91C_TSC_CLK, AT91C_TSC_DLYBS,
+					      AT91C_TSC_DLYBCT, SPI_CPHASE_SAMPLE_LEADING,
+					      SPI_CPOL_INACTIVE_LOW, AT91C_BITS_XFER);
+  
+	ret = spi_set_client_params(client, &params);
+	if (ret)
+		goto out_free_client;
+  
+	ret = spi_attach_client(client);
+	if (ret)
+		goto out_free_client;
+  
+	ret = spi_cfgpio_chipselect(client);
+	if (ret)
+		goto out_detach_client;
+  
+	dev_info(&adapter->dev, "%s SPI client driver Registred\n", client->name);
+	//printk("%s SPI client driver Registred\n", client->name);
+
+	return 0;
+  
+out_detach_client :
+	spi_detach_client(client);
+out_free_client :
+	kfree(tsc_dev);
+out_put_adapter :
+	spi_put_adapter(adapter);
+
+	return 1;
+}
+
+static int at91_tsc_attach_adapter(struct spi_adapter *adapter)
+{
+	int ret = 1;
+	struct at91_spi *host = adap_to_host(adapter);
+  
+	if (host->irq == AT91C_ID_SPI1)
+		return ret;
+  
+	// Detect touch screen controller on chip select 2 of SPI0
+	ret *= at91_tsc_spi_init(adapter, 2);
+
+	if (ret)
+		dev_err(&adapter->dev, "No touch screen controller detected\n");
+  
+	return ret;
+}
+
+static int at91_tsc_detach_adapter(struct spi_adapter *adapter)
+{
+	struct spi_client *client = &tsc_dev->client;
+  
+	spi_detach_client(client);
+	kfree(tsc_dev);
+  
+	return 0;
+}
+
+static struct spi_driver at91_tsc_spi_driver = {
+	.owner		= THIS_MODULE,
+	.name	        = "at91_tsc_spi_driver",
+	.attach_adapter	= at91_tsc_attach_adapter,
+	.detach_adapter = at91_tsc_detach_adapter,
+};
+
+static int __init at91_tsc_init(void)
+{
+	int ret;
+  
+	ret = spi_add_driver(&at91_tsc_spi_driver);
+	if (ret)
+		goto out;
+  
+	return 0;
+  
+out:
+	printk(KERN_ERR "%s: Driver initialization failed", __FILE__);
+	return ret;
+}
+
+
+static void __exit at91_tsc_exit(void)
+{
+	spi_remove_driver(&at91_tsc_spi_driver);
+}
+
+module_init(at91_tsc_init);
+module_exit(at91_tsc_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("M. Amine SAYA")
+MODULE_DESCRIPTION("Basic function driver for Atmel AT91SAM9261EK ADS7843E touchscreen controller")
diff -Nur linux-2.6.15.4-orig/drivers/spi/devices/at91_tsc_spi.h linux-2.6.15.4/drivers/spi/devices/at91_tsc_spi.h
--- linux-2.6.15.4-orig/drivers/spi/devices/at91_tsc_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/devices/at91_tsc_spi.h	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * drivers/spi/devices/at91_tsc_spi.h
+ *
+ * Definitions for ADS7843E touch screen. 
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France.
+ *
+ */
+
+#ifndef _AT91_TSC_SPI_H
+#define _AT91_TSC_SPI_H
+
+
+// Dataflash number of bits per transfers
+#define AT91C_BITS_XFER         8
+
+// Dataflash Clocks
+#define AT91C_TSC_CLK	        920000        // ADS7843E maximun conversion rate (clock)
+
+
+// Dataflash Timmings in nanoseconds
+#define AT91C_TSC_DLYBS   100
+#define AT91C_TSC_DLYBCT  200
+
+// Max dataflash name length
+#define MAX_TSC_NAME      20
+
+
+struct tsc_device {
+  struct spi_client client;
+  struct class_device class_dev;
+  struct completion released;
+};
+
+
+#define client_to_tsc(a) container_of(a, struct tsc_device, client)
+
+
+#endif  /* _AT91_TSC_SPI_H */
diff -Nur linux-2.6.15.4-orig/drivers/spi/devices/Kconfig linux-2.6.15.4/drivers/spi/devices/Kconfig
--- linux-2.6.15.4-orig/drivers/spi/devices/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/devices/Kconfig	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,23 @@
+#
+# SPI device interface configuration
+#
+
+menu "SPI Hardware device support"
+
+config TSC_SPI_AT91
+	tristate "AT91SAM9261 Touch Screen Controller generic driver"
+	depends on SPI_AT91
+	help
+	  If you say yes to this option, support will be included for the
+	  touch screen controller connected on AT91SAM9261 SPI.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called at91_tsc_spi.
+
+config TSC_SPI_DEBUG
+	tristate "AT91SAM9261 Touch Screen Controller debug"
+	depends on TSC_SPI_AT91
+	help
+	  This enables debug mode for this driver
+	
+endmenu
diff -Nur linux-2.6.15.4-orig/drivers/spi/devices/Makefile linux-2.6.15.4/drivers/spi/devices/Makefile
--- linux-2.6.15.4-orig/drivers/spi/devices/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/devices/Makefile	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,9 @@
+#
+# Makefile for the SPI device drivers.
+#
+
+obj-$(CONFIG_TSC_SPI_AT91)	+= at91_tsc_spi.o
+
+ifeq ($(CONFIG_TSC_SPI_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff -Nur linux-2.6.15.4-orig/drivers/spi/Kconfig linux-2.6.15.4/drivers/spi/Kconfig
--- linux-2.6.15.4-orig/drivers/spi/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/Kconfig	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,39 @@
+#
+# Serial Peripheral Interface
+#
+
+menu "SPI support"
+
+config SPI
+	tristate "SPI support"
+	help
+	  SPI (Serial Peripheral Interface) is a full-duplex serial
+	  bus protocol used in many microcontroller applications.
+
+	  If you want SPI support, you should say Y here and also to
+	  the specific driver for your bus adapter(s) below.
+
+	  SPI support can also be built as a module. If so, the module
+	  will be called spi-core.
+
+source "drivers/spi/busses/Kconfig"
+source "drivers/spi/devices/Kconfig"
+
+config SPI_DEBUG_CORE
+	bool "SPI Core debugging messages"
+	depends on SPI
+	help
+	  Say Y here if you want the SPI core to produce a bunch of debug
+	  messages to the system log. Select this if you are having a problem
+	  with SPI support and want to see more of what is going on.
+
+config SPI_DEBUG_BUS
+	bool "SPI Bus debugging messages"
+	depends on SPI
+	help
+	  Say Y here if you want the SPI bus drivers to produce a bunch of
+	  debug messages to the system log. Select this if you are having
+	  a problem with SPI support and want to see more of what is going
+	  on.
+
+endmenu
diff -Nur linux-2.6.15.4-orig/drivers/spi/Makefile linux-2.6.15.4/drivers/spi/Makefile
--- linux-2.6.15.4-orig/drivers/spi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/Makefile	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,10 @@
+#
+# Makefile for the SPI core.
+#
+
+obj-$(CONFIG_SPI)		+= spi-core.o
+obj-y				+= busses/ devices/
+
+ifeq ($(CONFIG_SPI_DEBUG_CORE),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff -Nur linux-2.6.15.4-orig/drivers/spi/spi-core.c linux-2.6.15.4/drivers/spi/spi-core.c
--- linux-2.6.15.4-orig/drivers/spi/spi-core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/spi/spi-core.c	2006-08-09 10:45:35.000000000 +0200
@@ -0,0 +1,359 @@
+/*
+ * Driver for the SPI bus interface. Inspired by the Linux i2c layer.
+ *
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/idr.h>
+#include <linux/spi.h>
+
+static LIST_HEAD(adapters);
+static LIST_HEAD(drivers);
+static DECLARE_MUTEX(core_lists);
+static DEFINE_IDR(spi_adapter_idr);
+
+static int spi_device_probe(struct device *dev)
+{
+	return -ENODEV;
+}
+
+static int spi_device_remove(struct device *dev)
+{
+	return 0;
+}
+
+static struct device_driver spi_adapter_driver = {
+	.name		= "spi_adapter",
+	.bus		= &spi_bus_type,
+	.probe		= spi_device_probe,
+	.remove		= spi_device_remove,
+};
+
+static void spi_adapter_dev_release(struct device *dev)
+{
+	struct spi_adapter *adap = dev_to_spi_adapter(dev);
+	complete(&adap->dev_released);
+}
+
+static void spi_adapter_class_dev_release(struct class_device *dev)
+{
+	struct spi_adapter *adap = class_dev_to_spi_adapter(dev);
+	complete(&adap->class_dev_released);
+}
+
+static struct class spi_adapter_class = {
+	.name		= "spi-adapter",
+	.release	= spi_adapter_class_dev_release,
+};
+
+static ssize_t show_adapter_name(struct device *dev, char *buf)
+{
+	struct spi_adapter *adap = dev_to_spi_adapter(dev);
+	return sprintf(buf, "%s\n", adap->name);
+}
+static DEVICE_ATTR(name, S_IRUGO, show_adapter_name, NULL);
+
+static void spi_client_release(struct device *dev)
+{
+	struct spi_client *client = to_spi_client(dev);
+	complete(&client->released);
+}
+
+/* ---- Registration ---- */
+
+int spi_add_adapter(struct spi_adapter *adap)
+{
+	int id, err;
+	struct spi_driver *driver;
+
+	down(&core_lists);
+
+	err = -ENOMEM;
+	if (idr_pre_get(&spi_adapter_idr, GFP_KERNEL) == 0)
+		goto out_unlock;
+
+	err = idr_get_new(&spi_adapter_idr, NULL, &id);
+	if (err) {
+		if (err == -EAGAIN)
+			err = -ENOMEM;
+		goto out_unlock;
+	}
+
+	adap->nr = id & MAX_ID_MASK;
+	list_add_tail(&adap->list, &adapters);
+	INIT_LIST_HEAD(&adap->clients);
+	init_MUTEX(&adap->clist_lock);
+
+	/*
+	 * Add the adapter to the driver core.
+	 */
+	if (!adap->dev.parent)
+		adap->dev.parent = &platform_bus;
+	sprintf(adap->dev.bus_id, "spi-%d", adap->nr);
+	adap->dev.driver = &spi_adapter_driver;
+	adap->dev.release = &spi_adapter_dev_release;
+	device_register(&adap->dev);
+	device_create_file(&adap->dev, &dev_attr_name);
+
+	/* Add this adapter to the spi_adapter class */
+	memset(&adap->class_dev, 0, sizeof(adap->class_dev));
+	adap->class_dev.dev = &adap->dev;
+	adap->class_dev.class = &spi_adapter_class;
+	strlcpy(adap->class_dev.class_id, adap->dev.bus_id, BUS_ID_SIZE);
+	class_device_register(&adap->class_dev);
+
+	/* Inform drivers of the new adapter */
+	list_for_each_entry(driver, &drivers, list)
+		driver->attach_adapter(adap);
+
+	dev_dbg(&adap->dev, "registered as adapter #%d\n", adap->nr);
+
+out_unlock:
+	up(&core_lists);
+	return err;
+}
+
+int spi_add_driver(struct spi_driver *driver)
+{
+	struct spi_adapter *adapter;
+	int err;
+
+	down(&core_lists);
+
+	/* Add the driver to the list of SPI drivers in the driver core */
+	driver->driver.name = driver->name;
+	driver->driver.bus = &spi_bus_type;
+	driver->driver.probe = spi_device_probe;
+	driver->driver.remove = spi_device_remove;
+
+	err = driver_register(&driver->driver);
+	if (err)
+		goto out_unlock;
+
+	list_add_tail(&driver->list, &drivers);
+	pr_debug("spi-core: driver %s registered.\n", driver->name);
+
+	/* Now look for instances of driver on our adapters */
+	list_for_each_entry(adapter, &adapters, list)
+		driver->attach_adapter(adapter);
+
+out_unlock:
+	up(&core_lists);
+	return err;
+}
+
+
+void spi_remove_driver(struct spi_driver *driver)
+{
+        struct spi_adapter *adapter;
+
+	down(&core_lists);
+
+	/* Now look for instances of driver on our adapters */
+	list_for_each_entry(adapter, &adapters, list)
+	  driver->detach_adapter(adapter);
+	
+	list_del(&driver->list);
+	
+	driver_unregister(&driver->driver);
+	
+	driver->driver.bus = NULL;
+	driver->driver.probe = NULL;
+	driver->driver.remove = NULL;
+	
+	up(&core_lists);
+}
+
+
+static int __spi_check_addr(struct spi_adapter *adap, unsigned int addr)
+{
+	struct spi_client *client;
+
+	list_for_each_entry(client, &adap->clients, list) {
+		if (client->addr == addr)
+			return -EBUSY;
+	}
+	return 0;
+}
+
+int spi_attach_client(struct spi_client *client)
+{
+	struct spi_adapter *adapter = client->adapter;
+
+	down(&adapter->clist_lock);
+	if (__spi_check_addr(adapter, client->addr)) {
+		up(&adapter->clist_lock);
+		return -EBUSY;
+	}
+	list_add_tail(&client->list, &adapter->clients);
+	up(&adapter->clist_lock);
+
+	dev_dbg(&adapter->dev, "client [%s] attached to adapter\n",
+		client->name);
+
+	client->dev.parent = &adapter->dev;
+	client->dev.driver = &client->driver->driver;
+	client->dev.bus = &spi_bus_type;
+	client->dev.release = &spi_client_release;
+
+	snprintf(client->dev.bus_id, sizeof(client->dev.bus_id),
+		 "%d-%04x", adapter->nr, client->addr);
+	device_register(&client->dev);
+	/* device_create_file(&client->dev, &dev_attr_client_name); */
+
+	return 0;
+}
+
+int spi_detach_client(struct spi_client *client)
+{
+	struct spi_adapter *adap = client->adapter;
+
+	down(&adap->clist_lock);
+	list_del(&client->list);
+	init_completion(&client->released);
+	/* device_remove_file(&client->dev, &dev_attr_client_name); */
+	device_unregister(&client->dev);
+	up(&adap->clist_lock);
+	wait_for_completion(&client->released);
+
+	return 0;
+}
+
+struct spi_adapter *spi_get_adapter(struct spi_adapter *adap)
+{
+	if (try_module_get(adap->owner))
+		return adap;
+	return NULL;
+}
+
+void spi_put_adapter(struct spi_adapter *adap)
+{
+	module_put(adap->owner);
+}
+
+/* ---- Functional interface ---- */
+
+//int spi_master_xfer(struct spi_client *client, char *buf, int count)
+int spi_master_xfer(struct spi_client *client, struct spi_xfer_desc *xfer_desc)
+{
+	struct spi_adapter *adap = client->adapter;
+	int err;
+
+	BUG_ON(!adap->master_xfer);
+
+	dev_dbg(&adap->dev, "master_xfer: %d xfers to client %s\n",
+		xfer_desc->nr_xfers, client->name);
+
+	//err = adap->master_xfer(client, buf, count);
+	err = adap->master_xfer(client, xfer_desc);
+	return err;
+}
+
+int spi_set_client_params(struct spi_client *client,
+			  struct spi_client_params *params)
+{
+	int ret = -EINVAL;
+
+	if (client->adapter->set_client_params)
+		ret = client->adapter->set_client_params(client, params);
+	return ret;
+}
+
+int spi_set_adapter_params(struct spi_adapter *adap,
+			   struct spi_adapter_params *params)
+{
+	int ret = -EINVAL;
+
+	if (adap->set_adapter_params)
+		ret = adap->set_adapter_params(adap, params);
+	return ret;
+}
+
+
+int spi_set_adapter_mode(struct spi_client *client)
+{
+	int ret = -EINVAL;
+  
+	if (client->adapter->set_adapter_mode)
+		ret = client->adapter->set_adapter_mode(client);
+
+	return ret;
+}
+
+
+int spi_cfgpio_chipselect(struct spi_client *client)
+{
+	int ret = -EINVAL;
+
+	if (client->adapter->configure_chipselect_pio) {
+		client->adapter->configure_chipselect_pio(client);
+		ret = 0;
+	}
+  
+	return ret;
+}
+
+
+/* ---- Driver core initialization ---- */
+
+static int spi_device_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+struct bus_type spi_bus_type = {
+	.name		= "spi",
+	.match		= spi_device_match,
+};
+
+static int __init spi_init(void)
+{
+	int retval;
+
+	retval = bus_register(&spi_bus_type);
+	if (retval)
+		return retval;
+	retval = driver_register(&spi_adapter_driver);
+	if (retval)
+		return retval;
+	return class_register(&spi_adapter_class);
+}
+
+static void __exit spi_exit(void)
+{
+	class_unregister(&spi_adapter_class);
+	driver_unregister(&spi_adapter_driver);
+	bus_unregister(&spi_bus_type);
+}
+
+subsys_initcall(spi_init);
+module_exit(spi_exit);
+
+EXPORT_SYMBOL(spi_add_adapter);
+EXPORT_SYMBOL(spi_add_driver);
+
+MODULE_AUTHOR("Atmel Norway");
+MODULE_DESCRIPTION("SPI Bus driver core");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.15.4-orig/drivers/usb/gadget/at91_udc.c linux-2.6.15.4/drivers/usb/gadget/at91_udc.c
--- linux-2.6.15.4-orig/drivers/usb/gadget/at91_udc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/gadget/at91_udc.c	2006-08-10 11:39:10.000000000 +0200
@@ -0,0 +1,1798 @@
+/*
+ * at91_udc -- driver for at91-series USB peripheral controller
+ *
+ * Copyright (C) 2004 by Thomas Rathbone
+ * Copyright (C) 2005 by HP Labs
+ * Copyright (C) 2005 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA  02111-1307, USA.
+ */
+
+#undef	DEBUG
+#undef	VERBOSE
+#undef	PACKET_TRACE
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/sysrq.h>
+#include <linux/proc_fs.h>
+#include <asm/hardware/clock.h>
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+#include <linux/dma-mapping.h>
+#include <asm/sizes.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/system.h>
+#include <asm/arch/pmc.h>
+
+#include "at91_udc.h"
+
+extern int at91_get_gpio_value(unsigned pin);
+extern int at91_set_gpio_value(unsigned pin, int value);
+
+/*
+ * This controller is simple and PIO-only.  It's used in many AT91-series
+ * ARMv4T controllers, including the at91rm9200 (arm920T, with MMU) and
+ * several no-mmu versions.
+ *
+ * This driver expects the board has been wired with two GPIOs suppporting
+ * a VBUS sensing IRQ, and a D+ pullup.  (They may be omitted, but the
+ * testing hasn't covered such cases.)  The pullup is most important; it
+ * provides software control over whether the host enumerates the device.
+ * The VBUS sensing helps during enumeration, and allows both USB clocks
+ * (and the transceiver) to stay gated off until they're necessary, saving
+ * power.  During USB suspend, the 48 MHz clock is gated off.
+ */
+#define	DRIVER_VERSION	"8 March 2005"
+
+static const char driver_name [] = "at91_udc";
+static const char ep0name[] = "ep0";
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Read from a UDP register.
+ */
+static inline unsigned long at91_udp_read(unsigned int reg)
+{
+	void __iomem *udp_base = (void __iomem *)AT91C_VA_BASE_UDP;
+	
+	return __raw_readl(udp_base + reg);
+}
+
+/*
+ * Write to a UDP register.
+ */
+static inline void at91_udp_write(unsigned int reg, unsigned long value)
+{
+	void __iomem *udp_base = (void __iomem *)AT91C_VA_BASE_UDP;
+
+	__raw_writel(value, udp_base + reg);
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char debug_filename[] = "driver/udc";
+
+#define FOURBITS "%s%s%s%s"
+#define EIGHTBITS FOURBITS FOURBITS
+
+static void proc_ep_show(struct seq_file *s, struct at91_ep *ep)
+{
+	static char		*types[] = {
+		"control", "out-iso", "out-bulk", "out-int",
+		"BOGUS",   "in-iso",  "in-bulk",  "in-int"};
+
+	u32			csr;
+	struct at91_request	*req;
+	unsigned long	flags;
+
+	local_irq_save(flags);
+
+	csr = __raw_readl(ep->creg);
+
+	/* NOTE:  not collecting per-endpoint irq statistics... */
+
+	seq_printf(s, "\n");
+	seq_printf(s, "%s, maxpacket %d %s%s %s%s\n",
+			ep->ep.name, ep->ep.maxpacket,
+			ep->is_in ? "in" : "out",
+			ep->is_iso ? " iso" : "",
+			ep->is_pingpong
+				? (ep->fifo_bank ? "pong" : "ping")
+				: "",
+			ep->stopped ? " stopped" : "");
+	seq_printf(s, "csr %08x rxbytes=%d %s %s %s" EIGHTBITS "\n",
+		csr,
+		(csr & 0x07ff0000) >> 16,
+		(csr & (1 << 15)) ? "enabled" : "disabled",
+		(csr & (1 << 11)) ? "DATA1" : "DATA0",
+		types[(csr & 0x700) >> 8],
+
+		/* iff type is control then print current direction */
+		(!(csr & 0x700))
+			? ((csr & (1 << 7)) ? " IN" : " OUT")
+			: "",
+		(csr & (1 << 6)) ? " rxdatabk1" : "",
+		(csr & (1 << 5)) ? " forcestall" : "",
+		(csr & (1 << 4)) ? " txpktrdy" : "",
+
+		(csr & (1 << 3)) ? " stallsent" : "",
+		(csr & (1 << 2)) ? " rxsetup" : "",
+		(csr & (1 << 1)) ? " rxdatabk0" : "",
+		(csr & (1 << 0)) ? " txcomp" : "");
+	if (list_empty (&ep->queue))
+		seq_printf(s, "\t(queue empty)\n");
+
+	else list_for_each_entry (req, &ep->queue, queue) {
+		unsigned	length = req->req.actual;
+
+		seq_printf(s, "\treq %p len %d/%d buf %p\n",
+				&req->req, length,
+				req->req.length, req->req.buf);
+	}
+	local_irq_restore(flags);
+}
+
+static void proc_irq_show(struct seq_file *s, const char *label, u32 mask)
+{
+	int i;
+
+	seq_printf(s, "%s %04x:%s%s" FOURBITS, label, mask,
+		(mask & (1 << 13)) ? " wakeup" : "",
+		(mask & (1 << 12)) ? " endbusres" : "",
+
+		(mask & (1 << 11)) ? " sofint" : "",
+		(mask & (1 << 10)) ? " extrsm" : "",
+		(mask & (1 << 9)) ? " rxrsm" : "",
+		(mask & (1 << 8)) ? " rxsusp" : "");
+	for (i = 0; i < 8; i++) {
+		if (mask & (1 << i))
+			seq_printf(s, " ep%d", i);
+	}
+	seq_printf(s, "\n");
+}
+
+static int proc_udc_show(struct seq_file *s, void *unused)
+{
+	struct at91_udc	*udc = s->private;
+	struct at91_ep	*ep;
+	u32		tmp;
+
+	seq_printf(s, "%s: version %s\n", driver_name, DRIVER_VERSION);
+
+	seq_printf(s, "vbus %s, pullup %s, %s powered%s, gadget %s\n\n",
+		udc->vbus ? "present" : "off",
+		udc->enabled
+			? (udc->vbus ? "active" : "enabled")
+			: "disabled",
+		udc->selfpowered ? "self" : "VBUS",
+		udc->suspended ? ", suspended" : "",
+		udc->driver ? udc->driver->driver.name : "(none)");
+
+	/* don't access registers when interface isn't clocked */
+	if (!udc->clocked) {
+		seq_printf(s, "(not clocked)\n");
+		return 0;
+	}
+
+	tmp = at91_udp_read(AT91_UDP_FRM_NUM);
+	seq_printf(s, "frame %05x:%s%s frame=%d\n", tmp,
+		(tmp & AT91_UDP_FRM_OK) ? " ok" : "",
+		(tmp & AT91_UDP_FRM_ERR) ? " err" : "",
+		(tmp & AT91_UDP_NUM));
+
+	tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+	seq_printf(s, "glbstate %02x:%s" FOURBITS "\n", tmp,
+		(tmp & AT91_UDP_RMWUPE) ? " rmwupe" : "",
+		(tmp & AT91_UDP_RSMINPR) ? " rsminpr" : "",
+		(tmp & AT91_UDP_ESR) ? " esr" : "",
+		(tmp & AT91_UDP_CONFG) ? " confg" : "",
+		(tmp & AT91_UDP_FADDEN) ? " fadden" : "");
+
+	tmp = at91_udp_read(AT91_UDP_FADDR);
+	seq_printf(s, "faddr   %03x:%s fadd=%d\n", tmp,
+		(tmp & AT91_UDP_FEN) ? " fen" : "",
+		(tmp & AT91_UDP_FADD));
+
+	proc_irq_show(s, "imr   ", at91_udp_read(AT91_UDP_IMR));
+	proc_irq_show(s, "isr   ", at91_udp_read(AT91_UDP_ISR));
+
+	if (udc->enabled && udc->vbus) {
+		proc_ep_show(s, &udc->ep[0]);
+		list_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {
+			if (ep->desc)
+				proc_ep_show(s, ep);
+		}
+	}
+	return 0;
+}
+
+static int proc_udc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_udc_show, PDE(inode)->data);
+}
+
+static struct file_operations proc_ops = {
+	.open		= proc_udc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void create_debug_file(struct at91_udc *udc)
+{
+	struct proc_dir_entry *pde;
+
+	pde = create_proc_entry (debug_filename, 0, NULL);
+	udc->pde = pde;
+	if (pde == NULL)
+		return;
+
+	pde->proc_fops = &proc_ops;
+	pde->data = udc;
+}
+
+static void remove_debug_file(struct at91_udc *udc)
+{
+	if (udc->pde)
+		remove_proc_entry(debug_filename, NULL);
+}
+
+#else
+
+static inline void create_debug_file(struct at91_udc *udc) {}
+static inline void remove_debug_file(struct at91_udc *udc) {}
+
+#endif
+
+
+/*-------------------------------------------------------------------------*/
+
+static void done(struct at91_ep *ep, struct at91_request *req, int status)
+{
+	unsigned	stopped = ep->stopped;
+
+	list_del_init(&req->queue);
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+	if (status && status != -ESHUTDOWN)
+		VDBG("%s done %p, status %d\n", ep->ep.name, req, status);
+
+	ep->stopped = 1;
+	req->req.complete(&ep->ep, &req->req);
+	ep->stopped = stopped;
+
+	/* ep0 is always ready; other endpoints need a non-empty queue */
+	if (list_empty(&ep->queue) && ep->int_mask != (1 << 0))
+		at91_udp_write(AT91_UDP_IDR, ep->int_mask);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* bits indicating OUT fifo has data ready */
+#define	RX_DATA_READY	(AT91_UDP_RX_DATA_BK0 | AT91_UDP_RX_DATA_BK1)
+
+/*
+ * Endpoint FIFO CSR bits have a mix of bits, making it unsafe to just write
+ * back most of the value you just read (because of side effects, including
+ * bits that may change after reading and before writing).
+ *
+ * Except when changing a specific bit, always write values which:
+ *  - clear SET_FX bits (setting them could change something)
+ *  - set CLR_FX bits (clearing them could change something)
+ *
+ * There are also state bits like FORCESTALL, EPEDS, DIR, and EPTYPE
+ * that shouldn't normally be changed.
+ */
+#define	SET_FX	(AT91_UDP_TXPKTRDY)
+#define	CLR_FX	(RX_DATA_READY | AT91_UDP_RXSETUP | AT91_UDP_STALLSENT | AT91_UDP_TXCOMP)
+
+/* pull OUT packet data from the endpoint's fifo */
+static int read_fifo (struct at91_ep *ep, struct at91_request *req)
+{
+	u32 __iomem	*creg = ep->creg;
+	u8 __iomem	*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));
+	u32		csr;
+	u8		*buf;
+	unsigned int	count, bufferspace, is_done;
+
+	buf = req->req.buf + req->req.actual;
+	bufferspace = req->req.length - req->req.actual;
+
+	/*
+	 * there might be nothing to read if ep_queue() calls us,
+	 * or if we already emptied both pingpong buffers
+	 */
+rescan:
+	csr = __raw_readl(creg);
+	if ((csr & RX_DATA_READY) == 0)
+		return 0;
+
+	count = (csr & AT91_UDP_RXBYTECNT) >> 16;
+	if (count > ep->ep.maxpacket)
+		count = ep->ep.maxpacket;
+	if (count > bufferspace) {
+		DBG("%s buffer overflow\n", ep->ep.name);
+		req->req.status = -EOVERFLOW;
+		count = bufferspace;
+	}
+	__raw_readsb(dreg, buf, count);
+
+	/* release and swap pingpong mem bank */
+	csr |= CLR_FX;
+	if (ep->is_pingpong) {
+		if (ep->fifo_bank == 0) {
+			csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);
+			ep->fifo_bank = 1;
+		} else {
+			csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK1);
+			ep->fifo_bank = 0;
+		}
+	} else
+		csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);
+	__raw_writel(csr, creg);
+
+	req->req.actual += count;
+	is_done = (count < ep->ep.maxpacket);
+	if (count == bufferspace)
+		is_done = 1;
+
+	PACKET("%s %p out/%d%s\n", ep->ep.name, &req->req, count,
+			is_done ? " (done)" : "");
+
+	/*
+	 * avoid extra trips through IRQ logic for packets already in
+	 * the fifo ... maybe preventing an extra (expensive) OUT-NAK
+	 */
+	if (is_done)
+		done(ep, req, 0);
+	else if (ep->is_pingpong) {
+		bufferspace -= count;
+		buf += count;
+		goto rescan;
+	}
+
+	return is_done;
+}
+
+/* load fifo for an IN packet */
+static int write_fifo(struct at91_ep *ep, struct at91_request *req)
+{
+	u32 __iomem	*creg = ep->creg;
+	u32		csr = __raw_readl(creg);
+	u8 __iomem	*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));
+	unsigned	total, count, is_last;
+
+	/*
+	 * TODO: allow for writing two packets to the fifo ... that'll
+	 * reduce the amount of IN-NAKing, but probably won't affect
+	 * throughput much.  (Unlike preventing OUT-NAKing!)
+	 */
+
+	/*
+	 * If ep_queue() calls us, the queue is empty and possibly in
+	 * odd states like TXCOMP not yet cleared (we do it, saving at
+	 * least one IRQ) or the fifo not yet being free.  Those aren't
+	 * issues normally (IRQ handler fast path).
+	 */
+	if (unlikely(csr & (AT91_UDP_TXCOMP | AT91_UDP_TXPKTRDY))) {
+		if (csr & AT91_UDP_TXCOMP) {
+			csr |= CLR_FX;
+			csr &= ~(SET_FX | AT91_UDP_TXCOMP);
+			__raw_writel(csr, creg);
+			csr = __raw_readl(creg);
+		}
+		if (csr & AT91_UDP_TXPKTRDY)
+			return 0;
+	}
+
+	total = req->req.length - req->req.actual;
+	if (ep->ep.maxpacket < total) {
+		count = ep->ep.maxpacket;
+		is_last = 0;
+	} else {
+		count = total;
+		is_last = (count < ep->ep.maxpacket) || !req->req.zero;
+	}
+
+	/*
+	 * Write the packet, maybe it's a ZLP.
+	 *
+	 * NOTE:  incrementing req->actual before we receive the ACK means
+	 * gadget driver IN bytecounts can be wrong in fault cases.  That's
+	 * fixable with PIO drivers like this one (save "count" here, and
+	 * do the increment later on TX irq), but not for most DMA hardware.
+	 *
+	 * So all gadget drivers must accept that potential error.  Some
+	 * hardware supports precise fifo status reporting, letting them
+	 * recover when the actual bytecount matters (e.g. for USB Test
+	 * and Measurement Class devices).
+	 */
+	__raw_writesb(dreg, req->req.buf + req->req.actual, count);
+	csr &= ~SET_FX;
+	csr |= CLR_FX | AT91_UDP_TXPKTRDY;
+	__raw_writel(csr, creg);
+	req->req.actual += count;
+
+	PACKET("%s %p in/%d%s\n", ep->ep.name, &req->req, count,
+			is_last ? " (done)" : "");
+	if (is_last)
+		done(ep, req, 0);
+	return is_last;
+}
+
+static void nuke(struct at91_ep *ep, int status)
+{
+	struct at91_request *req;
+
+	// terminer chaque requete dans la queue
+	ep->stopped = 1;
+	if (list_empty(&ep->queue))
+		return;
+
+	VDBG("%s %s\n", __FUNCTION__, ep->ep.name);
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct at91_request, queue);
+		done(ep, req, status);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int at91_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+{
+	struct at91_ep	*ep = container_of(_ep, struct at91_ep, ep);
+	struct at91_udc	*dev = ep->udc;
+	u16		maxpacket;
+	u32		tmp;
+	unsigned long	flags;
+
+	if (!_ep || !ep
+			|| !desc || ep->desc
+			|| _ep->name == ep0name
+			|| desc->bDescriptorType != USB_DT_ENDPOINT
+			|| (maxpacket = le16_to_cpu(desc->wMaxPacketSize)) == 0
+			|| maxpacket > ep->maxpacket) {
+		DBG("bad ep or descriptor\n");
+		return -EINVAL;
+	}
+
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DBG("bogus device state\n");
+		return -ESHUTDOWN;
+	}
+
+	tmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	switch (tmp) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		DBG("only one control endpoint\n");
+		return -EINVAL;
+	case USB_ENDPOINT_XFER_INT:
+		if (maxpacket > 64)
+			goto bogus_max;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		switch (maxpacket) {
+		case 8:
+		case 16:
+		case 32:
+		case 64:
+			goto ok;
+		}
+bogus_max:
+		DBG("bogus maxpacket %d\n", maxpacket);
+		return -EINVAL;
+	case USB_ENDPOINT_XFER_ISOC:
+		if (!ep->is_pingpong) {
+			DBG("iso requires double buffering\n");
+			return -EINVAL;
+		}
+		break;
+	}
+
+ok:
+	local_irq_save(flags);
+
+	/* initialize endpoint to match this descriptor */
+	ep->is_in = (desc->bEndpointAddress & USB_DIR_IN) != 0;
+	ep->is_iso = (tmp == USB_ENDPOINT_XFER_ISOC);
+	ep->stopped = 0;
+	if (ep->is_in)
+		tmp |= 0x04;
+	tmp <<= 8;
+	tmp |= AT91_UDP_EPEDS;
+	__raw_writel(tmp, ep->creg);
+
+	ep->desc = desc;
+	ep->ep.maxpacket = maxpacket;
+
+	/*
+	 * reset/init endpoint fifo.  NOTE:  leaves fifo_bank alone,
+	 * since endpoint resets don't reset hw pingpong state.
+	 */
+	at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+	at91_udp_write(AT91_UDP_RST_EP, 0);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int at91_ep_disable (struct usb_ep * _ep)
+{
+	struct at91_ep	*ep = container_of(_ep, struct at91_ep, ep);
+	unsigned long	flags;
+
+	if (ep == &ep->udc->ep[0])
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	nuke(ep, -ESHUTDOWN);
+
+	/* restore the endpoint's pristine config */
+	ep->desc = NULL;
+	ep->ep.maxpacket = ep->maxpacket;
+
+	/* reset fifos and endpoint */
+	if (ep->udc->clocked) {
+		at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+		at91_udp_write(AT91_UDP_RST_EP, 0);
+		__raw_writel(0, ep->creg);
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+/*
+ * this is a PIO-only driver, so there's nothing
+ * interesting for request or buffer allocation.
+ */
+
+static struct usb_request *at91_ep_alloc_request (struct usb_ep *_ep, unsigned int gfp_flags)
+{
+	struct at91_request *req;
+
+	req = kcalloc(1, sizeof (struct at91_request), SLAB_KERNEL);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+static void at91_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct at91_request *req;
+
+	req = container_of(_req, struct at91_request, req);
+	BUG_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+static void *at91_ep_alloc_buffer(
+	struct usb_ep *_ep,
+	unsigned bytes,
+	dma_addr_t *dma,
+	unsigned int gfp_flags)
+{
+	*dma = ~0;
+	return kmalloc(bytes, gfp_flags);
+}
+
+static void at91_ep_free_buffer(
+	struct usb_ep *ep,
+	void *buf,
+	dma_addr_t dma,
+	unsigned bytes)
+{
+	kfree(buf);
+}
+
+static int at91_ep_queue(struct usb_ep *_ep,
+			struct usb_request *_req, unsigned int gfp_flags)
+{
+	struct at91_request	*req;
+	struct at91_ep		*ep;
+	struct at91_udc		*dev;
+	int			status;
+	unsigned long		flags;
+
+	req = container_of(_req, struct at91_request, req);
+	ep = container_of(_ep, struct at91_ep, ep);
+
+	if (!_req || !_req->complete
+			|| !_req->buf || !list_empty(&req->queue)) {
+		DBG("invalid request\n");
+		return -EINVAL;
+	}
+
+	if (!_ep || (!ep->desc && ep->ep.name != ep0name)) {
+		DBG("invalid ep\n");
+		return -EINVAL;
+	}
+
+	dev = ep->udc;
+
+	if (!dev || !dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DBG("invalid device\n");
+		return -EINVAL;
+	}
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	local_irq_save(flags);
+
+	/* try to kickstart any empty and idle queue */
+	if (list_empty(&ep->queue) && !ep->stopped) {
+		int	is_ep0;
+
+		/*
+		 * If this control request has a non-empty DATA stage, this
+		 * will start that stage.  It works just like a non-control
+		 * request (until the status stage starts, maybe early).
+		 *
+		 * If the data stage is empty, then this starts a successful
+		 * IN/STATUS stage.  (Unsuccessful ones use set_halt.)
+		 */
+		is_ep0 = (ep->ep.name == ep0name);
+		if (is_ep0) {
+			u32	tmp;
+
+			if (!dev->req_pending) {
+				status = -EINVAL;
+				goto done;
+			}
+
+			/*
+			 * defer changing CONFG until after the gadget driver
+			 * reconfigures the endpoints.
+			 */
+			if (dev->wait_for_config_ack) {
+				tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+				tmp ^= AT91_UDP_CONFG;
+				VDBG("toggle config\n");
+				at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+			}
+			if (req->req.length == 0) {
+ep0_in_status:
+				PACKET("ep0 in/status\n");
+				status = 0;
+				tmp = __raw_readl(ep->creg);
+				tmp &= ~SET_FX;
+				tmp |= CLR_FX | AT91_UDP_TXPKTRDY;
+				__raw_writel(tmp, ep->creg);
+				dev->req_pending = 0;
+				goto done;
+			}
+		}
+
+		if (ep->is_in)
+			status = write_fifo(ep, req);
+		else {
+			status = read_fifo(ep, req);
+
+			/* IN/STATUS stage is otherwise triggered by irq */
+			if (status && is_ep0)
+				goto ep0_in_status;
+		}
+	} else
+		status = 0;
+
+	if (req && !status) {
+		list_add_tail (&req->queue, &ep->queue);
+		at91_udp_write(AT91_UDP_IER, ep->int_mask);
+	}
+done:
+	local_irq_restore(flags);
+	return (status < 0) ? status : 0;
+}
+
+static int at91_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct at91_ep	*ep;
+	struct at91_request	*req;
+
+	ep = container_of(_ep, struct at91_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req)
+		return -EINVAL;
+
+	done(ep, req, -ECONNRESET);
+	return 0;
+}
+
+static int at91_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct at91_ep	*ep = container_of(_ep, struct at91_ep, ep);
+	u32 __iomem	*creg;
+	u32		csr;
+	unsigned long	flags;
+	int		status = 0;
+
+	if (!_ep || ep->is_iso || !ep->udc->clocked)
+		return -EINVAL;
+
+	creg = ep->creg;
+	local_irq_save(flags);
+
+	csr = __raw_readl(creg);
+
+	/*
+	 * fail with still-busy IN endpoints, ensuring correct sequencing
+	 * of data tx then stall.  note that the fifo rx bytecount isn't
+	 * completely accurate as a tx bytecount.
+	 */
+	if (ep->is_in && (!list_empty(&ep->queue) || (csr >> 16) != 0))
+		status = -EAGAIN;
+	else {
+		csr |= CLR_FX;
+		csr &= ~SET_FX;
+		if (value) {
+			csr |= AT91_UDP_FORCESTALL;
+			VDBG("halt %s\n", ep->ep.name);
+		} else {
+			at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+			at91_udp_write(AT91_UDP_RST_EP, 0);
+			csr &= ~AT91_UDP_FORCESTALL;
+		}
+		__raw_writel(csr, creg);
+	}
+
+	local_irq_restore(flags);
+	return status;
+}
+
+static struct usb_ep_ops at91_ep_ops = {
+	.enable		= at91_ep_enable,
+	.disable	= at91_ep_disable,
+	.alloc_request	= at91_ep_alloc_request,
+	.free_request	= at91_ep_free_request,
+	.alloc_buffer	= at91_ep_alloc_buffer,
+	.free_buffer	= at91_ep_free_buffer,
+	.queue		= at91_ep_queue,
+	.dequeue	= at91_ep_dequeue,
+	.set_halt	= at91_ep_set_halt,
+	// there's only imprecise fifo status reporting
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int at91_get_frame(struct usb_gadget *gadget)
+{
+	if (!to_udc(gadget)->clocked)
+		return -EINVAL;
+	return at91_udp_read(AT91_UDP_FRM_NUM) & AT91_UDP_NUM;
+}
+
+static int at91_wakeup(struct usb_gadget *gadget)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	u32		glbstate;
+	int		status = -EINVAL;
+	unsigned long	flags;
+
+	DBG("%s\n", __FUNCTION__ );
+	local_irq_save(flags);
+
+	if (!udc->clocked || !udc->suspended)
+		goto done;
+
+	/* NOTE:  some "early versions" handle ESR differently ... */
+
+	glbstate = at91_udp_read(AT91_UDP_GLB_STAT);
+	if (!(glbstate & AT91_UDP_ESR))
+		goto done;
+	glbstate |= AT91_UDP_ESR;
+	at91_udp_write(AT91_UDP_GLB_STAT, glbstate);
+
+done:
+	local_irq_restore(flags);
+	return status;
+}
+
+/* reinit == restore inital software state */
+static void udc_reinit(struct at91_udc *udc)
+{
+	u32 i;
+
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	INIT_LIST_HEAD(&udc->gadget.ep0->ep_list);
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct at91_ep *ep = &udc->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+		ep->desc = NULL;
+		ep->stopped = 0;
+		ep->fifo_bank = 0;
+		ep->ep.maxpacket = ep->maxpacket;
+		// initialiser une queue par endpoint
+		INIT_LIST_HEAD(&ep->queue);
+	}
+}
+
+static void stop_activity(struct at91_udc *udc)
+{
+	struct usb_gadget_driver *driver = udc->driver;
+	int i;
+
+	if (udc->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct at91_ep *ep = &udc->ep[i];
+		ep->stopped = 1;
+		nuke(ep, -ESHUTDOWN);
+	}
+	if (driver)
+		driver->disconnect(&udc->gadget);
+
+	udc_reinit(udc);
+}
+
+static void clk_on(struct at91_udc *udc)
+{
+	if (udc->clocked)
+		return;
+	udc->clocked = 1;
+#if 0
+	clk_enable(udc->iclk);
+	clk_enable(udc->fclk);
+#endif
+	at91_enable_periph_clock(10);
+	at91_enable_system_clock(1 << 7);
+}
+
+static void clk_off(struct at91_udc *udc)
+{
+	if (!udc->clocked)
+		return;
+	udc->clocked = 0;
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+#if 0
+	clk_disable(udc->iclk);
+	clk_disable(udc->fclk);
+#endif
+	at91_disable_periph_clock(10);
+	at91_disable_system_clock(1 << 7);
+}
+
+/*
+ * activate/deactivate link with host; minimize power usage for
+ * inactive links by cutting clocks and transceiver power.
+ */
+static void pullup(struct at91_udc *udc, int is_on)
+{
+	if (!udc->enabled || !udc->vbus)
+		is_on = 0;
+	DBG("%sactive\n", is_on ? "" : "in");
+	if (is_on) {
+		clk_on(udc);
+		//at91_set_gpio_value(udc->board.pullup_pin, 1);
+		at91_udp_write(AT91_UDP_TXVC, 0);
+		at91_gpio_set_level(AT91C_VA_BASE_PIOB, 30, 1);
+	} else  {
+		stop_activity(udc);
+		at91_udp_write(AT91_UDP_TXVC, AT91_UDP_TXVC_TXVDIS);
+		//at91_set_gpio_value(udc->board.pullup_pin, 0);
+		at91_gpio_set_level(AT91C_VA_BASE_PIOB, 30, 0);
+		clk_off(udc);
+
+		// REVISIT:  with transceiver disabled, will D- float
+		// so that a host would falsely detect a device?
+	}
+}
+
+/* vbus is here!  turn everything on that's ready */
+static int at91_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	unsigned long	flags;
+
+	// VDBG("vbus %s\n", is_active ? "on" : "off");
+	local_irq_save(flags);
+	udc->vbus = (is_active != 0);
+	pullup(udc, is_active);
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int at91_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	unsigned long	flags;
+
+	local_irq_save(flags);
+	udc->enabled = is_on;
+	pullup(udc, is_on);
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int at91_set_selfpowered(struct usb_gadget *gadget, int is_on)
+{
+	struct at91_udc	*udc = to_udc(gadget);
+	unsigned long	flags;
+
+	local_irq_save(flags);
+	udc->selfpowered = (is_on != 0);
+	local_irq_restore(flags);
+	return 0;
+}
+
+static const struct usb_gadget_ops at91_udc_ops = {
+	.get_frame		= at91_get_frame,
+	.wakeup			= at91_wakeup,
+	.set_selfpowered	= at91_set_selfpowered,
+	.vbus_session		= at91_vbus_session,
+	.pullup			= at91_pullup,
+
+	/*
+	 * VBUS-powered devices may also also want to support bigger
+	 * power budgets after an appropriate SET_CONFIGURATION.
+	 */
+	// .vbus_power		= at91_vbus_power,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int handle_ep(struct at91_ep *ep)
+{
+	struct at91_request	*req;
+	u32 __iomem		*creg = ep->creg;
+	u32			csr = __raw_readl(creg);
+
+	if (!list_empty(&ep->queue))
+		req = list_entry(ep->queue.next,
+			struct at91_request, queue);
+	else
+		req = NULL;
+
+	if (ep->is_in) {
+		if (csr & (AT91_UDP_STALLSENT | AT91_UDP_TXCOMP)) {
+			csr |= CLR_FX;
+			csr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_TXCOMP);
+			__raw_writel(csr, creg);
+		}
+		if (req)
+			return write_fifo(ep, req);
+
+	} else {
+		if (csr & AT91_UDP_STALLSENT) {
+			/* STALLSENT bit == ISOERR */
+			if (ep->is_iso && req)
+				req->req.status = -EILSEQ;
+			csr |= CLR_FX;
+			csr &= ~(SET_FX | AT91_UDP_STALLSENT);
+			__raw_writel(csr, creg);
+			csr = __raw_readl(creg);
+		}
+		if (req && (csr & RX_DATA_READY))
+			return read_fifo(ep, req);
+	}
+	return 0;
+}
+
+union setup {
+	u8			raw[8];
+	struct usb_ctrlrequest	r;
+};
+
+static void handle_setup(struct at91_udc *udc, struct at91_ep *ep, u32 csr)
+{
+	u32 __iomem	*creg = ep->creg;
+	u8 __iomem	*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));
+	unsigned	rxcount, i = 0;
+	u32		tmp;
+	union setup	pkt;
+	int		status = 0;
+
+	/* read and ack SETUP; hard-fail for bogus packets */
+	rxcount = (csr & AT91_UDP_RXBYTECNT) >> 16;
+	if (likely(rxcount == 8)) {
+		while (rxcount--)
+			pkt.raw[i++] = __raw_readb(dreg);
+		if (pkt.r.bRequestType & USB_DIR_IN) {
+			csr |= AT91_UDP_DIR;
+			ep->is_in = 1;
+		} else {
+			csr &= ~AT91_UDP_DIR;
+			ep->is_in = 0;
+		}
+	} else {
+		// REVISIT this happens sometimes under load; why??
+		ERR("SETUP len %d, csr %08x\n", rxcount, csr);
+		status = -EINVAL;
+	}
+	csr |= CLR_FX;
+	csr &= ~(SET_FX | AT91_UDP_RXSETUP);
+	__raw_writel(csr, creg);
+	udc->wait_for_addr_ack = 0;
+	udc->wait_for_config_ack = 0;
+	ep->stopped = 0;
+	if (unlikely(status != 0))
+		goto stall;
+
+#define w_index		le16_to_cpu(pkt.r.wIndex)
+#define w_value		le16_to_cpu(pkt.r.wValue)
+#define w_length	le16_to_cpu(pkt.r.wLength)
+
+	VDBG("SETUP %02x.%02x v%04x i%04x l%04x\n",
+			pkt.r.bRequestType, pkt.r.bRequest,
+			w_value, w_index, w_length);
+
+	/*
+	 * A few standard requests get handled here, ones that touch
+	 * hardware ... notably for device and endpoint features.
+	 */
+	udc->req_pending = 1;
+	csr = __raw_readl(creg);
+	csr |= CLR_FX;
+	csr &= ~SET_FX;
+	switch ((pkt.r.bRequestType << 8) | pkt.r.bRequest) {
+
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_SET_ADDRESS:
+		__raw_writel(csr | AT91_UDP_TXPKTRDY, creg);
+		udc->addr = w_value;
+		udc->wait_for_addr_ack = 1;
+		udc->req_pending = 0;
+		/* FADDR is set later, when we ack host STATUS */
+		return;
+
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_SET_CONFIGURATION:
+		tmp = at91_udp_read(AT91_UDP_GLB_STAT) & AT91_UDP_CONFG;
+		if (pkt.r.wValue)
+			udc->wait_for_config_ack = (tmp == 0);
+		else
+			udc->wait_for_config_ack = (tmp != 0);
+		if (udc->wait_for_config_ack)
+			VDBG("wait for config\n");
+		/* CONFG is toggled later, if gadget driver succeeds */
+		break;
+
+	/*
+	 * Hosts may set or clear remote wakeup status, and
+	 * devices may report they're VBUS powered.
+	 */
+	case ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_GET_STATUS:
+		tmp = (udc->selfpowered << USB_DEVICE_SELF_POWERED);
+		if (at91_udp_read(AT91_UDP_GLB_STAT) & AT91_UDP_ESR)
+			tmp |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+		PACKET("get device status\n");
+		__raw_writeb(tmp, dreg);
+		__raw_writeb(0, dreg);
+		goto write_in;
+		/* then STATUS starts later, automatically */
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_SET_FEATURE:
+		if (w_value != USB_DEVICE_REMOTE_WAKEUP)
+			goto stall;
+		tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+		tmp |= AT91_UDP_ESR;
+		at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+		goto succeed;
+	case ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)
+			| USB_REQ_CLEAR_FEATURE:
+		if (w_value != USB_DEVICE_REMOTE_WAKEUP)
+			goto stall;
+		tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+		tmp &= ~AT91_UDP_ESR;
+		at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+		goto succeed;
+
+	/*
+	 * Interfaces have no feature settings; this is pretty useless.
+	 * we won't even insist the interface exists...
+	 */
+	case ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)
+			| USB_REQ_GET_STATUS:
+		PACKET("get interface status\n");
+		__raw_writeb(0, dreg);
+		__raw_writeb(0, dreg);
+		goto write_in;
+		/* then STATUS starts later, automatically */
+	case ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)
+			| USB_REQ_SET_FEATURE:
+	case ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)
+			| USB_REQ_CLEAR_FEATURE:
+		goto stall;
+
+	/*
+	 * Hosts may clear bulk/intr endpoint halt after the gadget
+	 * driver sets it (not widely used); or set it (for testing)
+	 */
+	case ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)
+			| USB_REQ_GET_STATUS:
+		tmp = w_index & USB_ENDPOINT_NUMBER_MASK;
+		ep = &udc->ep[tmp];
+		if (tmp > NUM_ENDPOINTS || (tmp && !ep->desc))
+			goto stall;
+
+		if (tmp) {
+			if ((w_index & USB_DIR_IN)) {
+				if (!ep->is_in)
+					goto stall;
+			} else if (ep->is_in)
+				goto stall;
+		}
+		PACKET("get %s status\n", ep->ep.name);
+		if (__raw_readl(ep->creg) & AT91_UDP_FORCESTALL)
+			tmp = (1 << USB_ENDPOINT_HALT);
+		else
+			tmp = 0;
+		__raw_writeb(tmp, dreg);
+		__raw_writeb(0, dreg);
+		goto write_in;
+		/* then STATUS starts later, automatically */
+	case ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)
+			| USB_REQ_SET_FEATURE:
+		tmp = w_index & USB_ENDPOINT_NUMBER_MASK;
+		ep = &udc->ep[tmp];
+		if (w_value != USB_ENDPOINT_HALT || tmp > NUM_ENDPOINTS)
+			goto stall;
+		if (!ep->desc || ep->is_iso)
+			goto stall;
+		if ((w_index & USB_DIR_IN)) {
+			if (!ep->is_in)
+				goto stall;
+		} else if (ep->is_in)
+			goto stall;
+
+		tmp = __raw_readl(ep->creg);
+		tmp &= ~SET_FX;
+		tmp |= CLR_FX | AT91_UDP_FORCESTALL;
+		__raw_writel(tmp, ep->creg);
+		goto succeed;
+	case ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)
+			| USB_REQ_CLEAR_FEATURE:
+		tmp = w_index & USB_ENDPOINT_NUMBER_MASK;
+		ep = &udc->ep[tmp];
+		if (w_value != USB_ENDPOINT_HALT || tmp > NUM_ENDPOINTS)
+			goto stall;
+		if (tmp == 0)
+			goto succeed;
+		if (!ep->desc || ep->is_iso)
+			goto stall;
+		if ((w_index & USB_DIR_IN)) {
+			if (!ep->is_in)
+				goto stall;
+		} else if (ep->is_in)
+			goto stall;
+
+		at91_udp_write(AT91_UDP_RST_EP, ep->int_mask);
+		at91_udp_write(AT91_UDP_RST_EP, 0);
+		tmp = __raw_readl(ep->creg);
+		tmp |= CLR_FX;
+		tmp &= ~(SET_FX | AT91_UDP_FORCESTALL);
+		__raw_writel(tmp, ep->creg);
+		if (!list_empty(&ep->queue))
+			handle_ep(ep);
+		goto succeed;
+	}
+
+#undef w_value
+#undef w_index
+#undef w_length
+
+	/* pass request up to the gadget driver */
+	status = udc->driver->setup(&udc->gadget, &pkt.r);
+	if (status < 0) {
+stall:
+		VDBG("req %02x.%02x protocol STALL; stat %d\n",
+				pkt.r.bRequestType, pkt.r.bRequest, status);
+		csr |= AT91_UDP_FORCESTALL;
+		__raw_writel(csr, creg);
+		udc->req_pending = 0;
+	}
+	return;
+
+succeed:
+	/* immediate successful (IN) STATUS after zero length DATA */
+	PACKET("ep0 in/status\n");
+write_in:
+	csr |= AT91_UDP_TXPKTRDY;
+	__raw_writel(csr, creg);
+	udc->req_pending = 0;
+	return;
+}
+
+static void handle_ep0(struct at91_udc *udc)
+{
+	struct at91_ep		*ep0 = &udc->ep[0];
+	u32 __iomem		*creg = ep0->creg;
+	u32			csr = __raw_readl(creg);
+	struct at91_request	*req;
+
+	if (unlikely(csr & AT91_UDP_STALLSENT)) {
+		nuke(ep0, -EPROTO);
+		udc->req_pending = 0;
+		csr |= CLR_FX;
+		csr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_FORCESTALL);
+		__raw_writel(csr, creg);
+		VDBG("ep0 stalled\n");
+		csr = __raw_readl(creg);
+	}
+	if (csr & AT91_UDP_RXSETUP) {
+		nuke(ep0, 0);
+		udc->req_pending = 0;
+		handle_setup(udc, ep0, csr);
+		return;
+	}
+
+	if (list_empty(&ep0->queue))
+		req = NULL;
+	else
+		req = list_entry(ep0->queue.next, struct at91_request, queue);
+
+	/* host ACKed an IN packet that we sent */
+	if (csr & AT91_UDP_TXCOMP) {
+		csr |= CLR_FX;
+		csr &= ~(SET_FX | AT91_UDP_TXCOMP);
+
+		/* write more IN DATA? */
+		if (req && ep0->is_in) {
+			if (handle_ep(ep0))
+				udc->req_pending = 0;
+
+		/*
+		 * Ack after:
+		 *  - last IN DATA packet (including GET_STATUS)
+		 *  - IN/STATUS for OUT DATA
+		 *  - IN/STATUS for any zero-length DATA stage
+		 * except for the IN DATA case, the host should send
+		 * an OUT status later, which we'll ack.
+		 */
+		} else {
+			udc->req_pending = 0;
+			__raw_writel(csr, creg);
+
+			/*
+			 * SET_ADDRESS takes effect only after the STATUS
+			 * (to the original address) gets acked.
+			 */
+			if (udc->wait_for_addr_ack) {
+				u32	tmp;
+
+				at91_udp_write(AT91_UDP_FADDR, AT91_UDP_FEN | udc->addr);
+				tmp = at91_udp_read(AT91_UDP_GLB_STAT);
+				tmp &= ~AT91_UDP_FADDEN;
+				if (udc->addr)
+					tmp |= AT91_UDP_FADDEN;
+				at91_udp_write(AT91_UDP_GLB_STAT, tmp);
+
+				udc->wait_for_addr_ack = 0;
+				VDBG("address %d\n", udc->addr);
+			}
+		}
+	}
+
+	/* OUT packet arrived ... */
+	else if (csr & AT91_UDP_RX_DATA_BK0) {
+		csr |= CLR_FX;
+		csr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);
+
+		/* OUT DATA stage */
+		if (!ep0->is_in) {
+			if (req) {
+				if (handle_ep(ep0)) {
+					/* send IN/STATUS */
+					PACKET("ep0 in/status\n");
+					csr = __raw_readl(creg);
+					csr &= ~SET_FX;
+					csr |= CLR_FX | AT91_UDP_TXPKTRDY;
+					__raw_writel(csr, creg);
+					udc->req_pending = 0;
+				}
+			} else if (udc->req_pending) {
+				/*
+				 * AT91 hardware has a hard time with this
+				 * "deferred response" mode for control-OUT
+				 * transfers.  (For control-IN it's fine.)
+				 *
+				 * The normal solution leaves OUT data in the
+				 * fifo until the gadget driver is ready.
+				 * We couldn't do that here without disabling
+				 * the IRQ that tells about SETUP packets,
+				 * e.g. when the host gets impatient...
+				 *
+				 * Working around it by copying into a buffer
+				 * would almost be a non-deferred response,
+				 * except that it wouldn't permit reliable
+				 * stalling of the request.  Instead, demand
+				 * that gadget drivers not use this mode.
+				 */
+				DBG("no control-OUT deferred responses!\n");
+				__raw_writel(csr | AT91_UDP_FORCESTALL, creg);
+				udc->req_pending = 0;
+			}
+
+		/* STATUS stage for control-IN; ack.  */
+		} else {
+			PACKET("ep0 out/status ACK\n");
+			__raw_writel(csr, creg);
+
+			/* "early" status stage */
+			if (req)
+				done(ep0, req, 0);
+		}
+	}
+}
+
+static irqreturn_t at91_udc_irq (int irq, void *_udc, struct pt_regs *r)
+{
+	struct at91_udc		*udc = _udc;
+	u32			rescans = 5;
+
+	while (rescans--) {
+		u32	status = at91_udp_read(AT91_UDP_ISR);
+
+		status &= at91_udp_read(AT91_UDP_IMR);
+		if (!status)
+			break;
+
+		/* USB reset irq:  not maskable */
+		if (status & AT91_UDP_ENDBUSRES) {
+			at91_udp_write(AT91_UDP_IDR, ~MINIMUS_INTERRUPTUS);
+			at91_udp_write(AT91_UDP_IER, MINIMUS_INTERRUPTUS);
+			/* Atmel code clears this irq twice */
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_ENDBUSRES);
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_ENDBUSRES);
+			VDBG("end bus reset\n");
+			udc->addr = 0;
+			stop_activity(udc);
+
+			/* enable ep0 */
+			at91_udp_write(AT91_UDP_CSR(0), AT91_UDP_EPEDS | AT91_UDP_EPTYPE_CTRL);
+			udc->gadget.speed = USB_SPEED_FULL;
+			udc->suspended = 0;
+			at91_udp_write(AT91_UDP_IER, AT91_UDP_EP(0));
+
+			/*
+			 * NOTE:  this driver keeps clocks off unless the
+			 * USB host is present.  That saves power, and also
+			 * eliminates IRQs (reset, resume, suspend) that can
+			 * otherwise flood from the controller.  If your
+			 * board doesn't support VBUS detection, suspend and
+			 * resume irq logic may need more attention...
+			 */
+
+		/* host initiated suspend (3+ms bus idle) */
+		} else if (status & AT91_UDP_RXSUSP) {
+			at91_udp_write(AT91_UDP_IDR, AT91_UDP_RXSUSP);
+			at91_udp_write(AT91_UDP_IER, AT91_UDP_RXRSM);
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_RXSUSP);
+			// VDBG("bus suspend\n");
+			if (udc->suspended)
+				continue;
+			udc->suspended = 1;
+
+			/*
+			 * NOTE:  when suspending a VBUS-powered device, the
+			 * gadget driver should switch into slow clock mode
+			 * and then into standby to avoid drawing more than
+			 * 500uA power (2500uA for some high-power configs).
+			 */
+			if (udc->driver && udc->driver->suspend)
+				udc->driver->suspend(&udc->gadget);
+
+		/* host initiated resume */
+		} else if (status & AT91_UDP_RXRSM) {
+			at91_udp_write(AT91_UDP_IDR, AT91_UDP_RXRSM);
+			at91_udp_write(AT91_UDP_IER, AT91_UDP_RXSUSP);
+			at91_udp_write(AT91_UDP_ICR, AT91_UDP_RXRSM);
+			// VDBG("bus resume\n");
+			if (!udc->suspended)
+				continue;
+			udc->suspended = 0;
+
+			/*
+			 * NOTE:  for a VBUS-powered device, the gadget driver
+			 * would normally want to switch out of slow clock
+			 * mode into normal mode.
+			 */
+			if (udc->driver && udc->driver->resume)
+				udc->driver->resume(&udc->gadget);
+
+		/* endpoint IRQs are cleared by handling them */
+		} else {
+			int		i;
+			unsigned	mask = 1;
+			struct at91_ep	*ep = &udc->ep[1];
+
+			if (status & mask)
+				handle_ep0(udc);
+			for (i = 1; i < NUM_ENDPOINTS; i++) {
+				mask <<= 1;
+				if (status & mask)
+					handle_ep(ep);
+				ep++;
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct at91_udc controller = {
+	.gadget = {
+		.ops = &at91_udc_ops,
+		.ep0 = &controller.ep[0].ep,
+		.name = driver_name,
+		.dev = {
+			.bus_id = "gadget"
+		}
+	},
+	.ep[0] = {
+		.ep = {
+			.name	= ep0name,
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 8,
+		.creg		= (void __iomem *)(AT91C_VA_BASE_UDP + AT91_UDP_CSR(0)),
+		.int_mask	= 1 << 0,
+	},
+	.ep[1] = {
+		.ep = {
+			.name	= "ep1",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 64,
+		.creg		= (void __iomem *)(AT91C_VA_BASE_UDP + AT91_UDP_CSR(1)),
+		.int_mask	= 1 << 1,
+	},
+	.ep[2] = {
+		.ep = {
+			.name	= "ep2",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 64,
+		.creg		= (void __iomem *)(AT91C_VA_BASE_UDP + AT91_UDP_CSR(2)),
+		.int_mask	= 1 << 2,
+	},
+	.ep[3] = {
+		.ep = {
+			/* could actually do bulk too */
+			.name	= "ep3-int",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 8,
+		.creg		= (void __iomem *)(AT91C_VA_BASE_UDP + AT91_UDP_CSR(3)),
+		.int_mask	= 1 << 3,
+	},
+	.ep[4] = {
+		.ep = {
+			.name	= "ep4",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 256,
+		.creg		= (void __iomem *)(AT91C_VA_BASE_UDP + AT91_UDP_CSR(4)),
+		.int_mask	= 1 << 4,
+	},
+	.ep[5] = {
+		.ep = {
+			.name	= "ep5",
+			.ops	= &at91_ep_ops,
+		},
+		.udc		= &controller,
+		.is_pingpong	= 1,
+		.maxpacket	= 256,
+		.creg		= (void __iomem *)(AT91C_VA_BASE_UDP + AT91_UDP_CSR(5)),
+		.int_mask	= 1 << 5,
+	},
+	/* ep6 and ep7 are also reserved */
+};
+
+static irqreturn_t at91_vbus_irq(int irq, void *_udc, struct pt_regs *r)
+{
+	struct at91_udc	*udc = _udc;
+	unsigned	value;
+
+	/* vbus needs at least brief debouncing */
+	udelay(10);
+	value = at91_get_gpio_value(udc->board.vbus_pin);
+	if (value != udc->vbus)
+		at91_vbus_session(&udc->gadget, value);
+
+	return IRQ_HANDLED;
+}
+
+int usb_gadget_register_driver (struct usb_gadget_driver *driver)
+{
+	struct at91_udc	*udc = &controller;
+	int		retval;
+
+	if (!driver
+			|| driver->speed != USB_SPEED_FULL
+			|| !driver->bind
+			|| !driver->unbind
+			|| !driver->setup) {
+		DBG("bad parameter.\n");
+		return -EINVAL;
+	}
+
+	if (udc->driver) {
+		DBG("UDC already has a gadget driver\n");
+		return -EBUSY;
+	}
+
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+	udc->gadget.dev.driver_data = &driver->driver;
+	udc->enabled = 1;
+	udc->selfpowered = 1;
+
+	retval = driver->bind(&udc->gadget);
+	if (retval) {
+		DBG("driver->bind() returned %d\n", retval);
+		udc->driver = NULL;
+		return retval;
+	}
+
+	local_irq_disable();
+	pullup(udc, 1);
+	local_irq_enable();
+
+	DBG("bound to %s\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_register_driver);
+
+int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
+{
+	struct at91_udc *udc = &controller;
+
+	if (!driver || driver != udc->driver)
+		return -EINVAL;
+
+	local_irq_disable();
+	udc->enabled = 0;
+	pullup(udc, 0);
+	local_irq_enable();
+
+	driver->unbind(&udc->gadget);
+	udc->driver = NULL;
+
+	DBG("unbound from %s\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------*/
+
+static void at91udc_shutdown(struct platform_device *dev)
+{
+	/* force disconnect on reboot */
+	pullup(platform_get_drvdata(dev), 0);
+}
+
+static int __devinit at91udc_probe(struct platform_device *pdev)
+{
+	struct device	*dev = &pdev->dev;
+	struct at91_udc	*udc;
+	int		retval;
+
+	if (!dev->platform_data) {
+		/* small (so we copy it) but critical! */
+		DBG("missing platform_data\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(AT91_BASE_UDP, SZ_16K, driver_name)) {
+		DBG("someone's using UDC memory\n");
+		return -EBUSY;
+	}
+
+	/* init software state */
+	udc = &controller;
+	udc->gadget.dev.parent = dev;
+	udc->board = *(struct at91_udc_data *) dev->platform_data;
+	udc->pdev = pdev;
+	udc_reinit(udc);
+	udc->enabled = 0;
+
+	/* get interface and function clocks */
+#if 0
+	udc->iclk = clk_get(dev, "udc_clk");
+	udc->fclk = clk_get(dev, "udpck");
+	if (IS_ERR(udc->iclk))
+		DBG("udc_clk missing");
+	if (IS_ERR(udc->fclk))
+		DBG("udpck missing");
+	if (IS_ERR(udc->iclk) || IS_ERR(udc->fclk)) {
+		DBG("clocks missing\n");
+		return -ENODEV;
+	}
+#endif
+
+	retval = device_register(&udc->gadget.dev);
+	if (retval < 0)
+		goto fail0;
+
+	/* disable everything until there's a gadget driver and vbus */
+	pullup(udc, 0);
+
+	/* request UDC and maybe VBUS irqs */
+	if (request_irq(AT91_ID_UDP, at91_udc_irq, SA_INTERRUPT, driver_name, udc)) {
+		DBG("request irq %d failed\n", AT91_ID_UDP);
+		retval = -EBUSY;
+		goto fail1;
+	}
+	if (udc->board.vbus_pin > 0) {
+		if (request_irq(udc->board.vbus_pin, at91_vbus_irq, SA_INTERRUPT, driver_name, udc)) {
+			DBG("request vbus irq %d failed\n", udc->board.vbus_pin);
+			free_irq(AT91_ID_UDP, udc);
+			retval = -EBUSY;
+			goto fail1;
+		}
+	} else {
+		DBG("no VBUS detection, assuming always-on\n");
+		udc->vbus = 1;
+	}
+	dev_set_drvdata(dev, udc);
+	create_debug_file(udc);
+
+	printk("%s version %s\n", driver_name, DRIVER_VERSION);
+
+	INFO("%s version %s\n", driver_name, DRIVER_VERSION);
+	return 0;
+
+fail1:
+	device_unregister(&udc->gadget.dev);
+fail0:
+	release_mem_region(AT91C_VA_BASE_UDP, SZ_16K);
+	DBG("%s probe failed, %d\n", driver_name, retval);
+	return retval;
+}
+
+static int __devexit at91udc_remove(struct platform_device *dev)
+{
+	struct at91_udc *udc = platform_get_drvdata(dev);
+
+	DBG("remove\n");
+
+	pullup(udc, 0);
+
+	if (udc->driver != 0)
+		usb_gadget_unregister_driver(udc->driver);
+
+	remove_debug_file(udc);
+	if (udc->board.vbus_pin > 0)
+		free_irq(udc->board.vbus_pin, udc);
+	free_irq(AT91_ID_UDP, udc);
+	device_unregister(&udc->gadget.dev);
+	release_mem_region(AT91_BASE_UDP, SZ_16K);
+
+#if 0
+	clk_put(udc->iclk);
+	clk_put(udc->fclk);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int at91udc_suspend(struct platform_device *dev, u32 state, u32 level)
+{
+	struct at91_udc *udc = platform_get_drvdata(dev);
+
+	/*
+	 * The "safe" suspend transitions are opportunistic ... e.g. when
+	 * the USB link is suspended (48MHz clock autogated off), or when
+	 * it's disconnected (programmatically gated off, elsewhere).
+	 * Then we can suspend, and the chip can enter slow clock mode.
+	 *
+	 * The problem case is some component (user mode?) suspending this
+	 * device while it's active, with the 48 MHz clock in use.  There
+	 * are two basic approaches:  (a) veto suspend levels involving slow
+	 * clock mode, (b) disconnect, so 48 MHz will no longer be in use
+	 * and we can enter slow clock mode.  This uses (b) for now, since
+	 * it's simplest until AT91 PM exists and supports the other option.
+	 */
+	if (udc->vbus && !udc->suspended)
+		pullup(udc, 0);
+	return 0;
+}
+
+static int at91udc_resume(struct platform_device *dev, u32 level)
+{
+	struct at91_udc *udc = platform_get_drvdata(dev);
+
+	/* maybe reconnect to host; if so, clocks on */
+	pullup(udc, 1);
+	return 0;
+}
+#else
+#define	at91udc_suspend	NULL
+#define	at91udc_resume	NULL
+#endif
+
+static struct platform_driver at91_udc = {
+	.probe		= at91udc_probe,
+	.remove		= __devexit_p(at91udc_remove),
+	.shutdown	= at91udc_shutdown,
+	.suspend	= at91udc_suspend,
+	.resume 	= at91udc_resume,
+	.driver		= {
+		.name	= (char *) driver_name,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __devinit udc_init_module(void)
+{
+	return platform_driver_register(&at91_udc);
+}
+module_init(udc_init_module);
+
+static void __devexit udc_exit_module(void)
+{
+	platform_driver_unregister(&at91_udc);
+}
+module_exit(udc_exit_module);
+
+MODULE_DESCRIPTION("AT91RM9200 udc driver");
+MODULE_AUTHOR("Thomas Rathbone, David Brownell");
+MODULE_LICENSE("GPL");
Binary files linux-2.6.15.4/drivers/usb/gadget/.at91_udc.c.swp and linux-2.6.15.4/drivers/usb/gadget/.at91_udc.c.swp differ
diff -Nur linux-2.6.15.4-orig/drivers/usb/gadget/at91_udc.h linux-2.6.15.4/drivers/usb/gadget/at91_udc.h
--- linux-2.6.15.4-orig/drivers/usb/gadget/at91_udc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/gadget/at91_udc.h	2006-08-09 16:57:01.000000000 +0200
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2004 by Thomas Rathbone, HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef AT91_UDC_H
+#define AT91_UDC_H
+
+#define	NUM_ENDPOINTS	6
+
+/*
+ * hardware won't disable bus reset, or resume while the controller
+ * is suspended ... watching suspend helps keep the logic symmetric.
+ */
+#define	MINIMUS_INTERRUPTUS \
+	(AT91_UDP_ENDBUSRES | AT91_UDP_RXRSM | AT91_UDP_RXSUSP)
+
+struct at91_ep {
+	struct usb_ep			ep;
+	struct list_head		queue;
+	struct at91_udc			*udc;
+	void __iomem			*creg;
+
+	unsigned			maxpacket:16;
+	u8				int_mask;
+	unsigned			is_pingpong:1;
+
+	unsigned			stopped:1;
+	unsigned			is_in:1;
+	unsigned			is_iso:1;
+	unsigned			fifo_bank:1;
+
+	const struct usb_endpoint_descriptor
+					*desc;
+};
+
+/*
+ * driver is non-SMP, and just blocks IRQs whenever it needs
+ * access protection for chip registers or driver state
+ */
+struct at91_udc {
+	struct usb_gadget		gadget;
+	struct at91_ep			ep[NUM_ENDPOINTS];
+	struct usb_gadget_driver	*driver;
+	unsigned			vbus:1;
+	unsigned			enabled:1;
+	unsigned			clocked:1;
+	unsigned			suspended:1;
+	unsigned			req_pending:1;
+	unsigned			wait_for_addr_ack:1;
+	unsigned			wait_for_config_ack:1;
+	unsigned			selfpowered:1;
+	u8				addr;
+	struct at91_udc_data		board;
+	struct clk			*iclk, *fclk;
+	struct platform_device		*pdev;
+	struct proc_dir_entry		*pde;
+};
+
+static inline struct at91_udc *to_udc(struct usb_gadget *g)
+{
+	return container_of(g, struct at91_udc, gadget);
+}
+
+struct at91_request {
+	struct usb_request		req;
+	struct list_head		queue;
+};
+
+/*-------------------------------------------------------------------------*/
+
+#define AT91_UDP_FRM_NUM	0x00		/* Frame Number Register */
+#define		AT91_UDP_NUM		(0x7ff <<  0)		/* Frame Number */
+#define		AT91_UDP_FRM_ERR	(1     << 16)		/* Frame Error */
+#define		AT91_UDP_FRM_OK		(1     << 17)		/* Frame OK */
+
+#define AT91_UDP_GLB_STAT	0x04		/* Global State Register */
+#define		AT91_UDP_FADDEN		(1 <<  0)		/* Function Address Enable */
+#define		AT91_UDP_CONFG		(1 <<  1)		/* Configured */
+#define		AT91_UDP_ESR		(1 <<  2)		/* Enable Send Resume */
+#define		AT91_UDP_RSMINPR	(1 <<  3)		/* Resume has been sent */
+#define		AT91_UDP_RMWUPE		(1 <<  4)		/* Remote Wake Up Enable */
+
+#define AT91_UDP_FADDR		0x08		/* Function Address Register */
+#define		AT91_UDP_FADD		(0x7f << 0)		/* Function Address Value */
+#define		AT91_UDP_FEN		(1    << 8)		/* Function Enable */
+
+#define AT91_UDP_IER		0x10		/* Interrupt Enable Register */
+#define AT91_UDP_IDR		0x14		/* Interrupt Disable Register */
+#define AT91_UDP_IMR		0x18		/* Interrupt Mask Register */
+
+#define AT91_UDP_ISR		0x1c		/* Interrupt Status Register */
+#define		AT91_UDP_EP(n)		(1 << (n))		/* Endpoint Interrupt Status */
+#define		AT91_UDP_RXSUSP		(1 <<  8) 		/* USB Suspend Interrupt Status */
+#define		AT91_UDP_RXRSM		(1 <<  9)		/* USB Resume Interrupt Status */
+#define		AT91_UDP_EXTRSM		(1 << 10)		/* External Resume Interrupt Status */
+#define		AT91_UDP_SOFINT		(1 << 11)		/* Start of Frame Interrupt Status */
+#define		AT91_UDP_ENDBUSRES	(1 << 12)		/* End of Bus Reset Interrpt Status */
+#define		AT91_UDP_WAKEUP		(1 << 13)		/* USB Wakeup Interrupt Status */
+
+#define AT91_UDP_ICR		0x20		/* Interrupt Clear Register */
+#define AT91_UDP_RST_EP		0x28		/* Reset Endpoint Register */
+
+#define AT91_UDP_CSR(n)		(0x30 + ((n) * 4))	/* Endpoint Control/Status Registers 0-7 */
+#define		AT91_UDP_TXCOMP		(1 <<  0)		/* Generates IN packet with data previously written in DPR */
+#define		AT91_UDP_RX_DATA_BK0	(1 <<  1)		/* Receive Data Bank 0 */
+#define		AT91_UDP_RXSETUP	(1 <<  2)		/* Send STALL to the host */
+#define		AT91_UDP_STALLSENT	(1 <<  3)		/* Stall Sent / Isochronous error (Isochronous endpoints) */
+#define		AT91_UDP_TXPKTRDY	(1 <<  4)		/* Transmit Packet Ready */
+#define		AT91_UDP_FORCESTALL	(1 <<  5)		/* Force Stall */
+#define		AT91_UDP_RX_DATA_BK1	(1 <<  6)		/* Receive Data Bank 1 */
+#define		AT91_UDP_DIR		(1 <<  7)		/* Transfer Direction */
+#define		AT91_UDP_EPTYPE		(7 <<  8)		/* Endpoint Type */
+#define			AT91_UDP_EPTYPE_CTRL		(0 <<  8)
+#define			AT91_UDP_EPTYPE_ISO_OUT		(1 <<  8)
+#define			AT91_UDP_EPTYPE_BULK_OUT	(2 <<  8)
+#define			AT91_UDP_EPTYPE_INT_OUT		(3 <<  8)
+#define			AT91_UDP_EPTYPE_ISO_IN		(5 <<  8)
+#define			AT91_UDP_EPTYPE_BULK_IN		(6 <<  8)
+#define			AT91_UDP_EPTYPE_INT_IN		(7 <<  8)
+#define		AT91_UDP_DTGLE		(1 << 11)		/* Data Toggle */
+#define		AT91_UDP_EPEDS		(1 << 15)		/* Endpoint Enable/Disable */
+#define		AT91_UDP_RXBYTECNT	(0x7ff << 16)		/* Number of bytes in FIFO */
+
+#define AT91_UDP_FDR(n)		(0x50 + ((n) * 4))	/* Endpoint FIFO Data Registers 0-7 */
+
+#define AT91_UDP_TXVC		0x74		/* Transceiver Control Register */
+#define		AT91_UDP_TXVC_TXVDIS	(1 << 8)		/* Transceiver Disable */
+#define 	AT91_UDP_PUON        	(0x1 << 9 ) /**< (UDP) Pull-up ON */
+
+#ifdef DEBUG
+#define DBG(stuff...)		printk(KERN_DEBUG "udc: " stuff)
+#else
+#define DBG(stuff...)		do{}while(0)
+#endif
+
+#ifdef VERBOSE
+#    define VDBG		DBG
+#else
+#    define VDBG(stuff...)	do{}while(0)
+#endif
+
+#ifdef PACKET_TRACE
+#    define PACKET		VDBG
+#else
+#    define PACKET(stuff...)	do{}while(0)
+#endif
+
+#define ERR(stuff...)		printk(KERN_ERR "udc: " stuff)
+#define WARN(stuff...)		printk(KERN_WARNING "udc: " stuff)
+#define INFO(stuff...)		printk(KERN_INFO "udc: " stuff)
+
+#endif
+
diff -Nur linux-2.6.15.4-orig/drivers/usb/gadget/Kconfig linux-2.6.15.4/drivers/usb/gadget/Kconfig
--- linux-2.6.15.4-orig/drivers/usb/gadget/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/gadget/Kconfig	2006-08-09 16:46:53.000000000 +0200
@@ -187,6 +187,24 @@
 
 	   Select this only if your OMAP board has a Mini-AB connector.
 
+config USB_GADGET_AT91
+        boolean "AT91 USB Device Port"
+        depends on (ARCH_AT91RM9200 || MACH_AT91SAM9261EK || MACH_AT91SAM9260EK)
+        select USB_GADGET_SELECTED
+        help
+           Many Atmel AT91 processors (such as the AT91RM9200, AT91SAM9261, AT91SAM9260) have a
+           full speed USB Device Port with support for five configurable
+           endpoints (plus endpoint zero). 
+
+           Say "y" to link the driver statically, or "m" to build a 
+           dynamically linked module called "at91_udc" and force all
+           gadget drivers to also be dynamically linked.
+
+config USB_AT91
+        tristate
+        depends on USB_GADGET_AT91
+        default USB_GADGET
+
 
 config USB_GADGET_DUMMY_HCD
 	boolean "Dummy HCD (DEVELOPMENT)"
diff -Nur linux-2.6.15.4-orig/drivers/usb/gadget/Makefile linux-2.6.15.4/drivers/usb/gadget/Makefile
--- linux-2.6.15.4-orig/drivers/usb/gadget/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/gadget/Makefile	2006-08-09 10:45:15.000000000 +0200
@@ -7,6 +7,7 @@
 obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
 obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
 obj-$(CONFIG_USB_LH7A40X)	+= lh7a40x_udc.o
+obj-$(CONFIG_USB_AT91)	        += at91_udc.o
 
 #
 # USB gadget drivers
diff -Nur linux-2.6.15.4-orig/drivers/usb/host/Kconfig linux-2.6.15.4/drivers/usb/host/Kconfig
--- linux-2.6.15.4-orig/drivers/usb/host/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/host/Kconfig	2006-08-09 10:45:15.000000000 +0200
@@ -79,6 +79,13 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ohci-hcd.
 
+config USB_OHCI_HCD_AT91
+	tristate "Support for SAM926X familly OHCI HCD"
+	depends on USB_OHCI_HCD
+	default N
+	help
+	  Adds support to SAM926X familly (AT91SAM9261 and NADIA2) USB OHCI HCD.
+
 config USB_OHCI_HCD_PPC_SOC
 	bool "OHCI support for on-chip PPC USB controller"
 	depends on USB_OHCI_HCD && (STB03xxx || PPC_MPC52xx)
@@ -146,5 +153,4 @@
 	  REX-CFU1U CF card (often used with PDAs).  If unsure, say N.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called "sl811_cs".
-
+	  module will be called "sl811_cs".
\ No newline at end of file
diff -Nur linux-2.6.15.4-orig/drivers/usb/host/ohci-at91.c linux-2.6.15.4/drivers/usb/host/ohci-at91.c
--- linux-2.6.15.4-orig/drivers/usb/host/ohci-at91.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/host/ohci-at91.c	2006-08-09 10:58:40.000000000 +0200
@@ -0,0 +1,325 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * SAM926X familly Bus Glue
+ *
+ *  Copyright (C) 2004 SAN People (Pty) Ltd.
+ *  Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ * 
+ * AT91RM9200 Bus Glue
+ *
+ * Based on fragments of 2,4 driver by Rick Bronson.
+ * Based on ohci-omap.c
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+
+//#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#include <asm/arch/uhp.h>
+
+
+#define uhp_writel(hcd, reg, value)     \
+        writel((value), (hcd)->regs + UHP_##reg)
+
+#define uhp_readl(hcd, reg)             \
+        readl((hcd)->regs + UHP_##reg)
+
+
+
+extern int usb_disabled(void);
+
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+char chip_name[] = "AT91SAM9261";
+#elif  CONFIG_MACH_AT91SAM9260EK
+char chip_name[] = "AT91SAM9260";
+#elif  CONFIG_MACH_NADIA2VB
+char chip_name[] = "NADIA2";
+#else
+char chip_name[] = "SAM926X";
+#endif
+
+
+
+/*-------------------------------------------------------------------------*/
+
+static void at91_start_hc(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+  //struct usb_hcd *hcd = (struct usb_hcd *) dev_get_drvdata(&pdev->dev);
+	//void __iomem *ohci_regs = hcd->regs;
+
+	dev_dbg(&pdev->dev, "starting %s OHCI USB Controller\n", chip_name);
+
+	// Enable UHP clock
+	at91_uhp_clock_enable();
+
+	/*
+	 * Configure the power sense and control lines.  Place the USB
+	 * host controller in reset.
+	 */
+	//ohci_regs->UHP_HcControl = 0;
+	uhp_writel(hcd, HcControl, 0);
+
+	/* Take Hc out of reset */
+	//ohci_regs->UHP_HcControl = (2 << 6);		/* HCFS: '10b' -> USBOperational */
+	uhp_writel(hcd, HcControl, (2 << 6));
+}
+
+static void at91_stop_hc(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+  //struct usb_hcd *hcd = dev_get_drvdata(&pdev->dev);
+	//void __iomem *ohci_regs = hcd->regs;
+
+	dev_dbg(&pdev->dev, "stopping %s OHCI USB Controller\n", chip_name);
+
+	/*
+	 * Put the USB host controller into reset.
+	 */
+	//ohci_regs->UHP_HcControl = 0;
+	uhp_writel(hcd, HcControl, 0);
+
+	/*
+	 * Disable UHP clock.
+	 */
+	at91_uhp_clock_disable();
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int usb_hcd_at91_remove (struct usb_hcd *, struct platform_device *);
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_hcd_at91_probe - initialize SAM926X-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ * Store this function in the HCD's struct pci_driver as probe().
+ */
+int usb_hcd_at91_probe (const struct hc_driver *driver,
+			struct platform_device *pdev)
+{
+	int retval;
+	struct usb_hcd *hcd = NULL;
+
+	if (pdev->num_resources != 2) {
+		pr_debug("hcd probe: invalid num_resources");
+		return -ENODEV;
+	}
+
+	if ((pdev->resource[0].flags != IORESOURCE_MEM) || (pdev->resource[1].flags != IORESOURCE_IRQ)) {
+		pr_debug("hcd probe: invalid resource type\n");
+		return -ENODEV;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, chip_name);
+	if (!hcd)
+	  return -ENOMEM;
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed\n");
+		retval = -EIO;
+		goto err2;
+	}
+
+	at91_start_hc(hcd, pdev);
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, pdev->resource[1].start, SA_INTERRUPT);
+	if (retval == 0)
+		return retval;
+
+
+	/* Error handling */
+	at91_stop_hc(hcd, pdev);
+	iounmap(hcd->regs);
+
+ err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+ err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_at91_remove - shutdown processing for AT91SAM9261-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_at91_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+static int usb_hcd_at91_remove (struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	at91_stop_hc(hcd, pdev);
+	iounmap(hcd->regs);
+ 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+	dev_set_drvdata(&pdev->dev, NULL);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit ohci_at91_start (struct usb_hcd *hcd)
+{
+//	struct at91_ohci_data	*board = hcd->self.controller->platform_data;
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+//	hcd->self.root_hub->maxchild = board->ports;
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_at91_hc_driver = {
+	.description =		hcd_name,
+#ifdef CONFIG_MACH_AT91SAM9261EK
+	.product_desc =		"AT91SAM9261 OHCI",
+#elif  CONFIG_MACH_AT91SAM9260EK
+	.product_desc =		"AT91SAM9260 OHCI",
+#elif  CONFIG_MACH_NADIA2VB
+	.product_desc =		"NADIA2 OHCI",
+#else
+	.product_desc =		"SAM926X OHCI",
+#endif
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_at91_start,
+	.stop =			ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+
+#ifdef CONFIG_PM
+	.hub_suspend =		ohci_hub_suspend,
+	.hub_resume =		ohci_hub_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_at91_drv_probe(struct device *dev)
+{
+	return usb_hcd_at91_probe(&ohci_at91_hc_driver, to_platform_device(dev));
+}
+
+static int ohci_hcd_at91_drv_remove(struct device *dev)
+{
+	return usb_hcd_at91_remove(dev_get_drvdata(dev), to_platform_device(dev));
+}
+
+//#ifdef CONFIG_PM
+
+static int ohci_hcd_at91_drv_suspend(struct device *dev, pm_message_t state)
+{
+  //	struct platform_device *pdev = to_platform_device(dev);
+  //	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	printk("%s(%s:%d): not implemented yet\n",
+		__func__, __FILE__, __LINE__);
+
+	return 0;
+}
+
+static int ohci_hcd_at91_drv_resume(struct device *dev)
+{
+//	struct platform_device *pdev = to_platform_device(dev);
+//	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	printk("%s(%s:%d): not implemented yet\n",
+		__func__, __FILE__, __LINE__);
+
+	return 0;
+}
+
+//#endif
+
+static struct device_driver ohci_hcd_at91_driver = {
+	.name		= "usb-ohci",
+	.bus		= &platform_bus_type,
+	.probe		= ohci_hcd_at91_drv_probe,
+	.remove		= ohci_hcd_at91_drv_remove,
+	//#ifdef CONFIG_PM
+	.suspend	= ohci_hcd_at91_drv_suspend,
+	.resume		= ohci_hcd_at91_drv_resume,
+	//#endif
+};
+
+static int __init ohci_hcd_at91_init (void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return driver_register(&ohci_hcd_at91_driver);
+}
+
+static void __exit ohci_hcd_at91_cleanup (void)
+{
+	driver_unregister(&ohci_hcd_at91_driver);
+}
+
+module_init (ohci_hcd_at91_init);
+module_exit (ohci_hcd_at91_cleanup);
diff -Nur linux-2.6.15.4-orig/drivers/usb/host/ohci-hcd.c linux-2.6.15.4/drivers/usb/host/ohci-hcd.c
--- linux-2.6.15.4-orig/drivers/usb/host/ohci-hcd.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/host/ohci-hcd.c	2006-08-09 10:58:28.000000000 +0200
@@ -917,6 +917,10 @@
 #include "ohci-ppc-soc.c"
 #endif
 
+#ifdef CONFIG_USB_OHCI_HCD_AT91 
+#include "ohci-at91.c"
+#endif
+
 #if !(defined(CONFIG_PCI) \
       || defined(CONFIG_SA1111) \
       || defined(CONFIG_ARCH_S3C2410) \
@@ -925,6 +929,9 @@
       || defined (CONFIG_PXA27x) \
       || defined (CONFIG_SOC_AU1X00) \
       || defined (CONFIG_USB_OHCI_HCD_PPC_SOC) \
+      || defined (CONFIG_MACH_NADIA2VB)      \
+      || defined (CONFIG_MACH_AT91SAM9261EK)  \
+      || defined (CONFIG_MACH_AT91SAM9260EK)  \
 	)
 #error "missing bus glue for ohci-hcd"
 #endif
diff -Nur linux-2.6.15.4-orig/drivers/usb/Kconfig linux-2.6.15.4/drivers/usb/Kconfig
--- linux-2.6.15.4-orig/drivers/usb/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/usb/Kconfig	2006-08-09 10:57:16.000000000 +0200
@@ -22,6 +22,9 @@
 	default y if ARCH_LH7A404
 	default y if ARCH_S3C2410
 	default y if PXA27x
+	default y if MACH_AT91SAM9261EK
+	default y if MACH_AT91SAM9260EK
+	default y if MACH_NADIA2VB
 	# PPC:
 	default y if STB03xxx
 	default y if PPC_MPC52xx
diff -Nur linux-2.6.15.4-orig/drivers/video/Kconfig linux-2.6.15.4/drivers/video/Kconfig
--- linux-2.6.15.4-orig/drivers/video/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/video/Kconfig	2006-08-09 10:45:33.000000000 +0200
@@ -193,6 +193,52 @@
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 
+config FB_SIDSA
+        tristate "SIDSA LCDC support"
+        depends on FB && ARM && (MACH_AT91SAM9261EK || MACH_NADIA2VB)
+        select FB_CFB_FILLRECT
+        select FB_CFB_COPYAREA
+        select FB_CFB_IMAGEBLIT
+        help
+          This enables support for the SIDSA LCD Controller.
+
+config FB_TCM
+        bool "Frame Buffer in TCM"
+        depends on FB_SIDSA 
+        help
+          This enables to map Frame Buffer in Internal SRAM. Say N if you want frame buffer in SDRAM.
+
+config FB_SDRAM
+        bool "Frame Buffer in SDRAM"
+        depends on FB_SIDSA
+        help
+          This enables to map Frame Buffer in SDRAM. Say N if you want frame buffer in internal SRAM.
+
+config TFT_AT91
+        bool "TX09D050VM1CCA display support"
+        depends on FB_SIDSA && (MACH_AT91SAM9261EK || MACH_NADIA2VB)
+        help
+          This enables support for TX09D050VM1CCA Color Display
+
+config FB_SIDSA_DEFAULT_BPP
+        int "SIDSA LCDC default color depth"
+        default 16
+        depends on FB_SIDSA
+        help
+          Specify the maximum color depth you want to be able to
+          support. This, together with the resolution of the LCD
+          panel, determines the amount of framebuffer memory allocated
+          when the driver is initialized.
+
+          Allowable values are 1, 2, 4, 8, 16, 24. If unsure,
+          say 16.
+
+config FB_SIDSA_DEBUG
+        bool "SIDSA framebuffer driver debug mode "
+        depends on FB_SIDSA
+        help
+          Enables Debug mode
+
 config FB_CYBER2000
 	tristate "CyberPro 2000/2010/5000 support"
 	depends on FB && PCI && (BROKEN || !SPARC64)
diff -Nur linux-2.6.15.4-orig/drivers/video/Makefile linux-2.6.15.4/drivers/video/Makefile
--- linux-2.6.15.4-orig/drivers/video/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/drivers/video/Makefile	2006-08-09 10:45:35.000000000 +0200
@@ -94,6 +94,11 @@
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
+obj-$(CONFIG_FB_SIDSA)            += sidsafb.o
+
+ifeq ($(CONFIG_FB_SIDSA_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_VESA)             += vesafb.o
diff -Nur linux-2.6.15.4-orig/drivers/video/sidsafb.c linux-2.6.15.4/drivers/video/sidsafb.c
--- linux-2.6.15.4-orig/drivers/video/sidsafb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/video/sidsafb.c	2006-08-09 10:45:33.000000000 +0200
@@ -0,0 +1,890 @@
+/*
+ *  linux/drivers/video/sidsafb.c
+ *
+ *  Driver for SIDSA LCD Controller IP
+ *
+ *  Copyright (C) 2004 Atmel Norway AS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#undef DEBUG
+#undef IO_DEBUG
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/hardware.h>
+#include <asm/platform.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/lcdc.h>
+
+#include "sidsafb.h"
+
+
+#define LCDC_PUT_BA1(sinfo,v)		writel(v, ((sinfo)->mmio + LCDC_BA1))
+#define LCDC_GET_FRMCFG(sinfo)		readl((sinfo)->mmio + LCDC_FRMCFG)
+#define LCDC_PUT_FRMCFG(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_FRMCFG))
+#define LCDC_GET_DMACON(sinfo)		readl((sinfo)->mmio + LCDC_DMACON)
+#define LCDC_PUT_DMACON(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_DMACON))
+#define LCDC_GET_DMA2DCFG(sinfo)	readl((sinfo)->mmio + LCDC_DMA2DCFG)
+#define LCDC_PUT_DMA2DCFG(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_DMA2DCFG))
+#define LCDC_GET_LCDCON1(sinfo)		readl((sinfo)->mmio + LCDC_LCDCON1)
+#define LCDC_PUT_LCDCON1(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_LCDCON1))
+#define LCDC_GET_LCDCON2(sinfo)		readl((sinfo)->mmio + LCDC_LCDCON2)
+#define LCDC_PUT_LCDCON2(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_LCDCON2))
+#define LCDC_GET_TIM1(sinfo)		readl((sinfo)->mmio + LCDC_TIM1)
+#define LCDC_PUT_TIM1(sinfo,v)		writel(v, ((sinfo)->mmio + LCDC_TIM1))
+#define LCDC_GET_TIM2(sinfo)		readl((sinfo)->mmio + LCDC_TIM2)
+#define LCDC_PUT_TIM2(sinfo,v)		writel(v, ((sinfo)->mmio + LCDC_TIM2))
+#define LCDC_GET_LCDFRCFG(sinfo)	readl((sinfo)->mmio + LCDC_LCDFRCFG)
+#define LCDC_PUT_LCDFRCFG(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_LCDFRCFG))
+#define LCDC_GET_FIFO(sinfo)		readl((sinfo)->mmio + LCDC_FIFO)
+#define LCDC_PUT_FIFO(sinfo,v)		writel(v, ((sinfo)->mmio + LCDC_FIFO))
+#define LCDC_GET_MVAL(sinfo)		readl((sinfo)->mmio + LCDC_MVAL)
+#define LCDC_PUT_MVAL(sinfo,v)		writel(v, ((sinfo)->mmio + LCDC_MVAL))
+#define LCDC_GET_PWRCON(sinfo)		readl((sinfo)->mmio + LCDC_PWRCON)
+#define LCDC_PUT_PWRCON(sinfo,v)	writel(v, (sinfo)->mmio + LCDC_PWRCON)
+#define LCDC_GET_CTRSTCON(sinfo)	readl((sinfo)->mmio + LCDC_CTRSTCON)
+#define LCDC_PUT_CTRSTCON(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_CTRSTCON))
+#define LCDC_GET_CTRSTVAL(sinfo)	readl((sinfo)->mmio + LCDC_CTRSTVAL)
+#define LCDC_PUT_CTRSTVAL(sinfo,v)	writel(v, ((sinfo)->mmio + LCDC_CTRSTVAL))
+#define LCDC_PUT_IDR(sinfo,v)		writel(v, ((sinfo)->mmio + LCDC_IDR))
+#define LCDC_GET_IMR(sinfo)		readl((sinfo)->mmio + LCDC_IMR)
+#define LCDC_PUT_ICR(sinfo,v)		writel(v, ((sinfo)->mmio + LCDC_ICR))
+#define LCDC_GET_LUT_ENTRYx(sinfo,addr)	readl((sinfo)->mmio + LCDC_LUT_ENTRY + (addr<<2))
+#define LCDC_PUT_LUT_ENTRYx(sinfo,addr,v) writel(v, ((sinfo)->mmio + LCDC_LUT_ENTRY + (addr<<2)))
+
+
+#ifdef  CONFIG_TFT_AT91
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+	        .name           = "TX09D50VM1CCA",
+		.refresh	= 60,
+		.xres		= 240,		.yres		= 320,
+		.pixclock	= 4965000,
+
+		.left_margin	= 1,		.right_margin	= 33,
+		.upper_margin	= 1,		.lower_margin	= 0,
+		.hsync_len	= 5,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+#else
+static struct fb_videomode vga_modes[] = {
+	{
+		.refresh	= 48,
+		.xres		= 320,		.yres		= 200,
+		.pixclock	= 80000,
+
+		.left_margin	= 10,		.right_margin	= 30,
+		.upper_margin	= 70,		.lower_margin	= 30,
+		.hsync_len	= 30,		.vsync_len	= 3,
+
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+#endif
+
+static struct fb_monspecs default_monspecs = {
+#ifdef  CONFIG_TFT_AT91
+        .modedb		= at91_tft_vga_modes,
+#else
+	.modedb		= vga_modes,
+#endif
+	.manufacturer	= "VGA",
+	.monitor	= "Generic VGA",
+	.serial_no	= "xxxx",
+	.ascii		= "yyyy",
+#ifdef  CONFIG_TFT_AT91
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+#else
+	.modedb_len	= ARRAY_SIZE(vga_modes),
+#endif
+	.hfmin		= 15000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+
+
+/* Driver defaults */
+static struct fb_fix_screeninfo sidsafb_fix __devinitdata = {
+	.id		= "sidsafb",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_TRUECOLOR,
+	.xpanstep	= 0,
+	.ypanstep	= 0,
+	.ywrapstep	= 0,
+	.accel		= FB_ACCEL_NONE,
+};
+
+
+// Make sure we map TCM only once and not at every 
+// sidsafb_resize_framebuffer call.
+#ifdef CONFIG_FB_TCM
+static unsigned int first_time_tcm_map = 1;
+#endif
+
+
+
+static void sidsafb_update_dma(struct fb_info *info,
+			       struct fb_var_screeninfo *var)
+{
+	struct sidsafb_info *sinfo = info->par;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	unsigned long dma_addr;
+	unsigned long pixeloff;
+
+	dma_addr = (fix->smem_start + var->yoffset * fix->line_length
+		    + var->xoffset * var->bits_per_pixel / 8);
+	
+	dma_addr &= ~3UL;
+	pixeloff = (var->xoffset * var->bits_per_pixel) & 31;
+
+	/* Set framebuffer DMA base address and pixel offset */
+	LCDC_PUT_BA1(sinfo, dma_addr);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_BA1));
+
+#ifdef CONFIG_MACH_NADIA2VB
+	pixeloff <<= 24;
+	pixeloff |= LCDC_GET_DMA2DCFG(sinfo) & 0xffff;
+
+	LCDC_PUT_DMA2DCFG(sinfo,pixeloff);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_DMA2DCFG));
+
+	/* Update configuration */
+	LCDC_PUT_DMACON(sinfo, (LCDC_GET_DMACON(sinfo) | AT91C_LCDC_DMAUPDT));
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_DMACON));
+#endif
+
+}
+
+
+/**
+ *	sidsafb_resize_framebuffer - Allocate framebuffer memory
+ *	@sinfo: the frame buffer to allocate memory for
+ *
+ *	Checks if the required framebuffer size has changed. If so, it
+ *	deallocates any existing framebuffer and allocates a new one
+ *	of the right size.
+ *
+ *	The LCD controller must be disabled, and interrupts globally
+ *	enabled when this function is called.
+ *
+ *	Returns -ENOMEM if the new framebuffer could not be allocated,
+ *	zero if no reallocation was necessary or one otherwise.
+ */
+static int sidsafb_resize_framebuffer(struct sidsafb_info *sinfo)
+{
+	struct fb_info *info = sinfo->info;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	unsigned int new_size;
+	dma_addr_t new_paddr;
+	void *new_vaddr;
+	
+	new_size = (var->xres_virtual * var->yres_virtual
+		    * ((var->bits_per_pixel + 7) / 8));
+
+	if (new_size == fix->smem_len)
+	        return 0;
+
+#ifdef CONFIG_FB_TCM
+	if (new_size > AT91C_IRAM_SIZE)
+	        return -ENOMEM; 
+#endif
+
+#ifdef CONFIG_FB_SDRAM
+	if (fix->smem_len)
+		dma_free_coherent(&sinfo->pdev->dev,
+				  fix->smem_len, info->screen_base,
+				  fix->smem_start);
+#endif
+	
+	fix->smem_len = 0;
+	
+	pr_debug("About to allocate frame buffer (%u bytes)...\n", new_size);
+
+#ifdef CONFIG_FB_TCM
+	new_paddr = (dma_addr_t)AT91C_IRAM_BASE;
+	
+	if (first_time_tcm_map) {
+		new_vaddr = ioremap((unsigned long)new_paddr, AT91C_IRAM_SIZE);
+		first_time_tcm_map--;
+	} else
+		new_vaddr = info->screen_base;
+#endif
+
+#ifdef CONFIG_FB_SDRAM
+	new_vaddr = dma_alloc_coherent(&sinfo->pdev->dev, new_size,
+				       &new_paddr, GFP_KERNEL);
+#endif
+
+	if (!new_vaddr)
+		return -ENOMEM;
+
+	info->screen_base = new_vaddr;
+	fix->smem_start = new_paddr;
+	fix->smem_len = new_size;
+	fix->line_length = var->xres_virtual * (var->bits_per_pixel / 8);
+
+	printk(KERN_INFO
+	       "sidsafb: %luKiB frame buffer at %08lx (mapped at %p)\n",
+	       (unsigned long)info->fix.smem_len / 1024,
+	       (unsigned long)info->fix.smem_start,
+	       info->screen_base);
+
+	return 1;
+}
+
+/**
+ *      sidsafb_check_var - Validates a var passed in. 
+ *      @var: frame buffer variable screen structure
+ *      @info: frame buffer structure that represents a single frame buffer 
+ *
+ *	Checks to see if the hardware supports the state requested by
+ *	var passed in. This function does not alter the hardware
+ *	state!!!  This means the data stored in struct fb_info and
+ *	struct sidsafb_info do not change. This includes the var
+ *	inside of struct fb_info.  Do NOT change these. This function
+ *	can be called on its own if we intent to only test a mode and
+ *	not actually set it. The stuff in modedb.c is a example of
+ *	this. If the var passed in is slightly off by what the
+ *	hardware can support then we alter the var PASSED in to what
+ *	we can do. If the hardware doesn't support mode change a
+ *	-EINVAL will be returned by the upper layers. You don't need
+ *	to implement this function then. If you hardware doesn't
+ *	support changing the resolution then this function is not
+ *	needed. In this case the driver would just provide a var that
+ *	represents the static state the screen is in.
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int sidsafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	pr_debug("sidsafb_check_var:\n");
+	pr_debug("  resolution: %ux%u\n", var->xres, var->yres);
+	pr_debug("  pixclk:     %lu Hz\n", var->pixclock);
+	pr_debug("  bpp:        %u\n", var->bits_per_pixel);
+
+	if ((var->pixclock * var->bits_per_pixel / 8) > AT91C_MASTER_CLOCK) {
+		printk(KERN_NOTICE "sidsafb: %u Hz pixel clock is too fast\n",
+		       var->pixclock);
+		return -EINVAL;
+	}
+
+	/* Force same alignment for each line */
+	var->xres = (var->xres + 3) & ~3UL;
+	var->xres_virtual = (var->xres_virtual + 3) & ~3UL;
+
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
+	var->transp.offset = var->transp.length = 0;
+
+	switch (var->bits_per_pixel) {
+	case 2:
+	case 4:
+	case 8:
+		var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length
+			= var->bits_per_pixel;
+		break;
+	case 16:
+		var->red.offset = 0;
+		var->green.offset = 5;
+		var->blue.offset = 10;
+		var->transp.offset = 15;
+		var->red.length = 5;
+		var->green.length = 5;
+		var->blue.length = 5;
+		var->transp.length = 1;
+		break;
+	case 24:
+	case 32:
+		var->red.offset = 16;
+		var->green.offset = 8;
+		var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length = 8;
+		break;
+	default:
+		printk(KERN_NOTICE "sidsafb: color depth %d not supported\n",
+		       var->bits_per_pixel);
+		return -EINVAL;
+	}
+	
+	var->xoffset = var->yoffset = 0;
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right =
+		var->transp.msb_right = 0;
+
+	return 0;
+}
+
+/**
+ *      sidsafb_set_par - Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Using the fb_var_screeninfo in fb_info we set the resolution
+ *	of the this particular framebuffer. This function alters the
+ *	par AND the fb_fix_screeninfo stored in fb_info. It doesn't
+ *	not alter var in fb_info since we are using that data. This
+ *	means we depend on the data in var inside fb_info to be
+ *	supported by the hardware.  sidsafb_check_var is always called
+ *	before sidsafb_set_par to ensure this.  Again if you can't
+ *	change the resolution you don't need this function.
+ *
+ */
+static int sidsafb_set_par(struct fb_info *info)
+{
+	struct sidsafb_info *sinfo = info->par;
+	unsigned long value;
+	int ret;
+
+	pr_debug("sidsafb_set_par:\n");
+	pr_debug("  * resolution: %ux%u (%ux%u virtual)\n",
+		 info->var.xres, info->var.yres,
+		 info->var.xres_virtual, info->var.yres_virtual);
+
+	/* Turn off the LCD controller and the DMA controller */
+	LCDC_PUT_PWRCON(sinfo, sinfo->guard_time << 1);
+	
+	LCDC_PUT_DMACON(sinfo, 0);
+
+	/* Reset LCDC DMA*/
+	LCDC_PUT_DMACON(sinfo, AT91C_LCDC_DMARST);
+
+	pr_debug("  * resize framebuffer\n");
+	ret = sidsafb_resize_framebuffer(info->par);
+	if (ret < 0)
+		return ret;
+
+	if (info->var.bits_per_pixel <= 8)
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	/* Re-initialize the DMA engine... */
+	pr_debug("  * update DMA engine\n");
+	sidsafb_update_dma(info, &info->var);
+
+	/* ...set frame size and burst length = 8 words (?) */
+	value = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;
+	value |= ((SIDSAFB_DMA_BURST_LEN - 1) << 24);
+	LCDC_PUT_FRMCFG(sinfo,value);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_FRMCFG));
+	
+#ifdef CONFIG_MACH_NADIA2VB
+	/* ...set 2D configuration (necessary for xres_virtual != xres) */
+	value = (info->var.xres_virtual - info->var.xres) / 4;
+	LCDC_PUT_DMA2DCFG(sinfo,value);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_DMA2DCFG));
+#endif
+
+	
+	/* Now, the LCD core... */
+
+	/* Set pixel clock */	
+	value = AT91C_MASTER_CLOCK / info->var.pixclock;
+
+	if (AT91C_MASTER_CLOCK % info->var.pixclock)
+		value++;
+
+	value = (value / 2) - 1;
+
+	if (!value) {
+		printk("sidsafb: Bypassing lcdc_pclk divider\n");
+		LCDC_PUT_LCDCON1(sinfo, AT91C_LCDC_BYPASS);
+	} else
+		LCDC_PUT_LCDCON1(sinfo, value << 12);
+	
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_LCDCON1));
+
+	/* Initialize control register 2 */
+#ifdef  CONFIG_TFT_AT91
+	value = ( AT91C_LCDC_MEMOR_LITTLEIND |
+		  AT91C_LCDC_DISTYPE_TFT | AT91C_LCDC_IFWIDTH_SIXTEENBITSWIDTH | 
+		  AT91C_LCDC_CLKMOD);
+#endif
+
+	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+		value |= 1 << 10;	/* INVLINE */
+	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+		value |= 1 << 9;	/* INVFRAME */
+
+	switch (info->var.bits_per_pixel) {
+		case 1:	value |= 0 << 5; break;
+		case 2: value |= 1 << 5; break;
+		case 4: value |= 2 << 5; break;
+		case 8: value |= 3 << 5; break;
+		case 16: value |= 4 << 5; break;
+		case 24: value |= 5 << 5; break;
+		case 32: value |= 6 << 5; break;
+		default: BUG(); break;
+	}
+	pr_debug("  * LCDCON2 = %08lx\n", value);
+	LCDC_PUT_LCDCON2(sinfo,value);	
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_LCDCON2));
+
+	/* Vertical timing */
+	value = (info->var.vsync_len - 1) << 16;
+	value |= info->var.upper_margin << 8;
+	value |= info->var.lower_margin;
+	pr_debug("  * LCDTIM1 = %08lx\n", value);
+	LCDC_PUT_TIM1(sinfo,value);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_TIM1));
+
+	/* Horizontal timing */
+	value = (info->var.right_margin - 1) << 21;
+	value |= (info->var.hsync_len - 1) << 8;
+	value |= (info->var.left_margin - 1);
+	pr_debug("  * LCDTIM2 = %08lx\n", value);
+	LCDC_PUT_TIM2(sinfo,value);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_TIM2));
+
+	/* Display size */
+	value = (info->var.xres - 1) << 21;
+	value |= info->var.yres - 1;
+
+	LCDC_PUT_LCDFRCFG(sinfo,value);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_LCDFRCFG));
+
+	/* FIFO Threshold: Use formula from data sheet */
+	value = SIDSAFB_FIFO_SIZE - (2 * SIDSAFB_DMA_BURST_LEN + 3);
+	LCDC_PUT_FIFO(sinfo,value);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_FIFO));
+
+	/* Toggle LCD_MODE every frame */
+	value = 0;
+	LCDC_PUT_MVAL(sinfo,value);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_MVAL));
+
+	/* Disable all interrupts */
+	LCDC_PUT_IDR(sinfo,~0UL);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_IMR));
+
+	// Set contrast
+	value = AT91C_LCDC_PS_DIVIDEDBYEIGHT | AT91C_LCDC_POL_POSITIVEPULSE | AT91C_LCDC_ENA_PWMGEMENABLED;
+	LCDC_PUT_CTRSTCON(sinfo,value);
+	LCDC_PUT_CTRSTVAL(sinfo,SIDSAFB_CRST_VAL);
+	/* ...wait for DMA engine to become idle... */
+	while (LCDC_GET_DMACON(sinfo) & AT91C_LCDC_DMABUSY)
+		msleep(10);
+
+	pr_debug("  * re-enable DMA engine\n");
+	/* ...and enable it with updated configuration */
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+	LCDC_PUT_DMACON(sinfo,AT91C_LCDC_DMAEN);
+#elif  CONFIG_MACH_NADIA2VB
+	LCDC_PUT_DMACON(sinfo,(AT91C_LCDC_DMAEN | AT91C_LCDC_DMAUPDT | AT91C_LCDC_DMA2DEN));
+	//LCDC_PUT_DMACON(sinfo,AT91C_LCDC_DMAEN);
+#else
+#error No ATMEL MACH is selected
+#endif
+
+	/* TODO : remove msleep and replace it with a timer otherwise the core is stuck */
+	/* Wait for the LCDC core to become idle and enable it */
+	/*
+	while(readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_PWRCON)) & AT91C_LCDC_BUSY_LCDBUSY)
+		msleep(10);
+	*/
+
+	pr_debug("  * re-enable LCD core\n");
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_PWRCON));
+
+	LCDC_PUT_PWRCON(sinfo,(sinfo->guard_time << 1) | AT91C_LCDC_PWR);
+
+	/* TODO : remove msleep and replace it with a timer otherwise the core is stuck */
+	/* Wait for the LCDC core to become idle and enable it */
+	//while(readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_PWRCON)) & AT91C_LCDC_BUSY_LCDBUSY)
+	msleep(10);
+
+	//lcdc_debug_readl(&(((AT91PS_LCDC)sinfo->mmio)->LCDC_PWRCON));
+
+	pr_debug("  * DONE\n");
+
+	return 0;
+}
+
+static inline u_int chan_to_field(u_int chan, const struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+/**
+ *  	sidsafb_setcolreg - Optional function. Sets a color register.
+ *      @regno: Which register in the CLUT we are programming 
+ *      @red: The red value which can be up to 16 bits wide 
+ *	@green: The green value which can be up to 16 bits wide 
+ *	@blue:  The blue value which can be up to 16 bits wide.
+ *	@transp: If supported the alpha value which can be up to 16 bits wide.	
+ *      @info: frame buffer info structure
+ * 
+ *  	Set a single color register. The values supplied have a 16 bit
+ *  	magnitude which needs to be scaled in this function for the hardware. 
+ *	Things to take into consideration are how many color registers, if
+ *	any, are supported with the current color visual. With truecolor mode
+ *	no color palettes are supported. Here a psuedo palette is created 
+ *	which we store the value in pseudo_palette in struct fb_info. For
+ *	pseudocolor mode we have a limited color palette. To deal with this
+ *	we can program what color is displayed for a particular pixel value.
+ *	DirectColor is similar in that we can program each color field. If
+ *	we have a static colormap we don't need to implement this function. 
+ * 
+ *	Returns negative errno on error, or zero on success. In an
+ *	ideal world, this would have been the case, but as it turns
+ *	out, the other drivers return 1 on failure, so that's what
+ *	we're going to do.
+ */
+static int sidsafb_setcolreg(unsigned int regno, unsigned int red,
+			     unsigned int green, unsigned int blue,
+			     unsigned int transp, struct fb_info *info)
+{
+	struct sidsafb_info *sinfo = info->par;
+	unsigned int val;
+	u32 *pal;
+	int ret = 1;
+
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green
+				      + 7471 * blue) >> 16;
+	
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		if (regno < 16) {
+			pal = info->pseudo_palette;
+			
+			val  = chan_to_field(red, &info->var.red);
+			val |= chan_to_field(green, &info->var.green);
+			val |= chan_to_field(blue, &info->var.blue);
+			val |= chan_to_field(transp, &info->var.transp);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < 256) {
+			val  = ((red   >> 11) & 0x001f);
+			val |= ((green >>  6) & 0x03e0);
+			val |= ((blue  >>  1) & 0x7c00);
+			
+			/*
+			 * TODO: intensity bit. Maybe something like
+			 *   ~(red[10] ^ green[10] ^ blue[10]) & 1
+			 */
+
+			LCDC_PUT_LUT_ENTRYx(sinfo,regno,val);
+			ret = 0;
+		}
+		break;
+	}
+	
+	return ret;
+}
+
+static int sidsafb_pan_display(struct fb_var_screeninfo *var,
+			       struct fb_info *info)
+{
+	pr_debug("sidsafb_pan_display\n");
+
+	sidsafb_update_dma(info, var);
+
+	return 0;
+}
+
+static struct fb_ops sidsafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= sidsafb_check_var,
+	.fb_set_par	= sidsafb_set_par,
+	.fb_setcolreg	= sidsafb_setcolreg,
+	.fb_pan_display	= sidsafb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+//	.fb_cursor	= soft_cursor,
+};
+
+static irqreturn_t sidsafb_interrupt(int irq, void *dev_id,
+				   struct pt_regs *regs)
+{
+	struct fb_info *info = dev_id;
+	struct sidsafb_info *sinfo = info->par;
+
+	pr_debug("sidsafb: DMA End Of Frame interrupt\n");
+
+	LCDC_PUT_ICR(sinfo,AT91C_LCDC_EOFI);
+	wake_up(&sinfo->vsync_wait);
+
+	return IRQ_HANDLED;
+}
+
+static void __devinit init_pseudo_palette(u32 *palette)
+{
+	static const u32 init_palette[16] = {
+		0x000000,
+		0xaa0000,
+		0x00aa00,
+		0xaa5500,
+		0x0000aa,
+		0xaa00aa,
+		0x00aaaa,
+		0xaaaaaa,
+		0x555555,
+		0xff5555,
+		0x55ff55,
+		0xffff55,
+		0x5555ff,
+		0xff55ff,
+		0x55ffff,
+		0xffffff
+	};
+
+	memcpy(palette, init_palette, sizeof(init_palette));
+}
+
+static int __devinit sidsafb_set_fbinfo(struct sidsafb_info *sinfo)
+{
+	struct fb_info *info = sinfo->info;
+
+	init_pseudo_palette(sinfo->pseudo_palette);
+
+	info->flags		= (FBINFO_DEFAULT
+				   | FBINFO_PARTIAL_PAN_OK
+				   | FBINFO_HWACCEL_XPAN
+				   | FBINFO_HWACCEL_YPAN);
+	memcpy(&info->fix, &sidsafb_fix, sizeof(info->fix));
+	memcpy(&info->monspecs, &default_monspecs, sizeof(info->monspecs));
+	info->fbops		= &sidsafb_ops;
+//	info->currcon		= -1;
+	info->pseudo_palette	= sinfo->pseudo_palette;
+
+	init_waitqueue_head(&sinfo->vsync_wait);
+
+	return 0;
+}
+
+static int __devinit sidsafb_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fb_info *info;
+	struct sidsafb_info *sinfo;
+	int ret;
+	
+	pr_debug("sidsafb_probe BEGIN\n");
+
+	ret = -ENOMEM;
+	info = framebuffer_alloc(sizeof(struct sidsafb_info), dev);
+	if (!info) {
+		printk(KERN_ERR "sidsafb: Could not allocate memory\n");
+		goto out;
+	}
+
+	sinfo = info->par;
+	sinfo->info = info;
+	sinfo->pdev = pdev;
+
+#ifdef  CONFIG_TFT_AT91
+	sinfo->guard_time = 1;
+#endif
+
+	/* Sanity check resources */
+	if ((pdev->num_resources < 2)
+	    || !(platform_resource_flags(pdev, 0) & IORESOURCE_MEM)
+	    || !(platform_resource_flags(pdev, 1) & IORESOURCE_IRQ)) {
+		ret = -ENODEV;
+		printk(KERN_ERR "sidsafb: Resources are unusable.\n");
+		goto free_info;
+	}
+
+	spin_lock_init(&sinfo->lock);
+	sidsafb_set_fbinfo(sinfo);
+	info->fix.mmio_start = platform_resource_start(pdev, 0);
+	info->fix.mmio_len = platform_resource_len(pdev, 0);
+	sinfo->irq_base = platform_resource_start(pdev, 1);
+
+	ret = fb_find_mode(&info->var, info, NULL, info->monspecs.modedb,
+			   info->monspecs.modedb_len, info->monspecs.modedb,
+			   CONFIG_FB_SIDSA_DEFAULT_BPP);
+
+	if (!ret) {
+		printk(KERN_ERR "sidsafb: No suitable video mode found\n");
+		goto free_info;
+	}
+
+	ret = sidsafb_resize_framebuffer(sinfo);
+	if (ret < 0)
+		goto free_info;
+
+	sinfo->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);
+	if (!sinfo->mmio) {
+		printk(KERN_ERR "sidsafb: Could not map LCDC registers\n");
+		goto free_fb;
+	}
+
+	ret = request_irq(sinfo->irq_base, sidsafb_interrupt, 0, "sidsa-lcdc", info);
+	if (ret)
+		goto unmap_mmio;
+
+	/* Allocate colormap */
+	if (fb_alloc_cmap(&info->cmap, 256, 0)) {
+		ret = -ENOMEM;
+		goto unregister_irqs;
+	}
+
+	/* Configure PIO for LCDC */
+	at91_device_pio_setup ((struct at91_pioline *)dev->platform_data);	
+	
+	/* Enable LCDC Clock */
+	at91_lcdc_clock_enable ();
+
+	// Power up the LCD screen
+	at91_lcdc_power_up ();
+
+
+	/*
+	 * Tell the world that we're ready to go
+	 */
+	ret = register_framebuffer(info);
+	if (ret)
+		goto free_cmap;
+
+	dev_set_drvdata(dev, info);
+
+	memset(info->screen_base, 0, info->fix.smem_len);
+	info->var.activate |= FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;
+	ret = fb_set_var(info, &info->var);
+	if (ret)
+		printk(KERN_WARNING
+		       "sidsafb: Unable to set display parameters\n");
+	info->var.activate &= ~(FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW);
+
+	pr_debug("sidsafb_probe SUCCESS\n");
+
+	printk(KERN_INFO "sidsafb: Driver $Revision: 1.2 $\n");
+
+	return 0;
+
+
+free_cmap:
+	fb_dealloc_cmap(&info->cmap);
+unregister_irqs:
+	free_irq(sinfo->irq_base, info);
+unmap_mmio:
+	iounmap(sinfo->mmio);
+free_fb:
+#ifdef CONFIG_FB_SDRAM
+	dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
+			  info->fix.smem_start);
+#endif
+
+#ifdef CONFIG_FB_TCM
+	iounmap(info->screen_base);
+	first_time_tcm_map++;
+#endif
+
+free_info:
+	framebuffer_release(info);
+out:
+	pr_debug("sidsafb_probe FAILED\n");
+	return ret;
+}
+
+static int __devexit sidsafb_remove(struct device *dev)
+{
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct sidsafb_info *sinfo = info->par;
+	unsigned long flags;
+
+	if (!sinfo)
+		return 0;
+
+	spin_lock_irqsave(&sinfo->lock, flags);
+	/* TODO: Restore original state */
+	unregister_framebuffer(info);
+	spin_unlock_irqrestore(&sinfo->lock, flags);
+
+	fb_dealloc_cmap(&info->cmap);
+	free_irq(sinfo->irq_base, info);
+	iounmap(sinfo->mmio);
+
+	// Power down LCD screen
+	at91_lcdc_power_down();
+
+	// Disable LCDC clock
+	at91_lcdc_clock_disable();
+
+#ifdef CONFIG_FB_SDRAM
+	dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
+			  info->fix.smem_start);
+#endif
+
+#ifdef CONFIG_FB_TCM
+	iounmap(info->screen_base);
+	first_time_tcm_map++;
+#endif
+	dev_set_drvdata(dev, NULL);
+	framebuffer_release(info);
+	return 0;
+}
+
+static struct device_driver sidsafb_driver = {
+	.name		= "sidsa-lcdc",
+	.bus		= &platform_bus_type,
+	.probe		= sidsafb_probe,
+	.remove		= __devexit_p(sidsafb_remove),
+};
+
+int __init sidsafb_init(void)
+{	
+	return driver_register(&sidsafb_driver);
+}
+
+static void __exit sidsafb_exit(void)
+{
+	driver_unregister(&sidsafb_driver);
+}
+
+module_init(sidsafb_init);
+module_exit(sidsafb_exit);
+
+MODULE_AUTHOR("Atmel Norway AS");
+MODULE_DESCRIPTION("SIDSA LCD Controller framebuffer driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.15.4-orig/drivers/video/sidsafb.h linux-2.6.15.4/drivers/video/sidsafb.h
--- linux-2.6.15.4-orig/drivers/video/sidsafb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/drivers/video/sidsafb.h	2006-08-09 10:45:33.000000000 +0200
@@ -0,0 +1,76 @@
+/*
+ *  linux/drivers/video/sidsafb.h
+ *
+ *  Driver for SIDSA LCD Controller IP
+ *
+ *  Copyright (C) 2004 Atmel Norway AS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __SIDSAFB_H__
+#define __SIDSAFB_H__
+
+struct sidsafb_info {
+	spinlock_t		lock;
+	struct fb_info *	info;
+	char *			mmio;
+	unsigned long		irq_base;
+	wait_queue_head_t	vsync_wait;
+	unsigned int		guard_time;
+	struct platform_device	*pdev;
+	u32			pseudo_palette[16];
+};
+
+
+static inline void lcdc_writel(u32 value, u32 reg)
+{
+#ifdef IO_DEBUG
+	pr_debug("lcdc writel %p <- %08lx\n",
+		 reg,
+		 (unsigned long)value);
+#endif
+	writel(value, reg);
+}
+
+static inline u32 lcdc_readl(u32 reg)
+{
+	u32 value = readl(reg);
+#ifdef IO_DEBUG
+	pr_debug("lcdc readl %p -> %08lx\n",
+		 reg,
+		 (unsigned long)value);
+#endif
+	return value;
+}
+
+#if defined(IO_DEBUG)
+#define lcdc_debug_readl(reg) lcdc_readl(reg)
+#else
+#define lcdc_debug_readl(reg)
+#endif
+
+
+/* More or less configurable parameters */
+#define SIDSAFB_FIFO_SIZE		512
+
+#ifdef CONFIG_STN_MONO_AT91
+#define SIDSAFB_DMA_BURST_LEN		8
+#elif CONFIG_TFT_AT91
+#define SIDSAFB_DMA_BURST_LEN		16
+#endif
+
+#define SIDSAFB_CRST_VAL                0xc8   // 0xda
+
+#endif /* __SIDSAFB_H__ */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_aic.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_aic.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_aic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_aic.h	2006-08-09 10:54:52.000000000 +0200
@@ -0,0 +1,90 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_aic.h
+ * 
+ * Hardware definition for the aic peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from AIC_6075B V1.3
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9260_AIC_H
+#define __AT91SAM9260_AIC_H
+
+/* -------------------------------------------------------- */
+/* AIC ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_FIQ
+#define AT91C_ID_FIQ   	 0 /**< Advanced Interrupt Controller (FIQ) id */
+#endif /* AT91C_ID_FIQ */
+#ifndef AT91C_ID_IRQ0
+#define AT91C_ID_IRQ0  	29 /**< Advanced Interrupt Controller (IRQ0) id */
+#endif /* AT91C_ID_IRQ0 */
+#ifndef AT91C_ID_IRQ1
+#define AT91C_ID_IRQ1  	30 /**< Advanced Interrupt Controller (IRQ1) id */
+#endif /* AT91C_ID_IRQ1 */
+#ifndef AT91C_ID_IRQ2
+#define AT91C_ID_IRQ2  	31 /**< Advanced Interrupt Controller (IRQ2) id */
+#endif /* AT91C_ID_IRQ2 */
+
+/* -------------------------------------------------------- */
+/* AIC Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_AIC       	0xFFFFF000 /**< AIC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PC13_FIQ      	(1 << 13) /**< AIC Fast Interrupt Input */
+#define AT91C_PC12_IRQ0     	(1 << 12) /**< External Interrupt 0 */
+#define AT91C_PC15_IRQ1     	(1 << 15) /**< External Interrupt 1 */
+#define AT91C_PC14_IRQ2     	(1 << 14) /**< External Interrupt 2 */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AIC_SMR 	(0x0000) 	/**< Source Mode Register */
+#define AIC_SVR 	(0x0080) 	/**< Source Vector Register */
+#define AIC_IVR 	(0x0100) 	/**< IRQ Vector Register */
+#define AIC_FVR 	(0x0104) 	/**< FIQ Vector Register */
+#define AIC_ISR 	(0x0108) 	/**< Interrupt Status Register */
+#define AIC_IPR 	(0x010C) 	/**< Interrupt Pending Register */
+#define AIC_IMR 	(0x0110) 	/**< Interrupt Mask Register */
+#define AIC_CISR 	(0x0114) 	/**< Core Interrupt Status Register */
+#define AIC_IECR 	(0x0120) 	/**< Interrupt Enable Command Register */
+#define AIC_IDCR 	(0x0124) 	/**< Interrupt Disable Command Register */
+#define AIC_ICCR 	(0x0128) 	/**< Interrupt Clear Command Register */
+#define AIC_ISCR 	(0x012C) 	/**< Interrupt Set Command Register */
+#define AIC_EOICR 	(0x0130) 	/**< End of Interrupt Command Register */
+#define AIC_SPU 	(0x0134) 	/**< Spurious Vector Register */
+#define AIC_DCR 	(0x0138) 	/**< Debug Control Register (Protect) */
+#define AIC_FFER 	(0x0140) 	/**< Fast Forcing Enable Register */
+#define AIC_FFDR 	(0x0144) 	/**< Fast Forcing Disable Register */
+#define AIC_FFSR 	(0x0148) 	/**< Fast Forcing Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register AIC_SMR */
+#define AT91C_AIC_PRIOR       (0x7 << 0 ) /**< (AIC) Priority Level */
+#define 	AT91C_AIC_PRIOR_LOWEST               0x0 /**< (AIC) Lowest priority level */
+#define 	AT91C_AIC_PRIOR_HIGHEST              0x7 /**< (AIC) Highest priority level */
+#define AT91C_AIC_SRCTYPE     (0x3 << 5 ) /**< (AIC) Interrupt Source Type */
+#define 	AT91C_AIC_SRCTYPE_EXT_LOW_LEVEL        (0x0 <<  5) /**< (AIC) External Sources Code Label Low-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL       (0x0 <<  5) /**< (AIC) Internal Sources Code Label High-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE    (0x1 <<  5) /**< (AIC) Internal Sources Code Label Positive Edge triggered */
+#define 	AT91C_AIC_SRCTYPE_EXT_NEGATIVE_EDGE    (0x1 <<  5) /**< (AIC) External Sources Code Label Negative Edge triggered */
+#define 	AT91C_AIC_SRCTYPE_HIGH_LEVEL           (0x2 <<  5) /**< (AIC) Internal Or External Sources Code Label High-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_POSITIVE_EDGE        (0x3 <<  5) /**< (AIC) Internal Or External Sources Code Label Positive Edge triggered */
+/* --- Register AIC_CISR */
+#define AT91C_AIC_NFIQ        (0x1 << 0 ) /**< (AIC) NFIQ Status */
+#define AT91C_AIC_NIRQ        (0x1 << 1 ) /**< (AIC) NIRQ Status */
+/* --- Register AIC_DCR */
+#define AT91C_AIC_DCR_PROT    (0x1 << 0 ) /**< (AIC) Protection Mode */
+#define AT91C_AIC_DCR_GMSK    (0x1 << 1 ) /**< (AIC) General Mask */
+
+#endif /* __AT91SAM9260_AIC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_ebi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_ebi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_ebi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_ebi.h	2006-08-09 10:54:54.000000000 +0200
@@ -0,0 +1,441 @@
+#ifndef __ASM_ARCH_AT91SAM9261_EBI_H
+#define __ASM_ARCH_AT91SAM9261_EBI_H
+
+#define AT91C_BASE_EBI       0xFFFFE000 /** Base Address */
+
+/* -------------------------------------------------------- */
+/* SMC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define SYS_SMC       	0x0C00 /**< SMC base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define SMC_SETUP0 	(SYS_SMC) 	/**<  Setup Register for CS 0 */
+#define SMC_PULSE0 	(SYS_SMC + 0x0004) 	/**<  Pulse Register for CS 0 */
+#define SMC_CYCLE0 	(SYS_SMC + 0x0008) 	/**<  Cycle Register for CS 0 */
+#define SMC_CTRL0 	(SYS_SMC + 0x000C) 	/**<  Control Register for CS 0 */
+#define SMC_SETUP1 	(SYS_SMC + 0x0010) 	/**<  Setup Register for CS 1 */
+#define SMC_PULSE1 	(SYS_SMC + 0x0014) 	/**<  Pulse Register for CS 1 */
+#define SMC_CYCLE1 	(SYS_SMC + 0x0018) 	/**<  Cycle Register for CS 1 */
+#define SMC_CTRL1 	(SYS_SMC + 0x001C) 	/**<  Control Register for CS 1 */
+#define SMC_SETUP2 	(SYS_SMC + 0x0020) 	/**<  Setup Register for CS 2 */
+#define SMC_PULSE2 	(SYS_SMC + 0x0024) 	/**<  Pulse Register for CS 2 */
+#define SMC_CYCLE2 	(SYS_SMC + 0x0028) 	/**<  Cycle Register for CS 2 */
+#define SMC_CTRL2 	(SYS_SMC + 0x002C) 	/**<  Control Register for CS 2 */
+#define SMC_SETUP3 	(SYS_SMC + 0x0030) 	/**<  Setup Register for CS 3 */
+#define SMC_PULSE3 	(SYS_SMC + 0x0034) 	/**<  Pulse Register for CS 3 */
+#define SMC_CYCLE3 	(SYS_SMC + 0x0038) 	/**<  Cycle Register for CS 3 */
+#define SMC_CTRL3 	(SYS_SMC + 0x003C) 	/**<  Control Register for CS 3 */
+#define SMC_SETUP4 	(SYS_SMC + 0x0040) 	/**<  Setup Register for CS 4 */
+#define SMC_PULSE4 	(SYS_SMC + 0x0044) 	/**<  Pulse Register for CS 4 */
+#define SMC_CYCLE4 	(SYS_SMC + 0x0048) 	/**<  Cycle Register for CS 4 */
+#define SMC_CTRL4 	(SYS_SMC + 0x004C) 	/**<  Control Register for CS 4 */
+#define SMC_SETUP5 	(SYS_SMC + 0x0050) 	/**<  Setup Register for CS 5 */
+#define SMC_PULSE5 	(SYS_SMC + 0x0054) 	/**<  Pulse Register for CS 5 */
+#define SMC_CYCLE5 	(SYS_SMC + 0x0058) 	/**<  Cycle Register for CS 5 */
+#define SMC_CTRL5 	(SYS_SMC + 0x005C) 	/**<  Control Register for CS 5 */
+#define SMC_SETUP6 	(SYS_SMC + 0x0060) 	/**<  Setup Register for CS 6 */
+#define SMC_PULSE6 	(SYS_SMC + 0x0064) 	/**<  Pulse Register for CS 6 */
+#define SMC_CYCLE6 	(SYS_SMC + 0x0068) 	/**<  Cycle Register for CS 6 */
+#define SMC_CTRL6 	(SYS_SMC + 0x006C) 	/**<  Control Register for CS 6 */
+#define SMC_SETUP7 	(SYS_SMC + 0x0070) 	/**<  Setup Register for CS 7 */
+#define SMC_PULSE7 	(SYS_SMC + 0x0074) 	/**<  Pulse Register for CS 7 */
+#define SMC_CYCLE7 	(SYS_SMC + 0x0078) 	/**<  Cycle Register for CS 7 */
+#define SMC_CTRL7 	(SYS_SMC + 0x007C) 	/**<  Control Register for CS 7 */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SMC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+
+
+/* -------------------------------------------------------- */
+/* MATRIX Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define SYS_MATRIX    	0x0E00 /**< MATRIX base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+#define MATRIX_MCFG 	(SYS_MATRIX) 	/**<  Master Configuration Register */
+#define MATRIX_SCFG0 	(SYS_MATRIX + 0x0004) 	/**<  Slave Configuration Register 0 */
+#define MATRIX_SCFG1 	(SYS_MATRIX + 0x0008) 	/**<  Slave Configuration Register 1 */
+#define MATRIX_SCFG2 	(SYS_MATRIX + 0x000C) 	/**<  Slave Configuration Register 2 */
+#define MATRIX_SCFG3 	(SYS_MATRIX + 0x0010) 	/**<  Slave Configuration Register 3 */
+#define MATRIX_SCFG4 	(SYS_MATRIX + 0x0014) 	/**<  Slave Configuration Register 4 */
+#define MATRIX_TCMR 	(SYS_MATRIX + 0x0024) 	/**<  Slave 0 Special Function Register */
+#define MATRIX_EBICSA 	(SYS_MATRIX + 0x0030) 	/**<  Slave 3 Special Function Register */
+#define MATRIX_USBPCR 	(SYS_MATRIX + 0x0034) 	/**<  Slave 4 Special Function Register */
+#define MATRIX_VERSION 	(SYS_MATRIX + 0x0044) 	/**<  Version Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register MATRIX_MCFG */
+#define MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_SCFG0 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR0 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG1 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR1 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG2 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR2 (0x1 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR2_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR2_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+/* --- Register MATRIX_SCFG3 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR3 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG4 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR4 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR4_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR4_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR4_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+/* --- Register MATRIX_TCMR */
+#define MATRIX_ITCM_SIZE (0xF << 0 ) /**< (MATRIX) Size of ITCM enabled memory block */
+#define 	MATRIX_ITCM_SIZE_0KB                  0x0 /**< (MATRIX) 0 KB (No ITCM Memory) */
+#define 	MATRIX_ITCM_SIZE_16KB                 0x5 /**< (MATRIX) 16 KB */
+#define 	MATRIX_ITCM_SIZE_32KB                 0x6 /**< (MATRIX) 32 KB */
+#define 	MATRIX_ITCM_SIZE_64KB                 0x7 /**< (MATRIX) 64 KB */
+#define MATRIX_DTCM_SIZE (0xF << 4 ) /**< (MATRIX) Size of DTCM enabled memory block */
+#define 	MATRIX_DTCM_SIZE_0KB                  (0x0 <<  4) /**< (MATRIX) 0 KB (No DTCM Memory) */
+#define 	MATRIX_DTCM_SIZE_16KB                 (0x5 <<  4) /**< (MATRIX) 16 KB */
+#define 	MATRIX_DTCM_SIZE_32KB                 (0x6 <<  4) /**< (MATRIX) 32 KB */
+#define 	MATRIX_DTCM_SIZE_64KB                 (0x7 <<  4) /**< (MATRIX) 64 KB */
+/* --- Register MATRIX_EBICSA */
+#define MATRIX_CS1A     (0x1 << 1 ) /**< (MATRIX) Chip Select 1 Assignment */
+#define 	MATRIX_CS1A_SMC                  (0x0 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the Static Memory Controller. */
+#define 	MATRIX_CS1A_SDRAMC               (0x1 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the SDRAM Controller. */
+#define MATRIX_CS3A     (0x1 << 3 ) /**< (MATRIX) Chip Select 3 Assignment */
+#define 	MATRIX_CS3A_SMC                  (0x0 <<  3) /**< (MATRIX) Chip Select 3 is only assigned to the Static Memory Controller and NCS3 behaves as defined by the SMC. */
+#define 	MATRIX_CS3A_SM                   (0x1 <<  3) /**< (MATRIX) Chip Select 3 is assigned to the Static Memory Controller and the SmartMedia Logic is activated. */
+#define MATRIX_CS4A     (0x1 << 4 ) /**< (MATRIX) Chip Select 4 Assignment */
+#define 	MATRIX_CS4A_SMC                  (0x0 <<  4) /**< (MATRIX) Chip Select 4 is only assigned to the Static Memory Controller and NCS4 behaves as defined by the SMC. */
+#define 	MATRIX_CS4A_CF                   (0x1 <<  4) /**< (MATRIX) Chip Select 4 is assigned to the Static Memory Controller and the CompactFlash Logic (first slot) is activated. */
+#define MATRIX_CS5A     (0x1 << 5 ) /**< (MATRIX) Chip Select 5 Assignment */
+#define 	MATRIX_CS5A_SMC                  (0x0 <<  5) /**< (MATRIX) Chip Select 5 is only assigned to the Static Memory Controller and NCS5 behaves as defined by the SMC */
+#define 	MATRIX_CS5A_CF                   (0x1 <<  5) /**< (MATRIX) Chip Select 5 is assigned to the Static Memory Controller and the CompactFlash Logic (second slot) is activated. */
+#define MATRIX_DBPUC    (0x1 << 8 ) /**< (MATRIX) Data Bus Pull-up Configuration */
+/* --- Register MATRIX_USBPCR */
+#define MATRIX_USBPCR_PUON (0x1 << 30) /**< (MATRIX) PullUp On */
+#define MATRIX_USBPCR_PUIDLE (0x1 << 31) /**< (MATRIX) PullUp Idle */
+
+#endif /* __ASM_ARCH_AT91SAM9261_EBI_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260ek.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260ek.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260ek.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260ek.h	2006-08-09 10:55:07.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/at91sam9261ek.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91SAM9261EK_H
+#define __ASM_ARCH_AT91SAM9261EK_H
+
+
+/* AT91SAM9261 clocks */
+#define AT91C_MAIN_CLOCK	198600000	/* from 18.432 MHz crystal (18432000 / 4 * 39) */
+#define AT91C_MASTER_CLOCK	99300000
+#define AT91C_SLOW_CLOCK	32768		/* slow clock */
+#define AT91_PLLB_VALUE		0x10483F0E	/* (18.432 / 14 * 73) /2 = 47.9714  */
+
+/* FLASH */
+#define AT91_NANDFLASH_BASE	0x40000000	// NCS0: Flash physical base address
+
+/* SDRAM */
+#define AT91_SDRAM_BASE		0x20000000	// NCS1: SDRAM physical base address
+
+/* Internal SRAM base address */
+#define AT91C_IRAM_BASE		0x00300000
+#define AT91C_IRAM_SIZE		0x00001000
+
+#define AT91C_CONSOLE_DEFAULT_BAUDRATE 115200	/* default serial console baud-rate */
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_emac.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_emac.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_emac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_emac.h	2006-08-09 10:54:55.000000000 +0200
@@ -0,0 +1,256 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_emac.h
+ * 
+ * Hardware definition for the emac peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  12/09/2005 (11:54:20) AT91 SW Application Group from EMACB_6119A V1.6
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_EMAC_H
+#define __AT91SAM9262_EMAC_H
+
+/* -------------------------------------------------------- */
+/* EMAC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_EMAC
+#define AT91C_ID_EMAC  	21 /**< Ethernet Mac id */
+#endif /* AT91C_ID_EMAC */
+
+/* -------------------------------------------------------- */
+/* EMAC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_EMAC     	0xFFFC4000 /**< MACB base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for EMAC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PC26_E_COL    	(1 << 26) /**<  */
+#define AT91C_PE22_E_CRS    	(1 << 22) /**<  */
+#define AT91C_PE31_E_F100   	(1 << 31) /**<  */
+#define AT91C_PE29_E_MDC    	(1 << 29) /**<  */
+#define AT91C_PE30_E_MDIO   	(1 << 30) /**<  */
+#define AT91C_PE25_E_RX0    	(1 << 25) /**<  */
+#define AT91C_PE26_E_RX1    	(1 << 26) /**<  */
+#define AT91C_PC22_E_RX2    	(1 << 22) /**<  */
+#define AT91C_PC23_E_RX3    	(1 << 23) /**<  */
+#define AT91C_PC27_E_RXCK   	(1 << 27) /**<  */
+#define AT91C_PC25_E_RXDV   	(1 << 25) /**<  */
+#define AT91C_PE27_E_RXER   	(1 << 27) /**<  */
+#define AT91C_PE23_E_TX0    	(1 << 23) /**<  */
+#define AT91C_PE24_E_TX1    	(1 << 24) /**<  */
+#define AT91C_PC20_E_TX2    	(1 << 20) /**<  */
+#define AT91C_PC21_E_TX3    	(1 << 21) /**<  */
+#define AT91C_PE21_E_TXCK   	(1 << 21) /**<  */
+#define AT91C_PE28_E_TXEN   	(1 << 28) /**<  */
+#define AT91C_PC24_E_TXER   	(1 << 24) /**<  */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for EMAC hardware peripheral */
+/* -------------------------------------------------------- */
+#define EMAC_NCR 	(0x0000) 	/**< Network Control Register */
+#define EMAC_NCFGR 	(0x0004) 	/**< Network Configuration Register */
+#define EMAC_NSR 	(0x0008) 	/**< Network Status Register */
+#define EMAC_TSR 	(0x0014) 	/**< Transmit Status Register */
+#define EMAC_RBQP 	(0x0018) 	/**< Receive Buffer Queue Pointer */
+#define EMAC_TBQP 	(0x001C) 	/**< Transmit Buffer Queue Pointer */
+#define EMAC_RSR 	(0x0020) 	/**< Receive Status Register */
+#define EMAC_ISR 	(0x0024) 	/**< Interrupt Status Register */
+#define EMAC_IER 	(0x0028) 	/**< Interrupt Enable Register */
+#define EMAC_IDR 	(0x002C) 	/**< Interrupt Disable Register */
+#define EMAC_IMR 	(0x0030) 	/**< Interrupt Mask Register */
+#define EMAC_MAN 	(0x0034) 	/**< PHY Maintenance Register */
+#define EMAC_PTR 	(0x0038) 	/**< Pause Time Register */
+#define EMAC_PFR 	(0x003C) 	/**< Pause Frames received Register */
+#define EMAC_FTO 	(0x0040) 	/**< Frames Transmitted OK Register */
+#define EMAC_SCF 	(0x0044) 	/**< Single Collision Frame Register */
+#define EMAC_MCF 	(0x0048) 	/**< Multiple Collision Frame Register */
+#define EMAC_FRO 	(0x004C) 	/**< Frames Received OK Register */
+#define EMAC_FCSE 	(0x0050) 	/**< Frame Check Sequence Error Register */
+#define EMAC_ALE 	(0x0054) 	/**< Alignment Error Register */
+#define EMAC_DTF 	(0x0058) 	/**< Deferred Transmission Frame Register */
+#define EMAC_LCOL 	(0x005C) 	/**< Late Collision Register */
+#define EMAC_ECOL 	(0x0060) 	/**< Excessive Collision Register */
+#define EMAC_TUND 	(0x0064) 	/**< Transmit Underrun Error Register */
+#define EMAC_CSE 	(0x0068) 	/**< Carrier Sense Error Register */
+#define EMAC_RRE 	(0x006C) 	/**< Receive Ressource Error Register */
+#define EMAC_ROV 	(0x0070) 	/**< Receive Overrun Errors Register */
+#define EMAC_RSE 	(0x0074) 	/**< Receive Symbol Errors Register */
+#define EMAC_ELE 	(0x0078) 	/**< Excessive Length Errors Register */
+#define EMAC_RJA 	(0x007C) 	/**< Receive Jabbers Register */
+#define EMAC_USF 	(0x0080) 	/**< Undersize Frames Register */
+#define EMAC_STE 	(0x0084) 	/**< SQE Test Error Register */
+#define EMAC_RLE 	(0x0088) 	/**< Receive Length Field Mismatch Register */
+#define EMAC_TPF 	(0x008C) 	/**< Transmitted Pause Frames Register */
+#define EMAC_HRB 	(0x0090) 	/**< Hash Address Bottom[31:0] */
+#define EMAC_HRT 	(0x0094) 	/**< Hash Address Top[63:32] */
+#define EMAC_SA1L 	(0x0098) 	/**< Specific Address 1 Bottom, First 4 bytes */
+#define EMAC_SA1H 	(0x009C) 	/**< Specific Address 1 Top, Last 2 bytes */
+#define EMAC_SA2L 	(0x00A0) 	/**< Specific Address 2 Bottom, First 4 bytes */
+#define EMAC_SA2H 	(0x00A4) 	/**< Specific Address 2 Top, Last 2 bytes */
+#define EMAC_SA3L 	(0x00A8) 	/**< Specific Address 3 Bottom, First 4 bytes */
+#define EMAC_SA3H 	(0x00AC) 	/**< Specific Address 3 Top, Last 2 bytes */
+#define EMAC_SA4L 	(0x00B0) 	/**< Specific Address 4 Bottom, First 4 bytes */
+#define EMAC_SA4H 	(0x00B4) 	/**< Specific Address 4 Top, Last 2 bytes */
+#define EMAC_TID 	(0x00B8) 	/**< Type ID Checking Register */
+#define EMAC_TPQ 	(0x00BC) 	/**< Transmit Pause Quantum Register */
+#define EMAC_USRIO 	(0x00C0) 	/**< USER Input/Output Register */
+#define EMAC_WOL 	(0x00C4) 	/**< Wake On LAN Register */
+#define EMAC_REV 	(0x00FC) 	/**< Revision Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for EMAC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register EMAC_NCR */
+#define AT91C_EMAC_LB         (0x1 << 0 ) /**< (EMAC) Loopback. Optional. When set, loopback signal is at high level. */
+#define AT91C_EMAC_LLB        (0x1 << 1 ) /**< (EMAC) Loopback local.  */
+#define AT91C_EMAC_RE         (0x1 << 2 ) /**< (EMAC) Receive enable.  */
+#define AT91C_EMAC_TE         (0x1 << 3 ) /**< (EMAC) Transmit enable.  */
+#define AT91C_EMAC_MPE        (0x1 << 4 ) /**< (EMAC) Management port enable.  */
+#define AT91C_EMAC_CLRSTAT    (0x1 << 5 ) /**< (EMAC) Clear statistics registers.  */
+#define AT91C_EMAC_INCSTAT    (0x1 << 6 ) /**< (EMAC) Increment statistics registers.  */
+#define AT91C_EMAC_WESTAT     (0x1 << 7 ) /**< (EMAC) Write enable for statistics registers.  */
+#define AT91C_EMAC_BP         (0x1 << 8 ) /**< (EMAC) Back pressure.  */
+#define AT91C_EMAC_TSTART     (0x1 << 9 ) /**< (EMAC) Start Transmission.  */
+#define AT91C_EMAC_THALT      (0x1 << 10) /**< (EMAC) Transmission Halt.  */
+#define AT91C_EMAC_TPFR       (0x1 << 11) /**< (EMAC) Transmit pause frame  */
+#define AT91C_EMAC_TZQ        (0x1 << 12) /**< (EMAC) Transmit zero quantum pause frame */
+/* --- Register EMAC_NCFGR */
+#define AT91C_EMAC_SPD        (0x1 << 0 ) /**< (EMAC) Speed.  */
+#define AT91C_EMAC_FD         (0x1 << 1 ) /**< (EMAC) Full duplex.  */
+#define AT91C_EMAC_JFRAME     (0x1 << 3 ) /**< (EMAC) Jumbo Frames.  */
+#define AT91C_EMAC_CAF        (0x1 << 4 ) /**< (EMAC) Copy all frames.  */
+#define AT91C_EMAC_NBC        (0x1 << 5 ) /**< (EMAC) No broadcast.  */
+#define AT91C_EMAC_MTI        (0x1 << 6 ) /**< (EMAC) Multicast hash event enable */
+#define AT91C_EMAC_UNI        (0x1 << 7 ) /**< (EMAC) Unicast hash enable.  */
+#define AT91C_EMAC_BIG        (0x1 << 8 ) /**< (EMAC) Receive 1522 bytes.  */
+#define AT91C_EMAC_EAE        (0x1 << 9 ) /**< (EMAC) External address match enable.  */
+#define AT91C_EMAC_CLK        (0x3 << 10) /**< (EMAC)  */
+#define 	AT91C_EMAC_CLK_HCLK_8               (0x0 << 10) /**< (EMAC) HCLK divided by 8 */
+#define 	AT91C_EMAC_CLK_HCLK_16              (0x1 << 10) /**< (EMAC) HCLK divided by 16 */
+#define 	AT91C_EMAC_CLK_HCLK_32              (0x2 << 10) /**< (EMAC) HCLK divided by 32 */
+#define 	AT91C_EMAC_CLK_HCLK_64              (0x3 << 10) /**< (EMAC) HCLK divided by 64 */
+#define AT91C_EMAC_RTY        (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PAE        (0x1 << 13) /**< (EMAC)  */
+#define AT91C_EMAC_RBOF       (0x3 << 14) /**< (EMAC)  */
+#define 	AT91C_EMAC_RBOF_OFFSET_0             (0x0 << 14) /**< (EMAC) no offset from start of receive buffer */
+#define 	AT91C_EMAC_RBOF_OFFSET_1             (0x1 << 14) /**< (EMAC) one byte offset from start of receive buffer */
+#define 	AT91C_EMAC_RBOF_OFFSET_2             (0x2 << 14) /**< (EMAC) two bytes offset from start of receive buffer */
+#define 	AT91C_EMAC_RBOF_OFFSET_3             (0x3 << 14) /**< (EMAC) three bytes offset from start of receive buffer */
+#define AT91C_EMAC_RLCE       (0x1 << 16) /**< (EMAC) Receive Length field Checking Enable */
+#define AT91C_EMAC_DRFCS      (0x1 << 17) /**< (EMAC) Discard Receive FCS */
+#define AT91C_EMAC_EFRHD      (0x1 << 18) /**< (EMAC)  */
+#define AT91C_EMAC_IRXFCS     (0x1 << 19) /**< (EMAC) Ignore RX FCS */
+/* --- Register EMAC_NSR */
+#define AT91C_EMAC_LINKR      (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_MDIO       (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_IDLE       (0x1 << 2 ) /**< (EMAC)  */
+/* --- Register EMAC_TSR */
+#define AT91C_EMAC_UBR        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_COL        (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLES       (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TGO        (0x1 << 3 ) /**< (EMAC) Transmit Go */
+#define AT91C_EMAC_BEX        (0x1 << 4 ) /**< (EMAC) Buffers exhausted mid frame */
+#define AT91C_EMAC_COMP       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_UND        (0x1 << 6 ) /**< (EMAC)  */
+/* --- Register EMAC_RSR */
+#define AT91C_EMAC_BNA        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_REC        (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_OVR        (0x1 << 2 ) /**< (EMAC)  */
+/* --- Register EMAC_ISR */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_IER */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_IDR */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_IMR */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_MAN */
+#define AT91C_EMAC_DATA       (0xFFFF << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_CODE       (0x3 << 16) /**< (EMAC)  */
+#define AT91C_EMAC_REGA       (0x1F << 18) /**< (EMAC)  */
+#define AT91C_EMAC_PHYA       (0x1F << 23) /**< (EMAC)  */
+#define AT91C_EMAC_RW         (0x3 << 28) /**< (EMAC)  */
+#define AT91C_EMAC_SOF        (0x3 << 30) /**< (EMAC)  */
+/* --- Register EMAC_USRIO */
+#define AT91C_EMAC_RMII       (0x1 << 0 ) /**< (EMAC) Reduce MII */
+#define AT91C_EMAC_CLKEN      (0x1 << 1 ) /**< (EMAC) Clock Enable */
+/* --- Register EMAC_WOL */
+#define AT91C_EMAC_IP         (0xFFFF << 0 ) /**< (EMAC) ARP request IP address */
+#define AT91C_EMAC_MAG        (0x1 << 16) /**< (EMAC) Magic packet event enable */
+#define AT91C_EMAC_ARP        (0x1 << 17) /**< (EMAC) ARP request event enable */
+#define AT91C_EMAC_SA1        (0x1 << 18) /**< (EMAC) Specific address register 1 event enable */
+#define AT91C_EMAC_WOL_MTI    (0x1 << 19) /**< (EMAC) Multicast hash event enable */
+/* --- Register EMAC_REV */
+#define AT91C_EMAC_REVREF     (0xFFFF << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_PARTREF    (0xFFFF << 16) /**< (EMAC)  */
+
+#endif /* __AT91SAM9262_EMAC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260.h	2006-08-09 10:54:52.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9260/at91sam9260.h
+ *
+ *  Copyright (c) 2006 ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91SAM9260_H
+#define __ASM_ARCH_AT91SAM9260_H
+
+/** ***************************************************************************** */
+/**               PERIPHERAL ID DEFINITIONS FOR AT91SAM9261                       */
+/** ***************************************************************************** */
+#define AT91_NR_PIO 3 /** AT91SAM9260 includes 3 PIO controllers */
+#define AT91_NR_US  6 /** AT91SAM9260 includes 3 USART controllers */
+#define AT91_NR_SPI 2 /** AT91SAM9260 includes 2 SPI controllers */
+#define AT91_NR_SSC 1 /** AT91SAM9260 includes 3 SSC controllers */
+#define AT91_NR_TC  3 /** AT91SAM9260 includes 6 TC controllers */
+
+/** ***************************************************************************** */
+/**               PERIPHERAL ID DEFINITIONS FOR AT91SAM9261                       */
+/** ***************************************************************************** */
+#define AT91_ID_FIQ     0 /** Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS     1 /** System Interrupt */
+#define AT91_ID_PIOA    2 /** Parallel IO Controller A */
+#define AT91_ID_PIOB    3 /** Parallel IO Controller B */
+#define AT91_ID_PIOC    4 /** Parallel IO Controller C */
+#define AT91_ID_US0     6 /** USART 0 */
+#define AT91_ID_US1     7 /** USART 1 */
+#define AT91_ID_US2     8 /** USART 2 */
+#define AT91_ID_MCI     9 /** Multimedia Card Interface */
+#define AT91_ID_UDP    10 /** USB Device Port */
+#define AT91_ID_TWI    11 /** Two-Wire Interface */
+#define AT91_ID_SPI0   12 /** Serial Peripheral Interface 0 */
+#define AT91_ID_SPI1   13 /** Serial Peripheral Interface 1 */
+#define AT91_ID_SSC0   14 /** Serial Synchronous Controller 0 */
+#define AT91_ID_TC0    17 /** Timer Counter 0 */
+#define AT91_ID_TC1    18 /** Timer Counter 1 */
+#define AT91_ID_TC2    19 /** Timer Counter 2 */
+#define AT91_ID_UHP    20 /** USB Host Port */
+#define AT91_ID_EMAC   21 /** USB Host Port */
+#define AT91_ID_ISI    22 /** USB Host Port */
+#define AT91_ID_US3    23 /** USART 3 */
+#define AT91_ID_US4    24 /** USART 4 */
+#define AT91_ID_US5    25 /** USART 5 */
+#define AT91_ID_TC3    26 /** Timer Counter 3 */
+#define AT91_ID_TC4    27 /** Timer Counter 4 */
+#define AT91_ID_TC5    28 /** Timer Counter 5 */
+#define AT91_ID_IRQ0   29 /** Advanced Interrupt Controller (IRQ0) */
+#define AT91_ID_IRQ1   30 /** Advanced Interrupt Controller (IRQ1) */
+#define AT91_ID_IRQ2   31 /** Advanced Interrupt Controller (IRQ2) */
+#define AT91_ALL_INT   0xFFFE7FFF /** ALL VALID INTERRUPTS */
+
+/** ***************************************************************************** */
+/**         INTERNAL PERIPHERAL BASE ADDRESS DEFINITIONS FOR AT91SAM9261          */
+/** ***************************************************************************** */
+#define AT91_BASE_SYS       0xFFFFE000 /** (SYS) Base Address */
+#define AT91_BASE_SDRAMC    0xFFFFEA00 /** (SDRAMC) Base Address */
+#define AT91_BASE_SMC       0xFFFFEC00 /** (SMC) Base Address */
+#define AT91_BASE_MATRIX    0xFFFFEE00 /** (MATRIX) Base Address */
+#define AT91_BASE_AIC       0xFFFFF000 /** (AIC) Base Address */
+#define AT91_BASE_PDC_DBGU  0xFFFFF300 /** (PDC_DBGU) Base Address */
+#define AT91_BASE_DBGU      0xFFFFF200 /** (DBGU) Base Address */
+#define AT91_BASE_PIOA      0xFFFFF400 /** (PIOA) Base Address */
+#define AT91_BASE_PIOB      0xFFFFF600 /** (PIOB) Base Address */
+#define AT91_BASE_PIOC      0xFFFFF800 /** (PIOC) Base Address */
+#define AT91_BASE_CKGR      0xFFFFFC20 /** (CKGR) Base Address */
+#define AT91_BASE_PMC       0xFFFFFC00 /** (PMC) Base Address */
+#define AT91_BASE_RSTC      0xFFFFFD00 /** (RSTC) Base Address */
+#define AT91_BASE_SHDWC     0xFFFFFD10 /** (SHDWC) Base Address */
+#define AT91_BASE_RTTC      0xFFFFFD20 /** (RTTC) Base Address */
+#define AT91_BASE_PITC      0xFFFFFD30 /** (PITC) Base Address */
+#define AT91_BASE_WDTC      0xFFFFFD40 /** (WDTC) Base Address */
+
+#define AT91_BASE_TC0       0xFFFA0000 /** (TC0) Base Address */
+#define AT91_BASE_TC1       0xFFFA0040 /** (TC1) Base Address */
+#define AT91_BASE_TC2       0xFFFA0080 /** (TC2) Base Address */
+#define AT91_BASE_TCB0      0xFFFA0000 /** (TCB0) Base Address */
+#define AT91_BASE_UDP       0xFFFA4000 /** (UDP) Base Address */
+#define AT91_BASE_PDC_MCI   0xFFFA8100 /** (PDC_MCI) Base Address */
+#define AT91_BASE_MCI       0xFFFA8000 /** (MCI) Base Address */
+#define AT91_BASE_TWI       0xFFFAC000 /** (TWI) Base Address */
+#define AT91_BASE_PDC_US0   0xFFFB0100 /** (PDC_US0) Base Address */
+#define AT91_BASE_US0       0xFFFB0000 /** (US0) Base Address */
+#define AT91_BASE_PDC_US1   0xFFFB4100 /** (PDC_US1) Base Address */
+#define AT91_BASE_US1       0xFFFB4000 /** (US1) Base Address */
+#define AT91_BASE_PDC_US2   0xFFFB8100 /** (PDC_US2) Base Address */
+#define AT91_BASE_US2       0xFFFB8000 /** (US2) Base Address */
+#define AT91_BASE_PDC_SSC0  0xFFFBC100 /** (PDC_SSC0) Base Address */
+#define AT91_BASE_SSC0      0xFFFBC000 /** (SSC0) Base Address */
+#define AT91_BASE_ISI       0xFFFC0000 /** (SSC1) Base Address */
+#define AT91_BASE_EMAC      0xFFFC4000 /** (SSC2) Base Address */
+#define AT91_BASE_PDC_SPI0  0xFFFC8100 /** (PDC_SPI0) Base Address */
+#define AT91_BASE_SPI0      0xFFFC8000 /** (SPI0) Base Address */
+#define AT91_BASE_PDC_SPI1  0xFFFCC100 /** (PDC_SPI1) Base Address */
+#define AT91_BASE_SPI1      0xFFFCC000 /** (SPI1) Base Address */
+#define AT91_BASE_PDC_US3   0xFFFD0100 /** (PDC_US3) Base Address */
+#define AT91_BASE_US3       0xFFFD0000 /** (US3) Base Address */
+#define AT91_BASE_PDC_US4   0xFFFD4100 /** (PDC_US4) Base Address */
+#define AT91_BASE_US4       0xFFFD4000 /** (US4) Base Address */
+#define AT91_BASE_PDC_US5   0xFFFD8100 /** (PDC_US5) Base Address */
+#define AT91_BASE_US5       0xFFFD8000 /** (US5) Base Address */
+#define AT91_BASE_TC3       0xFFFDC000 /** (TC1) Base Address */
+#define AT91_BASE_TC4       0xFFFDC400 /** (TC4) Base Address */
+#define AT91_BASE_TC5       0xFFFDC080 /** (TC5) Base Address */
+#define AT91_BASE_TCB1      0xFFFDC000 /** (TCB1) Base Address */
+#define AT91_BASE_ADC0      0xFFFE0000 /** (ADC0) Base Address */
+
+#define AT91_BASE_UHP       0x00500000 /** (UHP) Base Address */
+
+/** ***************************************************************************** */
+/**           INTERNAL MEMORIES BASE ADDRESS DEFINITIONS FOR AT91SAM9261          */
+/** ***************************************************************************** */
+#define AT91_BASE_ITCM       0x00100000 /** Maximum ITCM Area base address */
+#define AT91_SIZE_ITCM       0x00010000 /** Maximum ITCM Area size in byte (64 Kbytes)*/
+#define AT91_BASE_DTCM       0x00200000 /** Maximum DTCM Area base address*/
+#define AT91_SIZE_DTCM       0x00010000 /** Maximum DTCM Area size in byte (64 Kbytes) */
+#define AT91_BASE_SRAM       0x00300000 /** Maximum Internal SRAM base address */
+#define AT91_SIZE_SRAM       0x00001000 /** Maximum Internal SRAM size in byte (160 Kbytes) */
+#define AT91_BASE_IROM       0x00400000 /** Internal ROM base address */
+#define AT91_SIZE_IROM       0x00008000 /** Internal ROM size in byte (32 Kbytes) */
+
+/** ***************************************************************************** */
+/**           EXTERNAL MEMORIES BASE ADDRESS DEFINITIONS FOR AT91SAM9261          */
+/** ***************************************************************************** */
+#define AT91_EBI_CS0    0x10000000 /** EBI Chip Select 0 base address */
+#define AT91_EBI_CS1    0x20000000 /** EBI Chip Select 1 base address */
+#define AT91_EBI_CS2    0x30000000 /** EBI Chip Select 2 base address */
+#define AT91_EBI_CS3    0x40000000 /** EBI Chip Select 3 base address */
+#define AT91_EBI_CS4    0x50000000 /** EBI Chip Select 4 base address */
+#define AT91_EBI_CS5    0x60000000 /** EBI Chip Select 5 base address */
+#define AT91_EBI_CS6    0x70000000 /** EBI Chip Select 6 base address */
+#define AT91_EBI_CS7    0x80000000 /** EBI Chip Select 7 base address */
+
+#endif  /* __ASM_ARCH_AT91SAM9260_H */
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_isi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_isi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_isi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_isi.h	2006-08-09 10:54:56.000000000 +0200
@@ -0,0 +1,194 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_isi.h
+ * 
+ * Hardware definition for the isi peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  01/16/2006 (17:06:46) AT91 SW Application Group from ISI_xxxxx V1.3
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_ISI_H
+#define __AT91SAM9260_ISI_H
+
+/* -------------------------------------------------------- */
+/* ISI ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_HISI
+#define AT91C_ID_HISI  	22 /**< Image Sensor Interface id */
+#endif /* AT91C_ID_HISI */
+
+/* -------------------------------------------------------- */
+/* ISI Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_HISI      	0xFFFC0000 /**< HISI base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for ISI hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PB20_ISI_D0   	(1 << 20) /**< Image Sensor Data 0 */
+#define AT91C_PB21_ISI_D1   	(1 << 21) /**< Image Sensor Data 1 */
+#define AT91C_PB12_ISI_D10  	(1 << 12) /**< Image Sensor Data 10 */
+#define AT91C_PB13_ISI_D11  	(1 << 13) /**< Image Sensor Data 11 */
+#define AT91C_PB22_ISI_D2   	(1 << 22) /**< Image Sensor Data 2 */
+#define AT91C_PB23_ISI_D3   	(1 << 23) /**< Image Sensor Data 3 */
+#define AT91C_PB24_ISI_D4   	(1 << 24) /**< Image Sensor Data 4 */
+#define AT91C_PB25_ISI_D5   	(1 << 25) /**< Image Sensor Data 5 */
+#define AT91C_PB26_ISI_D6   	(1 << 26) /**< Image Sensor Data 6 */
+#define AT91C_PB27_ISI_D7   	(1 << 27) /**< Image Sensor Data 7 */
+#define AT91C_PB10_ISI_D8   	(1 << 10) /**< Image Sensor Data 8 */
+#define AT91C_PB11_ISI_D9   	(1 << 11) /**< Image Sensor Data 9 */
+#define AT91C_PB30_ISI_HSYNC 	(1 << 30) /**< Image Sensor Horizontal Synchro */
+#define AT91C_PB31_ISI_MCK  	(1 << 31) /**< Image Sensor Reference Clock */
+#define AT91C_PB28_ISI_PCK  	(1 << 28) /**< Image Sensor Data Clock */
+#define AT91C_PB29_ISI_VSYNC 	(1 << 29) /**< Image Sensor Vertical Synchro */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for ISI hardware peripheral */
+/* -------------------------------------------------------- */
+#define ISI_CR1 	(0x0000) 	/**< Control Register 1 */
+#define ISI_CR2 	(0x0004) 	/**< Control Register 2 */
+#define ISI_SR 	(0x0008) 	/**< Status Register */
+#define ISI_IER 	(0x000C) 	/**< Interrupt Enable Register */
+#define ISI_IDR 	(0x0010) 	/**< Interrupt Disable Register */
+#define ISI_IMR 	(0x0014) 	/**< Interrupt Mask Register */
+#define ISI_PSIZE 	(0x0020) 	/**< Preview Size Register */
+#define ISI_PDECF 	(0x0024) 	/**< Preview Decimation Factor Register */
+#define ISI_PPFBD    (0x0028) 	/**< Preview Primary Register */
+#define ISI_CDBA 	(0x002C) 	/**< Codec Dma Address Register */
+#define ISI_Y2RSET0 	(0x0030) 	/**< Color Space Conversion Register */
+#define ISI_Y2RSET1 	(0x0034) 	/**< Color Space Conversion Register */
+#define ISI_R2YSET0 	(0x0038) 	/**< Color Space Conversion Register */
+#define ISI_R2YSET1 	(0x003C) 	/**< Color Space Conversion Register */
+#define ISI_R2YSET2 	(0x0040) 	/**< Color Space Conversion Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for ISI hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register ISI_CR1 */
+#define AT91C_ISI_RST         (0x1 << 0 ) /**< (ISI) Image sensor interface reset */
+#define AT91C_ISI_DISABLE     (0x1 << 1 ) /**< (ISI) image sensor disable. */
+#define AT91C_ISI_HSYNC_POL   (0x1 << 2 ) /**< (ISI) Horizontal synchronisation polarity */
+#define AT91C_ISI_VSYNC_POL  (0x1 << 3) // (ISI) Vertical synchronization polarity
+#define AT91C_ISI_PIXCLK_POL  (0x1 << 4 ) /**< (ISI) Pixel Clock Polarity */
+#define AT91C_ISI_EMB_SYNC    (0x1 << 6 ) /**< (ISI) Embedded synchronisation */
+#define AT91C_ISI_CRC_SYNC    (0x1 << 7 ) /**< (ISI) CRC correction */
+#define AT91C_ISI_CRC_SYNC    (0x7 << 8 ) /**< (ISI) Frame rate capture */
+#define AT91C_ISI_FULL        (0x1 << 12) /**< (ISI) Full mode is allowed */
+#define AT91C_ISI_THMASK      (0x3 << 13) /**< (ISI) DMA Burst Mask */
+#define 	AT91C_ISI_THMASK_4_8_16_BURST         (0x0 << 13) /**< (ISI) 4,8 and 16 AHB burst are allowed */
+#define 	AT91C_ISI_THMASK_8_16_BURST           (0x1 << 13) /**< (ISI) 8 and 16 AHB burst are allowed */
+#define 	AT91C_ISI_THMASK_16_BURST             (0x2 << 13) /**< (ISI) Only 16 AHB burst are allowed */
+#define AT91C_ISI_CODEC_ON    (0x1 << 15) /**< (ISI) Enable the codec path */
+#define AT91C_ISI_SLD         (0xFF << 16) /**< (ISI) Start of Line Delay */
+#define AT91C_ISI_SFD         (0xFF << 24) /**< (ISI) Start of frame Delay */
+/* --- Register ISI_CR2 */
+#define AT91C_ISI_IM_VSIZE    (0x7FF << 0 ) /**< (ISI) Vertical size of the Image sensor [0..2047] */
+#define AT91C_ISI_GS_MODE     (0x1 << 11) /**< (ISI) Grayscale Memory Mode */
+#define AT91C_ISI_RGB_MODE    (0x3 << 12) /**< (ISI) RGB mode */
+#define 	AT91C_ISI_RGB_MODE_RGB_888              (0x0 << 12) /**< (ISI) RGB 8:8:8 24 bits */
+#define 	AT91C_ISI_RGB_MODE_RGB_565              (0x1 << 12) /**< (ISI) RGB 5:6:5 16 bits */
+#define 	AT91C_ISI_RGB_MODE_RGB_555              (0x2 << 12) /**< (ISI) RGB 5:5:5 16 bits */
+#define AT91C_ISI_GRAYSCALE   (0x1 << 13) /**< (ISI) Grayscale Mode */
+#define AT91C_ISI_RGB_SWAP    (0x1 << 14) /**< (ISI) RGB Swap */
+#define AT91C_ISI_COL_SPACE   (0x1 << 15) /**< (ISI) Color space for the image data */
+#define AT91C_ISI_IM_HSIZE    (0x7FF << 16) /**< (ISI) Horizontal size of the Image sensor [0..2047] */
+#define AT91C_ISI_RGB_MODE    (0x3 << 28) /**< (ISI) Ycc swap */
+#define 	AT91C_ISI_RGB_MODE_YCC_DEF              (0x0 << 28) /**< (ISI) Cb(i) Y(i) Cr(i) Y(i+1) */
+#define 	AT91C_ISI_RGB_MODE_YCC_MOD1             (0x1 << 28) /**< (ISI) Cr(i) Y(i) Cb(i) Y(i+1) */
+#define 	AT91C_ISI_RGB_MODE_YCC_MOD2             (0x2 << 28) /**< (ISI) Y(i) Cb(i) Y(i+1) Cr(i) */
+#define 	AT91C_ISI_RGB_MODE_YCC_MOD3             (0x3 << 28) /**< (ISI) Y(i) Cr(i) Y(i+1) Cb(i) */
+#define AT91C_ISI_RGB_CFG     (0x3 << 30) /**< (ISI) RGB configuration */
+#define 	AT91C_ISI_RGB_CFG_RGB_DEF              (0x0 << 30) /**< (ISI) R/G(MSB)  G(LSB)/B  R/G(MSB)  G(LSB)/B */
+#define 	AT91C_ISI_RGB_CFG_RGB_MOD1             (0x1 << 30) /**< (ISI) B/G(MSB)  G(LSB)/R  B/G(MSB)  G(LSB)/R */
+#define 	AT91C_ISI_RGB_CFG_RGB_MOD2             (0x2 << 30) /**< (ISI) G(LSB)/R  B/G(MSB)  G(LSB)/R  B/G(MSB) */
+#define 	AT91C_ISI_RGB_CFG_RGB_MOD3             (0x3 << 30) /**< (ISI) G(LSB)/B  R/G(MSB)  G(LSB)/B  R/G(MSB) */
+/* --- Register ISI_SR */
+#define AT91C_ISI_SOF         (0x1 << 0 ) /**< (ISI) Start of Frame */
+#define AT91C_ISI_DIS         (0x1 << 1 ) /**< (ISI) Image Sensor Interface disable */
+#define AT91C_ISI_SOFTRST     (0x1 << 2 ) /**< (ISI) Software Reset */
+#define AT91C_ISI_CRC_ERR     (0x1 << 4 ) /**< (ISI) CRC synchronisation error */
+#define AT91C_ISI_FO_C_OVF    (0x1 << 5 ) /**< (ISI) Fifo Codec Overflow  */
+#define AT91C_ISI_FO_P_OVF    (0x1 << 6 ) /**< (ISI) Fifo Preview Overflow  */
+#define AT91C_ISI_FO_P_EMP    (0x1 << 7 ) /**< (ISI) Fifo Preview Empty */
+#define AT91C_ISI_FO_C_EMP    (0x1 << 8 ) /**< (ISI) Fifo Codec Empty */
+#define AT91C_ISI_FR_OVR      (0x1 << 9 ) /**< (ISI) Frame rate overun */
+/* --- Register ISI_IER */
+#define AT91C_ISI_SOF         (0x1 << 0 ) /**< (ISI) Start of Frame */
+#define AT91C_ISI_DIS         (0x1 << 1 ) /**< (ISI) Image Sensor Interface disable */
+#define AT91C_ISI_SOFTRST     (0x1 << 2 ) /**< (ISI) Software Reset */
+#define AT91C_ISI_CRC_ERR     (0x1 << 4 ) /**< (ISI) CRC synchronisation error */
+#define AT91C_ISI_FO_C_OVF    (0x1 << 5 ) /**< (ISI) Fifo Codec Overflow  */
+#define AT91C_ISI_FO_P_OVF    (0x1 << 6 ) /**< (ISI) Fifo Preview Overflow  */
+#define AT91C_ISI_FO_P_EMP    (0x1 << 7 ) /**< (ISI) Fifo Preview Empty */
+#define AT91C_ISI_FO_C_EMP    (0x1 << 8 ) /**< (ISI) Fifo Codec Empty */
+#define AT91C_ISI_FR_OVR      (0x1 << 9 ) /**< (ISI) Frame rate overun */
+/* --- Register ISI_IDR */
+#define AT91C_ISI_SOF         (0x1 << 0 ) /**< (ISI) Start of Frame */
+#define AT91C_ISI_DIS         (0x1 << 1 ) /**< (ISI) Image Sensor Interface disable */
+#define AT91C_ISI_SOFTRST     (0x1 << 2 ) /**< (ISI) Software Reset */
+#define AT91C_ISI_CRC_ERR     (0x1 << 4 ) /**< (ISI) CRC synchronisation error */
+#define AT91C_ISI_FO_C_OVF    (0x1 << 5 ) /**< (ISI) Fifo Codec Overflow  */
+#define AT91C_ISI_FO_P_OVF    (0x1 << 6 ) /**< (ISI) Fifo Preview Overflow  */
+#define AT91C_ISI_FO_P_EMP    (0x1 << 7 ) /**< (ISI) Fifo Preview Empty */
+#define AT91C_ISI_FO_C_EMP    (0x1 << 8 ) /**< (ISI) Fifo Codec Empty */
+#define AT91C_ISI_FR_OVR      (0x1 << 9 ) /**< (ISI) Frame rate overun */
+/* --- Register ISI_IMR */
+#define AT91C_ISI_SOF         (0x1 << 0 ) /**< (ISI) Start of Frame */
+#define AT91C_ISI_DIS         (0x1 << 1 ) /**< (ISI) Image Sensor Interface disable */
+#define AT91C_ISI_SOFTRST     (0x1 << 2 ) /**< (ISI) Software Reset */
+#define AT91C_ISI_CRC_ERR     (0x1 << 4 ) /**< (ISI) CRC synchronisation error */
+#define AT91C_ISI_FO_C_OVF    (0x1 << 5 ) /**< (ISI) Fifo Codec Overflow  */
+#define AT91C_ISI_FO_P_OVF    (0x1 << 6 ) /**< (ISI) Fifo Preview Overflow  */
+#define AT91C_ISI_FO_P_EMP    (0x1 << 7 ) /**< (ISI) Fifo Preview Empty */
+#define AT91C_ISI_FO_C_EMP    (0x1 << 8 ) /**< (ISI) Fifo Codec Empty */
+#define AT91C_ISI_FR_OVR      (0x1 << 9 ) /**< (ISI) Frame rate overun */
+/* --- Register ISI_PSIZE */
+#define AT91C_ISI_PREV_VSIZE  (0x3FF << 0 ) /**< (ISI) Vertical size for the preview path */
+#define AT91C_ISI_PREV_HSIZE  (0x3FF << 16) /**< (ISI) Horizontal size for the preview path */
+/* --- Register ISI_Y2R_SET0 */
+#define AT91C_ISI_Y2R_C0      (0xFF << 0 ) /**< (ISI) Color Space Conversion Matrix Coefficient C0 */
+#define AT91C_ISI_Y2R_C1      (0xFF << 8 ) /**< (ISI) Color Space Conversion Matrix Coefficient C1 */
+#define AT91C_ISI_Y2R_C2      (0xFF << 16) /**< (ISI) Color Space Conversion Matrix Coefficient C2 */
+#define AT91C_ISI_Y2R_C3      (0xFF << 24) /**< (ISI) Color Space Conversion Matrix Coefficient C3 */
+/* --- Register ISI_Y2R_SET1 */
+#define AT91C_ISI_Y2R_C4      (0x1FF << 0 ) /**< (ISI) Color Space Conversion Matrix Coefficient C4 */
+#define AT91C_ISI_Y2R_YOFF    (0xFF << 12) /**< (ISI) Color Space Conversion Luninance default offset */
+#define AT91C_ISI_Y2R_CROFF   (0xFF << 13) /**< (ISI) Color Space Conversion Red Chrominance default offset */
+#define AT91C_ISI_Y2R_CBFF    (0xFF << 14) /**< (ISI) Color Space Conversion Luninance default offset */
+/* --- Register ISI_R2Y_SET0 */
+#define AT91C_ISI_R2Y_C0      (0x7F << 0 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C0 */
+#define AT91C_ISI_R2Y_C1      (0x7F << 1 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C1 */
+#define AT91C_ISI_R2Y_C2      (0x7F << 3 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C2 */
+#define AT91C_ISI_R2Y_ROFF    (0x1 << 4 ) /**< (ISI) Color Space Conversion Red component offset */
+/* --- Register ISI_R2Y_SET1 */
+#define AT91C_ISI_R2Y_C3      (0x7F << 0 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C3 */
+#define AT91C_ISI_R2Y_C4      (0x7F << 1 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C4 */
+#define AT91C_ISI_R2Y_C5      (0x7F << 3 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C5 */
+#define AT91C_ISI_R2Y_GOFF    (0x1 << 4 ) /**< (ISI) Color Space Conversion Green component offset */
+/* --- Register ISI_R2Y_SET2 */
+#define AT91C_ISI_R2Y_C6      (0x7F << 0 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C6 */
+#define AT91C_ISI_R2Y_C7      (0x7F << 1 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C7 */
+#define AT91C_ISI_R2Y_C8      (0x7F << 3 ) /**< (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C8 */
+#define AT91C_ISI_R2Y_BOFF    (0x1 << 4 ) /**< (ISI) Color Space Conversion Blue component offset */
+
+#endif /* __AT91SAM9260_ISI_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_matrix.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_matrix.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_matrix.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_matrix.h	2006-08-09 16:41:26.000000000 +0200
@@ -0,0 +1,159 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_matrix.h
+ * 
+ * Hardware definition for the matrix peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  01/16/2006 (17:06:46) AT91 SW Application Group from HMATRIX1_SAM9260 V1.4
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_MATRIX_H
+#define __AT91SAM9260_MATRIX_H
+
+/* -------------------------------------------------------- */
+/* MATRIX ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* MATRIX Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_MATRIX    	0xFFFFEE00 /**< MATRIX base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+#define MATRIX_MCFG0 	(0x0000) 	/**<  Master Configuration Register 0 (ram96k)      */
+#define MATRIX_MCFG1 	(0x0004) 	/**<  Master Configuration Register 1 (rom)     */
+#define MATRIX_MCFG2 	(0x0008) 	/**<  Master Configuration Register 2 (hperiphs)  */
+#define MATRIX_MCFG3 	(0x000C) 	/**<  Master Configuration Register 3 (ebi) */
+#define MATRIX_MCFG4 	(0x0010) 	/**<  Master Configuration Register 4 (bridge)     */
+#define MATRIX_MCFG5 	(0x0014) 	/**<  Master Configuration Register 5 (mailbox)     */
+#define MATRIX_MCFG6 	(0x0018) 	/**<  Master Configuration Register 6 (ram16k)   */
+#define MATRIX_MCFG7 	(0x001C) 	/**<  Master Configuration Register 7 (teak_prog)      */
+#define MATRIX_SCFG0 	(0x0040) 	/**<  Slave Configuration Register 0 (ram96k)      */
+#define MATRIX_SCFG1 	(0x0044) 	/**<  Slave Configuration Register 1 (rom)     */
+#define MATRIX_SCFG2 	(0x0048) 	/**<  Slave Configuration Register 2 (hperiphs)  */
+#define MATRIX_SCFG3 	(0x004C) 	/**<  Slave Configuration Register 3 (ebi) */
+#define MATRIX_SCFG4 	(0x0050) 	/**<  Slave Configuration Register 4 (bridge)     */
+#define MATRIX_PRAS0 	(0x0080) 	/**<  PRAS0 (ram0)  */
+#define MATRIX_PRBS0 	(0x0084) 	/**<  PRBS0 (ram0)  */
+#define MATRIX_PRAS1 	(0x0088) 	/**<  PRAS1 (ram1)  */
+#define MATRIX_PRBS1 	(0x008C) 	/**<  PRBS1 (ram1)  */
+#define MATRIX_PRAS2 	(0x0090) 	/**<  PRAS2 (ram2)  */
+#define MATRIX_PRBS2 	(0x0094) 	/**<  PRBS2 (ram2)  */
+#define MATRIX_MRCR 	(0x0100) 	/**<  Master Remp Control Register  */
+#define MATRIX_EBI 	(0x011C) 	/**<  Slave 3 (ebi) Special Function Register */
+#define MATRIX_TEAKCFG 	(0x012C) 	/**<  Slave 7 (teak_prog) Special Function Register */
+#define MATRIX_VERSION 	(0x01FC) 	/**<  Version Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register MATRIX_SCFG0 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR0 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_DMA                  (0x4 << 18) /**< (MATRIX) DMA Master is Default Master */
+/* --- Register MATRIX_SCFG1 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR1 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_DMA                  (0x4 << 18) /**< (MATRIX) DMA Master is Default Master */
+/* --- Register MATRIX_SCFG2 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR2 (0x1 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+/* --- Register MATRIX_SCFG3 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR3 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_DMA                  (0x4 << 18) /**< (MATRIX) DMA Master is Default Master */
+/* --- Register MATRIX_SCFG4 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR4 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+/* --- Register MATRIX_MRCR */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_EBI */
+#define AT91C_MATRIX_CS1A     (0x1 << 1 ) /**< (MATRIX) Chip Select 1 Assignment */
+#define 	AT91C_MATRIX_CS1A_SMC                  (0x0 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the Static Memory Controller. */
+#define 	AT91C_MATRIX_CS1A_SDRAMC               (0x1 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the SDRAM Controller. */
+#define AT91C_MATRIX_CS3A     (0x1 << 3 ) /**< (MATRIX) Chip Select 3 Assignment */
+#define 	AT91C_MATRIX_CS3A_SMC                  (0x0 <<  3) /**< (MATRIX) Chip Select 3 is only assigned to the Static Memory Controller and NCS3 behaves as defined by the SMC. */
+#define 	AT91C_MATRIX_CS3A_SM                   (0x1 <<  3) /**< (MATRIX) Chip Select 3 is assigned to the Static Memory Controller and the SmartMedia Logic is activated. */
+#define AT91C_MATRIX_CS4A     (0x1 << 4 ) /**< (MATRIX) Chip Select 4 Assignment */
+#define 	AT91C_MATRIX_CS4A_SMC                  (0x0 <<  4) /**< (MATRIX) Chip Select 4 is only assigned to the Static Memory Controller and NCS4 behaves as defined by the SMC. */
+#define 	AT91C_MATRIX_CS4A_CF                   (0x1 <<  4) /**< (MATRIX) Chip Select 4 is assigned to the Static Memory Controller and the CompactFlash Logic (first slot) is activated. */
+#define AT91C_MATRIX_CS5A     (0x1 << 5 ) /**< (MATRIX) Chip Select 5 Assignment */
+#define 	AT91C_MATRIX_CS5A_SMC                  (0x0 <<  5) /**< (MATRIX) Chip Select 5 is only assigned to the Static Memory Controller and NCS5 behaves as defined by the SMC */
+#define 	AT91C_MATRIX_CS5A_CF                   (0x1 <<  5) /**< (MATRIX) Chip Select 5 is assigned to the Static Memory Controller and the CompactFlash Logic (second slot) is activated. */
+#define AT91C_MATRIX_DBPUC    (0x1 << 8 ) /**< (MATRIX) Data Bus Pull-up Configuration */
+/* --- Register MATRIX_TEAKCFG */
+#define AT91C_TEAK_PROGRAM_ACCESS (0x1 << 0 ) /**< (MATRIX) TEAK program memory access from AHB */
+#define 	AT91C_TEAK_PROGRAM_ACCESS_DISABLED             0x0 /**< (MATRIX) TEAK program access disabled */
+#define 	AT91C_TEAK_PROGRAM_ACCESS_ENABLED              0x1 /**< (MATRIX) TEAK program access enabled */
+#define AT91C_TEAK_BOOT       (0x1 << 1 ) /**< (MATRIX) TEAK program start from boot routine */
+#define 	AT91C_TEAK_BOOT_DISABLED             (0x0 <<  1) /**< (MATRIX) TEAK program starts from boot routine disabled */
+#define 	AT91C_TEAK_BOOT_ENABLED              (0x1 <<  1) /**< (MATRIX) TEAK program starts from boot routine enabled */
+#define AT91C_TEAK_NRESET     (0x1 << 2 ) /**< (MATRIX) active low TEAK reset */
+#define 	AT91C_TEAK_NRESET_ENABLED              (0x0 <<  2) /**< (MATRIX) active low TEAK reset enabled */
+#define 	AT91C_TEAK_NRESET_DISABLED             (0x1 <<  2) /**< (MATRIX) active low TEAK reset disabled */
+#define AT91C_TEAK_LVECTORP   (0x3FFFF << 14) /**< (MATRIX) boot routine start address */
+
+#endif /* __AT91SAM9260_MATRIX_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pdc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pdc.h	2006-08-09 10:54:57.000000000 +0200
@@ -0,0 +1,83 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_pdc.h
+ * 
+ * Hardware definition for the pdc peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from PDC_6074C V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_PDC_H
+#define __AT91SAM9260_PDC_H
+
+/* -------------------------------------------------------- */
+/* PDC ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* PDC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PDC_DBGU  	0xFFFFF300 /**< PDC_DBGU base address */
+#define AT91C_BASE_PDC_MCI   	0xFFFA8100 /**< PDC_MCI base address */
+#define AT91C_BASE_PDC_TWI   	0xFFFAC100 /**< PDC_TWI base address */
+#define AT91C_BASE_PDC_US0   	0xFFFB0100 /**< PDC_US0 base address */
+#define AT91C_BASE_PDC_US1   	0xFFFB4100 /**< PDC_US1 base address */
+#define AT91C_BASE_PDC_US2   	0xFFFB8100 /**< PDC_US2 base address */
+#define AT91C_BASE_PDC_US3   	0xFFFD0100 /**< PDC_US3 base address */
+#define AT91C_BASE_PDC_US4   	0xFFFD4100 /**< PDC_US4 base address */
+#define AT91C_BASE_PDC_US5   	0xFFFD8100 /**< PDC_US5 base address */
+#define AT91C_BASE_PDC_SSC0  	0xFFFBC100 /**< PDC_SSC0 base address */
+#define AT91C_BASE_PDC_SPI0  	0xFFFC8100 /**< PDC_SPI0 base address */
+#define AT91C_BASE_PDC_SPI1  	0xFFFCC100 /**< PDC_SPI1 base address */
+#define AT91C_BASE_PDC_ADC   	0xFFFE0100 /**< PDC_ADC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PDC hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PDC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PDC_RPR 	(0x0000) 	/**< Receive Pointer Register */
+#define PDC_RCR 	(0x0004) 	/**< Receive Counter Register */
+#define PDC_TPR 	(0x0008) 	/**< Transmit Pointer Register */
+#define PDC_TCR 	(0x000C) 	/**< Transmit Counter Register */
+#define PDC_RNPR 	(0x0010) 	/**< Receive Next Pointer Register */
+#define PDC_RNCR 	(0x0014) 	/**< Receive Next Counter Register */
+#define PDC_TNPR 	(0x0018) 	/**< Transmit Next Pointer Register */
+#define PDC_TNCR 	(0x001C) 	/**< Transmit Next Counter Register */
+#define PDC_PTCR 	(0x0020) 	/**< PDC Transfer Control Register */
+#define PDC_PTSR 	(0x0024) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PDC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PDC_PTCR */
+#define AT91C_PDC_RXTEN       (0x1 << 0 ) /**< (PDC) Receiver Transfer Enable */
+#define AT91C_PDC_RXTDIS      (0x1 << 1 ) /**< (PDC) Receiver Transfer Disable */
+#define AT91C_PDC_TXTEN       (0x1 << 8 ) /**< (PDC) Transmitter Transfer Enable */
+#define AT91C_PDC_TXTDIS      (0x1 << 9 ) /**< (PDC) Transmitter Transfer Disable */
+/* --- Register PDC_PTSR */
+#define AT91C_PDC_RXTEN       (0x1 << 0 ) /**< (PDC) Receiver Transfer Enable */
+#define AT91C_PDC_TXTEN       (0x1 << 8 ) /**< (PDC) Transmitter Transfer Enable */
+
+#endif /* __AT91SAM9260_PDC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pio.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pio.h	2006-08-09 10:54:58.000000000 +0200
@@ -0,0 +1,93 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_pio.h
+ * 
+ * Hardware definition for the pio peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  01/16/2006 (17:06:46) AT91 SW Application Group from PIO_6057A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_PIO_H
+#define __AT91SAM9260_PIO_H
+
+/* -------------------------------------------------------- */
+/* PIO ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_PIOA
+#define AT91C_ID_PIOA  	 2 /**< Parallel IO Controller A id */
+#endif /* AT91C_ID_PIOA */
+#ifndef AT91C_ID_PIOB
+#define AT91C_ID_PIOB  	 3 /**< Parallel IO Controller B id */
+#endif /* AT91C_ID_PIOB */
+#ifndef AT91C_ID_PIOC
+#define AT91C_ID_PIOC  	 4 /**< Parallel IO Controller C id */
+#endif /* AT91C_ID_PIOC */
+
+/* -------------------------------------------------------- */
+/* PIO Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PIOA      	0xFFFFF400 /**< PIOA base address */
+#define AT91C_BASE_PIOB      	0xFFFFF600 /**< PIOB base address */
+#define AT91C_BASE_PIOC      	0xFFFFF800 /**< PIOC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+#define PIO_PER 	(0x0000) 	/**< PIO Enable Register */
+#define PIO_PDR 	(0x0004) 	/**< PIO Disable Register */
+#define PIO_PSR 	(0x0008) 	/**< PIO Status Register */
+#define PIO_OER 	(0x0010) 	/**< Output Enable Register */
+#define PIO_ODR 	(0x0014) 	/**< Output Disable Registerr */
+#define PIO_OSR 	(0x0018) 	/**< Output Status Register */
+#define PIO_IFER 	(0x0020) 	/**< Input Filter Enable Register */
+#define PIO_IFDR 	(0x0024) 	/**< Input Filter Disable Register */
+#define PIO_IFSR 	(0x0028) 	/**< Input Filter Status Register */
+#define PIO_SODR 	(0x0030) 	/**< Set Output Data Register */
+#define PIO_CODR 	(0x0034) 	/**< Clear Output Data Register */
+#define PIO_ODSR 	(0x0038) 	/**< Output Data Status Register */
+#define PIO_PDSR 	(0x003C) 	/**< Pin Data Status Register */
+#define PIO_IER 	(0x0040) 	/**< Interrupt Enable Register */
+#define PIO_IDR 	(0x0044) 	/**< Interrupt Disable Register */
+#define PIO_IMR 	(0x0048) 	/**< Interrupt Mask Register */
+#define PIO_ISR 	(0x004C) 	/**< Interrupt Status Register */
+#define PIO_MDER 	(0x0050) 	/**< Multi-driver Enable Register */
+#define PIO_MDDR 	(0x0054) 	/**< Multi-driver Disable Register */
+#define PIO_MDSR 	(0x0058) 	/**< Multi-driver Status Register */
+#define PIO_PPUDR 	(0x0060) 	/**< Pull-up Disable Register */
+#define PIO_PPUER 	(0x0064) 	/**< Pull-up Enable Register */
+#define PIO_PPUSR 	(0x0068) 	/**< Pull-up Status Register */
+#define PIO_ASR 	(0x0070) 	/**< Select A Register */
+#define PIO_BSR 	(0x0074) 	/**< Select B Register */
+#define PIO_ABSR 	(0x0078) 	/**< AB Select Status Register */
+#define PIO_OWER 	(0x00A0) 	/**< Output Write Enable Register */
+#define PIO_OWDR 	(0x00A4) 	/**< Output Write Disable Register */
+#define PIO_OWSR 	(0x00A8) 	/**< Output Write Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+
+#endif /* __AT91SAM9260_PIO_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pitc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pitc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pitc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pitc.h	2006-08-09 10:54:59.000000000 +0200
@@ -0,0 +1,57 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_pitc.h
+ * 
+ * Hardware definition for the pitc peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from PITC_6079A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9260_PITC_H
+#define __AT91SAM9260_PITC_H
+
+/* -------------------------------------------------------- */
+/* PITC ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SYS
+#define AT91C_ID_SYS   	 1 /**< System Controller id */
+#endif /* AT91C_ID_SYS */
+
+/* -------------------------------------------------------- */
+/* PITC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PITC      	0xFFFFFD30 /**< PITC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PITC_PIMR 	(0x0000) 	/**< Period Interval Mode Register */
+#define PITC_PISR 	(0x0004) 	/**< Period Interval Status Register */
+#define PITC_PIVR 	(0x0008) 	/**< Period Interval Value Register */
+#define PITC_PIIR 	(0x000C) 	/**< Period Interval Image Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PITC_PIMR */
+#define AT91C_PITC_PIV        (0xFFFFF << 0 ) /**< (PITC) Periodic Interval Value */
+#define AT91C_PITC_PITEN      (0x1 << 24) /**< (PITC) Periodic Interval Timer Enabled */
+#define AT91C_PITC_PITIEN     (0x1 << 25) /**< (PITC) Periodic Interval Timer Interrupt Enable */
+/* --- Register PITC_PISR */
+#define AT91C_PITC_PITS       (0x1 << 0 ) /**< (PITC) Periodic Interval Timer Status */
+/* --- Register PITC_PIVR */
+#define AT91C_PITC_CPIV       (0xFFFFF << 0 ) /**< (PITC) Current Periodic Interval Value */
+#define AT91C_PITC_PICNT      (0xFFF << 20) /**< (PITC) Periodic Interval Counter */
+/* --- Register PITC_PIIR */
+#define AT91C_PITC_CPIV       (0xFFFFF << 0 ) /**< (PITC) Current Periodic Interval Value */
+#define AT91C_PITC_PICNT      (0xFFF << 20) /**< (PITC) Periodic Interval Counter */
+
+#endif /* __AT91SAM9260_PITC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pmc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pmc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_pmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_pmc.h	2006-08-09 10:55:00.000000000 +0200
@@ -0,0 +1,181 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_pmc.h
+ * 
+ * Hardware definition for the pmc peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from PMC_SAM9261 V1.4
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9260_PMC_H
+#define __AT91SAM9260_PMC_H
+
+/* -------------------------------------------------------- */
+/* PMC ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SYS
+#define AT91C_ID_SYS   	 1 /**< System Controller id */
+#endif /* AT91C_ID_SYS */
+
+/* -------------------------------------------------------- */
+/* PMC Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PMC       	0xFFFFFC00 /**< PMC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PC1_PCK0     	(1 << 1) /**< PMC Programmable Clock Output 0 */
+#define AT91C_PB30_PCK0_0   	(1 << 30) /**< PMC Programmable Clock Output 0 */
+#define AT91C_PC2_PCK1     	(1 << 2) /**< PMC Programmable Clock Output 1 */
+#define AT91C_PB31_PCK1_0   	(1 << 31) /**< PMC Programmable Clock Output 1 */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PMC_SCER 	(0x0000) 	/**< System Clock Enable Register */
+#define PMC_SCDR 	(0x0004) 	/**< System Clock Disable Register */
+#define PMC_SCSR 	(0x0008) 	/**< System Clock Status Register */
+#define PMC_PCER 	(0x0010) 	/**< Peripheral Clock Enable Register */
+#define PMC_PCDR 	(0x0014) 	/**< Peripheral Clock Disable Register */
+#define PMC_PCSR 	(0x0018) 	/**< Peripheral Clock Status Register */
+#define PMC_MOR 	(0x0020) 	/**< Main Oscillator Register */
+#define PMC_MCFR 	(0x0024) 	/**< Main Clock  Frequency Register */
+#define PMC_PLLAR 	(0x0028) 	/**< PLL A Register */
+#define PMC_PLLBR 	(0x002C) 	/**< PLL B Register */
+#define PMC_MCKR 	(0x0030) 	/**< Master Clock Register */
+#define PMC_PCKR 	(0x0040) 	/**< Programmable Clock Register */
+#define PMC_IER 	(0x0060) 	/**< Interrupt Enable Register */
+#define PMC_IDR 	(0x0064) 	/**< Interrupt Disable Register */
+#define PMC_SR 	(0x0068) 	/**< Status Register */
+#define PMC_IMR 	(0x006C) 	/**< Interrupt Mask Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PMC_SCER */
+#define AT91C_PMC_PCK         (0x1 << 0 ) /**< (PMC) Processor Clock */
+#define AT91C_PMC_UHP         (0x1 << 6 ) /**< (PMC) USB Host Port Clock */
+#define AT91C_PMC_UDP         (0x1 << 7 ) /**< (PMC) USB Device Port Clock */
+#define AT91C_PMC_PCK0        (0x1 << 8 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1        (0x1 << 9 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_HCK0        (0x1 << 16) /**< (PMC) AHB UHP Clock Output */
+#define AT91C_PMC_HCK1        (0x1 << 17) /**< (PMC) AHB LCDC Clock Output */
+/* --- Register PMC_SCDR */
+#define AT91C_PMC_PCK         (0x1 << 0 ) /**< (PMC) Processor Clock */
+#define AT91C_PMC_UHP         (0x1 << 6 ) /**< (PMC) USB Host Port Clock */
+#define AT91C_PMC_UDP         (0x1 << 7 ) /**< (PMC) USB Device Port Clock */
+#define AT91C_PMC_PCK0        (0x1 << 8 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1        (0x1 << 9 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_HCK0        (0x1 << 16) /**< (PMC) AHB UHP Clock Output */
+#define AT91C_PMC_HCK1        (0x1 << 17) /**< (PMC) AHB LCDC Clock Output */
+/* --- Register PMC_SCSR */
+#define AT91C_PMC_PCK         (0x1 << 0 ) /**< (PMC) Processor Clock */
+#define AT91C_PMC_UHP         (0x1 << 6 ) /**< (PMC) USB Host Port Clock */
+#define AT91C_PMC_UDP         (0x1 << 7 ) /**< (PMC) USB Device Port Clock */
+#define AT91C_PMC_PCK0        (0x1 << 8 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1        (0x1 << 9 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_HCK0        (0x1 << 16) /**< (PMC) AHB UHP Clock Output */
+#define AT91C_PMC_HCK1        (0x1 << 17) /**< (PMC) AHB LCDC Clock Output */
+/* --- Register CKGR_MOR */
+#define AT91C_CKGR_MOSCEN     (0x1 << 0 ) /**< (PMC) Main Oscillator Enable */
+#define AT91C_CKGR_OSCBYPASS  (0x1 << 1 ) /**< (PMC) Main Oscillator Bypass */
+#define AT91C_CKGR_OSCOUNT    (0xFF << 8 ) /**< (PMC) Main Oscillator Start-up Time */
+/* --- Register CKGR_MCFR */
+#define AT91C_CKGR_MAINF      (0xFFFF << 0 ) /**< (PMC) Main Clock Frequency */
+#define AT91C_CKGR_MAINRDY    (0x1 << 16) /**< (PMC) Main Clock Ready */
+/* --- Register CKGR_PLLAR */
+#define AT91C_CKGR_DIVA       (0xFF << 0 ) /**< (PMC) Divider A Selected */
+#define 	AT91C_CKGR_DIVA_0                    0x0 /**< (PMC) Divider A output is 0 */
+#define 	AT91C_CKGR_DIVA_BYPASS               0x1 /**< (PMC) Divider A is bypassed */
+#define AT91C_CKGR_PLLACOUNT  (0x3F << 8 ) /**< (PMC) PLL A Counter */
+#define AT91C_CKGR_OUTA       (0x3 << 14) /**< (PMC) PLL A Output Frequency Range */
+#define 	AT91C_CKGR_OUTA_0                    (0x0 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_1                    (0x1 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_2                    (0x2 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_3                    (0x3 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define AT91C_CKGR_MULA       (0x7FF << 16) /**< (PMC) PLL A Multiplier */
+#define AT91C_CKGR_SRCA       (0x1 << 29) /**< (PMC)  */
+/* --- Register CKGR_PLLBR */
+#define AT91C_CKGR_DIVB       (0xFF << 0 ) /**< (PMC) Divider B Selected */
+#define 	AT91C_CKGR_DIVB_0                    0x0 /**< (PMC) Divider B output is 0 */
+#define 	AT91C_CKGR_DIVB_BYPASS               0x1 /**< (PMC) Divider B is bypassed */
+#define AT91C_CKGR_PLLBCOUNT  (0x3F << 8 ) /**< (PMC) PLL B Counter */
+#define AT91C_CKGR_OUTB       (0x3 << 14) /**< (PMC) PLL B Output Frequency Range */
+#define 	AT91C_CKGR_OUTB_0                    (0x0 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_1                    (0x1 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_2                    (0x2 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_3                    (0x3 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define AT91C_CKGR_MULB       (0x7FF << 16) /**< (PMC) PLL B Multiplier */
+#define AT91C_CKGR_USBDIV     (0x3 << 28) /**< (PMC) Divider for USB Clocks */
+#define 	AT91C_CKGR_USBDIV_0                    (0x0 << 28) /**< (PMC) Divider output is PLL clock output */
+#define 	AT91C_CKGR_USBDIV_1                    (0x1 << 28) /**< (PMC) Divider output is PLL clock output divided by 2 */
+#define 	AT91C_CKGR_USBDIV_2                    (0x2 << 28) /**< (PMC) Divider output is PLL clock output divided by 4 */
+/* --- Register PMC_MCKR */
+#define AT91C_PMC_CSS         (0x3 << 0 ) /**< (PMC) Programmable Clock Selection */
+#define 	AT91C_PMC_CSS_SLOW_CLK             0x0 /**< (PMC) Slow Clock is selected */
+#define 	AT91C_PMC_CSS_MAIN_CLK             0x1 /**< (PMC) Main Clock is selected */
+#define 	AT91C_PMC_CSS_PLLA_CLK             0x2 /**< (PMC) Clock from PLL A is selected */
+#define 	AT91C_PMC_CSS_PLLB_CLK             0x3 /**< (PMC) Clock from PLL B is selected */
+#define AT91C_PMC_PRES        (0x7 << 2 ) /**< (PMC) Programmable Clock Prescaler */
+#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) /**< (PMC) Selected clock */
+#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) /**< (PMC) Selected clock divided by 2 */
+#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) /**< (PMC) Selected clock divided by 4 */
+#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) /**< (PMC) Selected clock divided by 8 */
+#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) /**< (PMC) Selected clock divided by 16 */
+#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) /**< (PMC) Selected clock divided by 32 */
+#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) /**< (PMC) Selected clock divided by 64 */
+#define AT91C_PMC_MDIV        (0x3 << 8 ) /**< (PMC) Master Clock Division */
+#define 	AT91C_PMC_MDIV_1                    (0x0 <<  8) /**< (PMC) The master clock and the processor clock are the same */
+#define 	AT91C_PMC_MDIV_2                    (0x1 <<  8) /**< (PMC) The processor clock is twice as fast as the master clock */
+#define 	AT91C_PMC_MDIV_3                    (0x2 <<  8) /**< (PMC) The processor clock is four times faster than the master clock */
+/* --- Register PMC_PCKR */
+#define AT91C_PMC_CSS         (0x3 << 0 ) /**< (PMC) Programmable Clock Selection */
+#define 	AT91C_PMC_CSS_SLOW_CLK             0x0 /**< (PMC) Slow Clock is selected */
+#define 	AT91C_PMC_CSS_MAIN_CLK             0x1 /**< (PMC) Main Clock is selected */
+#define 	AT91C_PMC_CSS_PLLA_CLK             0x2 /**< (PMC) Clock from PLL A is selected */
+#define 	AT91C_PMC_CSS_PLLB_CLK             0x3 /**< (PMC) Clock from PLL B is selected */
+#define AT91C_PMC_PRES        (0x7 << 2 ) /**< (PMC) Programmable Clock Prescaler */
+#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) /**< (PMC) Selected clock */
+#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) /**< (PMC) Selected clock divided by 2 */
+#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) /**< (PMC) Selected clock divided by 4 */
+#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) /**< (PMC) Selected clock divided by 8 */
+#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) /**< (PMC) Selected clock divided by 16 */
+#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) /**< (PMC) Selected clock divided by 32 */
+#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) /**< (PMC) Selected clock divided by 64 */
+/* --- Register PMC_IER */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+/* --- Register PMC_IDR */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+/* --- Register PMC_SR */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_OSCSEL      (0x1 << 7 ) /**< (PMC) 32kHz Oscillator selection status */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+/* --- Register PMC_IMR */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+
+#endif /* __AT91SAM9260_PMC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_spi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_spi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_spi.h	2006-08-09 10:55:01.000000000 +0200
@@ -0,0 +1,180 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_spi.h
+ * 
+ * Hardware definition for the spi peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  01/16/2006 (17:06:46) AT91 SW Application Group from SPI_6088D V1.3
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_SPI_H
+#define __AT91SAM9260_SPI_H
+
+/* -------------------------------------------------------- */
+/* SPI ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SPI0
+#define AT91C_ID_SPI0  	12 /**< Serial Peripheral Interface 0 id */
+#endif /* AT91C_ID_SPI0 */
+#ifndef AT91C_ID_SPI1
+#define AT91C_ID_SPI1  	13 /**< Serial Peripheral Interface 1 id */
+#endif /* AT91C_ID_SPI1 */
+
+/* -------------------------------------------------------- */
+/* SPI Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_SPI0      	0xFFFC8000 /**< SPI0 base address */
+#define AT91C_BASE_SPI1      	0xFFFCC000 /**< SPI1 base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PA0_SPI0_MISO 	(1 << 0) /**< SPI 0 Master In Slave */
+#define AT91C_PA1_SPI0_MOSI 	(1 << 1) /**< SPI 0 Master Out Slave */
+#define AT91C_PA3_SPI0_NPCS0 	(1 << 3) /**< SPI 0 Peripheral Chip Select 0 */
+#define AT91C_PC11_SPI0_NPCS1 	(1 << 11) /**< SPI 0 Peripheral Chip Select 1 */
+#define AT91C_PC16_SPI0_NPCS2 	(1 << 16) /**< SPI 0 Peripheral Chip Select 2 */
+#define AT91C_PC17_SPI0_NPCS3 	(1 << 17) /**< SPI 0 Peripheral Chip Select 3 */
+#define AT91C_PA2_SPI0_SPCK 	(1 << 2) /**< SPI 0 Serial Clock */
+
+#define AT91C_PB0_SPI1_MISO 	(1 << 0) /**< SPI 1 Master In Slave */
+#define AT91C_PB1_SPI1_MOSI 	(1 << 1) /**< SPI 1 Master Out Slave */
+#define AT91C_PB3_SPI1_NPCS0 	(1 << 3) /**< SPI 1 Peripheral Chip Select 0 */
+#define AT91C_PC18_SPI1_NPCS1 	(1 << 18) /**< SPI 1 Peripheral Chip Select 1 */
+#define AT91C_PC19_SPI1_NPCS2 	(1 << 19) /**< SPI 1 Peripheral Chip Select 2 */
+#define AT91C_PC3_SPI1_NPCS3 	(1 << 3) /**< SPI 1 Peripheral Chip Select 3 */
+#define AT91C_PB2_SPI1_SPCK 	(1 << 2) /**< SPI 1 Serial Clock */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+#define SPI_CR 	(0x0000) 	/**< Control Register */
+#define SPI_MR 	(0x0004) 	/**< Mode Register */
+#define SPI_RDR 	(0x0008) 	/**< Receive Data Register */
+#define SPI_TDR 	(0x000C) 	/**< Transmit Data Register */
+#define SPI_SR 	(0x0010) 	/**< Status Register */
+#define SPI_IER 	(0x0014) 	/**< Interrupt Enable Register */
+#define SPI_IDR 	(0x0018) 	/**< Interrupt Disable Register */
+#define SPI_IMR 	(0x001C) 	/**< Interrupt Mask Register */
+#define SPI_CSR 	(0x0030) 	/**< Chip Select Register */
+#define SPI_RPR 	(0x0100) 	/**< Receive Pointer Register */
+#define SPI_RCR 	(0x0104) 	/**< Receive Counter Register */
+#define SPI_TPR 	(0x0108) 	/**< Transmit Pointer Register */
+#define SPI_TCR 	(0x010C) 	/**< Transmit Counter Register */
+#define SPI_RNPR 	(0x0110) 	/**< Receive Next Pointer Register */
+#define SPI_RNCR 	(0x0114) 	/**< Receive Next Counter Register */
+#define SPI_TNPR 	(0x0118) 	/**< Transmit Next Pointer Register */
+#define SPI_TNCR 	(0x011C) 	/**< Transmit Next Counter Register */
+#define SPI_PTCR 	(0x0120) 	/**< PDC Transfer Control Register */
+#define SPI_PTSR 	(0x0124) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register SPI_CR */
+#define AT91C_SPI_SPIEN       (0x1 << 0 ) /**< (SPI) SPI Enable */
+#define AT91C_SPI_SPIDIS      (0x1 << 1 ) /**< (SPI) SPI Disable */
+#define AT91C_SPI_SWRST       (0x1 << 7 ) /**< (SPI) SPI Software reset */
+#define AT91C_SPI_LASTXFER    (0x1 << 24) /**< (SPI) SPI Last Transfer */
+/* --- Register SPI_MR */
+#define AT91C_SPI_MSTR        (0x1 << 0 ) /**< (SPI) Master/Slave Mode */
+#define AT91C_SPI_PS          (0x1 << 1 ) /**< (SPI) Peripheral Select */
+#define 	AT91C_SPI_PS_FIXED                (0x0 <<  1) /**< (SPI) Fixed Peripheral Select */
+#define 	AT91C_SPI_PS_VARIABLE             (0x1 <<  1) /**< (SPI) Variable Peripheral Select */
+#define AT91C_SPI_PCSDEC      (0x1 << 2 ) /**< (SPI) Chip Select Decode */
+#define AT91C_SPI_FDIV        (0x1 << 3 ) /**< (SPI) Clock Selection */
+#define AT91C_SPI_MODFDIS     (0x1 << 4 ) /**< (SPI) Mode Fault Detection */
+#define AT91C_SPI_LLB         (0x1 << 7 ) /**< (SPI) Clock Selection */
+#define AT91C_SPI_PCS         (0xF << 16) /**< (SPI) Peripheral Chip Select */
+#define AT91C_SPI_DLYBCS      (0xFF << 24) /**< (SPI) Delay Between Chip Selects */
+/* --- Register SPI_RDR */
+#define AT91C_SPI_RD          (0xFFFF << 0 ) /**< (SPI) Receive Data */
+#define AT91C_SPI_RPCS        (0xF << 16) /**< (SPI) Peripheral Chip Select Status */
+/* --- Register SPI_TDR */
+#define AT91C_SPI_TD          (0xFFFF << 0 ) /**< (SPI) Transmit Data */
+#define AT91C_SPI_TPCS        (0xF << 16) /**< (SPI) Peripheral Chip Select Status */
+#define AT91C_SPI_LASTXFER    (0x1 << 24) /**< (SPI) SPI Last Transfer */
+/* --- Register SPI_SR */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+#define AT91C_SPI_SPIENS      (0x1 << 16) /**< (SPI) Enable Status */
+/* --- Register SPI_IER */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+/* --- Register SPI_IDR */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+/* --- Register SPI_IMR */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+/* --- Register SPI_CSR */
+#define AT91C_SPI_CPOL        (0x1 << 0 ) /**< (SPI) Clock Polarity */
+#define AT91C_SPI_NCPHA       (0x1 << 1 ) /**< (SPI) Clock Phase */
+#define AT91C_SPI_CSAAT       (0x1 << 3 ) /**< (SPI) Chip Select Active After Transfer */
+#define AT91C_SPI_BITS        (0xF << 4 ) /**< (SPI) Bits Per Transfer */
+#define 	AT91C_SPI_BITS_8                    (0x0 <<  4) /**< (SPI) 8 Bits Per transfer */
+#define 	AT91C_SPI_BITS_9                    (0x1 <<  4) /**< (SPI) 9 Bits Per transfer */
+#define 	AT91C_SPI_BITS_10                   (0x2 <<  4) /**< (SPI) 10 Bits Per transfer */
+#define 	AT91C_SPI_BITS_11                   (0x3 <<  4) /**< (SPI) 11 Bits Per transfer */
+#define 	AT91C_SPI_BITS_12                   (0x4 <<  4) /**< (SPI) 12 Bits Per transfer */
+#define 	AT91C_SPI_BITS_13                   (0x5 <<  4) /**< (SPI) 13 Bits Per transfer */
+#define 	AT91C_SPI_BITS_14                   (0x6 <<  4) /**< (SPI) 14 Bits Per transfer */
+#define 	AT91C_SPI_BITS_15                   (0x7 <<  4) /**< (SPI) 15 Bits Per transfer */
+#define 	AT91C_SPI_BITS_16                   (0x8 <<  4) /**< (SPI) 16 Bits Per transfer */
+#define AT91C_SPI_SCBR        (0xFF << 8 ) /**< (SPI) Serial Clock Baud Rate */
+#define AT91C_SPI_DLYBS       (0xFF << 16) /**< (SPI) Delay Before SPCK */
+#define AT91C_SPI_DLYBCT      (0xFF << 24) /**< (SPI) Delay Between Consecutive Transfers */
+
+#endif /* __AT91SAM9260_SPI_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_sys.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_sys.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_sys.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_sys.h	2006-08-09 10:55:02.000000000 +0200
@@ -0,0 +1,286 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_sys.h
+ * 
+ * Hardware definition for the sys peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  01/16/2006 (17:06:46) AT91 SW Application Group from SYS_SAM9260 V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_SYS_H
+#define __AT91SAM9260_SYS_H
+
+/* -------------------------------------------------------- */
+/* SYS ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* SYS Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_SYS       	0xFFFFFD00 /**< SYS base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for SYS hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SYS hardware peripheral */
+/* -------------------------------------------------------- */
+#define SDRAMC_MR 	(0x0000) 	/**< SDRAM Controller Mode Register */
+#define SDRAMC_TR 	(0x0004) 	/**< SDRAM Controller Refresh Timer Register */
+#define SDRAMC_CR 	(0x0008) 	/**< SDRAM Controller Configuration Register */
+#define SDRAMC_HSR 	(0x000C) 	/**< SDRAM Controller High Speed Register */
+#define SDRAMC_LPR 	(0x0010) 	/**< SDRAM Controller Low Power Register */
+#define SDRAMC_IER 	(0x0014) 	/**< SDRAM Controller Interrupt Enable Register */
+#define SDRAMC_IDR 	(0x0018) 	/**< SDRAM Controller Interrupt Disable Register */
+#define SDRAMC_IMR 	(0x001C) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SDRAMC_ISR 	(0x0020) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SDRAMC_MDR 	(0x0024) 	/**< SDRAM Memory Device Register */
+#define SMC_SETUP0 	(0x0200) 	/**<  Setup Register for CS 0 */
+#define SMC_PULSE0 	(0x0204) 	/**<  Pulse Register for CS 0 */
+#define SMC_CYCLE0 	(0x0208) 	/**<  Cycle Register for CS 0 */
+#define SMC_CTRL0 	(0x020C) 	/**<  Control Register for CS 0 */
+#define SMC_SETUP1 	(0x0210) 	/**<  Setup Register for CS 1 */
+#define SMC_PULSE1 	(0x0214) 	/**<  Pulse Register for CS 1 */
+#define SMC_CYCLE1 	(0x0218) 	/**<  Cycle Register for CS 1 */
+#define SMC_CTRL1 	(0x021C) 	/**<  Control Register for CS 1 */
+#define SMC_SETUP2 	(0x0220) 	/**<  Setup Register for CS 2 */
+#define SMC_PULSE2 	(0x0224) 	/**<  Pulse Register for CS 2 */
+#define SMC_CYCLE2 	(0x0228) 	/**<  Cycle Register for CS 2 */
+#define SMC_CTRL2 	(0x022C) 	/**<  Control Register for CS 2 */
+#define SMC_SETUP3 	(0x0230) 	/**<  Setup Register for CS 3 */
+#define SMC_PULSE3 	(0x0234) 	/**<  Pulse Register for CS 3 */
+#define SMC_CYCLE3 	(0x0238) 	/**<  Cycle Register for CS 3 */
+#define SMC_CTRL3 	(0x023C) 	/**<  Control Register for CS 3 */
+#define SMC_SETUP4 	(0x0240) 	/**<  Setup Register for CS 4 */
+#define SMC_PULSE4 	(0x0244) 	/**<  Pulse Register for CS 4 */
+#define SMC_CYCLE4 	(0x0248) 	/**<  Cycle Register for CS 4 */
+#define SMC_CTRL4 	(0x024C) 	/**<  Control Register for CS 4 */
+#define SMC_SETUP5 	(0x0250) 	/**<  Setup Register for CS 5 */
+#define SMC_PULSE5 	(0x0254) 	/**<  Pulse Register for CS 5 */
+#define SMC_CYCLE5 	(0x0258) 	/**<  Cycle Register for CS 5 */
+#define SMC_CTRL5 	(0x025C) 	/**<  Control Register for CS 5 */
+#define SMC_SETUP6 	(0x0260) 	/**<  Setup Register for CS 6 */
+#define SMC_PULSE6 	(0x0264) 	/**<  Pulse Register for CS 6 */
+#define SMC_CYCLE6 	(0x0268) 	/**<  Cycle Register for CS 6 */
+#define SMC_CTRL6 	(0x026C) 	/**<  Control Register for CS 6 */
+#define SMC_SETUP7 	(0x0270) 	/**<  Setup Register for CS 7 */
+#define SMC_PULSE7 	(0x0274) 	/**<  Pulse Register for CS 7 */
+#define SMC_CYCLE7 	(0x0278) 	/**<  Cycle Register for CS 7 */
+#define SMC_CTRL7 	(0x027C) 	/**<  Control Register for CS 7 */
+#define MATRIX_MCFG0 	(0x0400) 	/**<  Master Configuration Register 0 (ram96k)      */
+#define MATRIX_MCFG1 	(0x0404) 	/**<  Master Configuration Register 1 (rom)     */
+#define MATRIX_MCFG2 	(0x0408) 	/**<  Master Configuration Register 2 (hperiphs)  */
+#define MATRIX_MCFG3 	(0x040C) 	/**<  Master Configuration Register 3 (ebi) */
+#define MATRIX_MCFG4 	(0x0410) 	/**<  Master Configuration Register 4 (bridge)     */
+#define MATRIX_MCFG5 	(0x0414) 	/**<  Master Configuration Register 5 (mailbox)     */
+#define MATRIX_MCFG6 	(0x0418) 	/**<  Master Configuration Register 6 (ram16k)   */
+#define MATRIX_MCFG7 	(0x041C) 	/**<  Master Configuration Register 7 (teak_prog)      */
+#define MATRIX_SCFG0 	(0x0440) 	/**<  Slave Configuration Register 0 (ram96k)      */
+#define MATRIX_SCFG1 	(0x0444) 	/**<  Slave Configuration Register 1 (rom)     */
+#define MATRIX_SCFG2 	(0x0448) 	/**<  Slave Configuration Register 2 (hperiphs)  */
+#define MATRIX_SCFG3 	(0x044C) 	/**<  Slave Configuration Register 3 (ebi) */
+#define MATRIX_SCFG4 	(0x0450) 	/**<  Slave Configuration Register 4 (bridge)     */
+#define MATRIX_PRAS0 	(0x0480) 	/**<  PRAS0 (ram0)  */
+#define MATRIX_PRBS0 	(0x0484) 	/**<  PRBS0 (ram0)  */
+#define MATRIX_PRAS1 	(0x0488) 	/**<  PRAS1 (ram1)  */
+#define MATRIX_PRBS1 	(0x048C) 	/**<  PRBS1 (ram1)  */
+#define MATRIX_PRAS2 	(0x0490) 	/**<  PRAS2 (ram2)  */
+#define MATRIX_PRBS2 	(0x0494) 	/**<  PRBS2 (ram2)  */
+#define MATRIX_MRCR 	(0x0500) 	/**<  Master Remp Control Register  */
+#define CCFG_EBICSA 	(0x051C) 	/**<  EBI Chip Select Assignement Register */
+#define MATRIX_TEAKCFG 	(0x052C) 	/**<  Slave 7 (teak_prog) Special Function Register */
+#define CCFG_MATRIXVERSION 	(0x05FC) 	/**<  Version Register */
+#define AIC_SMR 	(0x0600) 	/**< Source Mode Register */
+#define AIC_SVR 	(0x0680) 	/**< Source Vector Register */
+#define AIC_IVR 	(0x0700) 	/**< IRQ Vector Register */
+#define AIC_FVR 	(0x0704) 	/**< FIQ Vector Register */
+#define AIC_ISR 	(0x0708) 	/**< Interrupt Status Register */
+#define AIC_IPR 	(0x070C) 	/**< Interrupt Pending Register */
+#define AIC_IMR 	(0x0710) 	/**< Interrupt Mask Register */
+#define AIC_CISR 	(0x0714) 	/**< Core Interrupt Status Register */
+#define AIC_IECR 	(0x0720) 	/**< Interrupt Enable Command Register */
+#define AIC_IDCR 	(0x0724) 	/**< Interrupt Disable Command Register */
+#define AIC_ICCR 	(0x0728) 	/**< Interrupt Clear Command Register */
+#define AIC_ISCR 	(0x072C) 	/**< Interrupt Set Command Register */
+#define AIC_EOICR 	(0x0730) 	/**< End of Interrupt Command Register */
+#define AIC_SPU 	(0x0734) 	/**< Spurious Vector Register */
+#define AIC_DCR 	(0x0738) 	/**< Debug Control Register (Protect) */
+#define AIC_FFER 	(0x0740) 	/**< Fast Forcing Enable Register */
+#define AIC_FFDR 	(0x0744) 	/**< Fast Forcing Disable Register */
+#define AIC_FFSR 	(0x0748) 	/**< Fast Forcing Status Register */
+#define DBGU_CR 	(0x0800) 	/**< Control Register */
+#define DBGU_MR 	(0x0804) 	/**< Mode Register */
+#define DBGU_IER 	(0x0808) 	/**< Interrupt Enable Register */
+#define DBGU_IDR 	(0x080C) 	/**< Interrupt Disable Register */
+#define DBGU_IMR 	(0x0810) 	/**< Interrupt Mask Register */
+#define DBGU_CSR 	(0x0814) 	/**< Channel Status Register */
+#define DBGU_RHR 	(0x0818) 	/**< Receiver Holding Register */
+#define DBGU_THR 	(0x081C) 	/**< Transmitter Holding Register */
+#define DBGU_BRGR 	(0x0820) 	/**< Baud Rate Generator Register */
+#define DBGU_CIDR 	(0x0840) 	/**< Chip ID Register */
+#define DBGU_EXID 	(0x0844) 	/**< Chip ID Extension Register */
+#define DBGU_FNTR 	(0x0848) 	/**< Force NTRST Register */
+#define DBGU_RPR 	(0x0900) 	/**< Receive Pointer Register */
+#define DBGU_RCR 	(0x0904) 	/**< Receive Counter Register */
+#define DBGU_TPR 	(0x0908) 	/**< Transmit Pointer Register */
+#define DBGU_TCR 	(0x090C) 	/**< Transmit Counter Register */
+#define DBGU_RNPR 	(0x0910) 	/**< Receive Next Pointer Register */
+#define DBGU_RNCR 	(0x0914) 	/**< Receive Next Counter Register */
+#define DBGU_TNPR 	(0x0918) 	/**< Transmit Next Pointer Register */
+#define DBGU_TNCR 	(0x091C) 	/**< Transmit Next Counter Register */
+#define DBGU_PTCR 	(0x0920) 	/**< PDC Transfer Control Register */
+#define DBGU_PTSR 	(0x0924) 	/**< PDC Transfer Status Register */
+#define PIOA_PER 	(0x0A00) 	/**< PIO Enable Register */
+#define PIOA_PDR 	(0x0A04) 	/**< PIO Disable Register */
+#define PIOA_PSR 	(0x0A08) 	/**< PIO Status Register */
+#define PIOA_OER 	(0x0A10) 	/**< Output Enable Register */
+#define PIOA_ODR 	(0x0A14) 	/**< Output Disable Registerr */
+#define PIOA_OSR 	(0x0A18) 	/**< Output Status Register */
+#define PIOA_IFER 	(0x0A20) 	/**< Input Filter Enable Register */
+#define PIOA_IFDR 	(0x0A24) 	/**< Input Filter Disable Register */
+#define PIOA_IFSR 	(0x0A28) 	/**< Input Filter Status Register */
+#define PIOA_SODR 	(0x0A30) 	/**< Set Output Data Register */
+#define PIOA_CODR 	(0x0A34) 	/**< Clear Output Data Register */
+#define PIOA_ODSR 	(0x0A38) 	/**< Output Data Status Register */
+#define PIOA_PDSR 	(0x0A3C) 	/**< Pin Data Status Register */
+#define PIOA_IER 	(0x0A40) 	/**< Interrupt Enable Register */
+#define PIOA_IDR 	(0x0A44) 	/**< Interrupt Disable Register */
+#define PIOA_IMR 	(0x0A48) 	/**< Interrupt Mask Register */
+#define PIOA_ISR 	(0x0A4C) 	/**< Interrupt Status Register */
+#define PIOA_MDER 	(0x0A50) 	/**< Multi-driver Enable Register */
+#define PIOA_MDDR 	(0x0A54) 	/**< Multi-driver Disable Register */
+#define PIOA_MDSR 	(0x0A58) 	/**< Multi-driver Status Register */
+#define PIOA_PPUDR 	(0x0A60) 	/**< Pull-up Disable Register */
+#define PIOA_PPUER 	(0x0A64) 	/**< Pull-up Enable Register */
+#define PIOA_PPUSR 	(0x0A68) 	/**< Pull-up Status Register */
+#define PIOA_ASR 	(0x0A70) 	/**< Select A Register */
+#define PIOA_BSR 	(0x0A74) 	/**< Select B Register */
+#define PIOA_ABSR 	(0x0A78) 	/**< AB Select Status Register */
+#define PIOA_OWER 	(0x0AA0) 	/**< Output Write Enable Register */
+#define PIOA_OWDR 	(0x0AA4) 	/**< Output Write Disable Register */
+#define PIOA_OWSR 	(0x0AA8) 	/**< Output Write Status Register */
+#define PIOB_PER 	(0x0C00) 	/**< PIO Enable Register */
+#define PIOB_PDR 	(0x0C04) 	/**< PIO Disable Register */
+#define PIOB_PSR 	(0x0C08) 	/**< PIO Status Register */
+#define PIOB_OER 	(0x0C10) 	/**< Output Enable Register */
+#define PIOB_ODR 	(0x0C14) 	/**< Output Disable Registerr */
+#define PIOB_OSR 	(0x0C18) 	/**< Output Status Register */
+#define PIOB_IFER 	(0x0C20) 	/**< Input Filter Enable Register */
+#define PIOB_IFDR 	(0x0C24) 	/**< Input Filter Disable Register */
+#define PIOB_IFSR 	(0x0C28) 	/**< Input Filter Status Register */
+#define PIOB_SODR 	(0x0C30) 	/**< Set Output Data Register */
+#define PIOB_CODR 	(0x0C34) 	/**< Clear Output Data Register */
+#define PIOB_ODSR 	(0x0C38) 	/**< Output Data Status Register */
+#define PIOB_PDSR 	(0x0C3C) 	/**< Pin Data Status Register */
+#define PIOB_IER 	(0x0C40) 	/**< Interrupt Enable Register */
+#define PIOB_IDR 	(0x0C44) 	/**< Interrupt Disable Register */
+#define PIOB_IMR 	(0x0C48) 	/**< Interrupt Mask Register */
+#define PIOB_ISR 	(0x0C4C) 	/**< Interrupt Status Register */
+#define PIOB_MDER 	(0x0C50) 	/**< Multi-driver Enable Register */
+#define PIOB_MDDR 	(0x0C54) 	/**< Multi-driver Disable Register */
+#define PIOB_MDSR 	(0x0C58) 	/**< Multi-driver Status Register */
+#define PIOB_PPUDR 	(0x0C60) 	/**< Pull-up Disable Register */
+#define PIOB_PPUER 	(0x0C64) 	/**< Pull-up Enable Register */
+#define PIOB_PPUSR 	(0x0C68) 	/**< Pull-up Status Register */
+#define PIOB_ASR 	(0x0C70) 	/**< Select A Register */
+#define PIOB_BSR 	(0x0C74) 	/**< Select B Register */
+#define PIOB_ABSR 	(0x0C78) 	/**< AB Select Status Register */
+#define PIOB_OWER 	(0x0CA0) 	/**< Output Write Enable Register */
+#define PIOB_OWDR 	(0x0CA4) 	/**< Output Write Disable Register */
+#define PIOB_OWSR 	(0x0CA8) 	/**< Output Write Status Register */
+#define PIOC_PER 	(0x0E00) 	/**< PIO Enable Register */
+#define PIOC_PDR 	(0x0E04) 	/**< PIO Disable Register */
+#define PIOC_PSR 	(0x0E08) 	/**< PIO Status Register */
+#define PIOC_OER 	(0x0E10) 	/**< Output Enable Register */
+#define PIOC_ODR 	(0x0E14) 	/**< Output Disable Registerr */
+#define PIOC_OSR 	(0x0E18) 	/**< Output Status Register */
+#define PIOC_IFER 	(0x0E20) 	/**< Input Filter Enable Register */
+#define PIOC_IFDR 	(0x0E24) 	/**< Input Filter Disable Register */
+#define PIOC_IFSR 	(0x0E28) 	/**< Input Filter Status Register */
+#define PIOC_SODR 	(0x0E30) 	/**< Set Output Data Register */
+#define PIOC_CODR 	(0x0E34) 	/**< Clear Output Data Register */
+#define PIOC_ODSR 	(0x0E38) 	/**< Output Data Status Register */
+#define PIOC_PDSR 	(0x0E3C) 	/**< Pin Data Status Register */
+#define PIOC_IER 	(0x0E40) 	/**< Interrupt Enable Register */
+#define PIOC_IDR 	(0x0E44) 	/**< Interrupt Disable Register */
+#define PIOC_IMR 	(0x0E48) 	/**< Interrupt Mask Register */
+#define PIOC_ISR 	(0x0E4C) 	/**< Interrupt Status Register */
+#define PIOC_MDER 	(0x0E50) 	/**< Multi-driver Enable Register */
+#define PIOC_MDDR 	(0x0E54) 	/**< Multi-driver Disable Register */
+#define PIOC_MDSR 	(0x0E58) 	/**< Multi-driver Status Register */
+#define PIOC_PPUDR 	(0x0E60) 	/**< Pull-up Disable Register */
+#define PIOC_PPUER 	(0x0E64) 	/**< Pull-up Enable Register */
+#define PIOC_PPUSR 	(0x0E68) 	/**< Pull-up Status Register */
+#define PIOC_ASR 	(0x0E70) 	/**< Select A Register */
+#define PIOC_BSR 	(0x0E74) 	/**< Select B Register */
+#define PIOC_ABSR 	(0x0E78) 	/**< AB Select Status Register */
+#define PIOC_OWER 	(0x0EA0) 	/**< Output Write Enable Register */
+#define PIOC_OWDR 	(0x0EA4) 	/**< Output Write Disable Register */
+#define PIOC_OWSR 	(0x0EA8) 	/**< Output Write Status Register */
+#define PMC_SCER 	(0x1200) 	/**< System Clock Enable Register */
+#define PMC_SCDR 	(0x1204) 	/**< System Clock Disable Register */
+#define PMC_SCSR 	(0x1208) 	/**< System Clock Status Register */
+#define PMC_PCER 	(0x1210) 	/**< Peripheral Clock Enable Register */
+#define PMC_PCDR 	(0x1214) 	/**< Peripheral Clock Disable Register */
+#define PMC_PCSR 	(0x1218) 	/**< Peripheral Clock Status Register */
+#define PMC_MOR 	(0x1220) 	/**< Main Oscillator Register */
+#define PMC_MCFR 	(0x1224) 	/**< Main Clock  Frequency Register */
+#define PMC_PLLAR 	(0x1228) 	/**< PLL A Register */
+#define PMC_PLLBR 	(0x122C) 	/**< PLL B Register */
+#define PMC_MCKR 	(0x1230) 	/**< Master Clock Register */
+#define PMC_PCKR 	(0x1240) 	/**< Programmable Clock Register */
+#define PMC_IER 	(0x1260) 	/**< Interrupt Enable Register */
+#define PMC_IDR 	(0x1264) 	/**< Interrupt Disable Register */
+#define PMC_SR 	(0x1268) 	/**< Status Register */
+#define PMC_IMR 	(0x126C) 	/**< Interrupt Mask Register */
+#define RSTC_RCR 	(0x1300) 	/**< Reset Control Register */
+#define RSTC_RSR 	(0x1304) 	/**< Reset Status Register */
+#define RSTC_RMR 	(0x1308) 	/**< Reset Mode Register */
+#define SHDWC_SHCR 	(0x1310) 	/**< Shut Down Control Register */
+#define SHDWC_SHMR 	(0x1314) 	/**< Shut Down Mode Register */
+#define SHDWC_SHSR 	(0x1318) 	/**< Shut Down Status Register */
+#define RTTC_RTMR 	(0x1320) 	/**< Real-time Mode Register */
+#define RTTC_RTAR 	(0x1324) 	/**< Real-time Alarm Register */
+#define RTTC_RTVR 	(0x1328) 	/**< Real-time Value Register */
+#define RTTC_RTSR 	(0x132C) 	/**< Real-time Status Register */
+#define PITC_PIMR 	(0x1330) 	/**< Period Interval Mode Register */
+#define PITC_PISR 	(0x1334) 	/**< Period Interval Status Register */
+#define PITC_PIVR 	(0x1338) 	/**< Period Interval Value Register */
+#define PITC_PIIR 	(0x133C) 	/**< Period Interval Image Register */
+#define WDTC_WDCR 	(0x1340) 	/**< Watchdog Control Register */
+#define WDTC_WDMR 	(0x1344) 	/**< Watchdog Mode Register */
+#define WDTC_WDSR 	(0x1348) 	/**< Watchdog Status Register */
+#define SYS_GPBR0 	(0x1350) 	/**< General Purpose Register 0 */
+#define SYS_GPBR1 	(0x1354) 	/**< General Purpose Register 1 */
+#define SYS_GPBR2 	(0x1358) 	/**< General Purpose Register 2 */
+#define SYS_GPBR3 	(0x135C) 	/**< General Purpose Register 3 */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SYS hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register GPBR */
+/* --- Register GPBR */
+/* --- Register GPBR */
+/* --- Register GPBR */
+
+#endif /* __AT91SAM9260_SYS_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_twi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_twi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_twi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_twi.h	2006-08-09 10:55:04.000000000 +0200
@@ -0,0 +1,117 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_twi.h
+ * 
+ * Hardware definition for the twi peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  01/16/2006 (17:06:46) AT91 SW Application Group from TWI_6061A V1.1
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_TWI_H
+#define __AT91SAM9260_TWI_H
+
+/* -------------------------------------------------------- */
+/* TWI ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_TWI
+#define AT91C_ID_TWI   	11 /**< Two-Wire Interface id */
+#endif /* AT91C_ID_TWI */
+
+/* -------------------------------------------------------- */
+/* TWI Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_TWI       	0xFFFAC000 /**< TWI base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for TWI hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PA24_TWCK     	(1 << 24) /**< TWI Two-wire Serial Clock */
+#define AT91C_PA23_TWD      	(1 << 23) /**< TWI Two-wire Serial Data */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for TWI hardware peripheral */
+/* -------------------------------------------------------- */
+#define TWI_CR 	(0x0000) 	/**< Control Register */
+#define TWI_MMR 	(0x0004) 	/**< Master Mode Register */
+#define TWI_IADR 	(0x000C) 	/**< Internal Address Register */
+#define TWI_CWGR 	(0x0010) 	/**< Clock Waveform Generator Register */
+#define TWI_SR 	(0x0020) 	/**< Status Register */
+#define TWI_IER 	(0x0024) 	/**< Interrupt Enable Register */
+#define TWI_IDR 	(0x0028) 	/**< Interrupt Disable Register */
+#define TWI_IMR 	(0x002C) 	/**< Interrupt Mask Register */
+#define TWI_RHR 	(0x0030) 	/**< Receive Holding Register */
+#define TWI_THR 	(0x0034) 	/**< Transmit Holding Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for TWI hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register TWI_CR */
+#define AT91C_TWI_START       (0x1 << 0 ) /**< (TWI) Send a START Condition */
+#define AT91C_TWI_STOP        (0x1 << 1 ) /**< (TWI) Send a STOP Condition */
+#define AT91C_TWI_MSEN        (0x1 << 2 ) /**< (TWI) TWI Master Transfer Enabled */
+#define AT91C_TWI_MSDIS       (0x1 << 3 ) /**< (TWI) TWI Master Transfer Disabled */
+#define AT91C_TWI_SVEN        ( 0x1 <<  4) // (TWI) TWI Slave Transfer Enabled
+#define AT91C_TWI_SVDIS       ( 0x1 <<  5) // (TWI) TWI Slave Transfer Disable
+#define AT91C_TWI_SWRST       (0x1 << 7 ) /**< (TWI) Software Reset */
+/* --- Register TWI_MMR */
+#define AT91C_TWI_IADRSZ      (0x3 << 8 ) /**< (TWI) Internal Device Address Size */
+#define 	AT91C_TWI_IADRSZ_NO                   (0x0 <<  8) /**< (TWI) No internal device address */
+#define 	AT91C_TWI_IADRSZ_1_BYTE               (0x1 <<  8) /**< (TWI) One-byte internal device address */
+#define 	AT91C_TWI_IADRSZ_2_BYTE               (0x2 <<  8) /**< (TWI) Two-byte internal device address */
+#define 	AT91C_TWI_IADRSZ_3_BYTE               (0x3 <<  8) /**< (TWI) Three-byte internal device address */
+#define AT91C_TWI_MREAD       (0x1 << 12) /**< (TWI) Master Read Direction */
+#define AT91C_TWI_DADR        (0x7F << 16) /**< (TWI) Device Address */
+/* --- Register TWI_CWGR */
+#define AT91C_TWI_CLDIV       (0xFF << 0 ) /**< (TWI) Clock Low Divider */
+#define AT91C_TWI_CHDIV       (0xFF << 8 ) /**< (TWI) Clock High Divider */
+#define AT91C_TWI_CKDIV       (0x7 << 16) /**< (TWI) Clock Divider */
+/* --- Register TWI_SR */
+#define AT91C_TWI_TXCOMP      (0x1 << 0 ) /**< (TWI) Transmission Completed */
+#define AT91C_TWI_RXRDY       (0x1 << 1 ) /**< (TWI) Receive holding register ReaDY */
+#define AT91C_TWI_TXRDY       (0x1 << 2 ) /**< (TWI) Transmit holding register ReaDY */
+#define AT91C_TWI_OVRE        (0x1 << 6 ) /**< (TWI) Overrun Error */
+#define AT91C_TWI_UNRE        (0x1 << 7 ) /**< (TWI) Underrun Error */
+#define AT91C_TWI_NACK        (0x1 << 8 ) /**< (TWI) Not Acknowledged */
+/* --- Register TWI_IER */
+#define AT91C_TWI_TXCOMP      (0x1 << 0 ) /**< (TWI) Transmission Completed */
+#define AT91C_TWI_RXRDY       (0x1 << 1 ) /**< (TWI) Receive holding register ReaDY */
+#define AT91C_TWI_TXRDY       (0x1 << 2 ) /**< (TWI) Transmit holding register ReaDY */
+#define AT91C_TWI_OVRE        (0x1 << 6 ) /**< (TWI) Overrun Error */
+#define AT91C_TWI_UNRE        (0x1 << 7 ) /**< (TWI) Underrun Error */
+#define AT91C_TWI_NACK        (0x1 << 8 ) /**< (TWI) Not Acknowledged */
+/* --- Register TWI_IDR */
+#define AT91C_TWI_TXCOMP      (0x1 << 0 ) /**< (TWI) Transmission Completed */
+#define AT91C_TWI_RXRDY       (0x1 << 1 ) /**< (TWI) Receive holding register ReaDY */
+#define AT91C_TWI_TXRDY       (0x1 << 2 ) /**< (TWI) Transmit holding register ReaDY */
+#define AT91C_TWI_OVRE        (0x1 << 6 ) /**< (TWI) Overrun Error */
+#define AT91C_TWI_UNRE        (0x1 << 7 ) /**< (TWI) Underrun Error */
+#define AT91C_TWI_NACK        (0x1 << 8 ) /**< (TWI) Not Acknowledged */
+/* --- Register TWI_IMR */
+#define AT91C_TWI_TXCOMP      (0x1 << 0 ) /**< (TWI) Transmission Completed */
+#define AT91C_TWI_RXRDY       (0x1 << 1 ) /**< (TWI) Receive holding register ReaDY */
+#define AT91C_TWI_TXRDY       (0x1 << 2 ) /**< (TWI) Transmit holding register ReaDY */
+#define AT91C_TWI_OVRE        (0x1 << 6 ) /**< (TWI) Overrun Error */
+#define AT91C_TWI_UNRE        (0x1 << 7 ) /**< (TWI) Underrun Error */
+#define AT91C_TWI_NACK        (0x1 << 8 ) /**< (TWI) Not Acknowledged */
+
+#endif /* __AT91SAM9260_TWI_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_udp.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_udp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_udp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_udp.h	2006-08-09 16:41:53.000000000 +0200
@@ -0,0 +1,172 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_udp.h
+ * 
+ * Hardware definition for the udp peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  01/16/2006 (17:06:46) AT91 SW Application Group from UDP_6083C V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_UDP_H
+#define __AT91SAM9260_UDP_H
+
+/* -------------------------------------------------------- */
+/* UDP ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_UDP
+#define AT91C_ID_UDP   	10 /**< USB Device Port id */
+#endif /* AT91C_ID_UDP */
+
+/* -------------------------------------------------------- */
+/* UDP Base Address definitions for  AT91SAM9260   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_UDP       	0xFFFA4000 /**< UDP base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for UDP hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for UDP hardware peripheral */
+/* -------------------------------------------------------- */
+#define UDP_NUM 	(0x0000) 	/**< Frame Number Register */
+#define UDP_GLBSTATE 	(0x0004) 	/**< Global State Register */
+#define UDP_FADDR 	(0x0008) 	/**< Function Address Register */
+#define UDP_IER 	(0x0010) 	/**< Interrupt Enable Register */
+#define UDP_IDR 	(0x0014) 	/**< Interrupt Disable Register */
+#define UDP_IMR 	(0x0018) 	/**< Interrupt Mask Register */
+#define UDP_ISR 	(0x001C) 	/**< Interrupt Status Register */
+#define UDP_ICR 	(0x0020) 	/**< Interrupt Clear Register */
+#define UDP_RSTEP 	(0x0028) 	/**< Reset Endpoint Register */
+#define UDP_CSR 	(0x0030) 	/**< Endpoint Control and Status Register */
+#define UDP_FDR 	(0x0050) 	/**< Endpoint FIFO Data Register */
+#define UDP_TXVC 	(0x0074) 	/**< Transceiver Control Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for UDP hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register UDP_FRM_NUM */
+#define AT91C_UDP_FRM_NUM     (0x7FF << 0 ) /**< (UDP) Frame Number as Defined in the Packet Field Formats */
+#define AT91C_UDP_FRM_ERR     (0x1 << 16) /**< (UDP) Frame Error */
+#define AT91C_UDP_FRM_OK      (0x1 << 17) /**< (UDP) Frame OK */
+/* --- Register UDP_GLB_STATE */
+#define AT91C_UDP_FADDEN      (0x1 << 0 ) /**< (UDP) Function Address Enable */
+#define AT91C_UDP_CONFG       (0x1 << 1 ) /**< (UDP) Configured */
+#define AT91C_UDP_ESR         (0x1 << 2 ) /**< (UDP) Enable Send Resume */
+#define AT91C_UDP_RSMINPR     (0x1 << 3 ) /**< (UDP) A Resume Has Been Sent to the Host */
+#define AT91C_UDP_RMWUPE      (0x1 << 4 ) /**< (UDP) Remote Wake Up Enable */
+/* --- Register UDP_FADDR */
+#define AT91C_UDP_FADD        (0xFF << 0 ) /**< (UDP) Function Address Value */
+#define AT91C_UDP_FEN         (0x1 << 8 ) /**< (UDP) Function Enable */
+/* --- Register UDP_IER */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_IDR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_IMR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_ISR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_ENDBUSRES   (0x1 << 12) /**< (UDP) USB End Of Bus Reset Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_ICR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_RST_EP */
+#define AT91C_UDP_EP0         (0x1 << 0 ) /**< (UDP) Reset Endpoint 0 */
+#define AT91C_UDP_EP1         (0x1 << 1 ) /**< (UDP) Reset Endpoint 1 */
+#define AT91C_UDP_EP2         (0x1 << 2 ) /**< (UDP) Reset Endpoint 2 */
+#define AT91C_UDP_EP3         (0x1 << 3 ) /**< (UDP) Reset Endpoint 3 */
+#define AT91C_UDP_EP4         (0x1 << 4 ) /**< (UDP) Reset Endpoint 4 */
+#define AT91C_UDP_EP5         (0x1 << 5 ) /**< (UDP) Reset Endpoint 5 */
+/* --- Register UDP_CSR */
+#define AT91C_UDP_TXCOMP      (0x1 << 0 ) /**< (UDP) Generates an IN packet with data previously written in the DPR */
+#define AT91C_UDP_RX_DATA_BK0 (0x1 << 1 ) /**< (UDP) Receive Data Bank 0 */
+#define AT91C_UDP_RXSETUP     (0x1 << 2 ) /**< (UDP) Sends STALL to the Host (Control endpoints) */
+#define AT91C_UDP_ISOERROR    (0x1 << 3 ) /**< (UDP) Isochronous error (Isochronous endpoints) */
+#define AT91C_UDP_TXPKTRDY    (0x1 << 4 ) /**< (UDP) Transmit Packet Ready */
+#define AT91C_UDP_FORCESTALL  (0x1 << 5 ) /**< (UDP) Force Stall (used by Control, Bulk and Isochronous endpoints). */
+#define AT91C_UDP_RX_DATA_BK1 (0x1 << 6 ) /**< (UDP) Receive Data Bank 1 (only used by endpoints with ping-pong attributes). */
+#define AT91C_UDP_DIR         (0x1 << 7 ) /**< (UDP) Transfer Direction */
+#define AT91C_UDP_EPTYPE      (0x7 << 8 ) /**< (UDP) Endpoint type */
+#define 	AT91C_UDP_EPTYPE_CTRL                 (0x0 <<  8) /**< (UDP) Control */
+#define 	AT91C_UDP_EPTYPE_ISO_OUT              (0x1 <<  8) /**< (UDP) Isochronous OUT */
+#define 	AT91C_UDP_EPTYPE_BULK_OUT             (0x2 <<  8) /**< (UDP) Bulk OUT */
+#define 	AT91C_UDP_EPTYPE_INT_OUT              (0x3 <<  8) /**< (UDP) Interrupt OUT */
+#define 	AT91C_UDP_EPTYPE_ISO_IN               (0x5 <<  8) /**< (UDP) Isochronous IN */
+#define 	AT91C_UDP_EPTYPE_BULK_IN              (0x6 <<  8) /**< (UDP) Bulk IN */
+#define 	AT91C_UDP_EPTYPE_INT_IN               (0x7 <<  8) /**< (UDP) Interrupt IN */
+#define AT91C_UDP_DTGLE       (0x1 << 11) /**< (UDP) Data Toggle */
+#define AT91C_UDP_EPEDS       (0x1 << 15) /**< (UDP) Endpoint Enable Disable */
+#define AT91C_UDP_RXBYTECNT   (0x7FF << 16) /**< (UDP) Number Of Bytes Available in the FIFO */
+/* --- Register UDP_TXVC */
+#define AT91C_UDP_TXVDIS      (0x1 << 8 ) /**< (UDP)  */
+#define AT91C_UDP_PUON        (0x1 << 9 ) /**< (UDP) Pull-up ON */
+
+#endif /* __AT91SAM9260_UDP_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_uhp.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_uhp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_uhp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_uhp.h	2006-08-09 10:55:05.000000000 +0200
@@ -0,0 +1,78 @@
+/* linux/include/asm-arm/arch-at91sam9260/at91sam9260_uhp.h
+ * 
+ * Hardware definition for the uhp peripheral in the ATMEL at91sam9260 processor
+ * 
+ * Generated  12/09/2005 (11:54:25) AT91 SW Application Group from UHP_6127A V1.1
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9260_UHP_H
+#define __AT91SAM9260_UHP_H
+
+/* -------------------------------------------------------- */
+/* UHP ID definitions for  AT91SAM9260           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_UHP
+#define AT91C_ID_UHP   	20 /**< USB Host Port id */
+#endif /* AT91C_ID_UHP */
+
+/* -------------------------------------------------------- */
+/* UHP Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_UHP       	0x00500000 /**< UHP base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+#define UHP_HcRevision 	(0x0000) 	/**< Revision */
+#define UHP_HcControl 	(0x0004) 	/**< Operating modes for the Host Controller */
+#define UHP_HcCommandStatus 	(0x0008) 	/**< Command & status Register */
+#define UHP_HcInterruptStatus 	(0x000C) 	/**< Interrupt Status Register */
+#define UHP_HcInterruptEnable 	(0x0010) 	/**< Interrupt Enable Register */
+#define UHP_HcInterruptDisable 	(0x0014) 	/**< Interrupt Disable Register */
+#define UHP_HcHCCA 	(0x0018) 	/**< Pointer to the Host Controller Communication Area */
+#define UHP_HcPeriodCurrentED 	(0x001C) 	/**< Current Isochronous or Interrupt Endpoint Descriptor */
+#define UHP_HcControlHeadED 	(0x0020) 	/**< First Endpoint Descriptor of the Control list */
+#define UHP_HcControlCurrentED 	(0x0024) 	/**< Endpoint Control and Status Register */
+#define UHP_HcBulkHeadED 	(0x0028) 	/**< First endpoint register of the Bulk list */
+#define UHP_HcBulkCurrentED 	(0x002C) 	/**< Current endpoint of the Bulk list */
+#define UHP_HcBulkDoneHead 	(0x0030) 	/**< Last completed transfer descriptor */
+#define UHP_HcFmInterval 	(0x0034) 	/**< Bit time between 2 consecutive SOFs */
+#define UHP_HcFmRemaining 	(0x0038) 	/**< Bit time remaining in the current Frame */
+#define UHP_HcFmNumber 	(0x003C) 	/**< Frame number */
+#define UHP_HcPeriodicStart 	(0x0040) 	/**< Periodic Start */
+#define UHP_HcLSThreshold 	(0x0044) 	/**< LS Threshold */
+#define UHP_HcRhDescriptorA 	(0x0048) 	/**< Root Hub characteristics A */
+#define UHP_HcRhDescriptorB 	(0x004C) 	/**< Root Hub characteristics B */
+#define UHP_HcRhStatus 	(0x0050) 	/**< Root Hub Status register */
+#define UHP_HcRhPortStatus 	(0x0054) 	/**< Root Hub Port Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+
+#endif /* __AT91SAM9260_UHP_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_usart.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_usart.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/at91sam9260_usart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/at91sam9260_usart.h	2006-08-09 10:55:06.000000000 +0200
@@ -0,0 +1,164 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_usart.h
+ * 
+ * Hardware definition for the usart peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from  V
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9261_USART_H
+#define __AT91SAM9261_USART_H
+
+/* -------------------------------------------------------- */
+/* USART ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_US0
+#define AT91C_ID_US0   	 6 /**< USART 0 id */
+#endif /* AT91C_ID_US0 */
+#ifndef AT91C_ID_US1
+#define AT91C_ID_US1   	 7 /**< USART 1 id */
+#endif /* AT91C_ID_US1 */
+#ifndef AT91C_ID_US2
+#define AT91C_ID_US2   	 8 /**< USART 2 id */
+#endif /* AT91C_ID_US2 */
+
+/* -------------------------------------------------------- */
+/* USART Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_US0       	0xFFFB0000 /**< US0 base address */
+#define AT91C_BASE_US1       	0xFFFB4000 /**< US1 base address */
+#define AT91C_BASE_US2       	0xFFFB8000 /**< US2 base address */
+/* -------------------------------------------------------- */
+/* DBGU Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_DBGU         0xFFFFF200 /**< DBGU base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for USART hardware peripheral */
+/* -------------------------------------------------------- */
+#define US_CR 	(0x0000) 	/**< Control Register */
+#define US_MR 	(0x0004) 	/**< Mode Register */
+#define US_IER 	(0x0008) 	/**< Interrupt Enable Register */
+#define US_IDR 	(0x000C) 	/**< Interrupt Disable Register */
+#define US_IMR 	(0x0010) 	/**< Interrupt Mask Register */
+#define US_CSR 	(0x0014) 	/**< Channel Status Register */
+#define US_RHR 	(0x0018) 	/**< Receiver Holding Register */
+#define US_THR 	(0x001C) 	/**< Transmitter Holding Register */
+#define US_BRGR 	(0x0020) 	/**< Baud Rate Generator Register */
+#define US_RTOR 	(0x0024) 	/**< Receiver Time-out Register */
+#define US_TTGR 	(0x0028) 	/**< Transmitter Time-guard Register */
+#define US_FIDI 	(0x0040) 	/**< FI_DI_Ratio Register */
+#define US_NER 	(0x0044) 	/**< Nb Errors Register */
+#define US_IF 	(0x004C) 	/**< IRDA_FILTER Register */
+#define US_RPR 	(0x0100) 	/**< Receive Pointer Register */
+#define US_RCR 	(0x0104) 	/**< Receive Counter Register */
+#define US_TPR 	(0x0108) 	/**< Transmit Pointer Register */
+#define US_TCR 	(0x010C) 	/**< Transmit Counter Register */
+#define US_RNPR 	(0x0110) 	/**< Receive Next Pointer Register */
+#define US_RNCR 	(0x0114) 	/**< Receive Next Counter Register */
+#define US_TNPR 	(0x0118) 	/**< Transmit Next Pointer Register */
+#define US_TNCR 	(0x011C) 	/**< Transmit Next Counter Register */
+#define US_PTCR 	(0x0120) 	/**< PDC Transfer Control Register */
+#define US_PTSR 	(0x0124) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for USART hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register US_CR */
+#define AT91C_US_RSTRX        (0x1 << 2 ) /**< (USART) Reset Receiver */
+#define AT91C_US_RSTTX        (0x1 << 3 ) /**< (USART) Reset Transmitter */
+#define AT91C_US_RXEN         (0x1 << 4 ) /**< (USART) Receiver Enable */
+#define AT91C_US_RXDIS        (0x1 << 5 ) /**< (USART) Receiver Disable */
+#define AT91C_US_TXEN         (0x1 << 6 ) /**< (USART) Transmitter Enable */
+#define AT91C_US_TXDIS        (0x1 << 7 ) /**< (USART) Transmitter Disable */
+#define AT91C_US_RSTSTA       (0x1 << 8 ) /**< (USART) Reset Status Bits */
+#define AT91C_US_STTBRK       (0x1 << 9 ) /**< (USART) Start Break */
+#define AT91C_US_STPBRK       (0x1 << 10) /**< (USART) Stop Break */
+#define AT91C_US_STTTO        (0x1 << 11) /**< (USART) Start Time-out */
+#define AT91C_US_SENDA        (0x1 << 12) /**< (USART) Send Address */
+#define AT91C_US_RSTIT        (0x1 << 13) /**< (USART) Reset Iterations */
+#define AT91C_US_RSTNACK      (0x1 << 14) /**< (USART) Reset Non Acknowledge */
+#define AT91C_US_RETTO        (0x1 << 15) /**< (USART) Rearm Time-out */
+#define AT91C_US_DTREN        (0x1 << 16) /**< (USART) Data Terminal ready Enable */
+#define AT91C_US_DTRDIS       (0x1 << 17) /**< (USART) Data Terminal ready Disable */
+#define AT91C_US_RTSEN        (0x1 << 18) /**< (USART) Request to Send enable */
+#define AT91C_US_RTSDIS       (0x1 << 19) /**< (USART) Request to Send Disable */
+/* --- Register US_MR */
+#define AT91C_US_USMODE       (0xF << 0 ) /**< (USART) Usart mode */
+#define 	AT91C_US_USMODE_NORMAL               0x0 /**< (USART) Normal */
+#define 	AT91C_US_USMODE_RS485                0x1 /**< (USART) RS485 */
+#define 	AT91C_US_USMODE_HWHSH                0x2 /**< (USART) Hardware Handshaking */
+#define 	AT91C_US_USMODE_MODEM                0x3 /**< (USART) Modem */
+#define 	AT91C_US_USMODE_ISO7816_0            0x4 /**< (USART) ISO7816 protocol: T = 0 */
+#define 	AT91C_US_USMODE_ISO7816_1            0x6 /**< (USART) ISO7816 protocol: T = 1 */
+#define 	AT91C_US_USMODE_IRDA                 0x8 /**< (USART) IrDA */
+#define 	AT91C_US_USMODE_SWHSH                0xC /**< (USART) Software Handshaking */
+#define AT91C_US_CLKS         (0x3 << 4 ) /**< (USART) Clock Selection (Baud Rate generator Input Clock */
+#define 	AT91C_US_CLKS_CLOCK                (0x0 <<  4) /**< (USART) Clock */
+#define 	AT91C_US_CLKS_FDIV1                (0x1 <<  4) /**< (USART) fdiv1 */
+#define 	AT91C_US_CLKS_SLOW                 (0x2 <<  4) /**< (USART) slow_clock (ARM) */
+#define 	AT91C_US_CLKS_EXT                  (0x3 <<  4) /**< (USART) External (SCK) */
+#define AT91C_US_CHRL         (0x3 << 6 ) /**< (USART) Clock Selection (Baud Rate generator Input Clock */
+#define 	AT91C_US_CHRL_5_BITS               (0x0 <<  6) /**< (USART) Character Length: 5 bits */
+#define 	AT91C_US_CHRL_6_BITS               (0x1 <<  6) /**< (USART) Character Length: 6 bits */
+#define 	AT91C_US_CHRL_7_BITS               (0x2 <<  6) /**< (USART) Character Length: 7 bits */
+#define 	AT91C_US_CHRL_8_BITS               (0x3 <<  6) /**< (USART) Character Length: 8 bits */
+#define AT91C_US_SYNC         (0x1 << 8 ) /**< (USART) Synchronous Mode Select */
+#define AT91C_US_PAR          (0x7 << 9 ) /**< (USART) Parity type */
+#define 	AT91C_US_PAR_EVEN                 (0x0 <<  9) /**< (USART) Even Parity */
+#define 	AT91C_US_PAR_ODD                  (0x1 <<  9) /**< (USART) Odd Parity */
+#define 	AT91C_US_PAR_SPACE                (0x2 <<  9) /**< (USART) Parity forced to 0 (Space) */
+#define 	AT91C_US_PAR_MARK                 (0x3 <<  9) /**< (USART) Parity forced to 1 (Mark) */
+#define 	AT91C_US_PAR_NONE                 (0x4 <<  9) /**< (USART) No Parity */
+#define 	AT91C_US_PAR_MULTI_DROP           (0x6 <<  9) /**< (USART) Multi-drop mode */
+#define AT91C_US_NBSTOP       (0x3 << 12) /**< (USART) Number of Stop bits */
+#define 	AT91C_US_NBSTOP_1_BIT                (0x0 << 12) /**< (USART) 1 stop bit */
+#define 	AT91C_US_NBSTOP_15_BIT               (0x1 << 12) /**< (USART) Asynchronous (SYNC=0) 2 stop bits Synchronous (SYNC=1) 2 stop bits */
+#define 	AT91C_US_NBSTOP_2_BIT                (0x2 << 12) /**< (USART) 2 stop bits */
+#define AT91C_US_CHMODE       (0x3 << 14) /**< (USART) Channel Mode */
+#define 	AT91C_US_CHMODE_NORMAL               (0x0 << 14) /**< (USART) Normal Mode: The USART channel operates as an RX/TX USART. */
+#define 	AT91C_US_CHMODE_AUTO                 (0x1 << 14) /**< (USART) Automatic Echo: Receiver Data Input is connected to the TXD pin. */
+#define 	AT91C_US_CHMODE_LOCAL                (0x2 << 14) /**< (USART) Local Loopback: Transmitter Output Signal is connected to Receiver Input Signal. */
+#define 	AT91C_US_CHMODE_REMOTE               (0x3 << 14) /**< (USART) Remote Loopback: RXD pin is internally connected to TXD pin. */
+#define AT91C_US_MSBF         (0x1 << 16) /**< (USART) Bit Order */
+#define AT91C_US_MODE9        (0x1 << 17) /**< (USART) 9-bit Character length */
+#define AT91C_US_CKLO         (0x1 << 18) /**< (USART) Clock Output Select */
+#define AT91C_US_OVER         (0x1 << 19) /**< (USART) Over Sampling Mode */
+#define AT91C_US_INACK        (0x1 << 20) /**< (USART) Inhibit Non Acknowledge */
+#define AT91C_US_DSNACK       (0x1 << 21) /**< (USART) Disable Successive NACK */
+#define AT91C_US_MAX_ITER     (0x1 << 24) /**< (USART) Number of Repetitions */
+#define AT91C_US_FILTER       (0x1 << 28) /**< (USART) Receive Line Filter */
+/* --- Register US_IER */
+/* --- Register US_IDR */
+/* --- Register US_IMR */
+/* --- Register US_CSR */
+#define AT91C_US_RXRDY        (0x1 << 0 ) /**< (USART) RXRDY Interrupt */
+#define AT91C_US_TXRDY        (0x1 << 1 ) /**< (USART) TXRDY Interrupt */
+#define AT91C_US_RXBRK        (0x1 << 2 ) /**< (USART) Break Received/End of Break */
+#define AT91C_US_ENDRX        (0x1 << 3 ) /**< (USART) End of Receive Transfer Interrupt */
+#define AT91C_US_ENDTX        (0x1 << 4 ) /**< (USART) End of Transmit Interrupt */
+#define AT91C_US_OVRE         (0x1 << 5 ) /**< (USART) Overrun Interrupt */
+#define AT91C_US_FRAME        (0x1 << 6 ) /**< (USART) Framing Error Interrupt */
+#define AT91C_US_PARE         (0x1 << 7 ) /**< (USART) Parity Error Interrupt */
+#define AT91C_US_TIMEOUT      (0x1 << 8 ) /**< (USART) Receiver Time-out */
+#define AT91C_US_TXEMPTY      (0x1 << 9 ) /**< (USART) TXEMPTY Interrupt */
+#define AT91C_US_ITERATION    (0x1 << 10) /**< (USART) Max number of Repetitions Reached */
+#define AT91C_US_TXBUFE       (0x1 << 11) /**< (USART) TXBUFE Interrupt */
+#define AT91C_US_RXBUFF       (0x1 << 12) /**< (USART) RXBUFF Interrupt */
+#define AT91C_US_NACK         (0x1 << 13) /**< (USART) Non Acknowledge */
+#define AT91C_US_RIIC         (0x1 << 16) /**< (USART) Ring INdicator Input Change Flag */
+#define AT91C_US_DSRIC        (0x1 << 17) /**< (USART) Data Set Ready Input Change Flag */
+#define AT91C_US_DCDIC        (0x1 << 18) /**< (USART) Data Carrier Flag */
+#define AT91C_US_CTSIC        (0x1 << 19) /**< (USART) Clear To Send Input Change Flag */
+/* --- Register US_CSR only */
+#define AT91C_US_RI           (0x1 << 20) /**< (USART) Image of RI Input */
+#define AT91C_US_DSR          (0x1 << 21) /**< (USART) Image of DSR Input */
+#define AT91C_US_DCD          (0x1 << 22) /**< (USART) Image of DCD Input */
+#define AT91C_US_CTS          (0x1 << 23) /**< (USART) Image of CTS Input */
+
+#endif /* __AT91SAM9261_USART_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/board.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/board.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/board.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/board.h	2006-08-09 10:55:07.000000000 +0200
@@ -0,0 +1,91 @@
+/*
+ * include/asm-arm/arch-at91sam9261/board.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *  Copyright (C) 2006 Atmel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * These are data structures found in platform_device.dev.platform_data,
+ * and describing board-specfic data needed by drivers.  For example,
+ * which pin is used for a given GPIO role.
+ *
+ * In 2.6, drivers should strongly avoid board-specific knowledge so
+ * that supporting new boards normally won't require driver patches.
+ * Most board-specific knowledge should be in arch/.../board-*.c files.
+ */
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+extern const struct platform_device *platform_get_device(const char *name, int id);
+
+extern struct resource dbgu_resources[2];
+extern struct resource us0_resources[2];
+extern struct resource lcdc_resources[2];
+
+ /* Clocks */
+extern unsigned long at91_master_clock;
+
+ /* Serial Port */
+extern void __init at91_add_device_usart(unsigned id, struct at91_pioline *data);
+
+ /* USB Device */
+struct at91_udc_data {
+	u8	vbus_pin;		/* high == host powering us */
+	u8	pullup_pin;		/* high == D+ pulled up */
+};
+//extern void __init at91_add_device_udc(struct at91_udc_data *data);
+extern void __init at91_add_device_udc(void);
+
+ /* Compact Flash */
+struct at91_cf_data {
+	u8	irq_pin;		/* I/O IRQ */
+	u8	det_pin;		/* Card detect */
+	u8	vcc_pin;		/* power switching */
+	u8	rst_pin;		/* card reset */
+};
+extern void __init at91_add_device_cf(struct at91_cf_data *data);
+
+ /* MMC / SD */
+struct at91_mmc_data {
+	u8		det_pin;	/* card detect IRQ */
+	unsigned	is_b:1;		/* uses B side (vs A) */
+	unsigned	wire4:1;	/* (SD) supports DAT0..DAT3 */
+	u8		wp_pin;		/* (SD) writeprotect detect */
+	u8		vcc_pin;	/* power switching (high == on) */
+};
+extern void __init at91_add_device_mmc(struct at91_mmc_data *data);
+
+ /* Ethernet */
+struct at91_eth_data {
+	u8		phy_irq_pin;	/* PHY IRQ */
+	u8		phy_rst_pin;	/* PHY RST */
+	u8		is_rmii;	/* using RMII interface? */
+};
+extern void __init at91_add_device_eth(struct at91_eth_data *data);
+
+ /* USB Host */
+struct at91_usbh_data {
+	u8		ports;		/* number of ports on root hub */
+};
+extern void __init at91_add_device_usbh(struct at91_usbh_data *data);
+
+/* LCD */
+extern void __init at91_add_device_lcd(struct at91_pioline *data);
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/debug-macro.S linux-2.6.15.4/include/asm-arm/arch-at91sam9260/debug-macro.S
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/debug-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/debug-macro.S	2006-08-09 10:55:08.000000000 +0200
@@ -0,0 +1,37 @@
+/* linux/include/asm-arm/arch-at91sam9261/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include "hardware.h"
+
+                .macro  addruart,rx
+                mrc     p15, 0, \rx, c1, c0
+                tst     \rx, #1                       @ MMU enabled?
+                ldreq   \rx, =AT91C_BASE_DBGU         @ DBGU peripheral (phys address)
+                ldrne   \rx, =AT91C_VA_BASE_DBGU      @ DBGU peripheral (virt address)
+                .endm   
+
+                .macro  senduart,rd,rx
+                strb    \rd, [\rx, #US_THR]           @ DBGU_THR
+                .endm   
+
+                .macro  waituart,rd,rx
+1001:           ldr     \rd, [\rx, #US_CSR]           @ DBGU_CSR
+                tst     \rd, #AT91C_US_TXRDY          @ US_TXRDY = 1 when ready to transmit
+                beq     1001b   
+                .endm   
+
+                .macro  busyuart,rd,rx
+1001:           ldr     \rd, [\rx, #US_CSR]           @ DBGU_CSR
+                tst     \rd, #AT91C_US_TXEMPTY        @ US_TXEMPTY = 1 when transmission complete
+                beq     1001b
+                .endm
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/dma.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/dma.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/dma.h	2006-08-09 10:55:09.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/dma.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/emac.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/emac.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/emac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/emac.h	2006-08-09 10:55:10.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-nadia2/emac.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_EMAC_H
+#define __ASM_ARCH_EMAC_H
+
+#include <asm/arch/at91sam9260_emac.h>
+#include <asm/arch/pmc.h>
+
+
+// EMAC data structure : Phy address + PIO lines
+struct at91_eth_pdata {
+        int phy_id;                      // PHY address
+        struct at91_pioline *pio_data;  
+};
+
+
+static inline void at91_macb_clock_enable(void)
+{
+       at91_enable_periph_clock(AT91C_ID_EMAC);
+}
+
+
+static inline void at91_macb_clock_disable(void)
+{
+       at91_disable_periph_clock(AT91C_ID_EMAC);  
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/entry-macro.S linux-2.6.15.4/include/asm-arm/arch-at91sam9260/entry-macro.S
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/entry-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/entry-macro.S	2006-08-09 10:55:11.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ * include/asm-arm/arch-at91sam9261/entry-macro.S
+ *
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France
+ * Low-level IRQ helper macros for AT91SAM9261 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/hardware.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(AT91C_VA_BASE_SYS)	@ base virtual address of SYS peripherals
+	ldr	\irqnr, [\base, #AIC_IVR]	@ read IRQ vector register: de-asserts nIRQ to processor (and clears interrupt)
+	ldr	\irqstat, [\base, #AIC_ISR]	@ read interrupt source number
+	teq	\irqstat, #0			@ ISR is 0 when no current interrupt, or spurious interrupt
+	streq	\tmp, [\base, #AIC_EOICR]	@ not going to be handled further, then ACK it now.
+	.endm
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/gpio.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/gpio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/gpio.h	2006-08-09 10:55:12.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * include/asm-arm/arch-at91sam9260/gpio.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm/arch/at91sam9260_pio.h>
+#include <asm/arch/pio.h>
+
+#define PIOA AT91C_VA_BASE_PIOA, AT91C_ID_PIOA
+#define PIOB AT91C_VA_BASE_PIOB, AT91C_ID_PIOB
+#define PIOC AT91C_VA_BASE_PIOC, AT91C_ID_PIOC
+
+#define pin_to_mask(pin)        (1 << (pin))
+
+#define TYPE_PIO	0
+#define TYPE_PERIPH	1
+
+#define OUTPUT_MODE	0
+#define INPUT_MODE	1
+
+#define PERIPH_A	0
+#define PERIPH_B	1
+
+#define NO_PULL_UP	0
+#define PULLED_UP	1
+
+#define NO_GLITCH_FLT	0
+#define GLITCH_FLT_ON	1
+
+#ifndef __ASSEMBLY__
+/* -------------------------------------------------------- */
+/* PIO line structure definition */
+/* -------------------------------------------------------- */
+struct at91_pioline {
+        const char*	pin_name;		/* Name of the pin */
+        unsigned int	pio_ctrl_va_base;	/* Virtual Address of the PIO controller*/
+        unsigned char	pio_ctrl_id;		/* PIO controller ID */
+        unsigned char	pin_num;		/* pin number */
+        unsigned char	type;			/* type of the pin: PIO or Peripheral mode */
+        unsigned char	direction;		/* if the pin is in PIO mode    --> selects input or output mode */ 
+						/* if the pin is in Periph mode --> selects periph A or B */
+        unsigned char	use_pullup;		/* pullup enable */
+        unsigned char	use_filter;		/* glitch filter enable */
+};
+
+
+extern void at91_gpio_periph_enable(unsigned int pio_va_base, unsigned char pin, unsigned char peripheral, unsigned char use_pullup, unsigned char use_filter);
+extern void at91_gpio_configure(unsigned int pio_va_base, unsigned char pin, unsigned char in_out, unsigned char use_pullup, unsigned char use_filter);
+extern void at91_gpio_set_level(unsigned int pio_va_base, unsigned int pin, unsigned int level);
+extern unsigned int at91_gpio_get_level(unsigned int pio_va_base, unsigned int pin);
+extern int at91_device_pio_setup (struct at91_pioline *pPin);
+
+#endif
+
+#endif
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/hardware.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/hardware.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/hardware.h	2006-08-09 10:55:13.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/hardware.h
+ *
+ * Copyright (c) 2005 ATMEL Rousset, France
+ * Revision	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/at91sam9260.h>
+/*
+#include <asm/arch/at91sam9260_sys.h>
+*/
+
+#include <asm/arch/at91sam9260_ebi.h>
+#include <asm/arch/at91sam9260_aic.h>
+#include <asm/arch/at91sam9260_pitc.h>
+#include <asm/arch/at91sam9260_pmc.h>
+#include <asm/arch/at91sam9260_pio.h>
+
+
+#include <asm/arch/at91sam9260_usart.h>
+
+#include <asm/arch/vmalloc.h>
+
+/*
+ * Remap the peripherals from address 0xFFFFEA00 .. 0xFFFFFFFF
+ * to 0xFEFA0000 .. 0xFF000000.  (384Kb)
+ */
+#define AT91C_IO_PHYS_BASE	0xFFFFE000
+#define AT91C_IO_VIRT_BASE	VMALLOC_END	
+
+ /* Convert a physical IO address to virtual IO address */
+#define AT91_IO_P2V(x)	((x) - AT91C_IO_PHYS_BASE + AT91C_IO_VIRT_BASE)
+
+/*
+ * Virtual to Physical Address mapping for IO devices.
+ */
+#define AT91C_VA_BASE_EBI	AT91_IO_P2V(AT91C_BASE_EBI)
+#define AT91C_VA_BASE_AIC	AT91_IO_P2V(AT91C_BASE_AIC)
+#define AT91C_VA_BASE_SYS	AT91_IO_P2V(AT91C_BASE_AIC)
+#define AT91C_VA_BASE_DBGU	AT91_IO_P2V(AT91C_BASE_DBGU)
+#define AT91C_VA_BASE_PIOA	AT91_IO_P2V(AT91C_BASE_PIOA)
+#define AT91C_VA_BASE_PIOB	AT91_IO_P2V(AT91C_BASE_PIOB)
+#define AT91C_VA_BASE_PIOC	AT91_IO_P2V(AT91C_BASE_PIOC)
+#define AT91C_VA_BASE_PITC	AT91_IO_P2V(AT91C_BASE_PITC)
+#define AT91C_VA_BASE_PMC	AT91_IO_P2V(AT91C_BASE_PMC)
+
+#define AT91C_VA_BASE_UDP	AT91_IO_P2V(AT91_BASE_UDP)
+
+/* 6 USART - 3's and one DBGU port */
+#define AT91C_NR_UART		7
+
+/*
+ * Serial port configuration.
+ *    1 .. 6 = USART0 .. USART5
+ *    0      = DBGU
+ */
+
+#define AT91C_CONSOLE		0			/* ttyS0 */
+
+/* Number of SPI ports */
+#define AT91C_NR_SPI            2
+
+
+ /* Definition of interrupt priority levels */
+#define AT91C_AIC_PRIOR_0 AT91C_AIC_PRIOR_LOWEST
+#define AT91C_AIC_PRIOR_1 ((unsigned int) 0x1)
+#define AT91C_AIC_PRIOR_2 ((unsigned int) 0x2)
+#define AT91C_AIC_PRIOR_3 ((unsigned int) 0x3)
+#define AT91C_AIC_PRIOR_4 ((unsigned int) 0x4)
+#define AT91C_AIC_PRIOR_5 ((unsigned int) 0x5)
+#define AT91C_AIC_PRIOR_6 ((unsigned int) 0x6)
+#define AT91C_AIC_PRIOR_7 AT91C_AIC_PRIOR_HIGHEST
+
+
+/* Peripheral interrupt configuration */
+#define AT91_SMR_FIQ	(AT91C_AIC_PRIOR_HIGHEST | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (FIQ)
+#define AT91_SMR_SYS	(AT91C_AIC_PRIOR_HIGHEST | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// System Peripheral
+#define AT91_SMR_PIOA	(AT91C_AIC_PRIOR_LOWEST	 | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller A
+#define AT91_SMR_PIOB	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller B
+#define AT91_SMR_PIOC	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller C
+#define AT91_SMR_US0	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 0
+#define AT91_SMR_US1	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 1
+#define AT91_SMR_US2	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 2
+#define AT91_SMR_MCI	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Multimedia Card Interface
+#define AT91_SMR_UDP	(AT91C_AIC_PRIOR_4       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB Device Port
+#define AT91_SMR_TWI	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Two-Wire Interface
+#define AT91_SMR_SPI0	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Peripheral Interface
+#define AT91_SMR_SPI1	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Peripheral Interface
+#define AT91_SMR_SSC0	(AT91C_AIC_PRIOR_5       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Synchronous Controller 0
+#define AT91_SMR_TC0	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 0
+#define AT91_SMR_TC1	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 1
+#define AT91_SMR_TC2	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 2
+#define AT91_SMR_TC3	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 0
+#define AT91_SMR_TC4	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 1
+#define AT91_SMR_TC5	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 2
+#define AT91_SMR_EMAC	(AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB Host port
+#define AT91_SMR_UHP	(AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB Host port
+#define AT91_SMR_US3	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 0
+#define AT91_SMR_US4	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 1
+#define AT91_SMR_US5	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 2
+#define AT91_SMR_IRQ0	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE)	// Advanced Interrupt Controller (IRQ0)
+#define AT91_SMR_IRQ1	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (IRQ1)
+#define AT91_SMR_IRQ2	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (IRQ2)
+
+
+/*
+ * Implementation specific hardware definitions.
+ */
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+#include <asm/arch/at91sam9260ek.h>
+#endif
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/io.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/io.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/io.h	2006-08-09 10:55:14.000000000 +0200
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/io.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT		0xFFFFFFFF
+
+#define __io(a)			(a)
+#define __mem_pci(a)		((unsigned long)(a))
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/irqs.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/irqs.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/irqs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/irqs.h	2006-08-09 10:55:15.000000000 +0200
@@ -0,0 +1,50 @@
+/*
+ * include/asm-arm/arch-at91rm9200/irqs.h
+ *
+ *  Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define NR_AIC_IRQS 32
+
+
+/*
+ * Acknowledge interrupt with AIC after interrupt has been handled.
+ *   (by kernel/irq.c)
+ */
+#define irq_finish(irq) do { *((volatile unsigned *) (AT91C_VA_BASE_AIC + AIC_EOICR)) = 0; } while (0)
+
+/*
+ * IRQ interrupt symbols are the AT91_ID_* symbols in at91rm9200.h
+ * for IRQs handled directly through the AIC, or else the AT91_PIN_*
+ * symbols in gpio.h for ones handled indirectly as GPIOs.
+ * We make provision for 4 banks of GPIO.
+ */
+#include <asm/arch/gpio.h>
+
+#define	NR_IRQS		(NR_AIC_IRQS + (3 * 32))
+
+
+#ifndef __ASSEMBLY__
+/*
+ * Initialize the IRQ controller.
+ */
+#endif
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/lcdc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/lcdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/lcdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/lcdc.h	2006-08-09 10:55:16.000000000 +0200
@@ -0,0 +1,37 @@
+#ifndef __ASM_ARCH_LCDC_H
+#define __ASM_ARCH_LCDC_H
+
+
+#include <asm/arch/at91sam9261_lcdc.h>
+#include <asm/arch/pmc.h>
+
+
+// Clock management functions 
+static inline void at91_lcdc_clock_enable (void) 
+{
+        at91_enable_system_clock(AT91C_PMC_HCK1);
+	at91_enable_periph_clock(AT91C_ID_LCDC);
+}
+
+
+static inline void at91_lcdc_clock_disable (void) 
+{
+        at91_disable_system_clock(AT91C_PMC_HCK1);
+	at91_disable_periph_clock(AT91C_ID_LCDC);
+}
+
+
+// LCD Power up and down function
+static inline void at91_lcdc_power_up (void)
+{
+       at91_gpio_set_level(AT91C_VA_BASE_PIOA, 12, 0);
+}
+
+
+static inline void at91_lcdc_power_down (void)
+{
+       at91_gpio_set_level(AT91C_VA_BASE_PIOA, 12, 1);
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/memory.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/memory.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/memory.h	2006-08-09 10:55:17.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/memory.h
+ * 
+ * Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ * Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/arch/hardware.h>
+
+#define PHYS_OFFSET	(AT91_SDRAM_BASE)
+
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/param.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/param.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/param.h	2006-08-09 10:55:18.000000000 +0200
@@ -0,0 +1,3 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/param.h
+ */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/pio.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/pio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/pio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/pio.h	2006-08-09 10:55:19.000000000 +0200
@@ -0,0 +1,139 @@
+
+/*
+ * include/asm-arm/arch-at91rm9200/gpio.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91SAM9261_GPIO_H
+#define __ASM_ARCH_AT91SAM9261_GPIO_H
+
+#define PIN_BASE		32
+
+/* these pin numbers double as IRQ numbers, like AT91C_ID_* values */
+
+#define	AT91_PIN_PA0	(PIN_BASE + 0x00 + 0)
+#define	AT91_PIN_PA1	(PIN_BASE + 0x00 + 1)
+#define	AT91_PIN_PA2	(PIN_BASE + 0x00 + 2)
+#define	AT91_PIN_PA3	(PIN_BASE + 0x00 + 3)
+#define	AT91_PIN_PA4	(PIN_BASE + 0x00 + 4)
+
+#define	AT91_PIN_PA5	(PIN_BASE + 0x00 + 5)
+#define	AT91_PIN_PA6	(PIN_BASE + 0x00 + 6)
+#define	AT91_PIN_PA7	(PIN_BASE + 0x00 + 7)
+#define	AT91_PIN_PA8	(PIN_BASE + 0x00 + 8)
+#define	AT91_PIN_PA9	(PIN_BASE + 0x00 + 9)
+
+#define	AT91_PIN_PA10	(PIN_BASE + 0x00 + 10)
+#define	AT91_PIN_PA11	(PIN_BASE + 0x00 + 11)
+#define	AT91_PIN_PA12	(PIN_BASE + 0x00 + 12)
+#define	AT91_PIN_PA13	(PIN_BASE + 0x00 + 13)
+#define	AT91_PIN_PA14	(PIN_BASE + 0x00 + 14)
+
+#define	AT91_PIN_PA15	(PIN_BASE + 0x00 + 15)
+#define	AT91_PIN_PA16	(PIN_BASE + 0x00 + 16)
+#define	AT91_PIN_PA17	(PIN_BASE + 0x00 + 17)
+#define	AT91_PIN_PA18	(PIN_BASE + 0x00 + 18)
+#define	AT91_PIN_PA19	(PIN_BASE + 0x00 + 19)
+
+#define	AT91_PIN_PA20	(PIN_BASE + 0x00 + 20)
+#define	AT91_PIN_PA21	(PIN_BASE + 0x00 + 21)
+#define	AT91_PIN_PA22	(PIN_BASE + 0x00 + 22)
+#define	AT91_PIN_PA23	(PIN_BASE + 0x00 + 23)
+#define	AT91_PIN_PA24	(PIN_BASE + 0x00 + 24)
+
+#define	AT91_PIN_PA25	(PIN_BASE + 0x00 + 25)
+#define	AT91_PIN_PA26	(PIN_BASE + 0x00 + 26)
+#define	AT91_PIN_PA27	(PIN_BASE + 0x00 + 27)
+#define	AT91_PIN_PA28	(PIN_BASE + 0x00 + 28)
+#define	AT91_PIN_PA29	(PIN_BASE + 0x00 + 29)
+
+#define	AT91_PIN_PA30	(PIN_BASE + 0x00 + 30)
+#define	AT91_PIN_PA31	(PIN_BASE + 0x00 + 31)
+
+#define	AT91_PIN_PB0	(PIN_BASE + 0x20 + 0)
+#define	AT91_PIN_PB1	(PIN_BASE + 0x20 + 1)
+#define	AT91_PIN_PB2	(PIN_BASE + 0x20 + 2)
+#define	AT91_PIN_PB3	(PIN_BASE + 0x20 + 3)
+#define	AT91_PIN_PB4	(PIN_BASE + 0x20 + 4)
+
+#define	AT91_PIN_PB5	(PIN_BASE + 0x20 + 5)
+#define	AT91_PIN_PB6	(PIN_BASE + 0x20 + 6)
+#define	AT91_PIN_PB7	(PIN_BASE + 0x20 + 7)
+#define	AT91_PIN_PB8	(PIN_BASE + 0x20 + 8)
+#define	AT91_PIN_PB9	(PIN_BASE + 0x20 + 9)
+
+#define	AT91_PIN_PB10	(PIN_BASE + 0x20 + 10)
+#define	AT91_PIN_PB11	(PIN_BASE + 0x20 + 11)
+#define	AT91_PIN_PB12	(PIN_BASE + 0x20 + 12)
+#define	AT91_PIN_PB13	(PIN_BASE + 0x20 + 13)
+#define	AT91_PIN_PB14	(PIN_BASE + 0x20 + 14)
+
+#define	AT91_PIN_PB15	(PIN_BASE + 0x20 + 15)
+#define	AT91_PIN_PB16	(PIN_BASE + 0x20 + 16)
+#define	AT91_PIN_PB17	(PIN_BASE + 0x20 + 17)
+#define	AT91_PIN_PB18	(PIN_BASE + 0x20 + 18)
+#define	AT91_PIN_PB19	(PIN_BASE + 0x20 + 19)
+
+#define	AT91_PIN_PB20	(PIN_BASE + 0x20 + 20)
+#define	AT91_PIN_PB21	(PIN_BASE + 0x20 + 21)
+#define	AT91_PIN_PB22	(PIN_BASE + 0x20 + 22)
+#define	AT91_PIN_PB23	(PIN_BASE + 0x20 + 23)
+#define	AT91_PIN_PB24	(PIN_BASE + 0x20 + 24)
+
+#define	AT91_PIN_PB25	(PIN_BASE + 0x20 + 25)
+#define	AT91_PIN_PB26	(PIN_BASE + 0x20 + 26)
+#define	AT91_PIN_PB27	(PIN_BASE + 0x20 + 27)
+#define	AT91_PIN_PB28	(PIN_BASE + 0x20 + 28)
+#define	AT91_PIN_PB29	(PIN_BASE + 0x20 + 29)
+
+#define	AT91_PIN_PB30	(PIN_BASE + 0x20 + 30)
+#define	AT91_PIN_PB31	(PIN_BASE + 0x20 + 31)
+
+#define	AT91_PIN_PC0	(PIN_BASE + 0x40 + 0)
+#define	AT91_PIN_PC1	(PIN_BASE + 0x40 + 1)
+#define	AT91_PIN_PC2	(PIN_BASE + 0x40 + 2)
+#define	AT91_PIN_PC3	(PIN_BASE + 0x40 + 3)
+#define	AT91_PIN_PC4	(PIN_BASE + 0x40 + 4)
+
+#define	AT91_PIN_PC5	(PIN_BASE + 0x40 + 5)
+#define	AT91_PIN_PC6	(PIN_BASE + 0x40 + 6)
+#define	AT91_PIN_PC7	(PIN_BASE + 0x40 + 7)
+#define	AT91_PIN_PC8	(PIN_BASE + 0x40 + 8)
+#define	AT91_PIN_PC9	(PIN_BASE + 0x40 + 9)
+
+#define	AT91_PIN_PC10	(PIN_BASE + 0x40 + 10)
+#define	AT91_PIN_PC11	(PIN_BASE + 0x40 + 11)
+#define	AT91_PIN_PC12	(PIN_BASE + 0x40 + 12)
+#define	AT91_PIN_PC13	(PIN_BASE + 0x40 + 13)
+#define	AT91_PIN_PC14	(PIN_BASE + 0x40 + 14)
+
+#define	AT91_PIN_PC15	(PIN_BASE + 0x40 + 15)
+#define	AT91_PIN_PC16	(PIN_BASE + 0x40 + 16)
+#define	AT91_PIN_PC17	(PIN_BASE + 0x40 + 17)
+#define	AT91_PIN_PC18	(PIN_BASE + 0x40 + 18)
+#define	AT91_PIN_PC19	(PIN_BASE + 0x40 + 19)
+
+#define	AT91_PIN_PC20	(PIN_BASE + 0x40 + 20)
+#define	AT91_PIN_PC21	(PIN_BASE + 0x40 + 21)
+#define	AT91_PIN_PC22	(PIN_BASE + 0x40 + 22)
+#define	AT91_PIN_PC23	(PIN_BASE + 0x40 + 23)
+#define	AT91_PIN_PC24	(PIN_BASE + 0x40 + 24)
+
+#define	AT91_PIN_PC25	(PIN_BASE + 0x40 + 25)
+#define	AT91_PIN_PC26	(PIN_BASE + 0x40 + 26)
+#define	AT91_PIN_PC27	(PIN_BASE + 0x40 + 27)
+#define	AT91_PIN_PC28	(PIN_BASE + 0x40 + 28)
+#define	AT91_PIN_PC29	(PIN_BASE + 0x40 + 29)
+
+#define	AT91_PIN_PC30	(PIN_BASE + 0x40 + 30)
+#define	AT91_PIN_PC31	(PIN_BASE + 0x40 + 31)
+
+#endif
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/pmc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/pmc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/pmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/pmc.h	2006-08-09 17:52:02.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/pmc.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _ASM_ARCH_PMC_H
+#define _ASM_ARCH_PMC_H
+
+extern void at91_disable_periph_clock(unsigned int irq);
+extern void at91_enable_periph_clock (unsigned int irq);
+extern void at91_disable_system_clock(unsigned int mask);
+extern void at91_enable_system_clock (unsigned int mask);
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/spi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/spi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/spi.h	2006-08-09 10:55:21.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef __ASM_ARCH_SPI_H
+#define __ASM_ARCH_SPI_H
+
+
+#include <asm/arch/at91sam9260_spi.h>
+#include <asm/arch/at91sam9260_pdc.h>
+#include <asm/arch/pmc.h>
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/system.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/system.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/system.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/system.h	2006-08-09 10:55:22.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9260/system.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/hardware.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+}
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/time.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/time.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/time.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/time.h	2006-08-09 10:55:23.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/time.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_TIME_H
+#define __ASM_ARCH_TIME_H
+
+
+#include <asm/mach/time.h>
+
+extern struct sys_timer at91sam9260_timer;
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/timex.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/timex.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/timex.h	2006-08-09 10:55:24.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/timex.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <asm/arch/hardware.h>
+
+#define CLOCK_TICK_RATE		(AT91C_MASTER_CLOCK/16)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/uhp.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/uhp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/uhp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/uhp.h	2006-08-09 10:55:25.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-at91sam9261/uhp.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+
+#ifndef __ASM_ARCH_UHP_H
+#define __ASM_ARCH_UHP_H
+
+
+#include <asm/arch/at91sam9260_uhp.h>
+#include <asm/arch/pmc.h>
+
+
+
+// Clock management functions
+static inline void at91_uhp_clock_enable (void) 
+{
+        at91_enable_system_clock(AT91C_PMC_UHP | AT91C_PMC_HCK0);
+        at91_enable_periph_clock(AT91C_ID_UHP);
+}
+
+
+static inline void at91_uhp_clock_disable (void) 
+{
+       at91_disable_system_clock(AT91C_PMC_UHP | AT91C_PMC_HCK0);
+       at91_disable_periph_clock(AT91C_ID_UHP);
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/uncompress.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/uncompress.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/uncompress.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/uncompress.h	2006-08-09 10:55:26.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/uncompress.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *  Revision 	  2005 Atmel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <asm/io.h>
+
+#include <asm/arch/hardware.h>
+
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	while (*s) {
+		while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXRDY)) {
+			barrier();
+		}
+		writel( *s, AT91C_BASE_DBGU + US_THR); 
+		if (*s == '\n')	{
+			while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXRDY)) {
+				barrier();
+			}
+			writel('\r', AT91C_BASE_DBGU + US_THR); 
+		}
+		s++;
+	}
+	/* wait for transmission to complete */
+	while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXEMPTY)) {
+		barrier();
+	}
+}
+
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/usart.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/usart.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/usart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/usart.h	2006-08-09 10:55:27.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __ASM_ARCH_USART_H
+#define __ASM_ARCH_USART_H
+
+
+#include <asm/arch/at91sam9260_usart.h>
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/vmalloc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9260/vmalloc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9260/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9260/vmalloc.h	2006-08-09 10:55:28.000000000 +0200
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END		(0xFF000000 - 0x00200000)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_aic.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_aic.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_aic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_aic.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,81 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_aic.h
+ * 
+ * Hardware definition for the aic peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from AIC_6075B V1.3
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9261_AIC_H
+#define __AT91SAM9261_AIC_H
+
+/* -------------------------------------------------------- */
+/* AIC ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_FIQ
+#define AT91C_ID_FIQ   	 0 /**< Advanced Interrupt Controller (FIQ) id */
+#endif /* AT91C_ID_FIQ */
+#ifndef AT91C_ID_IRQ0
+#define AT91C_ID_IRQ0  	29 /**< Advanced Interrupt Controller (IRQ0) id */
+#endif /* AT91C_ID_IRQ0 */
+#ifndef AT91C_ID_IRQ1
+#define AT91C_ID_IRQ1  	30 /**< Advanced Interrupt Controller (IRQ1) id */
+#endif /* AT91C_ID_IRQ1 */
+#ifndef AT91C_ID_IRQ2
+#define AT91C_ID_IRQ2  	31 /**< Advanced Interrupt Controller (IRQ2) id */
+#endif /* AT91C_ID_IRQ2 */
+
+/* -------------------------------------------------------- */
+/* AIC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_AIC       	0xFFFFF000 /**< AIC base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AIC_SMR 	(0x0000) 	/**< Source Mode Register */
+#define AIC_SVR 	(0x0080) 	/**< Source Vector Register */
+#define AIC_IVR 	(0x0100) 	/**< IRQ Vector Register */
+#define AIC_FVR 	(0x0104) 	/**< FIQ Vector Register */
+#define AIC_ISR 	(0x0108) 	/**< Interrupt Status Register */
+#define AIC_IPR 	(0x010C) 	/**< Interrupt Pending Register */
+#define AIC_IMR 	(0x0110) 	/**< Interrupt Mask Register */
+#define AIC_CISR 	(0x0114) 	/**< Core Interrupt Status Register */
+#define AIC_IECR 	(0x0120) 	/**< Interrupt Enable Command Register */
+#define AIC_IDCR 	(0x0124) 	/**< Interrupt Disable Command Register */
+#define AIC_ICCR 	(0x0128) 	/**< Interrupt Clear Command Register */
+#define AIC_ISCR 	(0x012C) 	/**< Interrupt Set Command Register */
+#define AIC_EOICR 	(0x0130) 	/**< End of Interrupt Command Register */
+#define AIC_SPU 	(0x0134) 	/**< Spurious Vector Register */
+#define AIC_DCR 	(0x0138) 	/**< Debug Control Register (Protect) */
+#define AIC_FFER 	(0x0140) 	/**< Fast Forcing Enable Register */
+#define AIC_FFDR 	(0x0144) 	/**< Fast Forcing Disable Register */
+#define AIC_FFSR 	(0x0148) 	/**< Fast Forcing Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register AIC_SMR */
+#define AT91C_AIC_PRIOR       (0x7 << 0 ) /**< (AIC) Priority Level */
+#define 	AT91C_AIC_PRIOR_LOWEST               0x0 /**< (AIC) Lowest priority level */
+#define 	AT91C_AIC_PRIOR_HIGHEST              0x7 /**< (AIC) Highest priority level */
+#define AT91C_AIC_SRCTYPE     (0x3 << 5 ) /**< (AIC) Interrupt Source Type */
+#define 	AT91C_AIC_SRCTYPE_EXT_LOW_LEVEL        (0x0 <<  5) /**< (AIC) External Sources Code Label Low-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL       (0x0 <<  5) /**< (AIC) Internal Sources Code Label High-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE    (0x1 <<  5) /**< (AIC) Internal Sources Code Label Positive Edge triggered */
+#define 	AT91C_AIC_SRCTYPE_EXT_NEGATIVE_EDGE    (0x1 <<  5) /**< (AIC) External Sources Code Label Negative Edge triggered */
+#define 	AT91C_AIC_SRCTYPE_HIGH_LEVEL           (0x2 <<  5) /**< (AIC) Internal Or External Sources Code Label High-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_POSITIVE_EDGE        (0x3 <<  5) /**< (AIC) Internal Or External Sources Code Label Positive Edge triggered */
+/* --- Register AIC_CISR */
+#define AT91C_AIC_NFIQ        (0x1 << 0 ) /**< (AIC) NFIQ Status */
+#define AT91C_AIC_NIRQ        (0x1 << 1 ) /**< (AIC) NIRQ Status */
+/* --- Register AIC_DCR */
+#define AT91C_AIC_DCR_PROT    (0x1 << 0 ) /**< (AIC) Protection Mode */
+#define AT91C_AIC_DCR_GMSK    (0x1 << 1 ) /**< (AIC) General Mask */
+
+#endif /* __AT91SAM9261_AIC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_ebi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_ebi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_ebi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_ebi.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,441 @@
+#ifndef __ASM_ARCH_AT91SAM9261_EBI_H
+#define __ASM_ARCH_AT91SAM9261_EBI_H
+
+#define AT91C_BASE_EBI       0xFFFFE000 /** Base Address */
+
+/* -------------------------------------------------------- */
+/* SMC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define SYS_SMC       	0x0C00 /**< SMC base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define SMC_SETUP0 	(SYS_SMC) 	/**<  Setup Register for CS 0 */
+#define SMC_PULSE0 	(SYS_SMC + 0x0004) 	/**<  Pulse Register for CS 0 */
+#define SMC_CYCLE0 	(SYS_SMC + 0x0008) 	/**<  Cycle Register for CS 0 */
+#define SMC_CTRL0 	(SYS_SMC + 0x000C) 	/**<  Control Register for CS 0 */
+#define SMC_SETUP1 	(SYS_SMC + 0x0010) 	/**<  Setup Register for CS 1 */
+#define SMC_PULSE1 	(SYS_SMC + 0x0014) 	/**<  Pulse Register for CS 1 */
+#define SMC_CYCLE1 	(SYS_SMC + 0x0018) 	/**<  Cycle Register for CS 1 */
+#define SMC_CTRL1 	(SYS_SMC + 0x001C) 	/**<  Control Register for CS 1 */
+#define SMC_SETUP2 	(SYS_SMC + 0x0020) 	/**<  Setup Register for CS 2 */
+#define SMC_PULSE2 	(SYS_SMC + 0x0024) 	/**<  Pulse Register for CS 2 */
+#define SMC_CYCLE2 	(SYS_SMC + 0x0028) 	/**<  Cycle Register for CS 2 */
+#define SMC_CTRL2 	(SYS_SMC + 0x002C) 	/**<  Control Register for CS 2 */
+#define SMC_SETUP3 	(SYS_SMC + 0x0030) 	/**<  Setup Register for CS 3 */
+#define SMC_PULSE3 	(SYS_SMC + 0x0034) 	/**<  Pulse Register for CS 3 */
+#define SMC_CYCLE3 	(SYS_SMC + 0x0038) 	/**<  Cycle Register for CS 3 */
+#define SMC_CTRL3 	(SYS_SMC + 0x003C) 	/**<  Control Register for CS 3 */
+#define SMC_SETUP4 	(SYS_SMC + 0x0040) 	/**<  Setup Register for CS 4 */
+#define SMC_PULSE4 	(SYS_SMC + 0x0044) 	/**<  Pulse Register for CS 4 */
+#define SMC_CYCLE4 	(SYS_SMC + 0x0048) 	/**<  Cycle Register for CS 4 */
+#define SMC_CTRL4 	(SYS_SMC + 0x004C) 	/**<  Control Register for CS 4 */
+#define SMC_SETUP5 	(SYS_SMC + 0x0050) 	/**<  Setup Register for CS 5 */
+#define SMC_PULSE5 	(SYS_SMC + 0x0054) 	/**<  Pulse Register for CS 5 */
+#define SMC_CYCLE5 	(SYS_SMC + 0x0058) 	/**<  Cycle Register for CS 5 */
+#define SMC_CTRL5 	(SYS_SMC + 0x005C) 	/**<  Control Register for CS 5 */
+#define SMC_SETUP6 	(SYS_SMC + 0x0060) 	/**<  Setup Register for CS 6 */
+#define SMC_PULSE6 	(SYS_SMC + 0x0064) 	/**<  Pulse Register for CS 6 */
+#define SMC_CYCLE6 	(SYS_SMC + 0x0068) 	/**<  Cycle Register for CS 6 */
+#define SMC_CTRL6 	(SYS_SMC + 0x006C) 	/**<  Control Register for CS 6 */
+#define SMC_SETUP7 	(SYS_SMC + 0x0070) 	/**<  Setup Register for CS 7 */
+#define SMC_PULSE7 	(SYS_SMC + 0x0074) 	/**<  Pulse Register for CS 7 */
+#define SMC_CYCLE7 	(SYS_SMC + 0x0078) 	/**<  Cycle Register for CS 7 */
+#define SMC_CTRL7 	(SYS_SMC + 0x007C) 	/**<  Control Register for CS 7 */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SMC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+
+
+/* -------------------------------------------------------- */
+/* MATRIX Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define SYS_MATRIX    	0x0E00 /**< MATRIX base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+#define MATRIX_MCFG 	(SYS_MATRIX) 	/**<  Master Configuration Register */
+#define MATRIX_SCFG0 	(SYS_MATRIX + 0x0004) 	/**<  Slave Configuration Register 0 */
+#define MATRIX_SCFG1 	(SYS_MATRIX + 0x0008) 	/**<  Slave Configuration Register 1 */
+#define MATRIX_SCFG2 	(SYS_MATRIX + 0x000C) 	/**<  Slave Configuration Register 2 */
+#define MATRIX_SCFG3 	(SYS_MATRIX + 0x0010) 	/**<  Slave Configuration Register 3 */
+#define MATRIX_SCFG4 	(SYS_MATRIX + 0x0014) 	/**<  Slave Configuration Register 4 */
+#define MATRIX_TCMR 	(SYS_MATRIX + 0x0024) 	/**<  Slave 0 Special Function Register */
+#define MATRIX_EBICSA 	(SYS_MATRIX + 0x0030) 	/**<  Slave 3 Special Function Register */
+#define MATRIX_USBPCR 	(SYS_MATRIX + 0x0034) 	/**<  Slave 4 Special Function Register */
+#define MATRIX_VERSION 	(SYS_MATRIX + 0x0044) 	/**<  Version Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register MATRIX_MCFG */
+#define MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_SCFG0 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR0 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR0_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG1 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR1 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR1_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG2 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR2 (0x1 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR2_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR2_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+/* --- Register MATRIX_SCFG3 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR3 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR3_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG4 */
+#define MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define MATRIX_FIXED_DEFMSTR4 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	MATRIX_FIXED_DEFMSTR4_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR4_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	MATRIX_FIXED_DEFMSTR4_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+/* --- Register MATRIX_TCMR */
+#define MATRIX_ITCM_SIZE (0xF << 0 ) /**< (MATRIX) Size of ITCM enabled memory block */
+#define 	MATRIX_ITCM_SIZE_0KB                  0x0 /**< (MATRIX) 0 KB (No ITCM Memory) */
+#define 	MATRIX_ITCM_SIZE_16KB                 0x5 /**< (MATRIX) 16 KB */
+#define 	MATRIX_ITCM_SIZE_32KB                 0x6 /**< (MATRIX) 32 KB */
+#define 	MATRIX_ITCM_SIZE_64KB                 0x7 /**< (MATRIX) 64 KB */
+#define MATRIX_DTCM_SIZE (0xF << 4 ) /**< (MATRIX) Size of DTCM enabled memory block */
+#define 	MATRIX_DTCM_SIZE_0KB                  (0x0 <<  4) /**< (MATRIX) 0 KB (No DTCM Memory) */
+#define 	MATRIX_DTCM_SIZE_16KB                 (0x5 <<  4) /**< (MATRIX) 16 KB */
+#define 	MATRIX_DTCM_SIZE_32KB                 (0x6 <<  4) /**< (MATRIX) 32 KB */
+#define 	MATRIX_DTCM_SIZE_64KB                 (0x7 <<  4) /**< (MATRIX) 64 KB */
+/* --- Register MATRIX_EBICSA */
+#define MATRIX_CS1A     (0x1 << 1 ) /**< (MATRIX) Chip Select 1 Assignment */
+#define 	MATRIX_CS1A_SMC                  (0x0 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the Static Memory Controller. */
+#define 	MATRIX_CS1A_SDRAMC               (0x1 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the SDRAM Controller. */
+#define MATRIX_CS3A     (0x1 << 3 ) /**< (MATRIX) Chip Select 3 Assignment */
+#define 	MATRIX_CS3A_SMC                  (0x0 <<  3) /**< (MATRIX) Chip Select 3 is only assigned to the Static Memory Controller and NCS3 behaves as defined by the SMC. */
+#define 	MATRIX_CS3A_SM                   (0x1 <<  3) /**< (MATRIX) Chip Select 3 is assigned to the Static Memory Controller and the SmartMedia Logic is activated. */
+#define MATRIX_CS4A     (0x1 << 4 ) /**< (MATRIX) Chip Select 4 Assignment */
+#define 	MATRIX_CS4A_SMC                  (0x0 <<  4) /**< (MATRIX) Chip Select 4 is only assigned to the Static Memory Controller and NCS4 behaves as defined by the SMC. */
+#define 	MATRIX_CS4A_CF                   (0x1 <<  4) /**< (MATRIX) Chip Select 4 is assigned to the Static Memory Controller and the CompactFlash Logic (first slot) is activated. */
+#define MATRIX_CS5A     (0x1 << 5 ) /**< (MATRIX) Chip Select 5 Assignment */
+#define 	MATRIX_CS5A_SMC                  (0x0 <<  5) /**< (MATRIX) Chip Select 5 is only assigned to the Static Memory Controller and NCS5 behaves as defined by the SMC */
+#define 	MATRIX_CS5A_CF                   (0x1 <<  5) /**< (MATRIX) Chip Select 5 is assigned to the Static Memory Controller and the CompactFlash Logic (second slot) is activated. */
+#define MATRIX_DBPUC    (0x1 << 8 ) /**< (MATRIX) Data Bus Pull-up Configuration */
+/* --- Register MATRIX_USBPCR */
+#define MATRIX_USBPCR_PUON (0x1 << 30) /**< (MATRIX) PullUp On */
+#define MATRIX_USBPCR_PUIDLE (0x1 << 31) /**< (MATRIX) PullUp Idle */
+
+#endif /* __ASM_ARCH_AT91SAM9261_EBI_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261ek.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261ek.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261ek.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261ek.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/at91sam9261ek.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91SAM9261EK_H
+#define __ASM_ARCH_AT91SAM9261EK_H
+
+
+/* AT91SAM9261 clocks */
+#define AT91C_MAIN_CLOCK	179712000	/* from 18.432 MHz crystal (18432000 / 4 * 39) */
+#define AT91C_MASTER_CLOCK	99300000
+#define AT91C_SLOW_CLOCK	32768		/* slow clock */
+#define AT91_PLLB_VALUE		0x10483F0E	/* (18.432 / 14 * 73) /2 = 47.9714  */
+
+/* FLASH */
+#define AT91_NANDFLASH_BASE	0x40000000	// NCS0: Flash physical base address
+
+/* SDRAM */
+#define AT91_SDRAM_BASE		0x20000000	// NCS1: SDRAM physical base address
+
+/* Internal SRAM base address */
+#define AT91C_IRAM_BASE		0x00300000
+#define AT91C_IRAM_SIZE		0x00028000
+
+#define AT91C_CONSOLE_DEFAULT_BAUDRATE 115200	/* default serial console baud-rate */
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,127 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/at91sam9261.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91SAM9261_H
+#define __ASM_ARCH_AT91SAM9261_H
+
+/** ***************************************************************************** */
+/**               PERIPHERAL ID DEFINITIONS FOR AT91SAM9261                       */
+/** ***************************************************************************** */
+#define AT91_NR_PIO 3 /** AT91SAM9261 includes 3 PIO controllers */
+#define AT91_NR_US  3 /** AT91SAM9261 includes 3 USART controllers */
+#define AT91_NR_SPI 2 /** AT91SAM9261 includes 2 SPI controllers */
+#define AT91_NR_SSC 3 /** AT91SAM9261 includes 3 SSC controllers */
+#define AT91_NR_TC  3 /** AT91SAM9261 includes 3 TC controllers */
+
+/** ***************************************************************************** */
+/**               PERIPHERAL ID DEFINITIONS FOR AT91SAM9261                       */
+/** ***************************************************************************** */
+#define AT91_ID_FIQ     0 /** Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS     1 /** System Interrupt */
+#define AT91_ID_PIOA    2 /** Parallel IO Controller A */
+#define AT91_ID_PIOB    3 /** Parallel IO Controller B */
+#define AT91_ID_PIOC    4 /** Parallel IO Controller C */
+#define AT91_ID_US0     6 /** USART 0 */
+#define AT91_ID_US1     7 /** USART 1 */
+#define AT91_ID_US2     8 /** USART 2 */
+#define AT91_ID_MCI     9 /** Multimedia Card Interface */
+#define AT91_ID_UDP    10 /** USB Device Port */
+#define AT91_ID_TWI    11 /** Two-Wire Interface */
+#define AT91_ID_SPI0   12 /** Serial Peripheral Interface 0 */
+#define AT91_ID_SPI1   13 /** Serial Peripheral Interface 1 */
+#define AT91_ID_SSC0   14 /** Serial Synchronous Controller 0 */
+#define AT91_ID_SSC1   15 /** Serial Synchronous Controller 1 */
+#define AT91_ID_SSC2   16 /** Serial Synchronous Controller 2 */
+#define AT91_ID_TC0    17 /** Timer Counter 0 */
+#define AT91_ID_TC1    18 /** Timer Counter 1 */
+#define AT91_ID_TC2    19 /** Timer Counter 2 */
+#define AT91_ID_UHP    20 /** USB Host Port */
+#define AT91_ID_LCDC   21 /** LCD Controller */
+#define AT91_ID_IRQ0   29 /** Advanced Interrupt Controller (IRQ0) */
+#define AT91_ID_IRQ1   30 /** Advanced Interrupt Controller (IRQ1) */
+#define AT91_ID_IRQ2   31 /** Advanced Interrupt Controller (IRQ2) */
+#define AT91_ALL_INT   0xE03FFFDF /** ALL VALID INTERRUPTS */
+
+/** ***************************************************************************** */
+/**         INTERNAL PERIPHERAL BASE ADDRESS DEFINITIONS FOR AT91SAM9261          */
+/** ***************************************************************************** */
+#define AT91_BASE_SYS       0xFFFFE000 /** (SYS) Base Address */
+#define AT91_BASE_SDRAMC    0xFFFFEA00 /** (SDRAMC) Base Address */
+#define AT91_BASE_SMC       0xFFFFEC00 /** (SMC) Base Address */
+#define AT91_BASE_MATRIX    0xFFFFEE00 /** (MATRIX) Base Address */
+#define AT91_BASE_AIC       0xFFFFF000 /** (AIC) Base Address */
+#define AT91_BASE_PDC_DBGU  0xFFFFF300 /** (PDC_DBGU) Base Address */
+#define AT91_BASE_DBGU      0xFFFFF200 /** (DBGU) Base Address */
+#define AT91_BASE_PIOA      0xFFFFF400 /** (PIOA) Base Address */
+#define AT91_BASE_PIOB      0xFFFFF600 /** (PIOB) Base Address */
+#define AT91_BASE_PIOC      0xFFFFF800 /** (PIOC) Base Address */
+#define AT91_BASE_CKGR      0xFFFFFC20 /** (CKGR) Base Address */
+#define AT91_BASE_PMC       0xFFFFFC00 /** (PMC) Base Address */
+#define AT91_BASE_RSTC      0xFFFFFD00 /** (RSTC) Base Address */
+#define AT91_BASE_SHDWC     0xFFFFFD10 /** (SHDWC) Base Address */
+#define AT91_BASE_RTTC      0xFFFFFD20 /** (RTTC) Base Address */
+#define AT91_BASE_PITC      0xFFFFFD30 /** (PITC) Base Address */
+#define AT91_BASE_WDTC      0xFFFFFD40 /** (WDTC) Base Address */
+#define AT91_BASE_TC0       0xFFFA0000 /** (TC0) Base Address */
+#define AT91_BASE_TC1       0xFFFA0040 /** (TC1) Base Address */
+#define AT91_BASE_TC2       0xFFFA0080 /** (TC2) Base Address */
+#define AT91_BASE_TCB0      0xFFFA0000 /** (TCB0) Base Address */
+#define AT91_BASE_UDP       0xFFFA4000 /** (UDP) Base Address */
+#define AT91_BASE_PDC_MCI   0xFFFA8100 /** (PDC_MCI) Base Address */
+#define AT91_BASE_MCI       0xFFFA8000 /** (MCI) Base Address */
+#define AT91_BASE_TWI       0xFFFAC000 /** (TWI) Base Address */
+#define AT91_BASE_PDC_US0   0xFFFB0100 /** (PDC_US0) Base Address */
+#define AT91_BASE_US0       0xFFFB0000 /** (US0) Base Address */
+#define AT91_BASE_PDC_US1   0xFFFB4100 /** (PDC_US1) Base Address */
+#define AT91_BASE_US1       0xFFFB4000 /** (US1) Base Address */
+#define AT91_BASE_PDC_US2   0xFFFB8100 /** (PDC_US2) Base Address */
+#define AT91_BASE_US2       0xFFFB8000 /** (US2) Base Address */
+#define AT91_BASE_PDC_SSC0  0xFFFBC100 /** (PDC_SSC0) Base Address */
+#define AT91_BASE_SSC0      0xFFFBC000 /** (SSC0) Base Address */
+#define AT91_BASE_PDC_SSC1  0xFFFC0100 /** (PDC_SSC1) Base Address */
+#define AT91_BASE_SSC1      0xFFFC0000 /** (SSC1) Base Address */
+#define AT91_BASE_PDC_SSC2  0xFFFC4100 /** (PDC_SSC2) Base Address */
+#define AT91_BASE_SSC2      0xFFFC4000 /** (SSC2) Base Address */
+#define AT91_BASE_PDC_SPI0  0xFFFC8100 /** (PDC_SPI0) Base Address */
+#define AT91_BASE_SPI0      0xFFFC8000 /** (SPI0) Base Address */
+#define AT91_BASE_PDC_SPI1  0xFFFCC100 /** (PDC_SPI1) Base Address */
+#define AT91_BASE_SPI1      0xFFFCC000 /** (SPI1) Base Address */
+#define AT91_BASE_UHP       0x00500000 /** (UHP) Base Address */
+#define AT91_BASE_LCDC      0x00600000 /** (LCDC) Base Address */
+#define AT91_BASE_LCDC_16B_TFT 0x00600000 /** (LCDC_16B_TFT) Base Address */
+
+/** ***************************************************************************** */
+/**           INTERNAL MEMORIES BASE ADDRESS DEFINITIONS FOR AT91SAM9261          */
+/** ***************************************************************************** */
+#define AT91_BASE_ITCM       0x00100000 /** Maximum ITCM Area base address */
+#define AT91_SIZE_ITCM       0x00010000 /** Maximum ITCM Area size in byte (64 Kbytes)*/
+#define AT91_BASE_DTCM       0x00200000 /** Maximum DTCM Area base address*/
+#define AT91_SIZE_DTCM       0x00010000 /** Maximum DTCM Area size in byte (64 Kbytes) */
+#define AT91_BASE_SRAM       0x00300000 /** Maximum Internal SRAM base address */
+#define AT91_SIZE_SRAM       0x00028000 /** Maximum Internal SRAM size in byte (160 Kbytes) */
+#define AT91_BASE_IROM       0x00400000 /** Internal ROM base address */
+#define AT91_SIZE_IROM       0x00008000 /** Internal ROM size in byte (32 Kbytes) */
+
+/** ***************************************************************************** */
+/**           EXTERNAL MEMORIES BASE ADDRESS DEFINITIONS FOR AT91SAM9261          */
+/** ***************************************************************************** */
+#define AT91_EBI_CS0    0x10000000 /** EBI Chip Select 0 base address */
+#define AT91_EBI_CS1    0x20000000 /** EBI Chip Select 1 base address */
+#define AT91_EBI_CS2    0x30000000 /** EBI Chip Select 2 base address */
+#define AT91_EBI_CS3    0x40000000 /** EBI Chip Select 3 base address */
+#define AT91_EBI_CS4    0x50000000 /** EBI Chip Select 4 base address */
+#define AT91_EBI_CS5    0x60000000 /** EBI Chip Select 5 base address */
+#define AT91_EBI_CS6    0x70000000 /** EBI Chip Select 6 base address */
+#define AT91_EBI_CS7    0x80000000 /** EBI Chip Select 7 base address */
+
+#endif  /* __ASM_ARCH_AT91SAM9261_H */
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_lcdc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_lcdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_lcdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_lcdc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,270 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_lcdc.h
+ * 
+ * Hardware definition for the lcdc peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from LCDC_6063A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9261_LCDC_H
+#define __AT91SAM9261_LCDC_H
+
+/* -------------------------------------------------------- */
+/* LCDC ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_LCDC
+#define AT91C_ID_LCDC  	21 /**< LCD Controller id */
+#endif /* AT91C_ID_LCDC */
+
+/* -------------------------------------------------------- */
+/* LCDC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_LCDC      	0x00600000 /**< LCDC base address */
+#define AT91C_BASE_LCDC_16B_TFT 	0x00600000 /**< LCDC_16B_TFT base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for LCDC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PB4_LCDCC    	(1 << 4) /**< LCD Contrast Control */
+#define AT91C_PB5_LCDD0    	(1 << 5) /**< LCD Data Bus Bit 0 */
+#define AT91C_PB6_LCDD1    	(1 << 6) /**< LCD Data Bus Bit 1 */
+#define AT91C_PB15_LCDD10   	(1 << 15) /**< LCD Data Bus Bit 10 */
+#define AT91C_PB16_LCDD11   	(1 << 16) /**< LCD Data Bus Bit 11 */
+#define AT91C_PB17_LCDD12   	(1 << 17) /**< LCD Data Bus Bit 12 */
+#define AT91C_PB18_LCDD13   	(1 << 18) /**< LCD Data Bus Bit 13 */
+#define AT91C_PB19_LCDD14   	(1 << 19) /**< LCD Data Bus Bit 14 */
+#define AT91C_PB20_LCDD15   	(1 << 20) /**< LCD Data Bus Bit 15 */
+#define AT91C_PB21_LCDD16   	(1 << 21) /**< LCD Data Bus Bit 16 */
+#define AT91C_PB22_LCDD17   	(1 << 22) /**< LCD Data Bus Bit 17 */
+#define AT91C_PB23_LCDD18   	(1 << 23) /**< LCD Data Bus Bit 18 */
+#define AT91C_PB24_LCDD19   	(1 << 24) /**< LCD Data Bus Bit 19 */
+#define AT91C_PB7_LCDD2    	(1 << 7) /**< LCD Data Bus Bit 2 */
+#define AT91C_PB25_LCDD20   	(1 << 25) /**< LCD Data Bus Bit 20 */
+#define AT91C_PB26_LCDD21   	(1 << 26) /**< LCD Data Bus Bit 21 */
+#define AT91C_PB27_LCDD22   	(1 << 27) /**< LCD Data Bus Bit 22 */
+#define AT91C_PB28_LCDD23   	(1 << 28) /**< LCD Data Bus Bit 23 */
+#define AT91C_PB8_LCDD3    	(1 << 8) /**< LCD Data Bus Bit 3 */
+#define AT91C_PB9_LCDD4    	(1 << 9) /**< LCD Data Bus Bit 4 */
+#define AT91C_PB10_LCDD5    	(1 << 10) /**< LCD Data Bus Bit 5 */
+#define AT91C_PB11_LCDD6    	(1 << 11) /**< LCD Data Bus Bit 6 */
+#define AT91C_PB12_LCDD7    	(1 << 12) /**< LCD Data Bus Bit 7 */
+#define AT91C_PB13_LCDD8    	(1 << 13) /**< LCD Data Bus Bit 8 */
+#define AT91C_PB14_LCDD9    	(1 << 14) /**< LCD Data Bus Bit 9 */
+#define AT91C_PB3_LCDDEN   	(1 << 3) /**< LCD Data Enable */
+#define AT91C_PB2_LCDDOTCK 	(1 << 2) /**< LCD Dot Clock */
+#define AT91C_PB1_LCDHSYNC 	(1 << 1) /**< LCD Horizontal Synchronization */
+#define AT91C_PB0_LCDVSYNC 	(1 << 0) /**< LCD Vertical Synchronization */
+
+#define AT91C_PB10_LCDD10   	(1 << 10) /**< LCD Data Bus Bit 10 */
+#define AT91C_PB11_LCDD11   	(1 << 11) /**< LCD Data Bus Bit 11 */
+#define AT91C_PB12_LCDD12   	(1 << 12) /**< LCD Data Bus Bit 12 */
+#define AT91C_PB13_LCDD13   	(1 << 13) /**< LCD Data Bus Bit 13 */
+#define AT91C_PB14_LCDD14   	(1 << 14) /**< LCD Data Bus Bit 14 */
+#define AT91C_PB15_LCDD15   	(1 << 15) /**< LCD Data Bus Bit 15 */
+#define AT91C_PB16_LCDD19   	(1 << 16) /**< LCD Data Bus Bit 19 */
+#define AT91C_PB17_LCDD20   	(1 << 17) /**< LCD Data Bus Bit 20 */
+#define AT91C_PB18_LCDD21   	(1 << 18) /**< LCD Data Bus Bit 21 */
+#define AT91C_PB19_LCDD22   	(1 << 19) /**< LCD Data Bus Bit 22 */
+#define AT91C_PB20_LCDD23   	(1 << 20) /**< LCD Data Bus Bit 23 */
+#define AT91C_PB5_LCDD3    	(1 << 5) /**< LCD Data Bus Bit 3 */
+#define AT91C_PB6_LCDD4    	(1 << 6) /**< LCD Data Bus Bit 4 */
+#define AT91C_PB7_LCDD5    	(1 << 7) /**< LCD Data Bus Bit 5 */
+#define AT91C_PB8_LCDD6    	(1 << 8) /**< LCD Data Bus Bit 6 */
+#define AT91C_PB9_LCDD7    	(1 << 9) /**< LCD Data Bus Bit 7 */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for LCDC hardware peripheral */
+/* -------------------------------------------------------- */
+#define LCDC_BA1 	(0x0000) 	/**< DMA Base Address Register 1 */
+#define LCDC_BA2 	(0x0004) 	/**< DMA Base Address Register 2 */
+#define LCDC_FRMP1 	(0x0008) 	/**< DMA Frame Pointer Register 1 */
+#define LCDC_FRMP2 	(0x000C) 	/**< DMA Frame Pointer Register 2 */
+#define LCDC_FRMA1 	(0x0010) 	/**< DMA Frame Address Register 1 */
+#define LCDC_FRMA2 	(0x0014) 	/**< DMA Frame Address Register 2 */
+#define LCDC_FRMCFG 	(0x0018) 	/**< DMA Frame Configuration Register */
+#define LCDC_DMACON 	(0x001C) 	/**< DMA Control Register */
+#define LCDC_DMA2DCFG 	(0x0020) 	/**< DMA 2D addressing configuration */
+#define LCDC_LCDCON1 	(0x0800) 	/**< LCD Control 1 Register */
+#define LCDC_LCDCON2 	(0x0804) 	/**< LCD Control 2 Register */
+#define LCDC_TIM1 	(0x0808) 	/**< LCD Timing Config 1 Register */
+#define LCDC_TIM2 	(0x080C) 	/**< LCD Timing Config 2 Register */
+#define LCDC_LCDFRCFG 	(0x0810) 	/**< LCD Frame Config Register */
+#define LCDC_FIFO 	(0x0814) 	/**< LCD FIFO Register */
+#define LCDC_MVAL 	(0x0818) 	/**< LCD Mode Toggle Rate Value Register */
+#define LCDC_DP1_2 	(0x081C) 	/**< Dithering Pattern DP1_2 Register */
+#define LCDC_DP4_7 	(0x0820) 	/**< Dithering Pattern DP4_7 Register */
+#define LCDC_DP3_5 	(0x0824) 	/**< Dithering Pattern DP3_5 Register */
+#define LCDC_DP2_3 	(0x0828) 	/**< Dithering Pattern DP2_3 Register */
+#define LCDC_DP5_7 	(0x082C) 	/**< Dithering Pattern DP5_7 Register */
+#define LCDC_DP3_4 	(0x0830) 	/**< Dithering Pattern DP3_4 Register */
+#define LCDC_DP4_5 	(0x0834) 	/**< Dithering Pattern DP4_5 Register */
+#define LCDC_DP6_7 	(0x0838) 	/**< Dithering Pattern DP6_7 Register */
+#define LCDC_PWRCON 	(0x083C) 	/**< Power Control Register */
+#define LCDC_CTRSTCON 	(0x0840) 	/**< Contrast Control Register */
+#define LCDC_CTRSTVAL 	(0x0844) 	/**< Contrast Value Register */
+#define LCDC_IER 	(0x0848) 	/**< Interrupt Enable Register */
+#define LCDC_IDR 	(0x084C) 	/**< Interrupt Disable Register */
+#define LCDC_IMR 	(0x0850) 	/**< Interrupt Mask Register */
+#define LCDC_ISR 	(0x0854) 	/**< Interrupt Enable Register */
+#define LCDC_ICR 	(0x0858) 	/**< Interrupt Clear Register */
+#define LCDC_GPR 	(0x085C) 	/**< General Purpose Register */
+#define LCDC_ITR 	(0x0860) 	/**< Interrupts Test Register */
+#define LCDC_IRR 	(0x0864) 	/**< Interrupts Raw Status Register */
+#define LCDC_LUT_ENTRY 	(0x0C00) 	/**< LUT Entries Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for LCDC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register LCDC_FRMP1 */
+#define AT91C_LCDC_FRMPT1     (0x3FFFFF << 0 ) /**< (LCDC) Frame Pointer Address 1 */
+/* --- Register LCDC_FRMP2 */
+#define AT91C_LCDC_FRMPT2     (0x1FFFFF << 0 ) /**< (LCDC) Frame Pointer Address 2 */
+/* --- Register LCDC_FRMCFG */
+#define AT91C_LCDC_FRSIZE     (0x3FFFFF << 0 ) /**< (LCDC) FRAME SIZE */
+#define AT91C_LCDC_BLENGTH    (0xF << 24) /**< (LCDC) BURST LENGTH */
+/* --- Register LCDC_DMACON */
+#define AT91C_LCDC_DMAEN      (0x1 << 0 ) /**< (LCDC) DAM Enable */
+#define AT91C_LCDC_DMARST     (0x1 << 1 ) /**< (LCDC) DMA Reset (WO) */
+#define AT91C_LCDC_DMABUSY    (0x1 << 2 ) /**< (LCDC) DMA Reset (WO) */
+#define AT91C_LCDC_DMAUPDT    (0x1 << 3 ) 
+#define AT91C_LCDC_DMA2DEN    (0x1 << 4 ) 
+/* --- Register LCDC_DMA2DCFG */
+#define AT91C_LCDC_ADDRINC    (0xFFFF << 0 ) /**< (LCDC) Number of 32b words that the DMA must jump when going to the next line */
+#define AT91C_LCDC_PIXELOFF   (0x1F << 24) /**< (LCDC) Offset (in bits) of the first pixel of the screen in the memory word which contain it */
+/* --- Register LCDC_LCDCON1 */
+#define AT91C_LCDC_BYPASS     (0x1 << 0 ) /**< (LCDC) Bypass lcd_pccklk divider */
+#define AT91C_LCDC_CLKVAL     (0x1FF << 12) /**< (LCDC) 9-bit Divider for pixel clock frequency */
+#define AT91C_LCDC_LINCNT     (0x7FF << 21) /**< (LCDC) Line Counter (RO) */
+/* --- Register LCDC_LCDCON2 */
+#define AT91C_LCDC_DISTYPE    (0x3 << 0 ) /**< (LCDC) Display Type */
+#define 	AT91C_LCDC_DISTYPE_STNMONO              0x0 /**< (LCDC) STN Mono */
+#define 	AT91C_LCDC_DISTYPE_STNCOLOR             0x1 /**< (LCDC) STN Color */
+#define 	AT91C_LCDC_DISTYPE_TFT                  0x2 /**< (LCDC) TFT */
+#define AT91C_LCDC_SCANMOD    (0x1 << 2 ) /**< (LCDC) Scan Mode */
+#define 	AT91C_LCDC_SCANMOD_SINGLESCAN           (0x0 <<  2) /**< (LCDC) Single Scan */
+#define 	AT91C_LCDC_SCANMOD_DUALSCAN             (0x1 <<  2) /**< (LCDC) Dual Scan */
+#define AT91C_LCDC_IFWIDTH    (0x3 << 3 ) /**< (LCDC) Interface Width */
+#define 	AT91C_LCDC_IFWIDTH_FOURBITSWIDTH        (0x0 <<  3) /**< (LCDC) 4 Bits */
+#define 	AT91C_LCDC_IFWIDTH_EIGTHBITSWIDTH       (0x1 <<  3) /**< (LCDC) 8 Bits */
+#define 	AT91C_LCDC_IFWIDTH_SIXTEENBITSWIDTH     (0x2 <<  3) /**< (LCDC) 16 Bits */
+#define AT91C_LCDC_PIXELSIZE  (0x7 << 5 ) /**< (LCDC) Bits per pixel */
+#define 	AT91C_LCDC_PIXELSIZE_ONEBITSPERPIXEL      (0x0 <<  5) /**< (LCDC) 1 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_TWOBITSPERPIXEL      (0x1 <<  5) /**< (LCDC) 2 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_FOURBITSPERPIXEL     (0x2 <<  5) /**< (LCDC) 4 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_EIGTHBITSPERPIXEL    (0x3 <<  5) /**< (LCDC) 8 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_SIXTEENBITSPERPIXEL  (0x4 <<  5) /**< (LCDC) 16 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_TWENTYFOURBITSPERPIXEL (0x5 <<  5) /**< (LCDC) 24 Bits */
+#define AT91C_LCDC_INVVD      (0x1 << 8 ) /**< (LCDC) lcd datas polarity */
+#define 	AT91C_LCDC_INVVD_NORMALPOL            (0x0 <<  8) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVVD_INVERTEDPOL          (0x1 <<  8) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVFRAME   (0x1 << 9 ) /**< (LCDC) lcd vsync polarity */
+#define 	AT91C_LCDC_INVFRAME_NORMALPOL            (0x0 <<  9) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVFRAME_INVERTEDPOL          (0x1 <<  9) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVLINE    (0x1 << 10) /**< (LCDC) lcd hsync polarity */
+#define 	AT91C_LCDC_INVLINE_NORMALPOL            (0x0 << 10) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVLINE_INVERTEDPOL          (0x1 << 10) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVCLK     (0x1 << 11) /**< (LCDC) lcd pclk polarity */
+#define 	AT91C_LCDC_INVCLK_NORMALPOL            (0x0 << 11) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVCLK_INVERTEDPOL          (0x1 << 11) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVDVAL    (0x1 << 12) /**< (LCDC) lcd dval polarity */
+#define 	AT91C_LCDC_INVDVAL_NORMALPOL            (0x0 << 12) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVDVAL_INVERTEDPOL          (0x1 << 12) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_CLKMOD     (0x1 << 15) /**< (LCDC) lcd pclk Mode */
+#define 	AT91C_LCDC_CLKMOD_ACTIVEONLYDISP       (0x0 << 15) /**< (LCDC) Active during display period */
+#define 	AT91C_LCDC_CLKMOD_ALWAYSACTIVE         (0x1 << 15) /**< (LCDC) Always Active */
+#define AT91C_LCDC_MEMOR      (0x1 << 31) /**< (LCDC) lcd pclk Mode */
+#define 	AT91C_LCDC_MEMOR_BIGIND               (0x0 << 31) /**< (LCDC) Big Endian */
+#define 	AT91C_LCDC_MEMOR_LITTLEIND            (0x1 << 31) /**< (LCDC) Little Endian */
+/* --- Register LCDC_TIM1 */
+#define AT91C_LCDC_VFP        (0xFF << 0 ) /**< (LCDC) Vertical Front Porch */
+#define AT91C_LCDC_VBP        (0xFF << 8 ) /**< (LCDC) Vertical Back Porch */
+#define AT91C_LCDC_VPW        (0x3F << 16) /**< (LCDC) Vertical Synchronization Pulse Width */
+#define AT91C_LCDC_VHDLY      (0xF << 24) /**< (LCDC) Vertical to Horizontal Delay */
+/* --- Register LCDC_TIM2 */
+#define AT91C_LCDC_HBP        (0xFF << 0 ) /**< (LCDC) Horizontal Back Porch */
+#define AT91C_LCDC_HPW        (0x3F << 8 ) /**< (LCDC) Horizontal Synchronization Pulse Width */
+#define AT91C_LCDC_HFP        (0x3FF << 22) /**< (LCDC) Horizontal Front Porch */
+/* --- Register LCDC_LCDFRCFG */
+#define AT91C_LCDC_LINEVAL    (0x7FF << 0 ) /**< (LCDC) Vertical Size of LCD Module */
+#define AT91C_LCDC_HOZVAL     (0x7FF << 21) /**< (LCDC) Horizontal Size of LCD Module */
+/* --- Register LCDC_FIFO */
+#define AT91C_LCDC_FIFOTH     (0xFFFF << 0 ) /**< (LCDC) FIFO Threshold */
+/* --- Register LCDC_MVAL */
+#define AT91C_LCDC_MVALUE     (0xFF << 0 ) /**< (LCDC) Toggle Rate Value */
+#define AT91C_LCDC_MMODE      (0x1 << 31) /**< (LCDC) Toggle Rate Sel */
+#define 	AT91C_LCDC_MMODE_EACHFRAME            (0x0 << 31) /**< (LCDC) Each Frame */
+#define 	AT91C_LCDC_MMODE_MVALDEFINED          (0x1 << 31) /**< (LCDC) Defined by MVAL */
+/* --- Register LCDC_DP1_2 */
+#define AT91C_LCDC_DP1_2_FIELD (0xFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP4_7 */
+#define AT91C_LCDC_DP4_7_FIELD (0xFFFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP3_5 */
+#define AT91C_LCDC_DP3_5_FIELD (0xFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP2_3 */
+#define AT91C_LCDC_DP2_3_FIELD (0xFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP5_7 */
+#define AT91C_LCDC_DP5_7_FIELD (0xFFFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP3_4 */
+#define AT91C_LCDC_DP3_4_FIELD (0xFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP4_5 */
+#define AT91C_LCDC_DP4_5_FIELD (0xFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP6_7 */
+#define AT91C_LCDC_DP6_7_FIELD (0xFFFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_PWRCON */
+#define AT91C_LCDC_PWR        (0x1 << 0 ) /**< (LCDC) LCD Module Power Control */
+#define AT91C_LCDC_GUARDT     (0x7F << 1 ) /**< (LCDC) Delay in Frame Period */
+#define AT91C_LCDC_BUSY       (0x1 << 31) /**< (LCDC) Read Only : 1 indicates that LCDC is busy */
+#define 	AT91C_LCDC_BUSY_LCDNOTBUSY           (0x0 << 31) /**< (LCDC) LCD is Not Busy */
+#define 	AT91C_LCDC_BUSY_LCDBUSY              (0x1 << 31) /**< (LCDC) LCD is Busy */
+/* --- Register LCDC_CTRSTCON */
+#define AT91C_LCDC_PS         (0x3 << 0 ) /**< (LCDC) LCD Contrast Counter Prescaler */
+#define 	AT91C_LCDC_PS_NOTDIVIDED           0x0 /**< (LCDC) Counter Freq is System Freq. */
+#define 	AT91C_LCDC_PS_DIVIDEDBYTWO         0x1 /**< (LCDC) Counter Freq is System Freq divided by 2. */
+#define 	AT91C_LCDC_PS_DIVIDEDBYFOUR        0x2 /**< (LCDC) Counter Freq is System Freq divided by 4. */
+#define 	AT91C_LCDC_PS_DIVIDEDBYEIGHT       0x3 /**< (LCDC) Counter Freq is System Freq divided by 8. */
+#define AT91C_LCDC_POL        (0x1 << 2 ) /**< (LCDC) Polarity of output Pulse */
+#define 	AT91C_LCDC_POL_NEGATIVEPULSE        (0x0 <<  2) /**< (LCDC) Negative Pulse */
+#define 	AT91C_LCDC_POL_POSITIVEPULSE        (0x1 <<  2) /**< (LCDC) Positive Pulse */
+#define AT91C_LCDC_ENA        (0x1 << 3 ) /**< (LCDC) PWM generator Control */
+#define 	AT91C_LCDC_ENA_PWMGEMDISABLED       (0x0 <<  3) /**< (LCDC) PWM Generator Disabled */
+#define 	AT91C_LCDC_ENA_PWMGEMENABLED        (0x1 <<  3) /**< (LCDC) PWM Generator Disabled */
+/* --- Register LCDC_CTRSTVAL */
+#define AT91C_LCDC_CVAL       (0xFF << 0 ) /**< (LCDC) PWM Compare Value */
+/* --- Register LCDC_IER */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+/* --- Register LCDC_IDR */
+/* --- Register LCDC_IMR */
+/* --- Register LCDC_ISR */
+/* --- Register LCDC_ICR */
+/* --- Register LCDC_GPR */
+#define AT91C_LCDC_GPRBUS     (0xFF << 0 ) /**< (LCDC) 8 bits available */
+/* --- Register LCDC_ITR */
+/* --- Register LCDC_IRR */
+
+#endif /* __AT91SAM9261_LCDC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_matrix.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_matrix.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_matrix.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_matrix.h	2006-08-09 16:40:54.000000000 +0200
@@ -0,0 +1,149 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_matrix.h
+ * 
+ * Hardware definition for the matrix peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  01/16/2006 (17:06:52) AT91 SW Application Group from HMATRIX1_SAM9261 V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9261_MATRIX_H
+#define __AT91SAM9261_MATRIX_H
+
+/* -------------------------------------------------------- */
+/* MATRIX ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* MATRIX Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_MATRIX    	0xFFFFEE00 /**< MATRIX base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+#define MATRIX_MCFG 	(0x0000) 	/**<  Master Configuration Register */
+#define MATRIX_SCFG0 	(0x0004) 	/**<  Slave Configuration Register 0 */
+#define MATRIX_SCFG1 	(0x0008) 	/**<  Slave Configuration Register 1 */
+#define MATRIX_SCFG2 	(0x000C) 	/**<  Slave Configuration Register 2 */
+#define MATRIX_SCFG3 	(0x0010) 	/**<  Slave Configuration Register 3 */
+#define MATRIX_SCFG4 	(0x0014) 	/**<  Slave Configuration Register 4 */
+#define MATRIX_TCMR 	(0x0024) 	/**<  Slave 0 Special Function Register */
+#define MATRIX_EBICSA 	(0x0030) 	/**<  Slave 3 Special Function Register */
+#define MATRIX_USBPCR 	(0x0034) 	/**<  Slave 4 Special Function Register */
+#define MATRIX_VERSION 	(0x0044) 	/**<  Version Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register MATRIX_MCFG */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_SCFG0 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR0 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG1 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR1 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG2 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR2 (0x1 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+/* --- Register MATRIX_SCFG3 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR3 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG4 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR4 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+/* --- Register MATRIX_TCMR */
+#define AT91C_MATRIX_ITCM_SIZE (0xF << 0 ) /**< (MATRIX) Size of ITCM enabled memory block */
+#define 	AT91C_MATRIX_ITCM_SIZE_0KB                  0x0 /**< (MATRIX) 0 KB (No ITCM Memory) */
+#define 	AT91C_MATRIX_ITCM_SIZE_16KB                 0x5 /**< (MATRIX) 16 KB */
+#define 	AT91C_MATRIX_ITCM_SIZE_32KB                 0x6 /**< (MATRIX) 32 KB */
+#define 	AT91C_MATRIX_ITCM_SIZE_64KB                 0x7 /**< (MATRIX) 64 KB */
+#define AT91C_MATRIX_DTCM_SIZE (0xF << 4 ) /**< (MATRIX) Size of DTCM enabled memory block */
+#define 	AT91C_MATRIX_DTCM_SIZE_0KB                  (0x0 <<  4) /**< (MATRIX) 0 KB (No DTCM Memory) */
+#define 	AT91C_MATRIX_DTCM_SIZE_16KB                 (0x5 <<  4) /**< (MATRIX) 16 KB */
+#define 	AT91C_MATRIX_DTCM_SIZE_32KB                 (0x6 <<  4) /**< (MATRIX) 32 KB */
+#define 	AT91C_MATRIX_DTCM_SIZE_64KB                 (0x7 <<  4) /**< (MATRIX) 64 KB */
+/* --- Register MATRIX_EBICSA */
+#define AT91C_MATRIX_CS1A     (0x1 << 1 ) /**< (MATRIX) Chip Select 1 Assignment */
+#define 	AT91C_MATRIX_CS1A_SMC                  (0x0 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the Static Memory Controller. */
+#define 	AT91C_MATRIX_CS1A_SDRAMC               (0x1 <<  1) /**< (MATRIX) Chip Select 1 is assigned to the SDRAM Controller. */
+#define AT91C_MATRIX_CS3A     (0x1 << 3 ) /**< (MATRIX) Chip Select 3 Assignment */
+#define 	AT91C_MATRIX_CS3A_SMC                  (0x0 <<  3) /**< (MATRIX) Chip Select 3 is only assigned to the Static Memory Controller and NCS3 behaves as defined by the SMC. */
+#define 	AT91C_MATRIX_CS3A_SM                   (0x1 <<  3) /**< (MATRIX) Chip Select 3 is assigned to the Static Memory Controller and the SmartMedia Logic is activated. */
+#define AT91C_MATRIX_CS4A     (0x1 << 4 ) /**< (MATRIX) Chip Select 4 Assignment */
+#define 	AT91C_MATRIX_CS4A_SMC                  (0x0 <<  4) /**< (MATRIX) Chip Select 4 is only assigned to the Static Memory Controller and NCS4 behaves as defined by the SMC. */
+#define 	AT91C_MATRIX_CS4A_CF                   (0x1 <<  4) /**< (MATRIX) Chip Select 4 is assigned to the Static Memory Controller and the CompactFlash Logic (first slot) is activated. */
+#define AT91C_MATRIX_CS5A     (0x1 << 5 ) /**< (MATRIX) Chip Select 5 Assignment */
+#define 	AT91C_MATRIX_CS5A_SMC                  (0x0 <<  5) /**< (MATRIX) Chip Select 5 is only assigned to the Static Memory Controller and NCS5 behaves as defined by the SMC */
+#define 	AT91C_MATRIX_CS5A_CF                   (0x1 <<  5) /**< (MATRIX) Chip Select 5 is assigned to the Static Memory Controller and the CompactFlash Logic (second slot) is activated. */
+#define AT91C_MATRIX_DBPUC    (0x1 << 8 ) /**< (MATRIX) Data Bus Pull-up Configuration */
+/* --- Register MATRIX_USBPCR */
+#define AT91C_MATRIX_USBPCR_PUON (0x1 << 30) /**< (MATRIX) PullUp On */
+#define AT91C_MATRIX_USBPCR_PUIDLE (0x1 << 31) /**< (MATRIX) PullUp Idle */
+
+#endif /* __AT91SAM9261_MATRIX_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pdc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pdc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,78 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_pdc.h
+ * 
+ * Hardware definition for the pdc peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from PDC_6074C V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9261_PDC_H
+#define __AT91SAM9261_PDC_H
+
+/* -------------------------------------------------------- */
+/* PDC ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* PDC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PDC_DBGU  	0xFFFFF300 /**< PDC_DBGU base address */
+#define AT91C_BASE_PDC_MCI   	0xFFFA8100 /**< PDC_MCI base address */
+#define AT91C_BASE_PDC_US0   	0xFFFB0100 /**< PDC_US0 base address */
+#define AT91C_BASE_PDC_US1   	0xFFFB4100 /**< PDC_US1 base address */
+#define AT91C_BASE_PDC_US2   	0xFFFB8100 /**< PDC_US2 base address */
+#define AT91C_BASE_PDC_SSC0  	0xFFFBC100 /**< PDC_SSC0 base address */
+#define AT91C_BASE_PDC_SSC1  	0xFFFC0100 /**< PDC_SSC1 base address */
+#define AT91C_BASE_PDC_SSC2  	0xFFFC4100 /**< PDC_SSC2 base address */
+#define AT91C_BASE_PDC_SPI0  	0xFFFC8100 /**< PDC_SPI0 base address */
+#define AT91C_BASE_PDC_SPI1  	0xFFFCC100 /**< PDC_SPI1 base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PDC hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PDC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PDC_RPR 	(0x0000) 	/**< Receive Pointer Register */
+#define PDC_RCR 	(0x0004) 	/**< Receive Counter Register */
+#define PDC_TPR 	(0x0008) 	/**< Transmit Pointer Register */
+#define PDC_TCR 	(0x000C) 	/**< Transmit Counter Register */
+#define PDC_RNPR 	(0x0010) 	/**< Receive Next Pointer Register */
+#define PDC_RNCR 	(0x0014) 	/**< Receive Next Counter Register */
+#define PDC_TNPR 	(0x0018) 	/**< Transmit Next Pointer Register */
+#define PDC_TNCR 	(0x001C) 	/**< Transmit Next Counter Register */
+#define PDC_PTCR 	(0x0020) 	/**< PDC Transfer Control Register */
+#define PDC_PTSR 	(0x0024) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PDC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PDC_PTCR */
+#define AT91C_PDC_RXTEN       (0x1 << 0 ) /**< (PDC) Receiver Transfer Enable */
+#define AT91C_PDC_RXTDIS      (0x1 << 1 ) /**< (PDC) Receiver Transfer Disable */
+#define AT91C_PDC_TXTEN       (0x1 << 8 ) /**< (PDC) Transmitter Transfer Enable */
+#define AT91C_PDC_TXTDIS      (0x1 << 9 ) /**< (PDC) Transmitter Transfer Disable */
+/* --- Register PDC_PTSR */
+
+#endif /* __AT91SAM9261_PDC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pio.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pio.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,74 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_pio.h
+ * 
+ * Hardware definition for the pio peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from PIO_6057A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9261_PIO_H
+#define __AT91SAM9261_PIO_H
+
+/* -------------------------------------------------------- */
+/* PIO ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_PIOA
+#define AT91C_ID_PIOA  	 2 /**< Parallel IO Controller A id */
+#endif /* AT91C_ID_PIOA */
+#ifndef AT91C_ID_PIOB
+#define AT91C_ID_PIOB  	 3 /**< Parallel IO Controller B id */
+#endif /* AT91C_ID_PIOB */
+#ifndef AT91C_ID_PIOC
+#define AT91C_ID_PIOC  	 4 /**< Parallel IO Controller C id */
+#endif /* AT91C_ID_PIOC */
+
+/* -------------------------------------------------------- */
+/* PIO Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PIOA      	0xFFFFF400 /**< PIOA base address */
+#define AT91C_BASE_PIOB      	0xFFFFF600 /**< PIOB base address */
+#define AT91C_BASE_PIOC      	0xFFFFF800 /**< PIOC base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+#define PIO_PER 	(0x0000) 	/**< PIO Enable Register */
+#define PIO_PDR 	(0x0004) 	/**< PIO Disable Register */
+#define PIO_PSR 	(0x0008) 	/**< PIO Status Register */
+#define PIO_OER 	(0x0010) 	/**< Output Enable Register */
+#define PIO_ODR 	(0x0014) 	/**< Output Disable Registerr */
+#define PIO_OSR 	(0x0018) 	/**< Output Status Register */
+#define PIO_IFER 	(0x0020) 	/**< Input Filter Enable Register */
+#define PIO_IFDR 	(0x0024) 	/**< Input Filter Disable Register */
+#define PIO_IFSR 	(0x0028) 	/**< Input Filter Status Register */
+#define PIO_SODR 	(0x0030) 	/**< Set Output Data Register */
+#define PIO_CODR 	(0x0034) 	/**< Clear Output Data Register */
+#define PIO_ODSR 	(0x0038) 	/**< Output Data Status Register */
+#define PIO_PDSR 	(0x003C) 	/**< Pin Data Status Register */
+#define PIO_IER 	(0x0040) 	/**< Interrupt Enable Register */
+#define PIO_IDR 	(0x0044) 	/**< Interrupt Disable Register */
+#define PIO_IMR 	(0x0048) 	/**< Interrupt Mask Register */
+#define PIO_ISR 	(0x004C) 	/**< Interrupt Status Register */
+#define PIO_MDER 	(0x0050) 	/**< Multi-driver Enable Register */
+#define PIO_MDDR 	(0x0054) 	/**< Multi-driver Disable Register */
+#define PIO_MDSR 	(0x0058) 	/**< Multi-driver Status Register */
+#define PIO_PPUDR 	(0x0060) 	/**< Pull-up Disable Register */
+#define PIO_PPUER 	(0x0064) 	/**< Pull-up Enable Register */
+#define PIO_PPUSR 	(0x0068) 	/**< Pull-up Status Register */
+#define PIO_ASR 	(0x0070) 	/**< Select A Register */
+#define PIO_BSR 	(0x0074) 	/**< Select B Register */
+#define PIO_ABSR 	(0x0078) 	/**< AB Select Status Register */
+#define PIO_OWER 	(0x00A0) 	/**< Output Write Enable Register */
+#define PIO_OWDR 	(0x00A4) 	/**< Output Write Disable Register */
+#define PIO_OWSR 	(0x00A8) 	/**< Output Write Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+
+#endif /* __AT91SAM9261_PIO_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pitc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pitc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pitc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pitc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,51 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_pitc.h
+ * 
+ * Hardware definition for the pitc peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from PITC_6079A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9261_PITC_H
+#define __AT91SAM9261_PITC_H
+
+/* -------------------------------------------------------- */
+/* PITC ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SYS
+#define AT91C_ID_SYS   	 1 /**< System Interrupt id */
+#endif /* AT91C_ID_SYS */
+
+/* -------------------------------------------------------- */
+/* PITC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PITC      	0xFFFFFD30 /**< PITC base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PITC_PIMR 	(0x0000) 	/**< Period Interval Mode Register */
+#define PITC_PISR 	(0x0004) 	/**< Period Interval Status Register */
+#define PITC_PIVR 	(0x0008) 	/**< Period Interval Value Register */
+#define PITC_PIIR 	(0x000C) 	/**< Period Interval Image Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PITC_PIMR */
+#define AT91C_PITC_PIV        (0xFFFFF << 0 ) /**< (PITC) Periodic Interval Value */
+#define AT91C_PITC_PITEN      (0x1 << 24) /**< (PITC) Periodic Interval Timer Enabled */
+#define AT91C_PITC_PITIEN     (0x1 << 25) /**< (PITC) Periodic Interval Timer Interrupt Enable */
+/* --- Register PITC_PISR */
+#define AT91C_PITC_PITS       (0x1 << 0 ) /**< (PITC) Periodic Interval Timer Status */
+/* --- Register PITC_PIVR */
+/* --- Register PITC_PIIR */
+#define AT91C_PITC_CPIV       (0xFFFFF << 0 ) /**< (PITC) Current Periodic Interval Value */
+#define AT91C_PITC_PICNT      (0xFFF << 20) /**< (PITC) Periodic Interval Counter */
+
+#endif /* __AT91SAM9261_PITC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pmc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pmc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_pmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_pmc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,143 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_pmc.h
+ * 
+ * Hardware definition for the pmc peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from PMC_SAM9261 V1.4
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9261_PMC_H
+#define __AT91SAM9261_PMC_H
+
+/* -------------------------------------------------------- */
+/* PMC ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SYS
+#define AT91C_ID_SYS   	 1 /**< System Interrupt id */
+#endif /* AT91C_ID_SYS */
+
+/* -------------------------------------------------------- */
+/* PMC Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PMC       	0xFFFFFC00 /**< PMC base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PMC_SCER 	(0x0000) 	/**< System Clock Enable Register */
+#define PMC_SCDR 	(0x0004) 	/**< System Clock Disable Register */
+#define PMC_SCSR 	(0x0008) 	/**< System Clock Status Register */
+#define PMC_PCER 	(0x0010) 	/**< Peripheral Clock Enable Register */
+#define PMC_PCDR 	(0x0014) 	/**< Peripheral Clock Disable Register */
+#define PMC_PCSR 	(0x0018) 	/**< Peripheral Clock Status Register */
+#define PMC_MOR 	(0x0020) 	/**< Main Oscillator Register */
+#define PMC_MCFR 	(0x0024) 	/**< Main Clock  Frequency Register */
+#define PMC_PLLAR 	(0x0028) 	/**< PLL A Register */
+#define PMC_PLLBR 	(0x002C) 	/**< PLL B Register */
+#define PMC_MCKR 	(0x0030) 	/**< Master Clock Register */
+#define PMC_PCKR 	(0x0040) 	/**< Programmable Clock Register */
+#define PMC_IER 	(0x0060) 	/**< Interrupt Enable Register */
+#define PMC_IDR 	(0x0064) 	/**< Interrupt Disable Register */
+#define PMC_SR 	(0x0068) 	/**< Status Register */
+#define PMC_IMR 	(0x006C) 	/**< Interrupt Mask Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PMC_SCER */
+/* --- Register PMC_SCDR */
+/* --- Register PMC_SCSR */
+#define AT91C_PMC_PCK         (0x1 << 0 ) /**< (PMC) Processor Clock */
+#define AT91C_PMC_UHP         (0x1 << 6 ) /**< (PMC) USB Host Port Clock */
+#define AT91C_PMC_UDP         (0x1 << 7 ) /**< (PMC) USB Device Port Clock */
+#define AT91C_PMC_PCK0        (0x1 << 8 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1        (0x1 << 9 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK2        (0x1 << 10) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK3        (0x1 << 11) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_HCK0        (0x1 << 16) /**< (PMC) AHB UHP Clock Output */
+#define AT91C_PMC_HCK1        (0x1 << 17) /**< (PMC) AHB LCDC Clock Output */
+/* --- Register CKGR_MOR */
+#define AT91C_CKGR_MOSCEN     (0x1 << 0 ) /**< (PMC) Main Oscillator Enable */
+#define AT91C_CKGR_OSCBYPASS  (0x1 << 1 ) /**< (PMC) Main Oscillator Bypass */
+#define AT91C_CKGR_OSCOUNT    (0xFF << 8 ) /**< (PMC) Main Oscillator Start-up Time */
+/* --- Register CKGR_MCFR */
+#define AT91C_CKGR_MAINF      (0xFFFF << 0 ) /**< (PMC) Main Clock Frequency */
+#define AT91C_CKGR_MAINRDY    (0x1 << 16) /**< (PMC) Main Clock Ready */
+/* --- Register CKGR_PLLAR */
+#define AT91C_CKGR_DIVA       (0xFF << 0 ) /**< (PMC) Divider A Selected */
+#define 	AT91C_CKGR_DIVA_0                    0x0 /**< (PMC) Divider A output is 0 */
+#define 	AT91C_CKGR_DIVA_BYPASS               0x1 /**< (PMC) Divider A is bypassed */
+#define AT91C_CKGR_PLLACOUNT  (0x3F << 8 ) /**< (PMC) PLL A Counter */
+#define AT91C_CKGR_OUTA       (0x3 << 14) /**< (PMC) PLL A Output Frequency Range */
+#define 	AT91C_CKGR_OUTA_0                    (0x0 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_1                    (0x1 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_2                    (0x2 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_3                    (0x3 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define AT91C_CKGR_MULA       (0x7FF << 16) /**< (PMC) PLL A Multiplier */
+#define AT91C_CKGR_SRCA       (0x1 << 29) /**< (PMC)  */
+/* --- Register CKGR_PLLBR */
+#define AT91C_CKGR_DIVB       (0xFF << 0 ) /**< (PMC) Divider B Selected */
+#define 	AT91C_CKGR_DIVB_0                    0x0 /**< (PMC) Divider B output is 0 */
+#define 	AT91C_CKGR_DIVB_BYPASS               0x1 /**< (PMC) Divider B is bypassed */
+#define AT91C_CKGR_PLLBCOUNT  (0x3F << 8 ) /**< (PMC) PLL B Counter */
+#define AT91C_CKGR_OUTB       (0x3 << 14) /**< (PMC) PLL B Output Frequency Range */
+#define 	AT91C_CKGR_OUTB_0                    (0x0 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_1                    (0x1 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_2                    (0x2 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_3                    (0x3 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define AT91C_CKGR_MULB       (0x7FF << 16) /**< (PMC) PLL B Multiplier */
+#define AT91C_CKGR_USBDIV     (0x3 << 28) /**< (PMC) Divider for USB Clocks */
+#define 	AT91C_CKGR_USBDIV_0                    (0x0 << 28) /**< (PMC) Divider output is PLL clock output */
+#define 	AT91C_CKGR_USBDIV_1                    (0x1 << 28) /**< (PMC) Divider output is PLL clock output divided by 2 */
+#define 	AT91C_CKGR_USBDIV_2                    (0x2 << 28) /**< (PMC) Divider output is PLL clock output divided by 4 */
+/* --- Register PMC_MCKR */
+#define AT91C_PMC_CSS         (0x3 << 0 ) /**< (PMC) Programmable Clock Selection */
+#define 	AT91C_PMC_CSS_SLOW_CLK             0x0 /**< (PMC) Slow Clock is selected */
+#define 	AT91C_PMC_CSS_MAIN_CLK             0x1 /**< (PMC) Main Clock is selected */
+#define 	AT91C_PMC_CSS_PLLA_CLK             0x2 /**< (PMC) Clock from PLL A is selected */
+#define 	AT91C_PMC_CSS_PLLB_CLK             0x3 /**< (PMC) Clock from PLL B is selected */
+#define AT91C_PMC_PRES        (0x7 << 2 ) /**< (PMC) Programmable Clock Prescaler */
+#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) /**< (PMC) Selected clock */
+#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) /**< (PMC) Selected clock divided by 2 */
+#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) /**< (PMC) Selected clock divided by 4 */
+#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) /**< (PMC) Selected clock divided by 8 */
+#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) /**< (PMC) Selected clock divided by 16 */
+#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) /**< (PMC) Selected clock divided by 32 */
+#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) /**< (PMC) Selected clock divided by 64 */
+#define AT91C_PMC_MDIV        (0x3 << 8 ) /**< (PMC) Master Clock Division */
+#define 	AT91C_PMC_MDIV_1                    (0x0 <<  8) /**< (PMC) The master clock and the processor clock are the same */
+#define 	AT91C_PMC_MDIV_2                    (0x1 <<  8) /**< (PMC) The processor clock is twice as fast as the master clock */
+#define 	AT91C_PMC_MDIV_3                    (0x2 <<  8) /**< (PMC) The processor clock is four times faster than the master clock */
+/* --- Register PMC_PCKR */
+#define AT91C_PMC_CSS         (0x3 << 0 ) /**< (PMC) Programmable Clock Selection */
+#define 	AT91C_PMC_CSS_SLOW_CLK             0x0 /**< (PMC) Slow Clock is selected */
+#define 	AT91C_PMC_CSS_MAIN_CLK             0x1 /**< (PMC) Main Clock is selected */
+#define 	AT91C_PMC_CSS_PLLA_CLK             0x2 /**< (PMC) Clock from PLL A is selected */
+#define 	AT91C_PMC_CSS_PLLB_CLK             0x3 /**< (PMC) Clock from PLL B is selected */
+#define AT91C_PMC_PRES        (0x7 << 2 ) /**< (PMC) Programmable Clock Prescaler */
+#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) /**< (PMC) Selected clock */
+#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) /**< (PMC) Selected clock divided by 2 */
+#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) /**< (PMC) Selected clock divided by 4 */
+#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) /**< (PMC) Selected clock divided by 8 */
+#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) /**< (PMC) Selected clock divided by 16 */
+#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) /**< (PMC) Selected clock divided by 32 */
+#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) /**< (PMC) Selected clock divided by 64 */
+/* --- Register PMC_IER */
+/* --- Register PMC_IDR */
+/* --- Register PMC_SR */
+/* --- Register PMC_IMR */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK2RDY     (0x1 << 10) /**< (PMC) PCK2_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK3RDY     (0x1 << 11) /**< (PMC) PCK3_RDY Status/Enable/Disable/Mask */
+
+#endif /* __AT91SAM9261_PMC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_spi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_spi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_spi.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,150 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_spi.h
+ * 
+ * Hardware definition for the spi peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from SPI_6088D V1.3
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9261_SPI_H
+#define __AT91SAM9261_SPI_H
+
+/* -------------------------------------------------------- */
+/* SPI ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SPI0
+#define AT91C_ID_SPI0  	12 /**< Serial Peripheral Interface 0 id */
+#endif /* AT91C_ID_SPI0 */
+#ifndef AT91C_ID_SPI1
+#define AT91C_ID_SPI1  	13 /**< Serial Peripheral Interface 1 id */
+#endif /* AT91C_ID_SPI1 */
+
+/* -------------------------------------------------------- */
+/* SPI Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_SPI0      	0xFFFC8000 /**< SPI0 base address */
+#define AT91C_BASE_SPI1      	0xFFFCC000 /**< SPI1 base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PA0_SPI0_MISO 	(1 << 0) /**< SPI0 Master In Slave */
+#define AT91C_PA1_SPI0_MOSI 	(1 << 1) /**< SPI0 Master Out Slave */
+#define AT91C_PA3_SPI0_NPCS0 	(1 << 3) /**< SPI0 Peripheral Chip Select 0 */
+#define AT91C_PA4_SPI0_NPCS1 	(1 << 4) /**< SPI0 Peripheral Chip Select 1 */
+#define AT91C_PA5_SPI0_NPCS2 	(1 << 5) /**< SPI0 Peripheral Chip Select 2 */
+#define AT91C_PA6_SPI0_NPCS3 	(1 << 6) /**< SPI0 Peripheral Chip Select 3 */
+#define AT91C_PA2_SPI0_SPCK 	(1 << 2) /**< SPI0 Serial Clock */
+
+#define AT91C_PB30_SPI1_MISO 	(1 << 30) /**< SPI1 Master In Slave */
+#define AT91C_PB31_SPI1_MOSI 	(1 << 31) /**< SPI1 Master Out Slave */
+#define AT91C_PB28_SPI1_NPCS0 	(1 << 28) /**< SPI1 Peripheral Chip Select 0 */
+#define AT91C_PA24_SPI1_NPCS1 	(1 << 24) /**< SPI1 Peripheral Chip Select 1 */
+#define AT91C_PC14_SPI1_NPCS2 	(1 << 14) /**< SPI1 Peripheral Chip Select 2 */
+#define AT91C_PC15_SPI1_NPCS3 	(1 << 15) /**< SPI1 Peripheral Chip Select 3 */
+#define AT91C_PB29_SPI1_SPCK 	(1 << 29) /**< SPI1 Serial Clock */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+#define SPI_CR 	(0x0000) 	/**< Control Register */
+#define SPI_MR 	(0x0004) 	/**< Mode Register */
+#define SPI_RDR 	(0x0008) 	/**< Receive Data Register */
+#define SPI_TDR 	(0x000C) 	/**< Transmit Data Register */
+#define SPI_SR 	(0x0010) 	/**< Status Register */
+#define SPI_IER 	(0x0014) 	/**< Interrupt Enable Register */
+#define SPI_IDR 	(0x0018) 	/**< Interrupt Disable Register */
+#define SPI_IMR 	(0x001C) 	/**< Interrupt Mask Register */
+#define SPI_CSR 	(0x0030) 	/**< Chip Select Register */
+#define SPI_RPR 	(0x0100) 	/**< Receive Pointer Register */
+#define SPI_RCR 	(0x0104) 	/**< Receive Counter Register */
+#define SPI_TPR 	(0x0108) 	/**< Transmit Pointer Register */
+#define SPI_TCR 	(0x010C) 	/**< Transmit Counter Register */
+#define SPI_RNPR 	(0x0110) 	/**< Receive Next Pointer Register */
+#define SPI_RNCR 	(0x0114) 	/**< Receive Next Counter Register */
+#define SPI_TNPR 	(0x0118) 	/**< Transmit Next Pointer Register */
+#define SPI_TNCR 	(0x011C) 	/**< Transmit Next Counter Register */
+#define SPI_PTCR 	(0x0120) 	/**< PDC Transfer Control Register */
+#define SPI_PTSR 	(0x0124) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register SPI_CR */
+#define AT91C_SPI_SPIEN       (0x1 << 0 ) /**< (SPI) SPI Enable */
+#define AT91C_SPI_SPIDIS      (0x1 << 1 ) /**< (SPI) SPI Disable */
+#define AT91C_SPI_SWRST       (0x1 << 7 ) /**< (SPI) SPI Software reset */
+#define AT91C_SPI_LASTXFER    (0x1 << 24) /**< (SPI) SPI Last Transfer */
+/* --- Register SPI_MR */
+#define AT91C_SPI_MSTR        (0x1 << 0 ) /**< (SPI) Master/Slave Mode */
+#define AT91C_SPI_PS          (0x1 << 1 ) /**< (SPI) Peripheral Select */
+#define 	AT91C_SPI_PS_FIXED                (0x0 <<  1) /**< (SPI) Fixed Peripheral Select */
+#define 	AT91C_SPI_PS_VARIABLE             (0x1 <<  1) /**< (SPI) Variable Peripheral Select */
+#define AT91C_SPI_PCSDEC      (0x1 << 2 ) /**< (SPI) Chip Select Decode */
+#define AT91C_SPI_FDIV        (0x1 << 3 ) /**< (SPI) Clock Selection */
+#define AT91C_SPI_MODFDIS     (0x1 << 4 ) /**< (SPI) Mode Fault Detection */
+#define AT91C_SPI_LLB         (0x1 << 7 ) /**< (SPI) Clock Selection */
+#define AT91C_SPI_PCS         (0xF << 16) /**< (SPI) Peripheral Chip Select */
+#define AT91C_SPI_DLYBCS      (0xFF << 24) /**< (SPI) Delay Between Chip Selects */
+/* --- Register SPI_RDR */
+#define AT91C_SPI_RD          (0xFFFF << 0 ) /**< (SPI) Receive Data */
+#define AT91C_SPI_RPCS        (0xF << 16) /**< (SPI) Peripheral Chip Select Status */
+/* --- Register SPI_TDR */
+#define AT91C_SPI_TD          (0xFFFF << 0 ) /**< (SPI) Transmit Data */
+#define AT91C_SPI_TPCS        (0xF << 16) /**< (SPI) Peripheral Chip Select Status */
+#define AT91C_SPI_LASTXFER    (0x1 << 24) /**< (SPI) SPI Last Transfer */
+/* --- Register SPI_SR */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+#define AT91C_SPI_SPIENS      (0x1 << 16) /**< (SPI) Enable Status */
+/* --- Register SPI_IER */
+/* --- Register SPI_IDR */
+/* --- Register SPI_IMR */
+/* --- Register SPI_CSR */
+#define AT91C_SPI_CPOL        (0x1 << 0 ) /**< (SPI) Clock Polarity */
+#define AT91C_SPI_NCPHA       (0x1 << 1 ) /**< (SPI) Clock Phase */
+#define AT91C_SPI_CSAAT       (0x1 << 3 ) /**< (SPI) Chip Select Active After Transfer */
+#define AT91C_SPI_BITS        (0xF << 4 ) /**< (SPI) Bits Per Transfer */
+#define 	AT91C_SPI_BITS_8                    (0x0 <<  4) /**< (SPI) 8 Bits Per transfer */
+#define 	AT91C_SPI_BITS_9                    (0x1 <<  4) /**< (SPI) 9 Bits Per transfer */
+#define 	AT91C_SPI_BITS_10                   (0x2 <<  4) /**< (SPI) 10 Bits Per transfer */
+#define 	AT91C_SPI_BITS_11                   (0x3 <<  4) /**< (SPI) 11 Bits Per transfer */
+#define 	AT91C_SPI_BITS_12                   (0x4 <<  4) /**< (SPI) 12 Bits Per transfer */
+#define 	AT91C_SPI_BITS_13                   (0x5 <<  4) /**< (SPI) 13 Bits Per transfer */
+#define 	AT91C_SPI_BITS_14                   (0x6 <<  4) /**< (SPI) 14 Bits Per transfer */
+#define 	AT91C_SPI_BITS_15                   (0x7 <<  4) /**< (SPI) 15 Bits Per transfer */
+#define 	AT91C_SPI_BITS_16                   (0x8 <<  4) /**< (SPI) 16 Bits Per transfer */
+#define AT91C_SPI_SCBR        (0xFF << 8 ) /**< (SPI) Serial Clock Baud Rate */
+#define AT91C_SPI_DLYBS       (0xFF << 16) /**< (SPI) Delay Before SPCK */
+#define AT91C_SPI_DLYBCT      (0xFF << 24) /**< (SPI) Delay Between Consecutive Transfers */
+
+#endif /* __AT91SAM9261_SPI_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_udp.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_udp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_udp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_udp.h	2006-08-09 16:42:15.000000000 +0200
@@ -0,0 +1,171 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_udp.h
+ * 
+ * Hardware definition for the udp peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  01/16/2006 (17:06:52) AT91 SW Application Group from UDP_SAM9261 V1.1
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9261_UDP_H
+#define __AT91SAM9261_UDP_H
+
+/* -------------------------------------------------------- */
+/* UDP ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_UDP
+#define AT91C_ID_UDP   	10 /**< USB Device Port id */
+#endif /* AT91C_ID_UDP */
+
+/* -------------------------------------------------------- */
+/* UDP Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_UDP       	0xFFFA4000 /**< UDP base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for UDP hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for UDP hardware peripheral */
+/* -------------------------------------------------------- */
+#define UDP_NUM 	(0x0000) 	/**< Frame Number Register */
+#define UDP_GLBSTATE 	(0x0004) 	/**< Global State Register */
+#define UDP_FADDR 	(0x0008) 	/**< Function Address Register */
+#define UDP_IER 	(0x0010) 	/**< Interrupt Enable Register */
+#define UDP_IDR 	(0x0014) 	/**< Interrupt Disable Register */
+#define UDP_IMR 	(0x0018) 	/**< Interrupt Mask Register */
+#define UDP_ISR 	(0x001C) 	/**< Interrupt Status Register */
+#define UDP_ICR 	(0x0020) 	/**< Interrupt Clear Register */
+#define UDP_RSTEP 	(0x0028) 	/**< Reset Endpoint Register */
+#define UDP_CSR 	(0x0030) 	/**< Endpoint Control and Status Register */
+#define UDP_FDR 	(0x0050) 	/**< Endpoint FIFO Data Register */
+#define UDP_TXVC 	(0x0074) 	/**< Transceiver Control Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for UDP hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register UDP_FRM_NUM */
+#define AT91C_UDP_FRM_NUM     (0x7FF << 0 ) /**< (UDP) Frame Number as Defined in the Packet Field Formats */
+#define AT91C_UDP_FRM_ERR     (0x1 << 16) /**< (UDP) Frame Error */
+#define AT91C_UDP_FRM_OK      (0x1 << 17) /**< (UDP) Frame OK */
+/* --- Register UDP_GLB_STATE */
+#define AT91C_UDP_FADDEN      (0x1 << 0 ) /**< (UDP) Function Address Enable */
+#define AT91C_UDP_CONFG       (0x1 << 1 ) /**< (UDP) Configured */
+#define AT91C_UDP_ESR         (0x1 << 2 ) /**< (UDP) Enable Send Resume */
+#define AT91C_UDP_RSMINPR     (0x1 << 3 ) /**< (UDP) A Resume Has Been Sent to the Host */
+#define AT91C_UDP_RMWUPE      (0x1 << 4 ) /**< (UDP) Remote Wake Up Enable */
+/* --- Register UDP_FADDR */
+#define AT91C_UDP_FADD        (0xFF << 0 ) /**< (UDP) Function Address Value */
+#define AT91C_UDP_FEN         (0x1 << 8 ) /**< (UDP) Function Enable */
+/* --- Register UDP_IER */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_IDR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_IMR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_ISR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_ENDBUSRES   (0x1 << 12) /**< (UDP) USB End Of Bus Reset Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_ICR */
+#define AT91C_UDP_EPINT0      (0x1 << 0 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT1      (0x1 << 1 ) /**< (UDP) Endpoint 0 Interrupt */
+#define AT91C_UDP_EPINT2      (0x1 << 2 ) /**< (UDP) Endpoint 2 Interrupt */
+#define AT91C_UDP_EPINT3      (0x1 << 3 ) /**< (UDP) Endpoint 3 Interrupt */
+#define AT91C_UDP_EPINT4      (0x1 << 4 ) /**< (UDP) Endpoint 4 Interrupt */
+#define AT91C_UDP_EPINT5      (0x1 << 5 ) /**< (UDP) Endpoint 5 Interrupt */
+#define AT91C_UDP_RXSUSP      (0x1 << 8 ) /**< (UDP) USB Suspend Interrupt */
+#define AT91C_UDP_RXRSM       (0x1 << 9 ) /**< (UDP) USB Resume Interrupt */
+#define AT91C_UDP_EXTRSM      (0x1 << 10) /**< (UDP) USB External Resume Interrupt */
+#define AT91C_UDP_SOFINT      (0x1 << 11) /**< (UDP) USB Start Of frame Interrupt */
+#define AT91C_UDP_WAKEUP      (0x1 << 13) /**< (UDP) USB Resume Interrupt */
+/* --- Register UDP_RST_EP */
+#define AT91C_UDP_EP0         (0x1 << 0 ) /**< (UDP) Reset Endpoint 0 */
+#define AT91C_UDP_EP1         (0x1 << 1 ) /**< (UDP) Reset Endpoint 1 */
+#define AT91C_UDP_EP2         (0x1 << 2 ) /**< (UDP) Reset Endpoint 2 */
+#define AT91C_UDP_EP3         (0x1 << 3 ) /**< (UDP) Reset Endpoint 3 */
+#define AT91C_UDP_EP4         (0x1 << 4 ) /**< (UDP) Reset Endpoint 4 */
+#define AT91C_UDP_EP5         (0x1 << 5 ) /**< (UDP) Reset Endpoint 5 */
+/* --- Register UDP_CSR */
+#define AT91C_UDP_TXCOMP      (0x1 << 0 ) /**< (UDP) Generates an IN packet with data previously written in the DPR */
+#define AT91C_UDP_RX_DATA_BK0 (0x1 << 1 ) /**< (UDP) Receive Data Bank 0 */
+#define AT91C_UDP_RXSETUP     (0x1 << 2 ) /**< (UDP) Sends STALL to the Host (Control endpoints) */
+#define AT91C_UDP_ISOERROR    (0x1 << 3 ) /**< (UDP) Isochronous error (Isochronous endpoints) */
+#define AT91C_UDP_TXPKTRDY    (0x1 << 4 ) /**< (UDP) Transmit Packet Ready */
+#define AT91C_UDP_FORCESTALL  (0x1 << 5 ) /**< (UDP) Force Stall (used by Control, Bulk and Isochronous endpoints). */
+#define AT91C_UDP_RX_DATA_BK1 (0x1 << 6 ) /**< (UDP) Receive Data Bank 1 (only used by endpoints with ping-pong attributes). */
+#define AT91C_UDP_DIR         (0x1 << 7 ) /**< (UDP) Transfer Direction */
+#define AT91C_UDP_EPTYPE      (0x7 << 8 ) /**< (UDP) Endpoint type */
+#define 	AT91C_UDP_EPTYPE_CTRL                 (0x0 <<  8) /**< (UDP) Control */
+#define 	AT91C_UDP_EPTYPE_ISO_OUT              (0x1 <<  8) /**< (UDP) Isochronous OUT */
+#define 	AT91C_UDP_EPTYPE_BULK_OUT             (0x2 <<  8) /**< (UDP) Bulk OUT */
+#define 	AT91C_UDP_EPTYPE_INT_OUT              (0x3 <<  8) /**< (UDP) Interrupt OUT */
+#define 	AT91C_UDP_EPTYPE_ISO_IN               (0x5 <<  8) /**< (UDP) Isochronous IN */
+#define 	AT91C_UDP_EPTYPE_BULK_IN              (0x6 <<  8) /**< (UDP) Bulk IN */
+#define 	AT91C_UDP_EPTYPE_INT_IN               (0x7 <<  8) /**< (UDP) Interrupt IN */
+#define AT91C_UDP_DTGLE       (0x1 << 11) /**< (UDP) Data Toggle */
+#define AT91C_UDP_EPEDS       (0x1 << 15) /**< (UDP) Endpoint Enable Disable */
+#define AT91C_UDP_RXBYTECNT   (0x7FF << 16) /**< (UDP) Number Of Bytes Available in the FIFO */
+/* --- Register UDP_TXVC */
+#define AT91C_UDP_TXVDIS      (0x1 << 8 ) /**< (UDP)  */
+
+#endif /* __AT91SAM9261_UDP_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_uhp.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_uhp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_uhp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_uhp.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,78 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_uhp.h
+ * 
+ * Hardware definition for the uhp peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  12/09/2005 (11:54:25) AT91 SW Application Group from UHP_6127A V1.1
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9261_UHP_H
+#define __AT91SAM9261_UHP_H
+
+/* -------------------------------------------------------- */
+/* UHP ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_UHP
+#define AT91C_ID_UHP   	20 /**< USB Host Port id */
+#endif /* AT91C_ID_UHP */
+
+/* -------------------------------------------------------- */
+/* UHP Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_UHP       	0x00500000 /**< UHP base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+#define UHP_HcRevision 	(0x0000) 	/**< Revision */
+#define UHP_HcControl 	(0x0004) 	/**< Operating modes for the Host Controller */
+#define UHP_HcCommandStatus 	(0x0008) 	/**< Command & status Register */
+#define UHP_HcInterruptStatus 	(0x000C) 	/**< Interrupt Status Register */
+#define UHP_HcInterruptEnable 	(0x0010) 	/**< Interrupt Enable Register */
+#define UHP_HcInterruptDisable 	(0x0014) 	/**< Interrupt Disable Register */
+#define UHP_HcHCCA 	(0x0018) 	/**< Pointer to the Host Controller Communication Area */
+#define UHP_HcPeriodCurrentED 	(0x001C) 	/**< Current Isochronous or Interrupt Endpoint Descriptor */
+#define UHP_HcControlHeadED 	(0x0020) 	/**< First Endpoint Descriptor of the Control list */
+#define UHP_HcControlCurrentED 	(0x0024) 	/**< Endpoint Control and Status Register */
+#define UHP_HcBulkHeadED 	(0x0028) 	/**< First endpoint register of the Bulk list */
+#define UHP_HcBulkCurrentED 	(0x002C) 	/**< Current endpoint of the Bulk list */
+#define UHP_HcBulkDoneHead 	(0x0030) 	/**< Last completed transfer descriptor */
+#define UHP_HcFmInterval 	(0x0034) 	/**< Bit time between 2 consecutive SOFs */
+#define UHP_HcFmRemaining 	(0x0038) 	/**< Bit time remaining in the current Frame */
+#define UHP_HcFmNumber 	(0x003C) 	/**< Frame number */
+#define UHP_HcPeriodicStart 	(0x0040) 	/**< Periodic Start */
+#define UHP_HcLSThreshold 	(0x0044) 	/**< LS Threshold */
+#define UHP_HcRhDescriptorA 	(0x0048) 	/**< Root Hub characteristics A */
+#define UHP_HcRhDescriptorB 	(0x004C) 	/**< Root Hub characteristics B */
+#define UHP_HcRhStatus 	(0x0050) 	/**< Root Hub Status register */
+#define UHP_HcRhPortStatus 	(0x0054) 	/**< Root Hub Port Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+
+#endif /* __AT91SAM9261_UHP_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_usart.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_usart.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/at91sam9261_usart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/at91sam9261_usart.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,164 @@
+/* linux/include/asm-arm/arch-at91sam9261/at91sam9261_usart.h
+ * 
+ * Hardware definition for the usart peripheral in the ATMEL at91sam9261 processor
+ * 
+ * Generated  10/04/2005 (15:38:51) AT91 SW Application Group from  V
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#ifndef __AT91SAM9261_USART_H
+#define __AT91SAM9261_USART_H
+
+/* -------------------------------------------------------- */
+/* USART ID definitions for  AT91SAM9261           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_US0
+#define AT91C_ID_US0   	 6 /**< USART 0 id */
+#endif /* AT91C_ID_US0 */
+#ifndef AT91C_ID_US1
+#define AT91C_ID_US1   	 7 /**< USART 1 id */
+#endif /* AT91C_ID_US1 */
+#ifndef AT91C_ID_US2
+#define AT91C_ID_US2   	 8 /**< USART 2 id */
+#endif /* AT91C_ID_US2 */
+
+/* -------------------------------------------------------- */
+/* USART Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_US0       	0xFFFB0000 /**< US0 base address */
+#define AT91C_BASE_US1       	0xFFFB4000 /**< US1 base address */
+#define AT91C_BASE_US2       	0xFFFB8000 /**< US2 base address */
+/* -------------------------------------------------------- */
+/* DBGU Base Address definitions for  AT91SAM9261   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_DBGU         0xFFFFF200 /**< DBGU base address */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for USART hardware peripheral */
+/* -------------------------------------------------------- */
+#define US_CR 	(0x0000) 	/**< Control Register */
+#define US_MR 	(0x0004) 	/**< Mode Register */
+#define US_IER 	(0x0008) 	/**< Interrupt Enable Register */
+#define US_IDR 	(0x000C) 	/**< Interrupt Disable Register */
+#define US_IMR 	(0x0010) 	/**< Interrupt Mask Register */
+#define US_CSR 	(0x0014) 	/**< Channel Status Register */
+#define US_RHR 	(0x0018) 	/**< Receiver Holding Register */
+#define US_THR 	(0x001C) 	/**< Transmitter Holding Register */
+#define US_BRGR 	(0x0020) 	/**< Baud Rate Generator Register */
+#define US_RTOR 	(0x0024) 	/**< Receiver Time-out Register */
+#define US_TTGR 	(0x0028) 	/**< Transmitter Time-guard Register */
+#define US_FIDI 	(0x0040) 	/**< FI_DI_Ratio Register */
+#define US_NER 	(0x0044) 	/**< Nb Errors Register */
+#define US_IF 	(0x004C) 	/**< IRDA_FILTER Register */
+#define US_RPR 	(0x0100) 	/**< Receive Pointer Register */
+#define US_RCR 	(0x0104) 	/**< Receive Counter Register */
+#define US_TPR 	(0x0108) 	/**< Transmit Pointer Register */
+#define US_TCR 	(0x010C) 	/**< Transmit Counter Register */
+#define US_RNPR 	(0x0110) 	/**< Receive Next Pointer Register */
+#define US_RNCR 	(0x0114) 	/**< Receive Next Counter Register */
+#define US_TNPR 	(0x0118) 	/**< Transmit Next Pointer Register */
+#define US_TNCR 	(0x011C) 	/**< Transmit Next Counter Register */
+#define US_PTCR 	(0x0120) 	/**< PDC Transfer Control Register */
+#define US_PTSR 	(0x0124) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for USART hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register US_CR */
+#define AT91C_US_RSTRX        (0x1 << 2 ) /**< (USART) Reset Receiver */
+#define AT91C_US_RSTTX        (0x1 << 3 ) /**< (USART) Reset Transmitter */
+#define AT91C_US_RXEN         (0x1 << 4 ) /**< (USART) Receiver Enable */
+#define AT91C_US_RXDIS        (0x1 << 5 ) /**< (USART) Receiver Disable */
+#define AT91C_US_TXEN         (0x1 << 6 ) /**< (USART) Transmitter Enable */
+#define AT91C_US_TXDIS        (0x1 << 7 ) /**< (USART) Transmitter Disable */
+#define AT91C_US_RSTSTA       (0x1 << 8 ) /**< (USART) Reset Status Bits */
+#define AT91C_US_STTBRK       (0x1 << 9 ) /**< (USART) Start Break */
+#define AT91C_US_STPBRK       (0x1 << 10) /**< (USART) Stop Break */
+#define AT91C_US_STTTO        (0x1 << 11) /**< (USART) Start Time-out */
+#define AT91C_US_SENDA        (0x1 << 12) /**< (USART) Send Address */
+#define AT91C_US_RSTIT        (0x1 << 13) /**< (USART) Reset Iterations */
+#define AT91C_US_RSTNACK      (0x1 << 14) /**< (USART) Reset Non Acknowledge */
+#define AT91C_US_RETTO        (0x1 << 15) /**< (USART) Rearm Time-out */
+#define AT91C_US_DTREN        (0x1 << 16) /**< (USART) Data Terminal ready Enable */
+#define AT91C_US_DTRDIS       (0x1 << 17) /**< (USART) Data Terminal ready Disable */
+#define AT91C_US_RTSEN        (0x1 << 18) /**< (USART) Request to Send enable */
+#define AT91C_US_RTSDIS       (0x1 << 19) /**< (USART) Request to Send Disable */
+/* --- Register US_MR */
+#define AT91C_US_USMODE       (0xF << 0 ) /**< (USART) Usart mode */
+#define 	AT91C_US_USMODE_NORMAL               0x0 /**< (USART) Normal */
+#define 	AT91C_US_USMODE_RS485                0x1 /**< (USART) RS485 */
+#define 	AT91C_US_USMODE_HWHSH                0x2 /**< (USART) Hardware Handshaking */
+#define 	AT91C_US_USMODE_MODEM                0x3 /**< (USART) Modem */
+#define 	AT91C_US_USMODE_ISO7816_0            0x4 /**< (USART) ISO7816 protocol: T = 0 */
+#define 	AT91C_US_USMODE_ISO7816_1            0x6 /**< (USART) ISO7816 protocol: T = 1 */
+#define 	AT91C_US_USMODE_IRDA                 0x8 /**< (USART) IrDA */
+#define 	AT91C_US_USMODE_SWHSH                0xC /**< (USART) Software Handshaking */
+#define AT91C_US_CLKS         (0x3 << 4 ) /**< (USART) Clock Selection (Baud Rate generator Input Clock */
+#define 	AT91C_US_CLKS_CLOCK                (0x0 <<  4) /**< (USART) Clock */
+#define 	AT91C_US_CLKS_FDIV1                (0x1 <<  4) /**< (USART) fdiv1 */
+#define 	AT91C_US_CLKS_SLOW                 (0x2 <<  4) /**< (USART) slow_clock (ARM) */
+#define 	AT91C_US_CLKS_EXT                  (0x3 <<  4) /**< (USART) External (SCK) */
+#define AT91C_US_CHRL         (0x3 << 6 ) /**< (USART) Clock Selection (Baud Rate generator Input Clock */
+#define 	AT91C_US_CHRL_5_BITS               (0x0 <<  6) /**< (USART) Character Length: 5 bits */
+#define 	AT91C_US_CHRL_6_BITS               (0x1 <<  6) /**< (USART) Character Length: 6 bits */
+#define 	AT91C_US_CHRL_7_BITS               (0x2 <<  6) /**< (USART) Character Length: 7 bits */
+#define 	AT91C_US_CHRL_8_BITS               (0x3 <<  6) /**< (USART) Character Length: 8 bits */
+#define AT91C_US_SYNC         (0x1 << 8 ) /**< (USART) Synchronous Mode Select */
+#define AT91C_US_PAR          (0x7 << 9 ) /**< (USART) Parity type */
+#define 	AT91C_US_PAR_EVEN                 (0x0 <<  9) /**< (USART) Even Parity */
+#define 	AT91C_US_PAR_ODD                  (0x1 <<  9) /**< (USART) Odd Parity */
+#define 	AT91C_US_PAR_SPACE                (0x2 <<  9) /**< (USART) Parity forced to 0 (Space) */
+#define 	AT91C_US_PAR_MARK                 (0x3 <<  9) /**< (USART) Parity forced to 1 (Mark) */
+#define 	AT91C_US_PAR_NONE                 (0x4 <<  9) /**< (USART) No Parity */
+#define 	AT91C_US_PAR_MULTI_DROP           (0x6 <<  9) /**< (USART) Multi-drop mode */
+#define AT91C_US_NBSTOP       (0x3 << 12) /**< (USART) Number of Stop bits */
+#define 	AT91C_US_NBSTOP_1_BIT                (0x0 << 12) /**< (USART) 1 stop bit */
+#define 	AT91C_US_NBSTOP_15_BIT               (0x1 << 12) /**< (USART) Asynchronous (SYNC=0) 2 stop bits Synchronous (SYNC=1) 2 stop bits */
+#define 	AT91C_US_NBSTOP_2_BIT                (0x2 << 12) /**< (USART) 2 stop bits */
+#define AT91C_US_CHMODE       (0x3 << 14) /**< (USART) Channel Mode */
+#define 	AT91C_US_CHMODE_NORMAL               (0x0 << 14) /**< (USART) Normal Mode: The USART channel operates as an RX/TX USART. */
+#define 	AT91C_US_CHMODE_AUTO                 (0x1 << 14) /**< (USART) Automatic Echo: Receiver Data Input is connected to the TXD pin. */
+#define 	AT91C_US_CHMODE_LOCAL                (0x2 << 14) /**< (USART) Local Loopback: Transmitter Output Signal is connected to Receiver Input Signal. */
+#define 	AT91C_US_CHMODE_REMOTE               (0x3 << 14) /**< (USART) Remote Loopback: RXD pin is internally connected to TXD pin. */
+#define AT91C_US_MSBF         (0x1 << 16) /**< (USART) Bit Order */
+#define AT91C_US_MODE9        (0x1 << 17) /**< (USART) 9-bit Character length */
+#define AT91C_US_CKLO         (0x1 << 18) /**< (USART) Clock Output Select */
+#define AT91C_US_OVER         (0x1 << 19) /**< (USART) Over Sampling Mode */
+#define AT91C_US_INACK        (0x1 << 20) /**< (USART) Inhibit Non Acknowledge */
+#define AT91C_US_DSNACK       (0x1 << 21) /**< (USART) Disable Successive NACK */
+#define AT91C_US_MAX_ITER     (0x1 << 24) /**< (USART) Number of Repetitions */
+#define AT91C_US_FILTER       (0x1 << 28) /**< (USART) Receive Line Filter */
+/* --- Register US_IER */
+/* --- Register US_IDR */
+/* --- Register US_IMR */
+/* --- Register US_CSR */
+#define AT91C_US_RXRDY        (0x1 << 0 ) /**< (USART) RXRDY Interrupt */
+#define AT91C_US_TXRDY        (0x1 << 1 ) /**< (USART) TXRDY Interrupt */
+#define AT91C_US_RXBRK        (0x1 << 2 ) /**< (USART) Break Received/End of Break */
+#define AT91C_US_ENDRX        (0x1 << 3 ) /**< (USART) End of Receive Transfer Interrupt */
+#define AT91C_US_ENDTX        (0x1 << 4 ) /**< (USART) End of Transmit Interrupt */
+#define AT91C_US_OVRE         (0x1 << 5 ) /**< (USART) Overrun Interrupt */
+#define AT91C_US_FRAME        (0x1 << 6 ) /**< (USART) Framing Error Interrupt */
+#define AT91C_US_PARE         (0x1 << 7 ) /**< (USART) Parity Error Interrupt */
+#define AT91C_US_TIMEOUT      (0x1 << 8 ) /**< (USART) Receiver Time-out */
+#define AT91C_US_TXEMPTY      (0x1 << 9 ) /**< (USART) TXEMPTY Interrupt */
+#define AT91C_US_ITERATION    (0x1 << 10) /**< (USART) Max number of Repetitions Reached */
+#define AT91C_US_TXBUFE       (0x1 << 11) /**< (USART) TXBUFE Interrupt */
+#define AT91C_US_RXBUFF       (0x1 << 12) /**< (USART) RXBUFF Interrupt */
+#define AT91C_US_NACK         (0x1 << 13) /**< (USART) Non Acknowledge */
+#define AT91C_US_RIIC         (0x1 << 16) /**< (USART) Ring INdicator Input Change Flag */
+#define AT91C_US_DSRIC        (0x1 << 17) /**< (USART) Data Set Ready Input Change Flag */
+#define AT91C_US_DCDIC        (0x1 << 18) /**< (USART) Data Carrier Flag */
+#define AT91C_US_CTSIC        (0x1 << 19) /**< (USART) Clear To Send Input Change Flag */
+/* --- Register US_CSR only */
+#define AT91C_US_RI           (0x1 << 20) /**< (USART) Image of RI Input */
+#define AT91C_US_DSR          (0x1 << 21) /**< (USART) Image of DSR Input */
+#define AT91C_US_DCD          (0x1 << 22) /**< (USART) Image of DCD Input */
+#define AT91C_US_CTS          (0x1 << 23) /**< (USART) Image of CTS Input */
+
+#endif /* __AT91SAM9261_USART_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/board.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/board.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/board.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/board.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,92 @@
+/*
+ * include/asm-arm/arch-at91sam9261/board.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *  Copyright (C) 2006 Atmel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * These are data structures found in platform_device.dev.platform_data,
+ * and describing board-specfic data needed by drivers.  For example,
+ * which pin is used for a given GPIO role.
+ *
+ * In 2.6, drivers should strongly avoid board-specific knowledge so
+ * that supporting new boards normally won't require driver patches.
+ * Most board-specific knowledge should be in arch/.../board-*.c files.
+ */
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+extern const struct platform_device *platform_get_device(const char *name, int id);
+
+extern struct resource dbgu_resources[2];
+extern struct resource us0_resources[2];
+extern struct resource lcdc_resources[2];
+
+ /* Clocks */
+extern unsigned long at91_master_clock;
+
+ /* Serial Port */
+extern void __init at91_add_device_usart(unsigned id, struct at91_pioline *data);
+
+ /* USB Device */
+struct at91_udc_data {
+	u8	vbus_pin;		/* high == host powering us */
+	u8	pullup_pin;		/* high == D+ pulled up */
+};
+//extern void __init at91_add_device_udc(struct at91_udc_data *data);
+extern void __init at91_add_device_udc(void);
+
+ /* Compact Flash */
+struct at91_cf_data {
+	u8	irq_pin;		/* I/O IRQ */
+	u8	det_pin;		/* Card detect */
+	u8	vcc_pin;		/* power switching */
+	u8	rst_pin;		/* card reset */
+};
+extern void __init at91_add_device_cf(struct at91_cf_data *data);
+
+ /* MMC / SD */
+struct at91_mmc_data {
+	u8		det_pin;	/* card detect IRQ */
+	unsigned	is_b:1;		/* uses B side (vs A) */
+	unsigned	wire4:1;	/* (SD) supports DAT0..DAT3 */
+	u8		wp_pin;		/* (SD) writeprotect detect */
+	u8		vcc_pin;	/* power switching (high == on) */
+};
+extern void __init at91_add_device_mmc(struct at91_mmc_data *data);
+
+ /* Ethernet */
+struct at91_eth_data {
+	u8		phy_irq_pin;	/* PHY IRQ */
+	u8		phy_rst_pin;	/* PHY RST */
+	u8		is_rmii;	/* using RMII interface? */
+};
+extern void __init at91_add_device_eth(struct at91_eth_data *data);
+
+ /* USB Host */
+struct at91_usbh_data {
+	u8		ports;		/* number of ports on root hub */
+};
+extern void __init at91_add_device_usbh(struct at91_usbh_data *data);
+
+/* LCD */
+extern void __init at91_add_device_lcd(struct at91_pioline *data);
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/debug-macro.S linux-2.6.15.4/include/asm-arm/arch-at91sam9261/debug-macro.S
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/debug-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/debug-macro.S	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,37 @@
+/* linux/include/asm-arm/arch-at91sam9261/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include "hardware.h"
+
+                .macro  addruart,rx
+                mrc     p15, 0, \rx, c1, c0
+                tst     \rx, #1                       @ MMU enabled?
+                ldreq   \rx, =AT91C_BASE_DBGU         @ DBGU peripheral (phys address)
+                ldrne   \rx, =AT91C_VA_BASE_DBGU      @ DBGU peripheral (virt address)
+                .endm   
+
+                .macro  senduart,rd,rx
+                strb    \rd, [\rx, #US_THR]           @ DBGU_THR
+                .endm   
+
+                .macro  waituart,rd,rx
+1001:           ldr     \rd, [\rx, #US_CSR]           @ DBGU_CSR
+                tst     \rd, #AT91C_US_TXRDY          @ US_TXRDY = 1 when ready to transmit
+                beq     1001b   
+                .endm   
+
+                .macro  busyuart,rd,rx
+1001:           ldr     \rd, [\rx, #US_CSR]           @ DBGU_CSR
+                tst     \rd, #AT91C_US_TXEMPTY        @ US_TXEMPTY = 1 when transmission complete
+                beq     1001b
+                .endm
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/dma.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/dma.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/dma.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/dma.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/entry-macro.S linux-2.6.15.4/include/asm-arm/arch-at91sam9261/entry-macro.S
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/entry-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/entry-macro.S	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ * include/asm-arm/arch-at91sam9261/entry-macro.S
+ *
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France
+ * Low-level IRQ helper macros for AT91SAM9261 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/hardware.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(AT91C_VA_BASE_SYS)	@ base virtual address of SYS peripherals
+	ldr	\irqnr, [\base, #AIC_IVR]	@ read IRQ vector register: de-asserts nIRQ to processor (and clears interrupt)
+	ldr	\irqstat, [\base, #AIC_ISR]	@ read interrupt source number
+	teq	\irqstat, #0			@ ISR is 0 when no current interrupt, or spurious interrupt
+	streq	\tmp, [\base, #AIC_EOICR]	@ not going to be handled further, then ACK it now.
+	.endm
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/gpio.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/gpio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/gpio.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * include/asm-arm/arch-at91sam9261/gpio.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm/arch/at91sam9261_pio.h>
+#include <asm/arch/pio.h>
+
+#define PIOA AT91C_VA_BASE_PIOA, AT91C_ID_PIOA
+#define PIOB AT91C_VA_BASE_PIOB, AT91C_ID_PIOB
+#define PIOC AT91C_VA_BASE_PIOC, AT91C_ID_PIOC
+
+#define pin_to_mask(pin)        (1 << (pin))
+
+#define TYPE_PIO	0
+#define TYPE_PERIPH	1
+
+#define OUTPUT_MODE	0
+#define INPUT_MODE	1
+
+#define PERIPH_A	0
+#define PERIPH_B	1
+
+#define NO_PULL_UP	0
+#define PULLED_UP	1
+
+#define NO_GLITCH_FLT	0
+#define GLITCH_FLT_ON	1
+
+#ifndef __ASSEMBLY__
+/* -------------------------------------------------------- */
+/* PIO line structure definition */
+/* -------------------------------------------------------- */
+struct at91_pioline {
+        const char*	pin_name;		/* Name of the pin */
+        unsigned int	pio_ctrl_va_base;	/* Virtual Address of the PIO controller*/
+        unsigned char	pio_ctrl_id;		/* PIO controller ID */
+        unsigned char	pin_num;		/* pin number */
+        unsigned char	type;			/* type of the pin: PIO or Peripheral mode */
+        unsigned char	direction;		/* if the pin is in PIO mode    --> selects input or output mode */ 
+						/* if the pin is in Periph mode --> selects periph A or B */
+        unsigned char	use_pullup;		/* pullup enable */
+        unsigned char	use_filter;		/* glitch filter enable */
+};
+
+
+extern void at91_gpio_periph_enable(unsigned int pio_va_base, unsigned char pin, unsigned char peripheral, unsigned char use_pullup, unsigned char use_filter);
+extern void at91_gpio_configure(unsigned int pio_va_base, unsigned char pin, unsigned char in_out, unsigned char use_pullup, unsigned char use_filter);
+extern void at91_gpio_set_level(unsigned int pio_va_base, unsigned int pin, unsigned int level);
+extern unsigned int at91_gpio_get_level(unsigned int pio_va_base, unsigned int pin);
+extern int at91_device_pio_setup (struct at91_pioline *pPin);
+
+#endif
+
+#endif
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/hardware.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/hardware.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/hardware.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,112 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/hardware.h
+ *
+ * Copyright (c) 2005 ATMEL Rousset, France
+ * Revision	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/at91sam9261.h>
+#include <asm/arch/at91sam9261_ebi.h>
+#include <asm/arch/at91sam9261_aic.h>
+#include <asm/arch/at91sam9261_pitc.h>
+#include <asm/arch/at91sam9261_pmc.h>
+#include <asm/arch/at91sam9261_usart.h>
+
+#include <asm/arch/vmalloc.h>
+
+/*
+ * Remap the peripherals from address 0xFFFFEA00 .. 0xFFFFFFFF
+ * to 0xFEFA0000 .. 0xFF000000.  (384Kb)
+ */
+#define AT91C_IO_PHYS_BASE	0xFFFFF000
+#define AT91C_IO_VIRT_BASE	VMALLOC_END	
+
+ /* Convert a physical IO address to virtual IO address */
+#define AT91_IO_P2V(x)	((x) - AT91C_IO_PHYS_BASE + AT91C_IO_VIRT_BASE)
+
+/*
+ * Virtual to Physical Address mapping for IO devices.
+ */
+#define AT91C_VA_BASE_EBI	AT91_IO_P2V(AT91C_BASE_EBI)
+#define AT91C_VA_BASE_AIC	AT91_IO_P2V(AT91C_BASE_AIC)
+#define AT91C_VA_BASE_SYS	AT91_IO_P2V(AT91C_BASE_AIC)
+#define AT91C_VA_BASE_DBGU	AT91_IO_P2V(AT91C_BASE_DBGU)
+#define AT91C_VA_BASE_PIOA	AT91_IO_P2V(AT91C_BASE_PIOA)
+#define AT91C_VA_BASE_PIOB	AT91_IO_P2V(AT91C_BASE_PIOB)
+#define AT91C_VA_BASE_PIOC	AT91_IO_P2V(AT91C_BASE_PIOC)
+#define AT91C_VA_BASE_PITC	AT91_IO_P2V(AT91C_BASE_PITC)
+#define AT91C_VA_BASE_PMC	AT91_IO_P2V(AT91C_BASE_PMC)
+
+#define AT91C_VA_BASE_UDP	AT91_IO_P2V(AT91_BASE_UDP)
+
+/* 4 USART - 3's and one DBGU port */
+#define AT91C_NR_UART		4
+
+/*
+ * Serial port configuration.
+ *    1 .. 3 = USART0 .. USART2
+ *    0      = DBGU
+ */
+
+#define AT91C_CONSOLE		0			/* ttyS0 */
+
+/* Number of SPI ports */
+#define AT91C_NR_SPI            2
+
+
+ /* Definition of interrupt priority levels */
+#define AT91C_AIC_PRIOR_0 AT91C_AIC_PRIOR_LOWEST
+#define AT91C_AIC_PRIOR_1 ((unsigned int) 0x1)
+#define AT91C_AIC_PRIOR_2 ((unsigned int) 0x2)
+#define AT91C_AIC_PRIOR_3 ((unsigned int) 0x3)
+#define AT91C_AIC_PRIOR_4 ((unsigned int) 0x4)
+#define AT91C_AIC_PRIOR_5 ((unsigned int) 0x5)
+#define AT91C_AIC_PRIOR_6 ((unsigned int) 0x6)
+#define AT91C_AIC_PRIOR_7 AT91C_AIC_PRIOR_HIGHEST
+
+
+/* Peripheral interrupt configuration */
+#define AT91_SMR_FIQ	(AT91C_AIC_PRIOR_HIGHEST | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (FIQ)
+#define AT91_SMR_SYS	(AT91C_AIC_PRIOR_HIGHEST | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// System Peripheral
+#define AT91_SMR_PIOA	(AT91C_AIC_PRIOR_LOWEST	 | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller A
+#define AT91_SMR_PIOB	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller B
+#define AT91_SMR_PIOC	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller C
+#define AT91_SMR_US0	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 0
+#define AT91_SMR_US1	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 1
+#define AT91_SMR_US2	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 2
+#define AT91_SMR_MCI	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Multimedia Card Interface
+#define AT91_SMR_UDP	(AT91C_AIC_PRIOR_4       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB Device Port
+#define AT91_SMR_TWI	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Two-Wire Interface
+#define AT91_SMR_SPI0	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Peripheral Interface
+#define AT91_SMR_SPI1	(AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Peripheral Interface
+#define AT91_SMR_SSC0	(AT91C_AIC_PRIOR_5       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Synchronous Controller 0
+#define AT91_SMR_SSC1	(AT91C_AIC_PRIOR_5       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Synchronous Controller 1
+#define AT91_SMR_SSC2	(AT91C_AIC_PRIOR_5       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Synchronous Controller 2
+#define AT91_SMR_TC0	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 0
+#define AT91_SMR_TC1	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 1
+#define AT91_SMR_TC2	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 2
+#define AT91_SMR_UHP	(AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB Host port
+#define AT91_SMR_LCDC  	(AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Ethernet MAC
+#define AT91_SMR_IRQ0	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE)	// Advanced Interrupt Controller (IRQ0)
+#define AT91_SMR_IRQ1	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (IRQ1)
+#define AT91_SMR_IRQ2	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (IRQ2)
+
+
+/*
+ * Implementation specific hardware definitions.
+ */
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+#include <asm/arch/at91sam9261ek.h>
+#endif
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/io.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/io.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/io.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/io.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT		0xFFFFFFFF
+
+#define __io(a)			(a)
+#define __mem_pci(a)		((unsigned long)(a))
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/irqs.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/irqs.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/irqs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/irqs.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,50 @@
+/*
+ * include/asm-arm/arch-at91rm9200/irqs.h
+ *
+ *  Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define NR_AIC_IRQS 32
+
+
+/*
+ * Acknowledge interrupt with AIC after interrupt has been handled.
+ *   (by kernel/irq.c)
+ */
+#define irq_finish(irq) do { *((volatile unsigned *) (AT91C_VA_BASE_AIC + AIC_EOICR)) = 0; } while (0)
+
+/*
+ * IRQ interrupt symbols are the AT91_ID_* symbols in at91rm9200.h
+ * for IRQs handled directly through the AIC, or else the AT91_PIN_*
+ * symbols in gpio.h for ones handled indirectly as GPIOs.
+ * We make provision for 4 banks of GPIO.
+ */
+#include <asm/arch/gpio.h>
+
+#define	NR_IRQS		(NR_AIC_IRQS + (3 * 32))
+
+
+#ifndef __ASSEMBLY__
+/*
+ * Initialize the IRQ controller.
+ */
+#endif
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/lcdc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/lcdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/lcdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/lcdc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,37 @@
+#ifndef __ASM_ARCH_LCDC_H
+#define __ASM_ARCH_LCDC_H
+
+
+#include <asm/arch/at91sam9261_lcdc.h>
+#include <asm/arch/pmc.h>
+
+
+// Clock management functions 
+static inline void at91_lcdc_clock_enable (void) 
+{
+        at91_enable_system_clock(AT91C_PMC_HCK1);
+	at91_enable_periph_clock(AT91C_ID_LCDC);
+}
+
+
+static inline void at91_lcdc_clock_disable (void) 
+{
+        at91_disable_system_clock(AT91C_PMC_HCK1);
+	at91_disable_periph_clock(AT91C_ID_LCDC);
+}
+
+
+// LCD Power up and down function
+static inline void at91_lcdc_power_up (void)
+{
+       at91_gpio_set_level(AT91C_VA_BASE_PIOA, 12, 0);
+}
+
+
+static inline void at91_lcdc_power_down (void)
+{
+       at91_gpio_set_level(AT91C_VA_BASE_PIOA, 12, 1);
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/memory.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/memory.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/memory.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/memory.h
+ * 
+ * Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ * Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/arch/hardware.h>
+
+#define PHYS_OFFSET	(AT91_SDRAM_BASE)
+
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/param.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/param.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/param.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,3 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/param.h
+ */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/pio.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/pio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/pio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/pio.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,139 @@
+
+/*
+ * include/asm-arm/arch-at91rm9200/gpio.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91SAM9261_GPIO_H
+#define __ASM_ARCH_AT91SAM9261_GPIO_H
+
+#define PIN_BASE		32
+
+/* these pin numbers double as IRQ numbers, like AT91C_ID_* values */
+
+#define	AT91_PIN_PA0	(PIN_BASE + 0x00 + 0)
+#define	AT91_PIN_PA1	(PIN_BASE + 0x00 + 1)
+#define	AT91_PIN_PA2	(PIN_BASE + 0x00 + 2)
+#define	AT91_PIN_PA3	(PIN_BASE + 0x00 + 3)
+#define	AT91_PIN_PA4	(PIN_BASE + 0x00 + 4)
+
+#define	AT91_PIN_PA5	(PIN_BASE + 0x00 + 5)
+#define	AT91_PIN_PA6	(PIN_BASE + 0x00 + 6)
+#define	AT91_PIN_PA7	(PIN_BASE + 0x00 + 7)
+#define	AT91_PIN_PA8	(PIN_BASE + 0x00 + 8)
+#define	AT91_PIN_PA9	(PIN_BASE + 0x00 + 9)
+
+#define	AT91_PIN_PA10	(PIN_BASE + 0x00 + 10)
+#define	AT91_PIN_PA11	(PIN_BASE + 0x00 + 11)
+#define	AT91_PIN_PA12	(PIN_BASE + 0x00 + 12)
+#define	AT91_PIN_PA13	(PIN_BASE + 0x00 + 13)
+#define	AT91_PIN_PA14	(PIN_BASE + 0x00 + 14)
+
+#define	AT91_PIN_PA15	(PIN_BASE + 0x00 + 15)
+#define	AT91_PIN_PA16	(PIN_BASE + 0x00 + 16)
+#define	AT91_PIN_PA17	(PIN_BASE + 0x00 + 17)
+#define	AT91_PIN_PA18	(PIN_BASE + 0x00 + 18)
+#define	AT91_PIN_PA19	(PIN_BASE + 0x00 + 19)
+
+#define	AT91_PIN_PA20	(PIN_BASE + 0x00 + 20)
+#define	AT91_PIN_PA21	(PIN_BASE + 0x00 + 21)
+#define	AT91_PIN_PA22	(PIN_BASE + 0x00 + 22)
+#define	AT91_PIN_PA23	(PIN_BASE + 0x00 + 23)
+#define	AT91_PIN_PA24	(PIN_BASE + 0x00 + 24)
+
+#define	AT91_PIN_PA25	(PIN_BASE + 0x00 + 25)
+#define	AT91_PIN_PA26	(PIN_BASE + 0x00 + 26)
+#define	AT91_PIN_PA27	(PIN_BASE + 0x00 + 27)
+#define	AT91_PIN_PA28	(PIN_BASE + 0x00 + 28)
+#define	AT91_PIN_PA29	(PIN_BASE + 0x00 + 29)
+
+#define	AT91_PIN_PA30	(PIN_BASE + 0x00 + 30)
+#define	AT91_PIN_PA31	(PIN_BASE + 0x00 + 31)
+
+#define	AT91_PIN_PB0	(PIN_BASE + 0x20 + 0)
+#define	AT91_PIN_PB1	(PIN_BASE + 0x20 + 1)
+#define	AT91_PIN_PB2	(PIN_BASE + 0x20 + 2)
+#define	AT91_PIN_PB3	(PIN_BASE + 0x20 + 3)
+#define	AT91_PIN_PB4	(PIN_BASE + 0x20 + 4)
+
+#define	AT91_PIN_PB5	(PIN_BASE + 0x20 + 5)
+#define	AT91_PIN_PB6	(PIN_BASE + 0x20 + 6)
+#define	AT91_PIN_PB7	(PIN_BASE + 0x20 + 7)
+#define	AT91_PIN_PB8	(PIN_BASE + 0x20 + 8)
+#define	AT91_PIN_PB9	(PIN_BASE + 0x20 + 9)
+
+#define	AT91_PIN_PB10	(PIN_BASE + 0x20 + 10)
+#define	AT91_PIN_PB11	(PIN_BASE + 0x20 + 11)
+#define	AT91_PIN_PB12	(PIN_BASE + 0x20 + 12)
+#define	AT91_PIN_PB13	(PIN_BASE + 0x20 + 13)
+#define	AT91_PIN_PB14	(PIN_BASE + 0x20 + 14)
+
+#define	AT91_PIN_PB15	(PIN_BASE + 0x20 + 15)
+#define	AT91_PIN_PB16	(PIN_BASE + 0x20 + 16)
+#define	AT91_PIN_PB17	(PIN_BASE + 0x20 + 17)
+#define	AT91_PIN_PB18	(PIN_BASE + 0x20 + 18)
+#define	AT91_PIN_PB19	(PIN_BASE + 0x20 + 19)
+
+#define	AT91_PIN_PB20	(PIN_BASE + 0x20 + 20)
+#define	AT91_PIN_PB21	(PIN_BASE + 0x20 + 21)
+#define	AT91_PIN_PB22	(PIN_BASE + 0x20 + 22)
+#define	AT91_PIN_PB23	(PIN_BASE + 0x20 + 23)
+#define	AT91_PIN_PB24	(PIN_BASE + 0x20 + 24)
+
+#define	AT91_PIN_PB25	(PIN_BASE + 0x20 + 25)
+#define	AT91_PIN_PB26	(PIN_BASE + 0x20 + 26)
+#define	AT91_PIN_PB27	(PIN_BASE + 0x20 + 27)
+#define	AT91_PIN_PB28	(PIN_BASE + 0x20 + 28)
+#define	AT91_PIN_PB29	(PIN_BASE + 0x20 + 29)
+
+#define	AT91_PIN_PB30	(PIN_BASE + 0x20 + 30)
+#define	AT91_PIN_PB31	(PIN_BASE + 0x20 + 31)
+
+#define	AT91_PIN_PC0	(PIN_BASE + 0x40 + 0)
+#define	AT91_PIN_PC1	(PIN_BASE + 0x40 + 1)
+#define	AT91_PIN_PC2	(PIN_BASE + 0x40 + 2)
+#define	AT91_PIN_PC3	(PIN_BASE + 0x40 + 3)
+#define	AT91_PIN_PC4	(PIN_BASE + 0x40 + 4)
+
+#define	AT91_PIN_PC5	(PIN_BASE + 0x40 + 5)
+#define	AT91_PIN_PC6	(PIN_BASE + 0x40 + 6)
+#define	AT91_PIN_PC7	(PIN_BASE + 0x40 + 7)
+#define	AT91_PIN_PC8	(PIN_BASE + 0x40 + 8)
+#define	AT91_PIN_PC9	(PIN_BASE + 0x40 + 9)
+
+#define	AT91_PIN_PC10	(PIN_BASE + 0x40 + 10)
+#define	AT91_PIN_PC11	(PIN_BASE + 0x40 + 11)
+#define	AT91_PIN_PC12	(PIN_BASE + 0x40 + 12)
+#define	AT91_PIN_PC13	(PIN_BASE + 0x40 + 13)
+#define	AT91_PIN_PC14	(PIN_BASE + 0x40 + 14)
+
+#define	AT91_PIN_PC15	(PIN_BASE + 0x40 + 15)
+#define	AT91_PIN_PC16	(PIN_BASE + 0x40 + 16)
+#define	AT91_PIN_PC17	(PIN_BASE + 0x40 + 17)
+#define	AT91_PIN_PC18	(PIN_BASE + 0x40 + 18)
+#define	AT91_PIN_PC19	(PIN_BASE + 0x40 + 19)
+
+#define	AT91_PIN_PC20	(PIN_BASE + 0x40 + 20)
+#define	AT91_PIN_PC21	(PIN_BASE + 0x40 + 21)
+#define	AT91_PIN_PC22	(PIN_BASE + 0x40 + 22)
+#define	AT91_PIN_PC23	(PIN_BASE + 0x40 + 23)
+#define	AT91_PIN_PC24	(PIN_BASE + 0x40 + 24)
+
+#define	AT91_PIN_PC25	(PIN_BASE + 0x40 + 25)
+#define	AT91_PIN_PC26	(PIN_BASE + 0x40 + 26)
+#define	AT91_PIN_PC27	(PIN_BASE + 0x40 + 27)
+#define	AT91_PIN_PC28	(PIN_BASE + 0x40 + 28)
+#define	AT91_PIN_PC29	(PIN_BASE + 0x40 + 29)
+
+#define	AT91_PIN_PC30	(PIN_BASE + 0x40 + 30)
+#define	AT91_PIN_PC31	(PIN_BASE + 0x40 + 31)
+
+#endif
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/pmc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/pmc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/pmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/pmc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/pmc.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _ASM_ARCH_PMC_H
+#define _ASM_ARCH_PMC_H
+
+extern void at91_disable_periph_clock(unsigned int irq);
+extern void at91_enable_periph_clock (unsigned int irq);
+extern void at91_disable_system_clock(unsigned int mask);
+extern void at91_enable_system_clock (unsigned int mask);
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/spi.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/spi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/spi.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef __ASM_ARCH_SPI_H
+#define __ASM_ARCH_SPI_H
+
+
+#include <asm/arch/at91sam9261_spi.h>
+#include <asm/arch/at91sam9261_pdc.h>
+#include <asm/arch/pmc.h>
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/system.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/system.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/system.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/system.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-at91rm9200/system.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/hardware.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+}
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/time.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/time.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/time.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/time.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/time.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_TIME_H
+#define __ASM_ARCH_TIME_H
+
+
+#include <asm/mach/time.h>
+
+extern struct sys_timer at91sam9261_timer;
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/timex.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/timex.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/timex.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/timex.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <asm/arch/hardware.h>
+
+#define CLOCK_TICK_RATE		(AT91C_MASTER_CLOCK/16)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/uhp.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/uhp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/uhp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/uhp.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-at91sam9261/uhp.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+
+#ifndef __ASM_ARCH_UHP_H
+#define __ASM_ARCH_UHP_H
+
+
+#include <asm/arch/at91sam9261_uhp.h>
+#include <asm/arch/pmc.h>
+
+
+
+// Clock management functions
+static inline void at91_uhp_clock_enable (void) 
+{
+        at91_enable_system_clock(AT91C_PMC_UHP | AT91C_PMC_HCK0);
+        at91_enable_periph_clock(AT91C_ID_UHP);
+}
+
+
+static inline void at91_uhp_clock_disable (void) 
+{
+       at91_disable_system_clock(AT91C_PMC_UHP | AT91C_PMC_HCK0);
+       at91_disable_periph_clock(AT91C_ID_UHP);
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/uncompress.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/uncompress.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/uncompress.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/uncompress.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/uncompress.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *  Revision 	  2005 Atmel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <asm/io.h>
+
+#include <asm/arch/hardware.h>
+
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	while (*s) {
+		while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXRDY)) {
+			barrier();
+		}
+		writel( *s, AT91C_BASE_DBGU + US_THR); 
+		if (*s == '\n')	{
+			while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXRDY)) {
+				barrier();
+			}
+			writel('\r', AT91C_BASE_DBGU + US_THR); 
+		}
+		s++;
+	}
+	/* wait for transmission to complete */
+	while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXEMPTY)) {
+		barrier();
+	}
+}
+
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/usart.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/usart.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/usart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/usart.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __ASM_ARCH_USART_H
+#define __ASM_ARCH_USART_H
+
+
+#include <asm/arch/at91sam9261_usart.h>
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/vmalloc.h linux-2.6.15.4/include/asm-arm/arch-at91sam9261/vmalloc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-at91sam9261/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-at91sam9261/vmalloc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END		(0xFF000000 - 0x00200000)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/ac97c.h linux-2.6.15.4/include/asm-arm/arch-nadia2/ac97c.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/ac97c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/ac97c.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * include/asm-arm/arch-nadia2/ac97c.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+
+#ifndef __ASM_ARCH_AC97C_H
+#define __ASM_ARCH_AC97C_H
+
+
+#include <asm/arch/nadia2_ac97c.h>
+#include <asm/arch/nadia2_pdc.h>
+#include <asm/arch/pmc.h>
+
+// Clock management functions
+static inline void at91_ac97c_clock_enable (void) 
+{
+       at91_enable_periph_clock(AT91C_ID_AC97C);
+}
+
+
+static inline void at91_ac97c_clock_disable (void) 
+{
+       at91_disable_periph_clock(AT91C_ID_AC97C);
+}
+
+
+// PIO management functions
+void at91_ac97c_drive_reset(unsigned int value)
+{
+       at91_gpio_set_level(AT91C_VA_BASE_PIOA, 13, value);
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/debug-macro.S linux-2.6.15.4/include/asm-arm/arch-nadia2/debug-macro.S
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/debug-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/debug-macro.S	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,37 @@
+/* linux/include/asm-arm/arch-nadia2/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <asm/arch/usart.h>
+	
+                .macro  addruart,rx
+                mrc     p15, 0, \rx, c1, c0
+                tst     \rx, #1                       @ MMU enabled?
+                ldreq   \rx, =AT91C_BASE_DBGU         @ DBGU peripheral (phys address)
+                ldrne   \rx, =AT91C_VA_BASE_DBGU      @ DBGU peripheral (virt address)
+                .endm   
+
+                .macro  senduart,rd,rx
+                strb    \rd, [\rx, #US_THR]           @ DBGU_THR
+                .endm   
+
+                .macro  waituart,rd,rx
+1001:           ldr     \rd, [\rx, #US_CSR]           @ DBGU_CSR
+                tst     \rd, #AT91C_US_TXRDY          @ US_TXRDY = 1 when ready to transmit
+                beq     1001b   
+                .endm   
+
+                .macro  busyuart,rd,rx
+1001:           ldr     \rd, [\rx, #US_CSR]           @ DBGU_CSR
+                tst     \rd, #AT91C_US_TXEMPTY        @ US_TXEMPTY = 1 when transmission complete
+                beq     1001b
+                .endm
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/dma.h linux-2.6.15.4/include/asm-arm/arch-nadia2/dma.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/dma.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/dma.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/emac.h linux-2.6.15.4/include/asm-arm/arch-nadia2/emac.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/emac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/emac.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-nadia2/emac.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_EMAC_H
+#define __ASM_ARCH_EMAC_H
+
+#include <asm/arch/nadia2_emac.h>
+#include <asm/arch/pmc.h>
+
+
+// EMAC data structure : Phy address + PIO lines
+struct at91_eth_pdata {
+        int phy_id;                      // PHY address
+        struct at91_pioline *pio_data;  
+};
+
+
+static inline void at91_macb_clock_enable(void)
+{
+       at91_enable_periph_clock(AT91C_ID_EMAC);
+}
+
+
+static inline void at91_macb_clock_disable(void)
+{
+       at91_disable_periph_clock(AT91C_ID_EMAC);  
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/entry-macro.S linux-2.6.15.4/include/asm-arm/arch-nadia2/entry-macro.S
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/entry-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/entry-macro.S	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ * include/asm-arm/arch-nadia2/entry-macro.S
+ *
+ * Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France
+ * Low-level IRQ helper macros for NADIA2 and SAM926X platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/hardware.h>
+	
+	.macro	disable_fiq
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(AT91C_VA_BASE_AIC)	@ base virtual address of SYS peripherals
+	ldr	\irqnr, [\base, #AIC_IVR]	@ read IRQ vector register: de-asserts nIRQ to processor (and clears interrupt)
+	ldr	\irqstat, [\base, #AIC_ISR]	@ read interrupt source number
+	teq	\irqstat, #0			@ ISR is 0 when no current interrupt, or spurious interrupt
+	streq	\tmp, [\base, #AIC_EOICR]	@ not going to be handled further, then ACK it now.
+	.endm
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/gpio.h linux-2.6.15.4/include/asm-arm/arch-nadia2/gpio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/gpio.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,108 @@
+/*
+ * include/asm-arm/arch-nadia2/gpio.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm/arch/nadia2_pio.h>
+
+
+#define PIOA AT91C_VA_BASE_PIOA, AT91C_ID_PIOA
+#define PIOB AT91C_VA_BASE_PIOB, AT91C_ID_PIOB
+#define PIOC AT91C_VA_BASE_PIOC, AT91C_ID_PIOCDE
+#define PIOD AT91C_VA_BASE_PIOD, AT91C_ID_PIOCDE
+#define PIOE AT91C_VA_BASE_PIOE, AT91C_ID_PIOCDE
+
+
+#define pin_to_mask(pin)        (1 << (pin))
+
+
+#define TYPE_PIO	0
+#define TYPE_PERIPH	1
+
+#define OUTPUT_MODE	0
+#define INPUT_MODE	1
+
+#define PERIPH_A	0
+#define PERIPH_B	1
+
+#define NO_PULL_UP	0
+#define PULL_UP	        1
+
+#define NO_GLITCH_FLT	0
+#define GLITCH_FLT_ON	1
+
+
+/* -------------------------------------------------------- */
+/* PIO line structure definition */
+/* -------------------------------------------------------- */
+struct at91_pioline {
+        const char*	pin_name;		/* Name of the pin */
+        unsigned int	pio_ctrl_va_base;	/* Virtual Address of the PIO controller*/
+        unsigned char	pio_ctrl_id;		/* PIO controller ID */
+        unsigned char	pin_num;		/* pin number */
+        unsigned char	type;			/* type of the pin: PIO or Peripheral mode */
+        unsigned char	direction;		/* if the pin is in PIO mode    --> selects input or output mode */ 
+						/* if the pin is in Periph mode --> selects periph A or B */
+        unsigned char	use_pullup;		/* pullup enable */
+        unsigned char	use_filter;		/* glitch filter enable */
+};
+
+
+#ifndef __ASSEMBLY__
+
+extern void at91_gpio_periph_enable(unsigned int pio_va_base, unsigned char pin, unsigned char peripheral, unsigned char use_pullup, unsigned char use_filter);
+extern void at91_gpio_configure(unsigned int pio_va_base, unsigned char pin, unsigned char in_out, unsigned char use_pullup, unsigned char use_filter);
+extern void at91_gpio_set_level(unsigned int pio_va_base, unsigned int pin, unsigned int level);
+extern unsigned int at91_gpio_get_level(unsigned int pio_va_base, unsigned int pin);
+extern int at91_device_pio_setup (struct at91_pioline *pPin);
+
+/*
+// SPI 0 Chip Select configurations
+static inline void AT91F_CfgPIO_SPI0_CS0(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA,  3, PERIPH_A, NO_PULL_UP);
+}
+
+static inline void AT91F_CfgPIO_SPI0_CS1(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA,  4, PERIPH_A, NO_PULL_UP);
+}
+
+static inline void AT91F_CfgPIO_SPI0_CS2(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA, 28, PERIPH_B, NO_PULL_UP);
+}
+
+static inline void AT91F_CfgPIO_SPI0_CS3(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA,  6, PERIPH_A, NO_PULL_UP);
+}
+
+// SPI 1 Chip Select configurations
+static inline void AT91F_CfgPIO_SPI1_CS0(void) {
+	at91_gpio_periph_enable(AT91C_VA_BASE_PIOB, 28, PERIPH_A, NO_PULL_UP);
+}
+
+static inline void AT91F_CfgPIO_SPI1_CS1(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOB, 27, PERIPH_A, NO_PULL_UP);
+}
+
+static inline void AT91F_CfgPIO_SPI1_CS2(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA, 25, PERIPH_B, NO_PULL_UP);
+}
+
+static inline void AT91F_CfgPIO_SPI1_CS3(void) {
+        at91_gpio_periph_enable(AT91C_VA_BASE_PIOA, 26, PERIPH_B, NO_PULL_UP);
+}
+*/
+
+#endif
+
+#endif
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/hardware.h linux-2.6.15.4/include/asm-arm/arch-nadia2/hardware.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/hardware.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,115 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/hardware.h
+ *
+ * Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/nadia2_sys.h>
+#include <asm/arch/nadia2_aic.h>
+
+#include <asm/arch/vmalloc.h>
+
+
+/*
+ * Remap the peripherals from address 0xFFFFEA00 .. 0xFFFFFFFF
+ * to 0xFEFA0000 .. 0xFF000000.  (384Kb)
+ */
+#define AT91C_IO_PHYS_BASE	0xFFFFE000
+#define AT91C_IO_VIRT_BASE	VMALLOC_END	
+
+ /* Convert a physical IO address to virtual IO address */
+#define AT91_IO_P2V(x)	((x) - AT91C_IO_PHYS_BASE + AT91C_IO_VIRT_BASE)
+
+/*
+ * Virtual to Physical Address mapping for IO devices.
+ */
+#define AT91C_VA_BASE_SYS	AT91_IO_P2V(AT91C_BASE_SYS)
+#define AT91C_VA_BASE_AIC	AT91_IO_P2V(AT91C_BASE_SYS + SYS_AIC_SMR)
+#define AT91C_VA_BASE_DBGU	AT91_IO_P2V(AT91C_BASE_SYS + SYS_DBGU_CR)
+#define AT91C_VA_BASE_PIOA	AT91_IO_P2V(AT91C_BASE_SYS + SYS_PIOA_PER)
+#define AT91C_VA_BASE_PIOB	AT91_IO_P2V(AT91C_BASE_SYS + SYS_PIOB_PER)
+#define AT91C_VA_BASE_PIOC	AT91_IO_P2V(AT91C_BASE_SYS + SYS_PIOC_PER)
+#define AT91C_VA_BASE_PIOD	AT91_IO_P2V(AT91C_BASE_SYS + SYS_PIOD_PER)
+#define AT91C_VA_BASE_PIOE	AT91_IO_P2V(AT91C_BASE_SYS + SYS_PIOE_PER)
+#define AT91C_VA_BASE_PITC	AT91_IO_P2V(AT91C_BASE_SYS + SYS_PITC_PIMR)
+#define AT91C_VA_BASE_PMC	AT91_IO_P2V(AT91C_BASE_SYS + SYS_PMC_SCER)
+
+
+/* 4 USART - 3's and one DBGU port */
+#define AT91C_NR_UART		4
+
+/*
+ * Serial port configuration.
+ *    1 .. 3 = USART0 .. USART2
+ *    0      = DBGU
+ */
+
+#define AT91C_CONSOLE		0			/* ttyAT0 */
+
+/* Number of SPI ports */
+#define AT91C_NR_SPI            2
+
+
+ /* Definition of interrupt priority levels */
+#define AT91C_AIC_PRIOR_0 AT91C_AIC_PRIOR_LOWEST
+#define AT91C_AIC_PRIOR_1 ((unsigned int) 0x1)
+#define AT91C_AIC_PRIOR_2 ((unsigned int) 0x2)
+#define AT91C_AIC_PRIOR_3 ((unsigned int) 0x3)
+#define AT91C_AIC_PRIOR_4 ((unsigned int) 0x4)
+#define AT91C_AIC_PRIOR_5 ((unsigned int) 0x5)
+#define AT91C_AIC_PRIOR_6 ((unsigned int) 0x6)
+#define AT91C_AIC_PRIOR_7 AT91C_AIC_PRIOR_HIGHEST
+
+
+/* Peripheral interrupt configuration */
+#define AT91_SMR_FIQ	        (AT91C_AIC_PRIOR_HIGHEST | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (FIQ)
+#define AT91_SMR_SYS	        (AT91C_AIC_PRIOR_HIGHEST | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// System Peripheral
+#define AT91_SMR_PIOA	        (AT91C_AIC_PRIOR_LOWEST	 | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller A
+#define AT91_SMR_PIOB	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller B
+#define AT91_SMR_PIOCDE	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Parallel IO Controller C
+#define AT91_SMR_AES	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// AES
+#define AT91_SMR_US0	        (AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 0
+#define AT91_SMR_US1	        (AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 1
+#define AT91_SMR_US2	        (AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USART 2
+#define AT91_SMR_MCI0	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Multimedia Card Interface
+#define AT91_SMR_MCI1	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Multimedia Card Interface
+#define AT91_SMR_CAN	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Controller Area Network
+#define AT91_SMR_UDP	        (AT91C_AIC_PRIOR_4       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB Device Port
+#define AT91_SMR_TWI	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Two-Wire Interface
+#define AT91_SMR_SPI0	        (AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Peripheral Interface
+#define AT91_SMR_SPI1	        (AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Peripheral Interface
+#define AT91_SMR_AC97C	        (AT91C_AIC_PRIOR_6       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// AC97 Controller
+#define AT91_SMR_SSC0	        (AT91C_AIC_PRIOR_5       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Synchronous Controller 0
+#define AT91_SMR_SSC1	        (AT91C_AIC_PRIOR_5       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Serial Synchronous Controller 1
+#define AT91_SMR_TC012	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Timer Counter 0,1,2
+#define AT91_SMR_EMAC	        (AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// MACB
+#define AT91_SMR_PWMC	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Pulse Width Modulation Controller
+#define AT91_SMR_UHP	        (AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB Host port
+#define AT91_SMR_LCDC  	        (AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// LCD Controller
+#define AT91_SMR_ISI	        (AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Image Sensor Interface
+#define AT91_SMR_DMAC	        (AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// DMA Controller
+#define AT91_SMR_OTG	        (AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// USB OTG
+#define AT91_SMR_2DGE	        (AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// 2D Graphics Engine
+#define AT91_SMR_GPSE_KBDI	(AT91C_AIC_PRIOR_3       | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// GPS Interface, KBD Interface
+#define AT91_SMR_IRQ0	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE)	// Advanced Interrupt Controller (IRQ0)
+#define AT91_SMR_IRQ1	        (AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL)	// Advanced Interrupt Controller (IRQ1)
+
+/*
+ * Implementation specific hardware definitions.
+ */
+
+#ifdef CONFIG_MACH_NADIA2VB
+#include <asm/arch/nadia2vb.h>
+#endif
+
+#endif  // __ASM_ARCH_HARDWARE_H
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/io.h linux-2.6.15.4/include/asm-arm/arch-nadia2/io.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/io.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/io.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT		0xFFFFFFFF
+
+#define __io(a)			(a)
+#define __mem_pci(a)		((unsigned long)(a))
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/irqs.h linux-2.6.15.4/include/asm-arm/arch-nadia2/irqs.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/irqs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/irqs.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/irqs.h
+ *
+ *  Copyright (C) 2005, M. Amine SAYA, ATMEL Rousset, France.
+ *  Revision	  2005, M. Nicolas Diremdjian, ATMEL Rousset, France.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define NR_IRQS 32
+
+/*
+ * Acknowledge interrupt with AIC after interrupt has been handled.
+ *   (by kernel/irq.c)
+ */
+#define irq_finish(irq) do { *((volatile unsigned int *)(AT91C_VA_BASE_AIC + AIC_EOICR))  = 0; } while (0)
+
+/*
+ *  IRQ interrupts definitions are the same as the ID definitions
+ *  in asm/arch/at91sam9261_xxx.h
+ */
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/lcdc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/lcdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/lcdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/lcdc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,50 @@
+/*
+ * include/asm-arm/arch-nadia2/lcdc.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+
+#ifndef __ASM_ARCH_LCDC_H
+#define __ASM_ARCH_LCDC_H
+
+
+#include <asm/arch/nadia2_lcdc.h>
+#include <asm/arch/pmc.h>
+
+// PIO management functions
+
+
+// Clock management functions 
+static inline void at91_lcdc_clock_enable (void) 
+{
+       at91_enable_periph_clock(AT91C_ID_LCDC);
+}
+
+
+static inline void at91_lcdc_clock_disable (void) 
+{
+       at91_disable_periph_clock(AT91C_ID_LCDC);
+}
+
+
+// LCD Power up and down function
+static inline void at91_lcdc_power_up (void)
+{
+       at91_gpio_set_level(AT91C_VA_BASE_PIOD, 12, 1);
+}
+
+
+static inline void at91_lcdc_power_down (void)
+{
+       at91_gpio_set_level(AT91C_VA_BASE_PIOD, 12, 0);
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/memory.h linux-2.6.15.4/include/asm-arm/arch-nadia2/memory.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/memory.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/memory.h
+ * 
+ * Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ * Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/arch/hardware.h>
+
+#define PHYS_OFFSET	(AT91_SDRAM_BASE)
+
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_ac97c.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_ac97c.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_ac97c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_ac97c.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,292 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_ac97c.h
+ * 
+ * Hardware definition for the ac97c peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  12/09/2005 (11:54:20) AT91 SW Application Group from AC97C_XXXX V1.3
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_AC97C_H
+#define __AT91SAM9262_AC97C_H
+
+/* -------------------------------------------------------- */
+/* AC97C ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_AC97C
+#define AT91C_ID_AC97C 	18 /**< AC97 Controller id */
+#endif /* AT91C_ID_AC97C */
+
+/* -------------------------------------------------------- */
+/* AC97C Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_AC97C     	0xFFFA0000 /**< AC97C base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PB1_AC97CK   	(1 << 1) /**<  */
+#define AT91C_PB0_AC97FS   	(1 << 0) /**<  */
+#define AT91C_PB3_AC97RX   	(1 << 3) /**<  */
+#define AT91C_PB2_AC97TX   	(1 << 2) /**<  */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+#define AC97C_MR 	(0x0008) 	/**< Mode Register */
+#define AC97C_ICA 	(0x0010) 	/**< Input Channel AssignementRegister */
+#define AC97C_OCA 	(0x0014) 	/**< Output Channel Assignement Register */
+#define AC97C_CARHR 	(0x0020) 	/**< Channel A Receive Holding Register */
+#define AC97C_CATHR 	(0x0024) 	/**< Channel A Transmit Holding Register */
+#define AC97C_CASR 	(0x0028) 	/**< Channel A Status Register */
+#define AC97C_CAMR 	(0x002C) 	/**< Channel A Mode Register */
+#define AC97C_CBRHR 	(0x0030) 	/**< Channel B Receive Holding Register (optional) */
+#define AC97C_CBTHR 	(0x0034) 	/**< Channel B Transmit Holding Register (optional) */
+#define AC97C_CBSR 	(0x0038) 	/**< Channel B Status Register */
+#define AC97C_CBMR 	(0x003C) 	/**< Channel B Mode Register */
+#define AC97C_CORHR 	(0x0040) 	/**< COdec Transmit Holding Register */
+#define AC97C_COTHR 	(0x0044) 	/**< COdec Transmit Holding Register */
+#define AC97C_COSR 	(0x0048) 	/**< CODEC Status Register */
+#define AC97C_COMR 	(0x004C) 	/**< CODEC Mask Status Register */
+#define AC97C_SR 	(0x0050) 	/**< Status Register */
+#define AC97C_IER 	(0x0054) 	/**< Interrupt Enable Register */
+#define AC97C_IDR 	(0x0058) 	/**< Interrupt Disable Register */
+#define AC97C_IMR 	(0x005C) 	/**< Interrupt Mask Register */
+#define AC97C_VERSION 	(0x00FC) 	/**< Version Register */
+#define AC97C_RPR 	(0x0100) 	/**< Receive Pointer Register */
+#define AC97C_RCR 	(0x0104) 	/**< Receive Counter Register */
+#define AC97C_TPR 	(0x0108) 	/**< Transmit Pointer Register */
+#define AC97C_TCR 	(0x010C) 	/**< Transmit Counter Register */
+#define AC97C_RNPR 	(0x0110) 	/**< Receive Next Pointer Register */
+#define AC97C_RNCR 	(0x0114) 	/**< Receive Next Counter Register */
+#define AC97C_TNPR 	(0x0118) 	/**< Transmit Next Pointer Register */
+#define AC97C_TNCR 	(0x011C) 	/**< Transmit Next Counter Register */
+#define AC97C_PTCR 	(0x0120) 	/**< PDC Transfer Control Register */
+#define AC97C_PTSR 	(0x0124) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register AC97C_MR */
+#define AT91C_AC97C_ENA       (0x1 << 0 ) /**< (AC97C) AC97 Controller Global Enable */
+#define AT91C_AC97C_WRST      (0x1 << 1 ) /**< (AC97C) Warm Reset */
+#define AT91C_AC97C_VRA       (0x1 << 2 ) /**< (AC97C) Variable RAte (for Data Slots) */
+/* --- Register AC97C_ICA */
+#define AT91C_AC97C_CHID3     (0x7 << 0 ) /**< (AC97C) Channel Id for the input slot 3 */
+#define 	AT91C_AC97C_CHID3_NONE                 0x0 /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CA                   0x1 /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CB                   0x2 /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CC                   0x3 /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID4     (0x7 << 3 ) /**< (AC97C) Channel Id for the input slot 4 */
+#define 	AT91C_AC97C_CHID4_NONE                 (0x0 <<  3) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CA                   (0x1 <<  3) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CB                   (0x2 <<  3) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CC                   (0x3 <<  3) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID5     (0x7 << 6 ) /**< (AC97C) Channel Id for the input slot 5 */
+#define 	AT91C_AC97C_CHID5_NONE                 (0x0 <<  6) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CA                   (0x1 <<  6) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CB                   (0x2 <<  6) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CC                   (0x3 <<  6) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID6     (0x7 << 9 ) /**< (AC97C) Channel Id for the input slot 6 */
+#define 	AT91C_AC97C_CHID6_NONE                 (0x0 <<  9) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CA                   (0x1 <<  9) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CB                   (0x2 <<  9) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CC                   (0x3 <<  9) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID7     (0x7 << 12) /**< (AC97C) Channel Id for the input slot 7 */
+#define 	AT91C_AC97C_CHID7_NONE                 (0x0 << 12) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CA                   (0x1 << 12) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CB                   (0x2 << 12) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CC                   (0x3 << 12) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID8     (0x7 << 15) /**< (AC97C) Channel Id for the input slot 8 */
+#define 	AT91C_AC97C_CHID8_NONE                 (0x0 << 15) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CA                   (0x1 << 15) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CB                   (0x2 << 15) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CC                   (0x3 << 15) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID9     (0x7 << 18) /**< (AC97C) Channel Id for the input slot 9 */
+#define 	AT91C_AC97C_CHID9_NONE                 (0x0 << 18) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CA                   (0x1 << 18) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CB                   (0x2 << 18) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CC                   (0x3 << 18) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID10    (0x7 << 21) /**< (AC97C) Channel Id for the input slot 10 */
+#define 	AT91C_AC97C_CHID10_NONE                 (0x0 << 21) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CA                   (0x1 << 21) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CB                   (0x2 << 21) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CC                   (0x3 << 21) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID11    (0x7 << 24) /**< (AC97C) Channel Id for the input slot 11 */
+#define 	AT91C_AC97C_CHID11_NONE                 (0x0 << 24) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CA                   (0x1 << 24) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CB                   (0x2 << 24) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CC                   (0x3 << 24) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID12    (0x7 << 27) /**< (AC97C) Channel Id for the input slot 12 */
+#define 	AT91C_AC97C_CHID12_NONE                 (0x0 << 27) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CA                   (0x1 << 27) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CB                   (0x2 << 27) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CC                   (0x3 << 27) /**< (AC97C) Channel C data will be transmitted during this slot */
+/* --- Register AC97C_OCA */
+#define AT91C_AC97C_CHID3     (0x7 << 0 ) /**< (AC97C) Channel Id for the input slot 3 */
+#define 	AT91C_AC97C_CHID3_NONE                 0x0 /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CA                   0x1 /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CB                   0x2 /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CC                   0x3 /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID4     (0x7 << 3 ) /**< (AC97C) Channel Id for the input slot 4 */
+#define 	AT91C_AC97C_CHID4_NONE                 (0x0 <<  3) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CA                   (0x1 <<  3) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CB                   (0x2 <<  3) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CC                   (0x3 <<  3) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID5     (0x7 << 6 ) /**< (AC97C) Channel Id for the input slot 5 */
+#define 	AT91C_AC97C_CHID5_NONE                 (0x0 <<  6) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CA                   (0x1 <<  6) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CB                   (0x2 <<  6) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CC                   (0x3 <<  6) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID6     (0x7 << 9 ) /**< (AC97C) Channel Id for the input slot 6 */
+#define 	AT91C_AC97C_CHID6_NONE                 (0x0 <<  9) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CA                   (0x1 <<  9) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CB                   (0x2 <<  9) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CC                   (0x3 <<  9) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID7     (0x7 << 12) /**< (AC97C) Channel Id for the input slot 7 */
+#define 	AT91C_AC97C_CHID7_NONE                 (0x0 << 12) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CA                   (0x1 << 12) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CB                   (0x2 << 12) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CC                   (0x3 << 12) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID8     (0x7 << 15) /**< (AC97C) Channel Id for the input slot 8 */
+#define 	AT91C_AC97C_CHID8_NONE                 (0x0 << 15) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CA                   (0x1 << 15) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CB                   (0x2 << 15) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CC                   (0x3 << 15) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID9     (0x7 << 18) /**< (AC97C) Channel Id for the input slot 9 */
+#define 	AT91C_AC97C_CHID9_NONE                 (0x0 << 18) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CA                   (0x1 << 18) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CB                   (0x2 << 18) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CC                   (0x3 << 18) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID10    (0x7 << 21) /**< (AC97C) Channel Id for the input slot 10 */
+#define 	AT91C_AC97C_CHID10_NONE                 (0x0 << 21) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CA                   (0x1 << 21) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CB                   (0x2 << 21) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CC                   (0x3 << 21) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID11    (0x7 << 24) /**< (AC97C) Channel Id for the input slot 11 */
+#define 	AT91C_AC97C_CHID11_NONE                 (0x0 << 24) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CA                   (0x1 << 24) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CB                   (0x2 << 24) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CC                   (0x3 << 24) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID12    (0x7 << 27) /**< (AC97C) Channel Id for the input slot 12 */
+#define 	AT91C_AC97C_CHID12_NONE                 (0x0 << 27) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CA                   (0x1 << 27) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CB                   (0x2 << 27) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CC                   (0x3 << 27) /**< (AC97C) Channel C data will be transmitted during this slot */
+/* --- Register AC97C_CARHR */
+#define AT91C_AC97C_RDATA     (0xFFFFF << 0 ) /**< (AC97C) Receive data */
+/* --- Register AC97C_CATHR */
+#define AT91C_AC97C_TDATA     (0xFFFFF << 0 ) /**< (AC97C) Transmit data */
+/* --- Register AC97C_CASR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_ENDTX     (0x1 << 10) /**< (AC97C)  */
+#define AT91C_AC97C_TXBUFE    (0x1 << 11) /**< (AC97C)  */
+#define AT91C_AC97C_ENDRX     (0x1 << 14) /**< (AC97C)  */
+#define AT91C_AC97C_RXBUFF    (0x1 << 15) /**< (AC97C)  */
+/* --- Register AC97C_CAMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_ENDTX     (0x1 << 10) /**< (AC97C)  */
+#define AT91C_AC97C_TXBUFE    (0x1 << 11) /**< (AC97C)  */
+#define AT91C_AC97C_ENDRX     (0x1 << 14) /**< (AC97C)  */
+#define AT91C_AC97C_RXBUFF    (0x1 << 15) /**< (AC97C)  */
+#define AT91C_AC97C_SIZE      (0x3 << 16) /**< (AC97C)  */
+#define 	AT91C_AC97C_SIZE_20_BITS              (0x0 << 16) /**< (AC97C) Data size is 20 bits */
+#define 	AT91C_AC97C_SIZE_18_BITS              (0x1 << 16) /**< (AC97C) Data size is 18 bits */
+#define 	AT91C_AC97C_SIZE_16_BITS              (0x2 << 16) /**< (AC97C) Data size is 16 bits */
+#define 	AT91C_AC97C_SIZE_10_BITS              (0x3 << 16) /**< (AC97C) Data size is 10 bits */
+#define AT91C_AC97C_CEM       (0x1 << 18) /**< (AC97C)  */
+#define AT91C_AC97C_CEN       (0x1 << 21) /**< (AC97C)  */
+#define AT91C_AC97C_PDCEN     (0x1 << 22) /**< (AC97C)  */
+/* --- Register AC97C_CBRHR */
+#define AT91C_AC97C_RDATA     (0xFFFFF << 0 ) /**< (AC97C) Receive data */
+/* --- Register AC97C_CBTHR */
+#define AT91C_AC97C_TDATA     (0xFFFFF << 0 ) /**< (AC97C) Transmit data */
+/* --- Register AC97C_CBSR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+/* --- Register AC97C_CBMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_SIZE      (0x3 << 16) /**< (AC97C)  */
+#define 	AT91C_AC97C_SIZE_20_BITS              (0x0 << 16) /**< (AC97C) Data size is 20 bits */
+#define 	AT91C_AC97C_SIZE_18_BITS              (0x1 << 16) /**< (AC97C) Data size is 18 bits */
+#define 	AT91C_AC97C_SIZE_16_BITS              (0x2 << 16) /**< (AC97C) Data size is 16 bits */
+#define 	AT91C_AC97C_SIZE_10_BITS              (0x3 << 16) /**< (AC97C) Data size is 10 bits */
+#define AT91C_AC97C_CEM       (0x1 << 18) /**< (AC97C)  */
+#define AT91C_AC97C_CEN       (0x1 << 21) /**< (AC97C)  */
+/* --- Register AC97C_CORHR */
+#define AT91C_AC97C_SDATA     (0xFFFF << 0 ) /**< (AC97C) Status Data */
+/* --- Register AC97C_COTHR */
+#define AT91C_AC97C_CDATA     (0xFFFF << 0 ) /**< (AC97C) Command Data */
+#define AT91C_AC97C_CADDR     (0x7F << 16) /**< (AC97C) COdec control register index */
+#define AT91C_AC97C_READ      (0x1 << 23) /**< (AC97C) Read/Write command */
+/* --- Register AC97C_COSR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_COMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_SR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IER */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IDR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IMR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+
+#endif /* __AT91SAM9262_AC97C_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_aic.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_aic.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_aic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_aic.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,92 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_aic.h
+ * 
+ * Hardware definition for the aic peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from AIC_6075A V1.1
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_AIC_H
+#define __AT91SAM9262_AIC_H
+
+/* -------------------------------------------------------- */
+/* AIC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_FIQ
+#define AT91C_ID_FIQ   	 0 /**< Advanced Interrupt Controller (FIQ) id */
+#endif /* AT91C_ID_FIQ */
+
+/* -------------------------------------------------------- */
+/* AIC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_AIC       	0xFFFFF000 /**< AIC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PD4_FIQ      	(1 << 4) /**<  */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AIC_SMR 	(0x0000) 	/**< Source Mode Register */
+#define AIC_SVR 	(0x0080) 	/**< Source Vector Register */
+#define AIC_IVR 	(0x0100) 	/**< IRQ Vector Register */
+#define AIC_FVR 	(0x0104) 	/**< FIQ Vector Register */
+#define AIC_ISR 	(0x0108) 	/**< Interrupt Status Register */
+#define AIC_IPR 	(0x010C) 	/**< Interrupt Pending Register */
+#define AIC_IMR 	(0x0110) 	/**< Interrupt Mask Register */
+#define AIC_CISR 	(0x0114) 	/**< Core Interrupt Status Register */
+#define AIC_IECR 	(0x0120) 	/**< Interrupt Enable Command Register */
+#define AIC_IDCR 	(0x0124) 	/**< Interrupt Disable Command Register */
+#define AIC_ICCR 	(0x0128) 	/**< Interrupt Clear Command Register */
+#define AIC_ISCR 	(0x012C) 	/**< Interrupt Set Command Register */
+#define AIC_EOICR 	(0x0130) 	/**< End of Interrupt Command Register */
+#define AIC_SPU 	(0x0134) 	/**< Spurious Vector Register */
+#define AIC_DCR 	(0x0138) 	/**< Debug Control Register (Protect) */
+#define AIC_FFER 	(0x0140) 	/**< Fast Forcing Enable Register */
+#define AIC_FFDR 	(0x0144) 	/**< Fast Forcing Disable Register */
+#define AIC_FFSR 	(0x0148) 	/**< Fast Forcing Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for AIC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register AIC_SMR */
+#define AT91C_AIC_PRIOR       (0x7 << 0 ) /**< (AIC) Priority Level */
+#define 	AT91C_AIC_PRIOR_LOWEST               0x0 /**< (AIC) Lowest priority level */
+#define 	AT91C_AIC_PRIOR_HIGHEST              0x7 /**< (AIC) Highest priority level */
+#define AT91C_AIC_SRCTYPE     (0x3 << 5 ) /**< (AIC) Interrupt Source Type */
+#define 	AT91C_AIC_SRCTYPE_EXT_LOW_LEVEL        (0x0 <<  5) /**< (AIC) External Sources Code Label Low-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL       (0x0 <<  5) /**< (AIC) Internal Sources Code Label High-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE    (0x1 <<  5) /**< (AIC) Internal Sources Code Label Positive Edge triggered */
+#define 	AT91C_AIC_SRCTYPE_EXT_NEGATIVE_EDGE    (0x1 <<  5) /**< (AIC) External Sources Code Label Negative Edge triggered */
+#define 	AT91C_AIC_SRCTYPE_HIGH_LEVEL           (0x2 <<  5) /**< (AIC) Internal Or External Sources Code Label High-level Sensitive */
+#define 	AT91C_AIC_SRCTYPE_POSITIVE_EDGE        (0x3 <<  5) /**< (AIC) Internal Or External Sources Code Label Positive Edge triggered */
+/* --- Register AIC_CISR */
+#define AT91C_AIC_NFIQ        (0x1 << 0 ) /**< (AIC) NFIQ Status */
+#define AT91C_AIC_NIRQ        (0x1 << 1 ) /**< (AIC) NIRQ Status */
+/* --- Register AIC_DCR */
+#define AT91C_AIC_DCR_PROT    (0x1 << 0 ) /**< (AIC) Protection Mode */
+#define AT91C_AIC_DCR_GMSK    (0x1 << 1 ) /**< (AIC) General Mask */
+
+#endif /* __AT91SAM9262_AIC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_ccfg.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_ccfg.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_ccfg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_ccfg.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,91 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_ccfg.h
+ * 
+ * Hardware definition for the ccfg peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from  V
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_CCFG_H
+#define __AT91SAM9262_CCFG_H
+
+/* -------------------------------------------------------- */
+/* CCFG ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* CCFG Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_CCFG      	0xFFFFED10 /**< CCFG base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for CCFG hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for CCFG hardware peripheral */
+/* -------------------------------------------------------- */
+#define CCFG_TCMR 	(0x0000) 	/**<  TCM configuration */
+#define CCFG_EBI0CSA 	(0x0014) 	/**<  EBI0 Chip Select Assignement Register */
+#define CCFG_EBI1CSA 	(0x0018) 	/**<  EBI1 Chip Select Assignement Register */
+#define CCFG_MATRIXVERSION 	(0x00EC) 	/**<  Version Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for CCFG hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register CCFG_TCMR */
+#define AT91C_CCFG_ITCM_SIZE  (0xF << 0 ) /**< (CCFG) Size of ITCM enabled memory block */
+#define 	AT91C_CCFG_ITCM_SIZE_0KB                  0x0 /**< (CCFG) 0 KB (No ITCM Memory) */
+#define 	AT91C_CCFG_ITCM_SIZE_16KB                 0x5 /**< (CCFG) 16 KB */
+#define 	AT91C_CCFG_ITCM_SIZE_32KB                 0x6 /**< (CCFG) 32 KB */
+#define 	AT91C_CCFG_ITCM_SIZE_64KB                 0x7 /**< (CCFG) 64 KB */
+#define AT91C_CCFG_DTCM_SIZE  (0xF << 4 ) /**< (CCFG) Size of DTCM enabled memory block */
+#define 	AT91C_CCFG_DTCM_SIZE_0KB                  (0x0 <<  4) /**< (CCFG) 0 KB (No DTCM Memory) */
+#define 	AT91C_CCFG_DTCM_SIZE_16KB                 (0x5 <<  4) /**< (CCFG) 16 KB */
+#define 	AT91C_CCFG_DTCM_SIZE_32KB                 (0x6 <<  4) /**< (CCFG) 32 KB */
+#define 	AT91C_CCFG_DTCM_SIZE_64KB                 (0x7 <<  4) /**< (CCFG) 64 KB */
+#define AT91C_CCFG_RM         (0xF << 8 ) /**< (CCFG) Read Margin registers */
+/* --- Register CCFG_EBI0CSA */
+#define AT91C_EBI_CS1A        (0x1 << 1 ) /**< (CCFG) Chip Select 1 Assignment */
+#define 	AT91C_EBI_CS1A_SMC                  (0x0 <<  1) /**< (CCFG) Chip Select 1 is assigned to the Static Memory Controller. */
+#define 	AT91C_EBI_CS1A_SDRAMC               (0x1 <<  1) /**< (CCFG) Chip Select 1 is assigned to the SDRAM Controller. */
+#define AT91C_EBI_CS3A        (0x1 << 3 ) /**< (CCFG) Chip Select 3 Assignment */
+#define 	AT91C_EBI_CS3A_SMC                  (0x0 <<  3) /**< (CCFG) Chip Select 3 is only assigned to the Static Memory Controller and NCS3 behaves as defined by the SMC. */
+#define 	AT91C_EBI_CS3A_SM                   (0x1 <<  3) /**< (CCFG) Chip Select 3 is assigned to the Static Memory Controller and the SmartMedia Logic is activated. */
+#define AT91C_EBI_CS4A        (0x1 << 4 ) /**< (CCFG) Chip Select 4 Assignment */
+#define 	AT91C_EBI_CS4A_SMC                  (0x0 <<  4) /**< (CCFG) Chip Select 4 is only assigned to the Static Memory Controller and NCS4 behaves as defined by the SMC. */
+#define 	AT91C_EBI_CS4A_CF                   (0x1 <<  4) /**< (CCFG) Chip Select 4 is assigned to the Static Memory Controller and the CompactFlash Logic (first slot) is activated. */
+#define AT91C_EBI_CS5A        (0x1 << 5 ) /**< (CCFG) Chip Select 5 Assignment */
+#define 	AT91C_EBI_CS5A_SMC                  (0x0 <<  5) /**< (CCFG) Chip Select 5 is only assigned to the Static Memory Controller and NCS5 behaves as defined by the SMC */
+#define 	AT91C_EBI_CS5A_CF                   (0x1 <<  5) /**< (CCFG) Chip Select 5 is assigned to the Static Memory Controller and the CompactFlash Logic (second slot) is activated. */
+#define AT91C_EBI_DBPUC       (0x1 << 8 ) /**< (CCFG) Data Bus Pull-up Configuration */
+/* --- Register CCFG_EBI1CSA */
+#define AT91C_EBI_CS1A        (0x1 << 1 ) /**< (CCFG) Chip Select 1 Assignment */
+#define 	AT91C_EBI_CS1A_SMC                  (0x0 <<  1) /**< (CCFG) Chip Select 1 is assigned to the Static Memory Controller. */
+#define 	AT91C_EBI_CS1A_SDRAMC               (0x1 <<  1) /**< (CCFG) Chip Select 1 is assigned to the SDRAM Controller. */
+#define AT91C_EBI_CS2A        (0x1 << 2 ) /**< (CCFG) EBI1 Chip Select 2 Assignment */
+#define 	AT91C_EBI_CS2A_SMC                  (0x0 <<  2) /**< (CCFG) Chip Select 2 is assigned to the Static Memory Controller. */
+#define 	AT91C_EBI_CS2A_SM                   (0x1 <<  2) /**< (CCFG) Chip Select 2 is assigned to the Static Memory Controller and the SmartMedia Logic is activated. */
+#define AT91C_EBI_DBPUC       (0x1 << 8 ) /**< (CCFG) Data Bus Pull-up Configuration */
+
+#endif /* __AT91SAM9262_CCFG_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_ecc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_ecc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_ecc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_ecc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,75 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_ecc.h
+ * 
+ * Hardware definition for the ecc peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from HECC_6143A V1.1
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_ECC_H
+#define __AT91SAM9262_ECC_H
+
+/* -------------------------------------------------------- */
+/* ECC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* ECC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_HECC0     	0xFFFFE000 /**< HECC0 base address */
+#define AT91C_BASE_HECC1     	0xFFFFE600 /**< HECC1 base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for ECC hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for ECC hardware peripheral */
+/* -------------------------------------------------------- */
+#define ECC_CR 	(0x0000) 	/**<  ECC reset register */
+#define ECC_MR 	(0x0004) 	/**<  ECC Page size register */
+#define ECC_SR 	(0x0008) 	/**<  ECC Status register */
+#define ECC_PR 	(0x000C) 	/**<  ECC Parity register */
+#define ECC_NPR 	(0x0010) 	/**<  ECC Parity N register */
+#define ECC_VR 	(0x00FC) 	/**<  ECC Version register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for ECC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register ECC_CR */
+#define AT91C_ECC_RST         (0x1 << 0 ) /**< (ECC) ECC reset parity */
+/* --- Register ECC_MR */
+#define AT91C_ECC_PAGE_SIZE   (0x3 << 0 ) /**< (ECC) Nand Flash page size */
+/* --- Register ECC_SR */
+#define AT91C_ECC_RECERR      (0x1 << 0 ) /**< (ECC) ECC error */
+#define AT91C_ECC_ECCERR      (0x1 << 1 ) /**< (ECC) ECC single error */
+#define AT91C_ECC_MULERR      (0x1 << 2 ) /**< (ECC) ECC_MULERR */
+/* --- Register ECC_PR */
+#define AT91C_ECC_BITADDR     (0xF << 0 ) /**< (ECC) Bit address error */
+#define AT91C_ECC_WORDADDR    (0xFFF << 4 ) /**< (ECC) address of the failing bit */
+/* --- Register ECC_NPR */
+#define AT91C_ECC_NPARITY     (0xFFFF << 0 ) /**< (ECC) ECC parity N  */
+/* --- Register ECC_VR */
+#define AT91C_ECC_VR          (0xF << 0 ) /**< (ECC) ECC version register */
+
+#endif /* __AT91SAM9262_ECC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_emac.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_emac.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_emac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_emac.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,256 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_emac.h
+ * 
+ * Hardware definition for the emac peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  12/09/2005 (11:54:20) AT91 SW Application Group from EMACB_6119A V1.6
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_EMAC_H
+#define __AT91SAM9262_EMAC_H
+
+/* -------------------------------------------------------- */
+/* EMAC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_EMAC
+#define AT91C_ID_EMAC  	21 /**< Ethernet Mac id */
+#endif /* AT91C_ID_EMAC */
+
+/* -------------------------------------------------------- */
+/* EMAC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_EMAC     	0xFFFBC000 /**< MACB base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for EMAC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PC26_E_COL    	(1 << 26) /**<  */
+#define AT91C_PE22_E_CRS    	(1 << 22) /**<  */
+#define AT91C_PE31_E_F100   	(1 << 31) /**<  */
+#define AT91C_PE29_E_MDC    	(1 << 29) /**<  */
+#define AT91C_PE30_E_MDIO   	(1 << 30) /**<  */
+#define AT91C_PE25_E_RX0    	(1 << 25) /**<  */
+#define AT91C_PE26_E_RX1    	(1 << 26) /**<  */
+#define AT91C_PC22_E_RX2    	(1 << 22) /**<  */
+#define AT91C_PC23_E_RX3    	(1 << 23) /**<  */
+#define AT91C_PC27_E_RXCK   	(1 << 27) /**<  */
+#define AT91C_PC25_E_RXDV   	(1 << 25) /**<  */
+#define AT91C_PE27_E_RXER   	(1 << 27) /**<  */
+#define AT91C_PE23_E_TX0    	(1 << 23) /**<  */
+#define AT91C_PE24_E_TX1    	(1 << 24) /**<  */
+#define AT91C_PC20_E_TX2    	(1 << 20) /**<  */
+#define AT91C_PC21_E_TX3    	(1 << 21) /**<  */
+#define AT91C_PE21_E_TXCK   	(1 << 21) /**<  */
+#define AT91C_PE28_E_TXEN   	(1 << 28) /**<  */
+#define AT91C_PC24_E_TXER   	(1 << 24) /**<  */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for EMAC hardware peripheral */
+/* -------------------------------------------------------- */
+#define EMAC_NCR 	(0x0000) 	/**< Network Control Register */
+#define EMAC_NCFGR 	(0x0004) 	/**< Network Configuration Register */
+#define EMAC_NSR 	(0x0008) 	/**< Network Status Register */
+#define EMAC_TSR 	(0x0014) 	/**< Transmit Status Register */
+#define EMAC_RBQP 	(0x0018) 	/**< Receive Buffer Queue Pointer */
+#define EMAC_TBQP 	(0x001C) 	/**< Transmit Buffer Queue Pointer */
+#define EMAC_RSR 	(0x0020) 	/**< Receive Status Register */
+#define EMAC_ISR 	(0x0024) 	/**< Interrupt Status Register */
+#define EMAC_IER 	(0x0028) 	/**< Interrupt Enable Register */
+#define EMAC_IDR 	(0x002C) 	/**< Interrupt Disable Register */
+#define EMAC_IMR 	(0x0030) 	/**< Interrupt Mask Register */
+#define EMAC_MAN 	(0x0034) 	/**< PHY Maintenance Register */
+#define EMAC_PTR 	(0x0038) 	/**< Pause Time Register */
+#define EMAC_PFR 	(0x003C) 	/**< Pause Frames received Register */
+#define EMAC_FTO 	(0x0040) 	/**< Frames Transmitted OK Register */
+#define EMAC_SCF 	(0x0044) 	/**< Single Collision Frame Register */
+#define EMAC_MCF 	(0x0048) 	/**< Multiple Collision Frame Register */
+#define EMAC_FRO 	(0x004C) 	/**< Frames Received OK Register */
+#define EMAC_FCSE 	(0x0050) 	/**< Frame Check Sequence Error Register */
+#define EMAC_ALE 	(0x0054) 	/**< Alignment Error Register */
+#define EMAC_DTF 	(0x0058) 	/**< Deferred Transmission Frame Register */
+#define EMAC_LCOL 	(0x005C) 	/**< Late Collision Register */
+#define EMAC_ECOL 	(0x0060) 	/**< Excessive Collision Register */
+#define EMAC_TUND 	(0x0064) 	/**< Transmit Underrun Error Register */
+#define EMAC_CSE 	(0x0068) 	/**< Carrier Sense Error Register */
+#define EMAC_RRE 	(0x006C) 	/**< Receive Ressource Error Register */
+#define EMAC_ROV 	(0x0070) 	/**< Receive Overrun Errors Register */
+#define EMAC_RSE 	(0x0074) 	/**< Receive Symbol Errors Register */
+#define EMAC_ELE 	(0x0078) 	/**< Excessive Length Errors Register */
+#define EMAC_RJA 	(0x007C) 	/**< Receive Jabbers Register */
+#define EMAC_USF 	(0x0080) 	/**< Undersize Frames Register */
+#define EMAC_STE 	(0x0084) 	/**< SQE Test Error Register */
+#define EMAC_RLE 	(0x0088) 	/**< Receive Length Field Mismatch Register */
+#define EMAC_TPF 	(0x008C) 	/**< Transmitted Pause Frames Register */
+#define EMAC_HRB 	(0x0090) 	/**< Hash Address Bottom[31:0] */
+#define EMAC_HRT 	(0x0094) 	/**< Hash Address Top[63:32] */
+#define EMAC_SA1L 	(0x0098) 	/**< Specific Address 1 Bottom, First 4 bytes */
+#define EMAC_SA1H 	(0x009C) 	/**< Specific Address 1 Top, Last 2 bytes */
+#define EMAC_SA2L 	(0x00A0) 	/**< Specific Address 2 Bottom, First 4 bytes */
+#define EMAC_SA2H 	(0x00A4) 	/**< Specific Address 2 Top, Last 2 bytes */
+#define EMAC_SA3L 	(0x00A8) 	/**< Specific Address 3 Bottom, First 4 bytes */
+#define EMAC_SA3H 	(0x00AC) 	/**< Specific Address 3 Top, Last 2 bytes */
+#define EMAC_SA4L 	(0x00B0) 	/**< Specific Address 4 Bottom, First 4 bytes */
+#define EMAC_SA4H 	(0x00B4) 	/**< Specific Address 4 Top, Last 2 bytes */
+#define EMAC_TID 	(0x00B8) 	/**< Type ID Checking Register */
+#define EMAC_TPQ 	(0x00BC) 	/**< Transmit Pause Quantum Register */
+#define EMAC_USRIO 	(0x00C0) 	/**< USER Input/Output Register */
+#define EMAC_WOL 	(0x00C4) 	/**< Wake On LAN Register */
+#define EMAC_REV 	(0x00FC) 	/**< Revision Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for EMAC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register EMAC_NCR */
+#define AT91C_EMAC_LB         (0x1 << 0 ) /**< (EMAC) Loopback. Optional. When set, loopback signal is at high level. */
+#define AT91C_EMAC_LLB        (0x1 << 1 ) /**< (EMAC) Loopback local.  */
+#define AT91C_EMAC_RE         (0x1 << 2 ) /**< (EMAC) Receive enable.  */
+#define AT91C_EMAC_TE         (0x1 << 3 ) /**< (EMAC) Transmit enable.  */
+#define AT91C_EMAC_MPE        (0x1 << 4 ) /**< (EMAC) Management port enable.  */
+#define AT91C_EMAC_CLRSTAT    (0x1 << 5 ) /**< (EMAC) Clear statistics registers.  */
+#define AT91C_EMAC_INCSTAT    (0x1 << 6 ) /**< (EMAC) Increment statistics registers.  */
+#define AT91C_EMAC_WESTAT     (0x1 << 7 ) /**< (EMAC) Write enable for statistics registers.  */
+#define AT91C_EMAC_BP         (0x1 << 8 ) /**< (EMAC) Back pressure.  */
+#define AT91C_EMAC_TSTART     (0x1 << 9 ) /**< (EMAC) Start Transmission.  */
+#define AT91C_EMAC_THALT      (0x1 << 10) /**< (EMAC) Transmission Halt.  */
+#define AT91C_EMAC_TPFR       (0x1 << 11) /**< (EMAC) Transmit pause frame  */
+#define AT91C_EMAC_TZQ        (0x1 << 12) /**< (EMAC) Transmit zero quantum pause frame */
+/* --- Register EMAC_NCFGR */
+#define AT91C_EMAC_SPD        (0x1 << 0 ) /**< (EMAC) Speed.  */
+#define AT91C_EMAC_FD         (0x1 << 1 ) /**< (EMAC) Full duplex.  */
+#define AT91C_EMAC_JFRAME     (0x1 << 3 ) /**< (EMAC) Jumbo Frames.  */
+#define AT91C_EMAC_CAF        (0x1 << 4 ) /**< (EMAC) Copy all frames.  */
+#define AT91C_EMAC_NBC        (0x1 << 5 ) /**< (EMAC) No broadcast.  */
+#define AT91C_EMAC_MTI        (0x1 << 6 ) /**< (EMAC) Multicast hash event enable */
+#define AT91C_EMAC_UNI        (0x1 << 7 ) /**< (EMAC) Unicast hash enable.  */
+#define AT91C_EMAC_BIG        (0x1 << 8 ) /**< (EMAC) Receive 1522 bytes.  */
+#define AT91C_EMAC_EAE        (0x1 << 9 ) /**< (EMAC) External address match enable.  */
+#define AT91C_EMAC_CLK        (0x3 << 10) /**< (EMAC)  */
+#define 	AT91C_EMAC_CLK_HCLK_8               (0x0 << 10) /**< (EMAC) HCLK divided by 8 */
+#define 	AT91C_EMAC_CLK_HCLK_16              (0x1 << 10) /**< (EMAC) HCLK divided by 16 */
+#define 	AT91C_EMAC_CLK_HCLK_32              (0x2 << 10) /**< (EMAC) HCLK divided by 32 */
+#define 	AT91C_EMAC_CLK_HCLK_64              (0x3 << 10) /**< (EMAC) HCLK divided by 64 */
+#define AT91C_EMAC_RTY        (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PAE        (0x1 << 13) /**< (EMAC)  */
+#define AT91C_EMAC_RBOF       (0x3 << 14) /**< (EMAC)  */
+#define 	AT91C_EMAC_RBOF_OFFSET_0             (0x0 << 14) /**< (EMAC) no offset from start of receive buffer */
+#define 	AT91C_EMAC_RBOF_OFFSET_1             (0x1 << 14) /**< (EMAC) one byte offset from start of receive buffer */
+#define 	AT91C_EMAC_RBOF_OFFSET_2             (0x2 << 14) /**< (EMAC) two bytes offset from start of receive buffer */
+#define 	AT91C_EMAC_RBOF_OFFSET_3             (0x3 << 14) /**< (EMAC) three bytes offset from start of receive buffer */
+#define AT91C_EMAC_RLCE       (0x1 << 16) /**< (EMAC) Receive Length field Checking Enable */
+#define AT91C_EMAC_DRFCS      (0x1 << 17) /**< (EMAC) Discard Receive FCS */
+#define AT91C_EMAC_EFRHD      (0x1 << 18) /**< (EMAC)  */
+#define AT91C_EMAC_IRXFCS     (0x1 << 19) /**< (EMAC) Ignore RX FCS */
+/* --- Register EMAC_NSR */
+#define AT91C_EMAC_LINKR      (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_MDIO       (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_IDLE       (0x1 << 2 ) /**< (EMAC)  */
+/* --- Register EMAC_TSR */
+#define AT91C_EMAC_UBR        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_COL        (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLES       (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TGO        (0x1 << 3 ) /**< (EMAC) Transmit Go */
+#define AT91C_EMAC_BEX        (0x1 << 4 ) /**< (EMAC) Buffers exhausted mid frame */
+#define AT91C_EMAC_COMP       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_UND        (0x1 << 6 ) /**< (EMAC)  */
+/* --- Register EMAC_RSR */
+#define AT91C_EMAC_BNA        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_REC        (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_OVR        (0x1 << 2 ) /**< (EMAC)  */
+/* --- Register EMAC_ISR */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_IER */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_IDR */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_IMR */
+#define AT91C_EMAC_MFD        (0x1 << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_RCOMP      (0x1 << 1 ) /**< (EMAC)  */
+#define AT91C_EMAC_RXUBR      (0x1 << 2 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXUBR      (0x1 << 3 ) /**< (EMAC)  */
+#define AT91C_EMAC_TUNDR      (0x1 << 4 ) /**< (EMAC)  */
+#define AT91C_EMAC_RLEX       (0x1 << 5 ) /**< (EMAC)  */
+#define AT91C_EMAC_TXERR      (0x1 << 6 ) /**< (EMAC)  */
+#define AT91C_EMAC_TCOMP      (0x1 << 7 ) /**< (EMAC)  */
+#define AT91C_EMAC_LINK       (0x1 << 9 ) /**< (EMAC)  */
+#define AT91C_EMAC_ROVR       (0x1 << 10) /**< (EMAC)  */
+#define AT91C_EMAC_HRESP      (0x1 << 11) /**< (EMAC)  */
+#define AT91C_EMAC_PFRE       (0x1 << 12) /**< (EMAC)  */
+#define AT91C_EMAC_PTZ        (0x1 << 13) /**< (EMAC)  */
+/* --- Register EMAC_MAN */
+#define AT91C_EMAC_DATA       (0xFFFF << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_CODE       (0x3 << 16) /**< (EMAC)  */
+#define AT91C_EMAC_REGA       (0x1F << 18) /**< (EMAC)  */
+#define AT91C_EMAC_PHYA       (0x1F << 23) /**< (EMAC)  */
+#define AT91C_EMAC_RW         (0x3 << 28) /**< (EMAC)  */
+#define AT91C_EMAC_SOF        (0x3 << 30) /**< (EMAC)  */
+/* --- Register EMAC_USRIO */
+#define AT91C_EMAC_RMII       (0x1 << 0 ) /**< (EMAC) Reduce MII */
+#define AT91C_EMAC_CLKEN      (0x1 << 1 ) /**< (EMAC) Clock Enable */
+/* --- Register EMAC_WOL */
+#define AT91C_EMAC_IP         (0xFFFF << 0 ) /**< (EMAC) ARP request IP address */
+#define AT91C_EMAC_MAG        (0x1 << 16) /**< (EMAC) Magic packet event enable */
+#define AT91C_EMAC_ARP        (0x1 << 17) /**< (EMAC) ARP request event enable */
+#define AT91C_EMAC_SA1        (0x1 << 18) /**< (EMAC) Specific address register 1 event enable */
+#define AT91C_EMAC_WOL_MTI    (0x1 << 19) /**< (EMAC) Multicast hash event enable */
+/* --- Register EMAC_REV */
+#define AT91C_EMAC_REVREF     (0xFFFF << 0 ) /**< (EMAC)  */
+#define AT91C_EMAC_PARTREF    (0xFFFF << 16) /**< (EMAC)  */
+
+#endif /* __AT91SAM9262_EMAC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_lcdc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_lcdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_lcdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_lcdc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,304 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_lcdc.h
+ * 
+ * Hardware definition for the lcdc peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  12/09/2005 (11:54:20) AT91 SW Application Group from LCDC_6063A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_LCDC_H
+#define __AT91SAM9262_LCDC_H
+
+/* -------------------------------------------------------- */
+/* LCDC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_LCDC
+#define AT91C_ID_LCDC  	26 /**< LCD Controller id */
+#endif /* AT91C_ID_LCDC */
+
+/* -------------------------------------------------------- */
+/* LCDC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_LCDC      	0x00700000 /**< LCDC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for LCDC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PB9_LCDCC    	(1 << 9) /**<  */
+#define AT91C_PC4_LCDD0    	(1 << 4) /**<  */
+#define AT91C_PC5_LCDD1    	(1 << 5) /**<  */
+#define AT91C_PC14_LCDD10   	(1 << 14) /**<  */
+#define AT91C_PC9_LCDD10B  	(1 << 9) /**<  */
+#define AT91C_PC15_LCDD11   	(1 << 15) /**<  */
+#define AT91C_PC10_LCDD11B  	(1 << 10) /**<  */
+#define AT91C_PC16_LCDD12   	(1 << 16) /**<  */
+#define AT91C_PC11_LCDD12B  	(1 << 11) /**<  */
+#define AT91C_PC17_LCDD13   	(1 << 17) /**<  */
+#define AT91C_PC12_LCDD13B  	(1 << 12) /**<  */
+#define AT91C_PC18_LCDD14   	(1 << 18) /**<  */
+#define AT91C_PC13_LCDD14B  	(1 << 13) /**<  */
+#define AT91C_PC19_LCDD15   	(1 << 19) /**<  */
+#define AT91C_PC14_LCDD15B  	(1 << 14) /**<  */
+#define AT91C_PC20_LCDD16   	(1 << 20) /**<  */
+#define AT91C_PC21_LCDD17   	(1 << 21) /**<  */
+#define AT91C_PC22_LCDD18   	(1 << 22) /**<  */
+#define AT91C_PC23_LCDD19   	(1 << 23) /**<  */
+#define AT91C_PC15_LCDD19B  	(1 << 15) /**<  */
+#define AT91C_PC6_LCDD2    	(1 << 6) /**<  */
+#define AT91C_PC24_LCDD20   	(1 << 24) /**<  */
+#define AT91C_PC16_LCDD20B  	(1 << 16) /**<  */
+#define AT91C_PC25_LCDD21   	(1 << 25) /**<  */
+#define AT91C_PC17_LCDD21B  	(1 << 17) /**<  */
+#define AT91C_PC26_LCDD22   	(1 << 26) /**<  */
+#define AT91C_PC18_LCDD22B  	(1 << 18) /**<  */
+#define AT91C_PC27_LCDD23   	(1 << 27) /**<  */
+#define AT91C_PC19_LCDD23B  	(1 << 19) /**<  */
+#define AT91C_PC7_LCDD3    	(1 << 7) /**<  */
+#define AT91C_PC4_LCDD3B   	(1 << 4) /**<  */
+#define AT91C_PC8_LCDD4    	(1 << 8) /**<  */
+#define AT91C_PC5_LCDD4B   	(1 << 5) /**<  */
+#define AT91C_PC9_LCDD5    	(1 << 9) /**<  */
+#define AT91C_PC6_LCDD5B   	(1 << 6) /**<  */
+#define AT91C_PC10_LCDD6    	(1 << 10) /**<  */
+#define AT91C_PC7_LCDD6B   	(1 << 7) /**<  */
+#define AT91C_PC11_LCDD7    	(1 << 11) /**<  */
+#define AT91C_PC8_LCDD7B   	(1 << 8) /**<  */
+#define AT91C_PC12_LCDD8    	(1 << 12) /**<  */
+#define AT91C_PC13_LCDD9    	(1 << 13) /**<  */
+#define AT91C_PC2_LCDDOTCK 	(1 << 2) /**<  */
+#define AT91C_PC3_LCDEN    	(1 << 3) /**<  */
+#define AT91C_PC1_LCDHSYNC 	(1 << 1) /**<  */
+#define AT91C_PC0_LCDVSYNC 	(1 << 0) /**<  */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for LCDC hardware peripheral */
+/* -------------------------------------------------------- */
+#define LCDC_BA1 	(0x0000) 	/**< DMA Base Address Register 1 */
+#define LCDC_BA2 	(0x0004) 	/**< DMA Base Address Register 2 */
+#define LCDC_FRMP1 	(0x0008) 	/**< DMA Frame Pointer Register 1 */
+#define LCDC_FRMP2 	(0x000C) 	/**< DMA Frame Pointer Register 2 */
+#define LCDC_FRMA1 	(0x0010) 	/**< DMA Frame Address Register 1 */
+#define LCDC_FRMA2 	(0x0014) 	/**< DMA Frame Address Register 2 */
+#define LCDC_FRMCFG 	(0x0018) 	/**< DMA Frame Configuration Register */
+#define LCDC_DMACON 	(0x001C) 	/**< DMA Control Register */
+#define LCDC_DMA2DCFG 	(0x0020) 	/**< DMA 2D addressing configuration */
+#define LCDC_LCDCON1 	(0x0800) 	/**< LCD Control 1 Register */
+#define LCDC_LCDCON2 	(0x0804) 	/**< LCD Control 2 Register */
+#define LCDC_TIM1 	(0x0808) 	/**< LCD Timing Config 1 Register */
+#define LCDC_TIM2 	(0x080C) 	/**< LCD Timing Config 2 Register */
+#define LCDC_LCDFRCFG 	(0x0810) 	/**< LCD Frame Config Register */
+#define LCDC_FIFO 	(0x0814) 	/**< LCD FIFO Register */
+#define LCDC_MVAL 	(0x0818) 	/**< LCD Mode Toggle Rate Value Register */
+#define LCDC_DP1_2 	(0x081C) 	/**< Dithering Pattern DP1_2 Register */
+#define LCDC_DP4_7 	(0x0820) 	/**< Dithering Pattern DP4_7 Register */
+#define LCDC_DP3_5 	(0x0824) 	/**< Dithering Pattern DP3_5 Register */
+#define LCDC_DP2_3 	(0x0828) 	/**< Dithering Pattern DP2_3 Register */
+#define LCDC_DP5_7 	(0x082C) 	/**< Dithering Pattern DP5_7 Register */
+#define LCDC_DP3_4 	(0x0830) 	/**< Dithering Pattern DP3_4 Register */
+#define LCDC_DP4_5 	(0x0834) 	/**< Dithering Pattern DP4_5 Register */
+#define LCDC_DP6_7 	(0x0838) 	/**< Dithering Pattern DP6_7 Register */
+#define LCDC_PWRCON 	(0x083C) 	/**< Power Control Register */
+#define LCDC_CTRSTCON 	(0x0840) 	/**< Contrast Control Register */
+#define LCDC_CTRSTVAL 	(0x0844) 	/**< Contrast Value Register */
+#define LCDC_IER 	(0x0848) 	/**< Interrupt Enable Register */
+#define LCDC_IDR 	(0x084C) 	/**< Interrupt Disable Register */
+#define LCDC_IMR 	(0x0850) 	/**< Interrupt Mask Register */
+#define LCDC_ISR 	(0x0854) 	/**< Interrupt Enable Register */
+#define LCDC_ICR 	(0x0858) 	/**< Interrupt Clear Register */
+#define LCDC_GPR 	(0x085C) 	/**< General Purpose Register */
+#define LCDC_ITR 	(0x0860) 	/**< Interrupts Test Register */
+#define LCDC_IRR 	(0x0864) 	/**< Interrupts Raw Status Register */
+#define LCDC_LUT_ENTRY 	(0x0C00) 	/**< LUT Entries Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for LCDC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register LCDC_FRMP1 */
+#define AT91C_LCDC_FRMPT1     (0x3FFFFF << 0 ) /**< (LCDC) Frame Pointer Address 1 */
+/* --- Register LCDC_FRMP2 */
+#define AT91C_LCDC_FRMPT2     (0x1FFFFF << 0 ) /**< (LCDC) Frame Pointer Address 2 */
+/* --- Register LCDC_FRMCFG */
+#define AT91C_LCDC_FRSIZE     (0x3FFFFF << 0 ) /**< (LCDC) FRAME SIZE */
+#define AT91C_LCDC_BLENGTH    (0xF << 24) /**< (LCDC) BURST LENGTH */
+/* --- Register LCDC_DMACON */
+#define AT91C_LCDC_DMAEN      (0x1 << 0 ) /**< (LCDC) DAM Enable */
+#define AT91C_LCDC_DMARST     (0x1 << 1 ) /**< (LCDC) DMA Reset (WO) */
+#define AT91C_LCDC_DMABUSY    (0x1 << 2 ) /**< (LCDC) DMA Reset (WO) */
+#define AT91C_LCDC_DMAUPDT    (0x1 << 3 ) /**< (LCDC) DMA Configuration Update */
+#define AT91C_LCDC_DMA2DEN    (0x1 << 4 ) /**< (LCDC) 2D Addressing Enable */
+/* --- Register LCDC_DMA2DCFG */
+#define AT91C_LCDC_ADDRINC    (0xFFFF << 0 ) /**< (LCDC) Number of 32b words that the DMA must jump when going to the next line */
+#define AT91C_LCDC_PIXELOFF   (0x1F << 24) /**< (LCDC) Offset (in bits) of the first pixel of the screen in the memory word which contain it */
+/* --- Register LCDC_LCDCON1 */
+#define AT91C_LCDC_BYPASS     (0x1 << 0 ) /**< (LCDC) Bypass lcd_pccklk divider */
+#define AT91C_LCDC_CLKVAL     (0x1FF << 12) /**< (LCDC) 9-bit Divider for pixel clock frequency */
+#define AT91C_LCDC_LINCNT     (0x7FF << 21) /**< (LCDC) Line Counter (RO) */
+/* --- Register LCDC_LCDCON2 */
+#define AT91C_LCDC_DISTYPE    (0x3 << 0 ) /**< (LCDC) Display Type */
+#define 	AT91C_LCDC_DISTYPE_STNMONO              0x0 /**< (LCDC) STN Mono */
+#define 	AT91C_LCDC_DISTYPE_STNCOLOR             0x1 /**< (LCDC) STN Color */
+#define 	AT91C_LCDC_DISTYPE_TFT                  0x2 /**< (LCDC) TFT */
+#define AT91C_LCDC_SCANMOD    (0x1 << 2 ) /**< (LCDC) Scan Mode */
+#define 	AT91C_LCDC_SCANMOD_SINGLESCAN           (0x0 <<  2) /**< (LCDC) Single Scan */
+#define 	AT91C_LCDC_SCANMOD_DUALSCAN             (0x1 <<  2) /**< (LCDC) Dual Scan */
+#define AT91C_LCDC_IFWIDTH    (0x3 << 3 ) /**< (LCDC) Interface Width */
+#define 	AT91C_LCDC_IFWIDTH_FOURBITSWIDTH        (0x0 <<  3) /**< (LCDC) 4 Bits */
+#define 	AT91C_LCDC_IFWIDTH_EIGTHBITSWIDTH       (0x1 <<  3) /**< (LCDC) 8 Bits */
+#define 	AT91C_LCDC_IFWIDTH_SIXTEENBITSWIDTH     (0x2 <<  3) /**< (LCDC) 16 Bits */
+#define AT91C_LCDC_PIXELSIZE  (0x7 << 5 ) /**< (LCDC) Bits per pixel */
+#define 	AT91C_LCDC_PIXELSIZE_ONEBITSPERPIXEL      (0x0 <<  5) /**< (LCDC) 1 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_TWOBITSPERPIXEL      (0x1 <<  5) /**< (LCDC) 2 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_FOURBITSPERPIXEL     (0x2 <<  5) /**< (LCDC) 4 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_EIGTHBITSPERPIXEL    (0x3 <<  5) /**< (LCDC) 8 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_SIXTEENBITSPERPIXEL  (0x4 <<  5) /**< (LCDC) 16 Bits */
+#define 	AT91C_LCDC_PIXELSIZE_TWENTYFOURBITSPERPIXEL (0x5 <<  5) /**< (LCDC) 24 Bits */
+#define AT91C_LCDC_INVVD      (0x1 << 8 ) /**< (LCDC) lcd datas polarity */
+#define 	AT91C_LCDC_INVVD_NORMALPOL            (0x0 <<  8) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVVD_INVERTEDPOL          (0x1 <<  8) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVFRAME   (0x1 << 9 ) /**< (LCDC) lcd vsync polarity */
+#define 	AT91C_LCDC_INVFRAME_NORMALPOL            (0x0 <<  9) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVFRAME_INVERTEDPOL          (0x1 <<  9) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVLINE    (0x1 << 10) /**< (LCDC) lcd hsync polarity */
+#define 	AT91C_LCDC_INVLINE_NORMALPOL            (0x0 << 10) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVLINE_INVERTEDPOL          (0x1 << 10) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVCLK     (0x1 << 11) /**< (LCDC) lcd pclk polarity */
+#define 	AT91C_LCDC_INVCLK_NORMALPOL            (0x0 << 11) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVCLK_INVERTEDPOL          (0x1 << 11) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_INVDVAL    (0x1 << 12) /**< (LCDC) lcd dval polarity */
+#define 	AT91C_LCDC_INVDVAL_NORMALPOL            (0x0 << 12) /**< (LCDC) Normal Polarity */
+#define 	AT91C_LCDC_INVDVAL_INVERTEDPOL          (0x1 << 12) /**< (LCDC) Inverted Polarity */
+#define AT91C_LCDC_CLKMOD     (0x1 << 15) /**< (LCDC) lcd pclk Mode */
+#define 	AT91C_LCDC_CLKMOD_ACTIVEONLYDISP       (0x0 << 15) /**< (LCDC) Active during display period */
+#define 	AT91C_LCDC_CLKMOD_ALWAYSACTIVE         (0x1 << 15) /**< (LCDC) Always Active */
+#define AT91C_LCDC_MEMOR      (0x1 << 31) /**< (LCDC) lcd pclk Mode */
+#define 	AT91C_LCDC_MEMOR_BIGIND               (0x0 << 31) /**< (LCDC) Big Endian */
+#define 	AT91C_LCDC_MEMOR_LITTLEIND            (0x1 << 31) /**< (LCDC) Little Endian */
+/* --- Register LCDC_TIM1 */
+#define AT91C_LCDC_VFP        (0xFF << 0 ) /**< (LCDC) Vertical Front Porch */
+#define AT91C_LCDC_VBP        (0xFF << 8 ) /**< (LCDC) Vertical Back Porch */
+#define AT91C_LCDC_VPW        (0x3F << 16) /**< (LCDC) Vertical Synchronization Pulse Width */
+#define AT91C_LCDC_VHDLY      (0xF << 24) /**< (LCDC) Vertical to Horizontal Delay */
+/* --- Register LCDC_TIM2 */
+#define AT91C_LCDC_HBP        (0xFF << 0 ) /**< (LCDC) Horizontal Back Porch */
+#define AT91C_LCDC_HPW        (0x3F << 8 ) /**< (LCDC) Horizontal Synchronization Pulse Width */
+#define AT91C_LCDC_HFP        (0x3FF << 22) /**< (LCDC) Horizontal Front Porch */
+/* --- Register LCDC_LCDFRCFG */
+#define AT91C_LCDC_LINEVAL    (0x7FF << 0 ) /**< (LCDC) Vertical Size of LCD Module */
+#define AT91C_LCDC_HOZVAL     (0x7FF << 21) /**< (LCDC) Horizontal Size of LCD Module */
+/* --- Register LCDC_FIFO */
+#define AT91C_LCDC_FIFOTH     (0xFFFF << 0 ) /**< (LCDC) FIFO Threshold */
+/* --- Register LCDC_MVAL */
+#define AT91C_LCDC_MVALUE     (0xFF << 0 ) /**< (LCDC) Toggle Rate Value */
+#define AT91C_LCDC_MMODE      (0x1 << 31) /**< (LCDC) Toggle Rate Sel */
+#define 	AT91C_LCDC_MMODE_EACHFRAME            (0x0 << 31) /**< (LCDC) Each Frame */
+#define 	AT91C_LCDC_MMODE_MVALDEFINED          (0x1 << 31) /**< (LCDC) Defined by MVAL */
+/* --- Register LCDC_DP1_2 */
+#define AT91C_LCDC_DP1_2_FIELD (0xFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP4_7 */
+#define AT91C_LCDC_DP4_7_FIELD (0xFFFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP3_5 */
+#define AT91C_LCDC_DP3_5_FIELD (0xFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP2_3 */
+#define AT91C_LCDC_DP2_3_FIELD (0xFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP5_7 */
+#define AT91C_LCDC_DP5_7_FIELD (0xFFFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP3_4 */
+#define AT91C_LCDC_DP3_4_FIELD (0xFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP4_5 */
+#define AT91C_LCDC_DP4_5_FIELD (0xFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_DP6_7 */
+#define AT91C_LCDC_DP6_7_FIELD (0xFFFFFFF << 0 ) /**< (LCDC) Ratio */
+/* --- Register LCDC_PWRCON */
+#define AT91C_LCDC_PWR        (0x1 << 0 ) /**< (LCDC) LCD Module Power Control */
+#define AT91C_LCDC_GUARDT     (0x7F << 1 ) /**< (LCDC) Delay in Frame Period */
+#define AT91C_LCDC_BUSY       (0x1 << 31) /**< (LCDC) Read Only : 1 indicates that LCDC is busy */
+#define 	AT91C_LCDC_BUSY_LCDNOTBUSY           (0x0 << 31) /**< (LCDC) LCD is Not Busy */
+#define 	AT91C_LCDC_BUSY_LCDBUSY              (0x1 << 31) /**< (LCDC) LCD is Busy */
+/* --- Register LCDC_CTRSTCON */
+#define AT91C_LCDC_PS         (0x3 << 0 ) /**< (LCDC) LCD Contrast Counter Prescaler */
+#define 	AT91C_LCDC_PS_NOTDIVIDED           0x0 /**< (LCDC) Counter Freq is System Freq. */
+#define 	AT91C_LCDC_PS_DIVIDEDBYTWO         0x1 /**< (LCDC) Counter Freq is System Freq divided by 2. */
+#define 	AT91C_LCDC_PS_DIVIDEDBYFOUR        0x2 /**< (LCDC) Counter Freq is System Freq divided by 4. */
+#define 	AT91C_LCDC_PS_DIVIDEDBYEIGHT       0x3 /**< (LCDC) Counter Freq is System Freq divided by 8. */
+#define AT91C_LCDC_POL        (0x1 << 2 ) /**< (LCDC) Polarity of output Pulse */
+#define 	AT91C_LCDC_POL_NEGATIVEPULSE        (0x0 <<  2) /**< (LCDC) Negative Pulse */
+#define 	AT91C_LCDC_POL_POSITIVEPULSE        (0x1 <<  2) /**< (LCDC) Positive Pulse */
+#define AT91C_LCDC_ENA        (0x1 << 3 ) /**< (LCDC) PWM generator Control */
+#define 	AT91C_LCDC_ENA_PWMGEMDISABLED       (0x0 <<  3) /**< (LCDC) PWM Generator Disabled */
+#define 	AT91C_LCDC_ENA_PWMGEMENABLED        (0x1 <<  3) /**< (LCDC) PWM Generator Disabled */
+/* --- Register LCDC_CTRSTVAL */
+#define AT91C_LCDC_CVAL       (0xFF << 0 ) /**< (LCDC) PWM Compare Value */
+/* --- Register LCDC_IER */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+/* --- Register LCDC_IDR */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+/* --- Register LCDC_IMR */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+/* --- Register LCDC_ISR */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+/* --- Register LCDC_ICR */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+/* --- Register LCDC_GPR */
+#define AT91C_LCDC_GPRBUS     (0xFF << 0 ) /**< (LCDC) 8 bits available */
+/* --- Register LCDC_ITR */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+/* --- Register LCDC_IRR */
+#define AT91C_LCDC_LNI        (0x1 << 0 ) /**< (LCDC) Line Interrupt */
+#define AT91C_LCDC_LSTLNI     (0x1 << 1 ) /**< (LCDC) Last Line Interrupt */
+#define AT91C_LCDC_EOFI       (0x1 << 2 ) /**< (LCDC) End Of Frame Interrupt */
+#define AT91C_LCDC_UFLWI      (0x1 << 4 ) /**< (LCDC) FIFO Underflow Interrupt */
+#define AT91C_LCDC_OWRI       (0x1 << 5 ) /**< (LCDC) Over Write Interrupt */
+#define AT91C_LCDC_MERI       (0x1 << 6 ) /**< (LCDC) Memory Error  Interrupt */
+
+#endif /* __AT91SAM9262_LCDC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_matrix.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_matrix.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_matrix.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_matrix.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,199 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_matrix.h
+ * 
+ * Hardware definition for the matrix peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from HMATRIX1_SAM9262 V1.8
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_MATRIX_H
+#define __AT91SAM9262_MATRIX_H
+
+/* -------------------------------------------------------- */
+/* MATRIX ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* MATRIX Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_MATRIX    	0xFFFFEC00 /**< MATRIX base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+#define MATRIX_MCFG0 	(0x0000) 	/**<  Master Configuration Register 0 (rom)      */
+#define MATRIX_MCFG1 	(0x0004) 	/**<  Master Configuration Register 1 (htcm)     */
+#define MATRIX_MCFG2 	(0x0008) 	/**<  Master Configuration Register 2 (gps_tcm)  */
+#define MATRIX_MCFG3 	(0x000C) 	/**<  Master Configuration Register 3 (hperiphs) */
+#define MATRIX_MCFG4 	(0x0010) 	/**<  Master Configuration Register 4 (ebi0)     */
+#define MATRIX_MCFG5 	(0x0014) 	/**<  Master Configuration Register 5 (ebi1)     */
+#define MATRIX_MCFG6 	(0x0018) 	/**<  Master Configuration Register 6 (bridge)   */
+#define MATRIX_MCFG7 	(0x001C) 	/**<  Master Configuration Register 7 (gps)      */
+#define MATRIX_MCFG8 	(0x0020) 	/**<  Master Configuration Register 8 (gps)      */
+#define MATRIX_SCFG0 	(0x0040) 	/**<  Slave Configuration Register 0 */
+#define MATRIX_SCFG1 	(0x0044) 	/**<  Slave Configuration Register 1 */
+#define MATRIX_SCFG2 	(0x0048) 	/**<  Slave Configuration Register 2 */
+#define MATRIX_SCFG3 	(0x004C) 	/**<  Slave Configuration Register 3 */
+#define MATRIX_SCFG4 	(0x0050) 	/**<  Slave Configuration Register 4 */
+#define MATRIX_SCFG5 	(0x0054) 	/**<  Slave Configuration Register 5 */
+#define MATRIX_SCFG6 	(0x0058) 	/**<  Slave Configuration Register 6 */
+#define MATRIX_SCFG7 	(0x005C) 	/**<  Slave Configuration Register 7 */
+#define MATRIX_PRAS0 	(0x0080) 	/**<  PRAS0 */
+#define MATRIX_PRBS0 	(0x0084) 	/**<  PRBS0 */
+#define MATRIX_PRAS1 	(0x0088) 	/**<  PRAS1 */
+#define MATRIX_PRBS1 	(0x008C) 	/**<  PRBS1 */
+#define MATRIX_PRAS2 	(0x0090) 	/**<  PRAS2 */
+#define MATRIX_PRBS2 	(0x0094) 	/**<  PRBS2 */
+#define MATRIX_PRAS3 	(0x0098) 	/**<  PRAS3 */
+#define MATRIX_PRBS3 	(0x009C) 	/**<  PRBS3 */
+#define MATRIX_PRAS4 	(0x00A0) 	/**<  PRAS4 */
+#define MATRIX_PRBS4 	(0x00A4) 	/**<  PRBS4 */
+#define MATRIX_PRAS5 	(0x00A8) 	/**<  PRAS5 */
+#define MATRIX_PRBS5 	(0x00AC) 	/**<  PRBS5 */
+#define MATRIX_PRAS6 	(0x00B0) 	/**<  PRAS6 */
+#define MATRIX_PRBS6 	(0x00B4) 	/**<  PRBS6 */
+#define MATRIX_PRAS7 	(0x00B8) 	/**<  PRAS7 */
+#define MATRIX_PRBS7 	(0x00BC) 	/**<  PRBS7 */
+#define MATRIX_MRCR 	(0x0100) 	/**<  Master Remp Control Register  */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for MATRIX hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register MATRIX_MCFG0 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG1 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG2 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG3 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG4 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG5 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG6 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG7 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_MCFG8 */
+#define AT91C_MATRIX_RCA926I  (0x1 << 0 ) /**< (MATRIX) Remap Command for ARM926EJ-S Instruction Master */
+#define AT91C_MATRIX_RCA926D  (0x1 << 1 ) /**< (MATRIX) Remap Command for ARM926EJ-S Data Master */
+/* --- Register MATRIX_SCFG0 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR0 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG1 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR1 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG2 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR2 (0x1 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+/* --- Register MATRIX_SCFG3 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR3 (0x7 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_LCDC                 (0x3 << 18) /**< (MATRIX) LCDC Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_UHP                  (0x4 << 18) /**< (MATRIX) UHP Master is Default Master */
+/* --- Register MATRIX_SCFG4 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR4 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+/* --- Register MATRIX_SCFG5 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR5 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR5_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR5_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR5_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+/* --- Register MATRIX_SCFG6 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR6 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR6_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR6_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR6_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+/* --- Register MATRIX_SCFG7 */
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF << 0 ) /**< (MATRIX) Maximum Number of Allowed Cycles for a Burst */
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) /**< (MATRIX) Default Master Type */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) /**< (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) /**< (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave. */
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) /**< (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave. */
+#define AT91C_MATRIX_FIXED_DEFMSTR7 (0x3 << 18) /**< (MATRIX) Fixed Index of Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR7_ARM926I              (0x0 << 18) /**< (MATRIX) ARM926EJ-S Instruction Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR7_ARM926D              (0x1 << 18) /**< (MATRIX) ARM926EJ-S Data Master is Default Master */
+#define 	AT91C_MATRIX_FIXED_DEFMSTR7_HPDC3                (0x2 << 18) /**< (MATRIX) HPDC3 Master is Default Master */
+
+#endif /* __AT91SAM9262_MATRIX_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pdc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pdc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pdc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pdc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,44 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_pdc.h
+ * 
+ * Hardware definition for the pdc peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:32) AT91 SW Application Group from PDC_6074C V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_PDC_H
+#define __AT91SAM9262_PDC_H
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PDC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PDC_PTCR */
+#define AT91C_PDC_RXTEN       (0x1 << 0 ) /**< (PDC) Receiver Transfer Enable */
+#define AT91C_PDC_RXTDIS      (0x1 << 1 ) /**< (PDC) Receiver Transfer Disable */
+#define AT91C_PDC_TXTEN       (0x1 << 8 ) /**< (PDC) Transmitter Transfer Enable */
+#define AT91C_PDC_TXTDIS      (0x1 << 9 ) /**< (PDC) Transmitter Transfer Disable */
+/* --- Register PDC_PTSR */
+#define AT91C_PDC_RXTEN       (0x1 << 0 ) /**< (PDC) Receiver Transfer Enable */
+#define AT91C_PDC_TXTEN       (0x1 << 8 ) /**< (PDC) Transmitter Transfer Enable */
+
+#endif /* __AT91SAM9262_PDC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pio.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pio.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pio.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,97 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_pio.h
+ * 
+ * Hardware definition for the pio peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from PIO_6057A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_PIO_H
+#define __AT91SAM9262_PIO_H
+
+/* -------------------------------------------------------- */
+/* PIO ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_PIOA
+#define AT91C_ID_PIOA  	 2 /**< Parallel IO Controller A id */
+#endif /* AT91C_ID_PIOA */
+
+#ifndef AT91C_ID_PIOB
+#define AT91C_ID_PIOB  	 3 /**< Parallel IO Controller B id */
+#endif /* AT91C_ID_PIOB */
+
+#ifndef AT91C_ID_PIOCDE
+#define AT91C_ID_PIOCDE 	 4 /**< Parallel IO Controller C, Parallel IO Controller D, Parallel IO Controller E id */
+#endif /* AT91C_ID_PIOCDE */
+
+/* -------------------------------------------------------- */
+/* PIO Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PIOA      	0xFFFFF200 /**< PIOA base address */
+#define AT91C_BASE_PIOB      	0xFFFFF400 /**< PIOB base address */
+#define AT91C_BASE_PIOC      	0xFFFFF600 /**< PIOC base address */
+#define AT91C_BASE_PIOD      	0xFFFFF800 /**< PIOD base address */
+#define AT91C_BASE_PIOE      	0xFFFFFA00 /**< PIOE base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+#define PIO_PER 	(0x0000) 	/**< PIO Enable Register */
+#define PIO_PDR 	(0x0004) 	/**< PIO Disable Register */
+#define PIO_PSR 	(0x0008) 	/**< PIO Status Register */
+#define PIO_OER 	(0x0010) 	/**< Output Enable Register */
+#define PIO_ODR 	(0x0014) 	/**< Output Disable Registerr */
+#define PIO_OSR 	(0x0018) 	/**< Output Status Register */
+#define PIO_IFER 	(0x0020) 	/**< Input Filter Enable Register */
+#define PIO_IFDR 	(0x0024) 	/**< Input Filter Disable Register */
+#define PIO_IFSR 	(0x0028) 	/**< Input Filter Status Register */
+#define PIO_SODR 	(0x0030) 	/**< Set Output Data Register */
+#define PIO_CODR 	(0x0034) 	/**< Clear Output Data Register */
+#define PIO_ODSR 	(0x0038) 	/**< Output Data Status Register */
+#define PIO_PDSR 	(0x003C) 	/**< Pin Data Status Register */
+#define PIO_IER 	(0x0040) 	/**< Interrupt Enable Register */
+#define PIO_IDR 	(0x0044) 	/**< Interrupt Disable Register */
+#define PIO_IMR 	(0x0048) 	/**< Interrupt Mask Register */
+#define PIO_ISR 	(0x004C) 	/**< Interrupt Status Register */
+#define PIO_MDER 	(0x0050) 	/**< Multi-driver Enable Register */
+#define PIO_MDDR 	(0x0054) 	/**< Multi-driver Disable Register */
+#define PIO_MDSR 	(0x0058) 	/**< Multi-driver Status Register */
+#define PIO_PPUDR 	(0x0060) 	/**< Pull-up Disable Register */
+#define PIO_PPUER 	(0x0064) 	/**< Pull-up Enable Register */
+#define PIO_PPUSR 	(0x0068) 	/**< Pull-up Status Register */
+#define PIO_ASR 	(0x0070) 	/**< Select A Register */
+#define PIO_BSR 	(0x0074) 	/**< Select B Register */
+#define PIO_ABSR 	(0x0078) 	/**< AB Select Status Register */
+#define PIO_OWER 	(0x00A0) 	/**< Output Write Enable Register */
+#define PIO_OWDR 	(0x00A4) 	/**< Output Write Disable Register */
+#define PIO_OWSR 	(0x00A8) 	/**< Output Write Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PIO hardware peripheral */
+/* -------------------------------------------------------- */
+
+#endif /* __AT91SAM9262_PIO_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pitc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pitc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pitc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pitc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,72 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_pitc.h
+ * 
+ * Hardware definition for the pitc peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from PITC_6079A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_PITC_H
+#define __AT91SAM9262_PITC_H
+
+/* -------------------------------------------------------- */
+/* PITC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SYS
+#define AT91C_ID_SYS   	 1 /**< System Controller id */
+#endif /* AT91C_ID_SYS */
+
+/* -------------------------------------------------------- */
+/* PITC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PITC      	0xFFFFFD30 /**< PITC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PITC_PIMR 	(0x0000) 	/**< Period Interval Mode Register */
+#define PITC_PISR 	(0x0004) 	/**< Period Interval Status Register */
+#define PITC_PIVR 	(0x0008) 	/**< Period Interval Value Register */
+#define PITC_PIIR 	(0x000C) 	/**< Period Interval Image Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PITC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PITC_PIMR */
+#define AT91C_PITC_PIV        (0xFFFFF << 0 ) /**< (PITC) Periodic Interval Value */
+#define AT91C_PITC_PITEN      (0x1 << 24) /**< (PITC) Periodic Interval Timer Enabled */
+#define AT91C_PITC_PITIEN     (0x1 << 25) /**< (PITC) Periodic Interval Timer Interrupt Enable */
+/* --- Register PITC_PISR */
+#define AT91C_PITC_PITS       (0x1 << 0 ) /**< (PITC) Periodic Interval Timer Status */
+/* --- Register PITC_PIVR */
+#define AT91C_PITC_CPIV       (0xFFFFF << 0 ) /**< (PITC) Current Periodic Interval Value */
+#define AT91C_PITC_PICNT      (0xFFF << 20) /**< (PITC) Periodic Interval Counter */
+/* --- Register PITC_PIIR */
+#define AT91C_PITC_CPIV       (0xFFFFF << 0 ) /**< (PITC) Current Periodic Interval Value */
+#define AT91C_PITC_PICNT      (0xFFF << 20) /**< (PITC) Periodic Interval Counter */
+
+#endif /* __AT91SAM9262_PITC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pmc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pmc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_pmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_pmc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,206 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_pmc.h
+ * 
+ * Hardware definition for the pmc peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from PMC_SAM9262 V1.4
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_PMC_H
+#define __AT91SAM9262_PMC_H
+
+/* -------------------------------------------------------- */
+/* PMC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SYS
+#define AT91C_ID_SYS   	 1 /**< System Controller id */
+#endif /* AT91C_ID_SYS */
+
+/* -------------------------------------------------------- */
+/* PMC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_PMC       	0xFFFFFC00 /**< PMC base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PA13_PCK0     	(1 << 13) /**<  */
+#define AT91C_PB16_PCK1     	(1 << 16) /**<  */
+#define AT91C_PA6_PCK2     	(1 << 6) /**<  */
+#define AT91C_PE11_PCK3     	(1 << 11) /**<  */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define PMC_SCER 	(0x0000) 	/**< System Clock Enable Register */
+#define PMC_SCDR 	(0x0004) 	/**< System Clock Disable Register */
+#define PMC_SCSR 	(0x0008) 	/**< System Clock Status Register */
+#define PMC_PCER 	(0x0010) 	/**< Peripheral Clock Enable Register */
+#define PMC_PCDR 	(0x0014) 	/**< Peripheral Clock Disable Register */
+#define PMC_PCSR 	(0x0018) 	/**< Peripheral Clock Status Register */
+#define PMC_MOR 	(0x0020) 	/**< Main Oscillator Register */
+#define PMC_MCFR 	(0x0024) 	/**< Main Clock  Frequency Register */
+#define PMC_PLLAR 	(0x0028) 	/**< PLL A Register */
+#define PMC_PLLBR 	(0x002C) 	/**< PLL B Register */
+#define PMC_MCKR 	(0x0030) 	/**< Master Clock Register */
+#define PMC_PCKR 	(0x0040) 	/**< Programmable Clock Register */
+#define PMC_IER 	(0x0060) 	/**< Interrupt Enable Register */
+#define PMC_IDR 	(0x0064) 	/**< Interrupt Disable Register */
+#define PMC_SR 	(0x0068) 	/**< Status Register */
+#define PMC_IMR 	(0x006C) 	/**< Interrupt Mask Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for PMC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register PMC_SCER */
+#define AT91C_PMC_PCK         (0x1 << 0 ) /**< (PMC) Processor Clock */
+#define AT91C_PMC_OTG         (0x1 << 5 ) /**< (PMC) USB OTG Clock */
+#define AT91C_PMC_UHP         (0x1 << 6 ) /**< (PMC) USB Host Port Clock */
+#define AT91C_PMC_UDP         (0x1 << 7 ) /**< (PMC) USB Device Port Clock */
+#define AT91C_PMC_PCK0        (0x1 << 8 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1        (0x1 << 9 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK2        (0x1 << 10) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK3        (0x1 << 11) /**< (PMC) Programmable Clock Output */
+/* --- Register PMC_SCDR */
+#define AT91C_PMC_PCK         (0x1 << 0 ) /**< (PMC) Processor Clock */
+#define AT91C_PMC_OTG         (0x1 << 5 ) /**< (PMC) USB OTG Clock */
+#define AT91C_PMC_UHP         (0x1 << 6 ) /**< (PMC) USB Host Port Clock */
+#define AT91C_PMC_UDP         (0x1 << 7 ) /**< (PMC) USB Device Port Clock */
+#define AT91C_PMC_PCK0        (0x1 << 8 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1        (0x1 << 9 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK2        (0x1 << 10) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK3        (0x1 << 11) /**< (PMC) Programmable Clock Output */
+/* --- Register PMC_SCSR */
+#define AT91C_PMC_PCK         (0x1 << 0 ) /**< (PMC) Processor Clock */
+#define AT91C_PMC_OTG         (0x1 << 5 ) /**< (PMC) USB OTG Clock */
+#define AT91C_PMC_UHP         (0x1 << 6 ) /**< (PMC) USB Host Port Clock */
+#define AT91C_PMC_UDP         (0x1 << 7 ) /**< (PMC) USB Device Port Clock */
+#define AT91C_PMC_PCK0        (0x1 << 8 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1        (0x1 << 9 ) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK2        (0x1 << 10) /**< (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK3        (0x1 << 11) /**< (PMC) Programmable Clock Output */
+/* --- Register CKGR_MOR */
+#define AT91C_CKGR_MOSCEN     (0x1 << 0 ) /**< (PMC) Main Oscillator Enable */
+#define AT91C_CKGR_OSCBYPASS  (0x1 << 1 ) /**< (PMC) Main Oscillator Bypass */
+#define AT91C_CKGR_OSCOUNT    (0xFF << 8 ) /**< (PMC) Main Oscillator Start-up Time */
+/* --- Register CKGR_MCFR */
+#define AT91C_CKGR_MAINF      (0xFFFF << 0 ) /**< (PMC) Main Clock Frequency */
+#define AT91C_CKGR_MAINRDY    (0x1 << 16) /**< (PMC) Main Clock Ready */
+/* --- Register CKGR_PLLAR */
+#define AT91C_CKGR_DIVA       (0xFF << 0 ) /**< (PMC) Divider A Selected */
+#define 	AT91C_CKGR_DIVA_0                    0x0 /**< (PMC) Divider A output is 0 */
+#define 	AT91C_CKGR_DIVA_BYPASS               0x1 /**< (PMC) Divider A is bypassed */
+#define AT91C_CKGR_PLLACOUNT  (0x3F << 8 ) /**< (PMC) PLL A Counter */
+#define AT91C_CKGR_OUTA       (0x3 << 14) /**< (PMC) PLL A Output Frequency Range */
+#define 	AT91C_CKGR_OUTA_0                    (0x0 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_1                    (0x1 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_2                    (0x2 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define 	AT91C_CKGR_OUTA_3                    (0x3 << 14) /**< (PMC) Please refer to the PLLA datasheet */
+#define AT91C_CKGR_MULA       (0x7FF << 16) /**< (PMC) PLL A Multiplier */
+#define AT91C_CKGR_SRCA       (0x1 << 29) /**< (PMC)  */
+/* --- Register CKGR_PLLBR */
+#define AT91C_CKGR_DIVB       (0xFF << 0 ) /**< (PMC) Divider B Selected */
+#define 	AT91C_CKGR_DIVB_0                    0x0 /**< (PMC) Divider B output is 0 */
+#define 	AT91C_CKGR_DIVB_BYPASS               0x1 /**< (PMC) Divider B is bypassed */
+#define AT91C_CKGR_PLLBCOUNT  (0x3F << 8 ) /**< (PMC) PLL B Counter */
+#define AT91C_CKGR_OUTB       (0x3 << 14) /**< (PMC) PLL B Output Frequency Range */
+#define 	AT91C_CKGR_OUTB_0                    (0x0 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_1                    (0x1 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_2                    (0x2 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define 	AT91C_CKGR_OUTB_3                    (0x3 << 14) /**< (PMC) Please refer to the PLLB datasheet */
+#define AT91C_CKGR_MULB       (0x7FF << 16) /**< (PMC) PLL B Multiplier */
+#define AT91C_CKGR_USBDIV     (0x3 << 28) /**< (PMC) Divider for USB Clocks */
+#define 	AT91C_CKGR_USBDIV_0                    (0x0 << 28) /**< (PMC) Divider output is PLL clock output */
+#define 	AT91C_CKGR_USBDIV_1                    (0x1 << 28) /**< (PMC) Divider output is PLL clock output divided by 2 */
+#define 	AT91C_CKGR_USBDIV_2                    (0x2 << 28) /**< (PMC) Divider output is PLL clock output divided by 4 */
+/* --- Register PMC_MCKR */
+#define AT91C_PMC_CSS         (0x3 << 0 ) /**< (PMC) Programmable Clock Selection */
+#define 	AT91C_PMC_CSS_SLOW_CLK             0x0 /**< (PMC) Slow Clock is selected */
+#define 	AT91C_PMC_CSS_MAIN_CLK             0x1 /**< (PMC) Main Clock is selected */
+#define 	AT91C_PMC_CSS_PLLA_CLK             0x2 /**< (PMC) Clock from PLL A is selected */
+#define 	AT91C_PMC_CSS_PLLB_CLK             0x3 /**< (PMC) Clock from PLL B is selected */
+#define AT91C_PMC_PRES        (0x7 << 2 ) /**< (PMC) Programmable Clock Prescaler */
+#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) /**< (PMC) Selected clock */
+#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) /**< (PMC) Selected clock divided by 2 */
+#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) /**< (PMC) Selected clock divided by 4 */
+#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) /**< (PMC) Selected clock divided by 8 */
+#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) /**< (PMC) Selected clock divided by 16 */
+#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) /**< (PMC) Selected clock divided by 32 */
+#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) /**< (PMC) Selected clock divided by 64 */
+#define AT91C_PMC_MDIV        (0x3 << 8 ) /**< (PMC) Master Clock Division */
+#define 	AT91C_PMC_MDIV_1                    (0x0 <<  8) /**< (PMC) The master clock and the processor clock are the same */
+#define 	AT91C_PMC_MDIV_2                    (0x1 <<  8) /**< (PMC) The processor clock is twice as fast as the master clock */
+#define 	AT91C_PMC_MDIV_3                    (0x2 <<  8) /**< (PMC) The processor clock is four times faster than the master clock */
+/* --- Register PMC_PCKR */
+#define AT91C_PMC_CSS         (0x3 << 0 ) /**< (PMC) Programmable Clock Selection */
+#define 	AT91C_PMC_CSS_SLOW_CLK             0x0 /**< (PMC) Slow Clock is selected */
+#define 	AT91C_PMC_CSS_MAIN_CLK             0x1 /**< (PMC) Main Clock is selected */
+#define 	AT91C_PMC_CSS_PLLA_CLK             0x2 /**< (PMC) Clock from PLL A is selected */
+#define 	AT91C_PMC_CSS_PLLB_CLK             0x3 /**< (PMC) Clock from PLL B is selected */
+#define AT91C_PMC_PRES        (0x7 << 2 ) /**< (PMC) Programmable Clock Prescaler */
+#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) /**< (PMC) Selected clock */
+#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) /**< (PMC) Selected clock divided by 2 */
+#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) /**< (PMC) Selected clock divided by 4 */
+#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) /**< (PMC) Selected clock divided by 8 */
+#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) /**< (PMC) Selected clock divided by 16 */
+#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) /**< (PMC) Selected clock divided by 32 */
+#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) /**< (PMC) Selected clock divided by 64 */
+/* --- Register PMC_IER */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK2RDY     (0x1 << 10) /**< (PMC) PCK2_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK3RDY     (0x1 << 11) /**< (PMC) PCK3_RDY Status/Enable/Disable/Mask */
+/* --- Register PMC_IDR */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK2RDY     (0x1 << 10) /**< (PMC) PCK2_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK3RDY     (0x1 << 11) /**< (PMC) PCK3_RDY Status/Enable/Disable/Mask */
+/* --- Register PMC_SR */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK2RDY     (0x1 << 10) /**< (PMC) PCK2_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK3RDY     (0x1 << 11) /**< (PMC) PCK3_RDY Status/Enable/Disable/Mask */
+/* --- Register PMC_IMR */
+#define AT91C_PMC_MOSCS       (0x1 << 0 ) /**< (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA       (0x1 << 1 ) /**< (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB       (0x1 << 2 ) /**< (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY      (0x1 << 3 ) /**< (PMC) Master Clock Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY     (0x1 << 8 ) /**< (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY     (0x1 << 9 ) /**< (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK2RDY     (0x1 << 10) /**< (PMC) PCK2_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK3RDY     (0x1 << 11) /**< (PMC) PCK3_RDY Status/Enable/Disable/Mask */
+
+#endif /* __AT91SAM9262_PMC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_sdramc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_sdramc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_sdramc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_sdramc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,225 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_sdramc.h
+ * 
+ * Hardware definition for the sdramc peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from HSDRAMC1_6100A V1.2
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_SDRAMC_H
+#define __AT91SAM9262_SDRAMC_H
+
+/* -------------------------------------------------------- */
+/* SDRAMC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* SDRAMC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_SDRAMC0   	0xFFFFE200 /**< SDRAMC0 base address */
+#define AT91C_BASE_SDRAMC1   	0xFFFFE800 /**< SDRAMC1 base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for SDRAMC hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SDRAMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define SDRAMC_MR 	(0x0000) 	/**< SDRAM Controller Mode Register */
+#define SDRAMC_TR 	(0x0004) 	/**< SDRAM Controller Refresh Timer Register */
+#define SDRAMC_CR 	(0x0008) 	/**< SDRAM Controller Configuration Register */
+#define SDRAMC_HSR 	(0x000C) 	/**< SDRAM Controller High Speed Register */
+#define SDRAMC_LPR 	(0x0010) 	/**< SDRAM Controller Low Power Register */
+#define SDRAMC_IER 	(0x0014) 	/**< SDRAM Controller Interrupt Enable Register */
+#define SDRAMC_IDR 	(0x0018) 	/**< SDRAM Controller Interrupt Disable Register */
+#define SDRAMC_IMR 	(0x001C) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SDRAMC_ISR 	(0x0020) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SDRAMC_MDR 	(0x0024) 	/**< SDRAM Memory Device Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SDRAMC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register SDRAMC_MR */
+#define AT91C_SDRAMC_MODE     (0xF << 0 ) /**< (SDRAMC) Mode */
+#define 	AT91C_SDRAMC_MODE_NORMAL_CMD           0x0 /**< (SDRAMC) Normal Mode */
+#define 	AT91C_SDRAMC_MODE_NOP_CMD              0x1 /**< (SDRAMC) Issue a NOP Command at every access */
+#define 	AT91C_SDRAMC_MODE_PRCGALL_CMD          0x2 /**< (SDRAMC) Issue a All Banks Precharge Command at every access */
+#define 	AT91C_SDRAMC_MODE_LMR_CMD              0x3 /**< (SDRAMC) Issue a Load Mode Register at every access */
+#define 	AT91C_SDRAMC_MODE_RFSH_CMD             0x4 /**< (SDRAMC) Issue a Refresh */
+#define 	AT91C_SDRAMC_MODE_EXT_LMR_CMD          0x5 /**< (SDRAMC) Issue an Extended Load Mode Register */
+#define 	AT91C_SDRAMC_MODE_DEEP_CMD             0x6 /**< (SDRAMC) Enter Deep Power Mode */
+/* --- Register SDRAMC_TR */
+#define AT91C_SDRAMC_COUNT    (0xFFF << 0 ) /**< (SDRAMC) Refresh Counter */
+/* --- Register SDRAMC_CR */
+#define AT91C_SDRAMC_NC       (0x3 << 0 ) /**< (SDRAMC) Number of Column Bits */
+#define 	AT91C_SDRAMC_NC_8                    0x0 /**< (SDRAMC) 8 Bits */
+#define 	AT91C_SDRAMC_NC_9                    0x1 /**< (SDRAMC) 9 Bits */
+#define 	AT91C_SDRAMC_NC_10                   0x2 /**< (SDRAMC) 10 Bits */
+#define 	AT91C_SDRAMC_NC_11                   0x3 /**< (SDRAMC) 11 Bits */
+#define AT91C_SDRAMC_NR       (0x3 << 2 ) /**< (SDRAMC) Number of Row Bits */
+#define 	AT91C_SDRAMC_NR_11                   (0x0 <<  2) /**< (SDRAMC) 11 Bits */
+#define 	AT91C_SDRAMC_NR_12                   (0x1 <<  2) /**< (SDRAMC) 12 Bits */
+#define 	AT91C_SDRAMC_NR_13                   (0x2 <<  2) /**< (SDRAMC) 13 Bits */
+#define AT91C_SDRAMC_NB       (0x1 << 4 ) /**< (SDRAMC) Number of Banks */
+#define 	AT91C_SDRAMC_NB_2_BANKS              (0x0 <<  4) /**< (SDRAMC) 2 banks */
+#define 	AT91C_SDRAMC_NB_4_BANKS              (0x1 <<  4) /**< (SDRAMC) 4 banks */
+#define AT91C_SDRAMC_CAS      (0x3 << 5 ) /**< (SDRAMC) CAS Latency */
+#define 	AT91C_SDRAMC_CAS_2                    (0x2 <<  5) /**< (SDRAMC) 2 cycles */
+#define 	AT91C_SDRAMC_CAS_3                    (0x3 <<  5) /**< (SDRAMC) 3 cycles */
+#define AT91C_SDRAMC_DBW      (0x1 << 7 ) /**< (SDRAMC) Data Bus Width */
+#define 	AT91C_SDRAMC_DBW_32_BITS              (0x0 <<  7) /**< (SDRAMC) 32 Bits datas bus */
+#define 	AT91C_SDRAMC_DBW_16_BITS              (0x1 <<  7) /**< (SDRAMC) 16 Bits datas bus */
+#define AT91C_SDRAMC_TWR      (0xF << 8 ) /**< (SDRAMC) Number of Write Recovery Time Cycles */
+#define 	AT91C_SDRAMC_TWR_0                    (0x0 <<  8) /**< (SDRAMC) Value :  0 */
+#define 	AT91C_SDRAMC_TWR_1                    (0x1 <<  8) /**< (SDRAMC) Value :  1 */
+#define 	AT91C_SDRAMC_TWR_2                    (0x2 <<  8) /**< (SDRAMC) Value :  2 */
+#define 	AT91C_SDRAMC_TWR_3                    (0x3 <<  8) /**< (SDRAMC) Value :  3 */
+#define 	AT91C_SDRAMC_TWR_4                    (0x4 <<  8) /**< (SDRAMC) Value :  4 */
+#define 	AT91C_SDRAMC_TWR_5                    (0x5 <<  8) /**< (SDRAMC) Value :  5 */
+#define 	AT91C_SDRAMC_TWR_6                    (0x6 <<  8) /**< (SDRAMC) Value :  6 */
+#define 	AT91C_SDRAMC_TWR_7                    (0x7 <<  8) /**< (SDRAMC) Value :  7 */
+#define 	AT91C_SDRAMC_TWR_8                    (0x8 <<  8) /**< (SDRAMC) Value :  8 */
+#define 	AT91C_SDRAMC_TWR_9                    (0x9 <<  8) /**< (SDRAMC) Value :  9 */
+#define 	AT91C_SDRAMC_TWR_10                   (0xA <<  8) /**< (SDRAMC) Value : 10 */
+#define 	AT91C_SDRAMC_TWR_11                   (0xB <<  8) /**< (SDRAMC) Value : 11 */
+#define 	AT91C_SDRAMC_TWR_12                   (0xC <<  8) /**< (SDRAMC) Value : 12 */
+#define 	AT91C_SDRAMC_TWR_13                   (0xD <<  8) /**< (SDRAMC) Value : 13 */
+#define 	AT91C_SDRAMC_TWR_14                   (0xE <<  8) /**< (SDRAMC) Value : 14 */
+#define 	AT91C_SDRAMC_TWR_15                   (0xF <<  8) /**< (SDRAMC) Value : 15 */
+#define AT91C_SDRAMC_TRC      (0xF << 12) /**< (SDRAMC) Number of RAS Cycle Time Cycles */
+#define 	AT91C_SDRAMC_TRC_0                    (0x0 << 12) /**< (SDRAMC) Value :  0 */
+#define 	AT91C_SDRAMC_TRC_1                    (0x1 << 12) /**< (SDRAMC) Value :  1 */
+#define 	AT91C_SDRAMC_TRC_2                    (0x2 << 12) /**< (SDRAMC) Value :  2 */
+#define 	AT91C_SDRAMC_TRC_3                    (0x3 << 12) /**< (SDRAMC) Value :  3 */
+#define 	AT91C_SDRAMC_TRC_4                    (0x4 << 12) /**< (SDRAMC) Value :  4 */
+#define 	AT91C_SDRAMC_TRC_5                    (0x5 << 12) /**< (SDRAMC) Value :  5 */
+#define 	AT91C_SDRAMC_TRC_6                    (0x6 << 12) /**< (SDRAMC) Value :  6 */
+#define 	AT91C_SDRAMC_TRC_7                    (0x7 << 12) /**< (SDRAMC) Value :  7 */
+#define 	AT91C_SDRAMC_TRC_8                    (0x8 << 12) /**< (SDRAMC) Value :  8 */
+#define 	AT91C_SDRAMC_TRC_9                    (0x9 << 12) /**< (SDRAMC) Value :  9 */
+#define 	AT91C_SDRAMC_TRC_10                   (0xA << 12) /**< (SDRAMC) Value : 10 */
+#define 	AT91C_SDRAMC_TRC_11                   (0xB << 12) /**< (SDRAMC) Value : 11 */
+#define 	AT91C_SDRAMC_TRC_12                   (0xC << 12) /**< (SDRAMC) Value : 12 */
+#define 	AT91C_SDRAMC_TRC_13                   (0xD << 12) /**< (SDRAMC) Value : 13 */
+#define 	AT91C_SDRAMC_TRC_14                   (0xE << 12) /**< (SDRAMC) Value : 14 */
+#define 	AT91C_SDRAMC_TRC_15                   (0xF << 12) /**< (SDRAMC) Value : 15 */
+#define AT91C_SDRAMC_TRP      (0xF << 16) /**< (SDRAMC) Number of RAS Precharge Time Cycles */
+#define 	AT91C_SDRAMC_TRP_0                    (0x0 << 16) /**< (SDRAMC) Value :  0 */
+#define 	AT91C_SDRAMC_TRP_1                    (0x1 << 16) /**< (SDRAMC) Value :  1 */
+#define 	AT91C_SDRAMC_TRP_2                    (0x2 << 16) /**< (SDRAMC) Value :  2 */
+#define 	AT91C_SDRAMC_TRP_3                    (0x3 << 16) /**< (SDRAMC) Value :  3 */
+#define 	AT91C_SDRAMC_TRP_4                    (0x4 << 16) /**< (SDRAMC) Value :  4 */
+#define 	AT91C_SDRAMC_TRP_5                    (0x5 << 16) /**< (SDRAMC) Value :  5 */
+#define 	AT91C_SDRAMC_TRP_6                    (0x6 << 16) /**< (SDRAMC) Value :  6 */
+#define 	AT91C_SDRAMC_TRP_7                    (0x7 << 16) /**< (SDRAMC) Value :  7 */
+#define 	AT91C_SDRAMC_TRP_8                    (0x8 << 16) /**< (SDRAMC) Value :  8 */
+#define 	AT91C_SDRAMC_TRP_9                    (0x9 << 16) /**< (SDRAMC) Value :  9 */
+#define 	AT91C_SDRAMC_TRP_10                   (0xA << 16) /**< (SDRAMC) Value : 10 */
+#define 	AT91C_SDRAMC_TRP_11                   (0xB << 16) /**< (SDRAMC) Value : 11 */
+#define 	AT91C_SDRAMC_TRP_12                   (0xC << 16) /**< (SDRAMC) Value : 12 */
+#define 	AT91C_SDRAMC_TRP_13                   (0xD << 16) /**< (SDRAMC) Value : 13 */
+#define 	AT91C_SDRAMC_TRP_14                   (0xE << 16) /**< (SDRAMC) Value : 14 */
+#define 	AT91C_SDRAMC_TRP_15                   (0xF << 16) /**< (SDRAMC) Value : 15 */
+#define AT91C_SDRAMC_TRCD     (0xF << 20) /**< (SDRAMC) Number of RAS to CAS Delay Cycles */
+#define 	AT91C_SDRAMC_TRCD_0                    (0x0 << 20) /**< (SDRAMC) Value :  0 */
+#define 	AT91C_SDRAMC_TRCD_1                    (0x1 << 20) /**< (SDRAMC) Value :  1 */
+#define 	AT91C_SDRAMC_TRCD_2                    (0x2 << 20) /**< (SDRAMC) Value :  2 */
+#define 	AT91C_SDRAMC_TRCD_3                    (0x3 << 20) /**< (SDRAMC) Value :  3 */
+#define 	AT91C_SDRAMC_TRCD_4                    (0x4 << 20) /**< (SDRAMC) Value :  4 */
+#define 	AT91C_SDRAMC_TRCD_5                    (0x5 << 20) /**< (SDRAMC) Value :  5 */
+#define 	AT91C_SDRAMC_TRCD_6                    (0x6 << 20) /**< (SDRAMC) Value :  6 */
+#define 	AT91C_SDRAMC_TRCD_7                    (0x7 << 20) /**< (SDRAMC) Value :  7 */
+#define 	AT91C_SDRAMC_TRCD_8                    (0x8 << 20) /**< (SDRAMC) Value :  8 */
+#define 	AT91C_SDRAMC_TRCD_9                    (0x9 << 20) /**< (SDRAMC) Value :  9 */
+#define 	AT91C_SDRAMC_TRCD_10                   (0xA << 20) /**< (SDRAMC) Value : 10 */
+#define 	AT91C_SDRAMC_TRCD_11                   (0xB << 20) /**< (SDRAMC) Value : 11 */
+#define 	AT91C_SDRAMC_TRCD_12                   (0xC << 20) /**< (SDRAMC) Value : 12 */
+#define 	AT91C_SDRAMC_TRCD_13                   (0xD << 20) /**< (SDRAMC) Value : 13 */
+#define 	AT91C_SDRAMC_TRCD_14                   (0xE << 20) /**< (SDRAMC) Value : 14 */
+#define 	AT91C_SDRAMC_TRCD_15                   (0xF << 20) /**< (SDRAMC) Value : 15 */
+#define AT91C_SDRAMC_TRAS     (0xF << 24) /**< (SDRAMC) Number of RAS Active Time Cycles */
+#define 	AT91C_SDRAMC_TRAS_0                    (0x0 << 24) /**< (SDRAMC) Value :  0 */
+#define 	AT91C_SDRAMC_TRAS_1                    (0x1 << 24) /**< (SDRAMC) Value :  1 */
+#define 	AT91C_SDRAMC_TRAS_2                    (0x2 << 24) /**< (SDRAMC) Value :  2 */
+#define 	AT91C_SDRAMC_TRAS_3                    (0x3 << 24) /**< (SDRAMC) Value :  3 */
+#define 	AT91C_SDRAMC_TRAS_4                    (0x4 << 24) /**< (SDRAMC) Value :  4 */
+#define 	AT91C_SDRAMC_TRAS_5                    (0x5 << 24) /**< (SDRAMC) Value :  5 */
+#define 	AT91C_SDRAMC_TRAS_6                    (0x6 << 24) /**< (SDRAMC) Value :  6 */
+#define 	AT91C_SDRAMC_TRAS_7                    (0x7 << 24) /**< (SDRAMC) Value :  7 */
+#define 	AT91C_SDRAMC_TRAS_8                    (0x8 << 24) /**< (SDRAMC) Value :  8 */
+#define 	AT91C_SDRAMC_TRAS_9                    (0x9 << 24) /**< (SDRAMC) Value :  9 */
+#define 	AT91C_SDRAMC_TRAS_10                   (0xA << 24) /**< (SDRAMC) Value : 10 */
+#define 	AT91C_SDRAMC_TRAS_11                   (0xB << 24) /**< (SDRAMC) Value : 11 */
+#define 	AT91C_SDRAMC_TRAS_12                   (0xC << 24) /**< (SDRAMC) Value : 12 */
+#define 	AT91C_SDRAMC_TRAS_13                   (0xD << 24) /**< (SDRAMC) Value : 13 */
+#define 	AT91C_SDRAMC_TRAS_14                   (0xE << 24) /**< (SDRAMC) Value : 14 */
+#define 	AT91C_SDRAMC_TRAS_15                   (0xF << 24) /**< (SDRAMC) Value : 15 */
+#define AT91C_SDRAMC_TXSR     (0xF << 28) /**< (SDRAMC) Number of Command Recovery Time Cycles */
+#define 	AT91C_SDRAMC_TXSR_0                    (0x0 << 28) /**< (SDRAMC) Value :  0 */
+#define 	AT91C_SDRAMC_TXSR_1                    (0x1 << 28) /**< (SDRAMC) Value :  1 */
+#define 	AT91C_SDRAMC_TXSR_2                    (0x2 << 28) /**< (SDRAMC) Value :  2 */
+#define 	AT91C_SDRAMC_TXSR_3                    (0x3 << 28) /**< (SDRAMC) Value :  3 */
+#define 	AT91C_SDRAMC_TXSR_4                    (0x4 << 28) /**< (SDRAMC) Value :  4 */
+#define 	AT91C_SDRAMC_TXSR_5                    (0x5 << 28) /**< (SDRAMC) Value :  5 */
+#define 	AT91C_SDRAMC_TXSR_6                    (0x6 << 28) /**< (SDRAMC) Value :  6 */
+#define 	AT91C_SDRAMC_TXSR_7                    (0x7 << 28) /**< (SDRAMC) Value :  7 */
+#define 	AT91C_SDRAMC_TXSR_8                    (0x8 << 28) /**< (SDRAMC) Value :  8 */
+#define 	AT91C_SDRAMC_TXSR_9                    (0x9 << 28) /**< (SDRAMC) Value :  9 */
+#define 	AT91C_SDRAMC_TXSR_10                   (0xA << 28) /**< (SDRAMC) Value : 10 */
+#define 	AT91C_SDRAMC_TXSR_11                   (0xB << 28) /**< (SDRAMC) Value : 11 */
+#define 	AT91C_SDRAMC_TXSR_12                   (0xC << 28) /**< (SDRAMC) Value : 12 */
+#define 	AT91C_SDRAMC_TXSR_13                   (0xD << 28) /**< (SDRAMC) Value : 13 */
+#define 	AT91C_SDRAMC_TXSR_14                   (0xE << 28) /**< (SDRAMC) Value : 14 */
+#define 	AT91C_SDRAMC_TXSR_15                   (0xF << 28) /**< (SDRAMC) Value : 15 */
+/* --- Register SDRAMC_HSR */
+#define AT91C_SDRAMC_DA       (0x1 << 0 ) /**< (SDRAMC) Decode Cycle Enable Bit */
+#define 	AT91C_SDRAMC_DA_DISABLE              0x0 /**< (SDRAMC) Disable Decode Cycle */
+#define 	AT91C_SDRAMC_DA_ENABLE               0x1 /**< (SDRAMC) Enable Decode Cycle */
+/* --- Register SDRAMC_LPR */
+#define AT91C_SDRAMC_LPCB     (0x3 << 0 ) /**< (SDRAMC) Low-power Configurations */
+#define 	AT91C_SDRAMC_LPCB_DISABLE              0x0 /**< (SDRAMC) Disable Low Power Features */
+#define 	AT91C_SDRAMC_LPCB_SELF_REFRESH         0x1 /**< (SDRAMC) Enable SELF_REFRESH */
+#define 	AT91C_SDRAMC_LPCB_POWER_DOWN           0x2 /**< (SDRAMC) Enable POWER_DOWN */
+#define 	AT91C_SDRAMC_LPCB_DEEP_POWER_DOWN      0x3 /**< (SDRAMC) Enable DEEP_POWER_DOWN */
+#define AT91C_SDRAMC_PASR     (0x7 << 4 ) /**< (SDRAMC) Partial Array Self Refresh (only for Low Power SDRAM) */
+#define AT91C_SDRAMC_TCSR     (0x3 << 8 ) /**< (SDRAMC) Temperature Compensated Self Refresh (only for Low Power SDRAM) */
+#define AT91C_SDRAMC_DS       (0x3 << 10) /**< (SDRAMC) Drive Strenght (only for Low Power SDRAM) */
+#define AT91C_SDRAMC_TIMEOUT  (0x3 << 12) /**< (SDRAMC) Time to define when Low Power Mode is enabled */
+#define 	AT91C_SDRAMC_TIMEOUT_0_CLK_CYCLES         (0x0 << 12) /**< (SDRAMC) Activate SDRAM Low Power Mode Immediately */
+#define 	AT91C_SDRAMC_TIMEOUT_64_CLK_CYCLES        (0x1 << 12) /**< (SDRAMC) Activate SDRAM Low Power Mode after 64 clock cycles after the end of the last transfer */
+#define 	AT91C_SDRAMC_TIMEOUT_128_CLK_CYCLES       (0x2 << 12) /**< (SDRAMC) Activate SDRAM Low Power Mode after 64 clock cycles after the end of the last transfer */
+/* --- Register SDRAMC_IER */
+#define AT91C_SDRAMC_RES      (0x1 << 0 ) /**< (SDRAMC) Refresh Error Status */
+/* --- Register SDRAMC_IDR */
+#define AT91C_SDRAMC_RES      (0x1 << 0 ) /**< (SDRAMC) Refresh Error Status */
+/* --- Register SDRAMC_IMR */
+#define AT91C_SDRAMC_RES      (0x1 << 0 ) /**< (SDRAMC) Refresh Error Status */
+/* --- Register SDRAMC_ISR */
+#define AT91C_SDRAMC_RES      (0x1 << 0 ) /**< (SDRAMC) Refresh Error Status */
+/* --- Register SDRAMC_MDR */
+#define AT91C_SDRAMC_MD       (0x3 << 0 ) /**< (SDRAMC) Memory Device Type */
+#define 	AT91C_SDRAMC_MD_SDRAM                0x0 /**< (SDRAMC) SDRAM Mode */
+#define 	AT91C_SDRAMC_MD_LOW_POWER_SDRAM      0x1 /**< (SDRAMC) SDRAM Low Power Mode */
+
+#endif /* __AT91SAM9262_SDRAMC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_smc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_smc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_smc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_smc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,366 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_smc.h
+ * 
+ * Hardware definition for the smc peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from HSMC3_6105A V1.4
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_SMC_H
+#define __AT91SAM9262_SMC_H
+
+/* -------------------------------------------------------- */
+/* SMC ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* SMC Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_SMC0      	0xFFFFE400 /**< SMC0 base address */
+#define AT91C_BASE_SMC1      	0xFFFFEA00 /**< SMC1 base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for SMC hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SMC hardware peripheral */
+/* -------------------------------------------------------- */
+#define SMC_SETUP0 	(0x0000) 	/**<  Setup Register for CS 0 */
+#define SMC_PULSE0 	(0x0004) 	/**<  Pulse Register for CS 0 */
+#define SMC_CYCLE0 	(0x0008) 	/**<  Cycle Register for CS 0 */
+#define SMC_CTRL0 	(0x000C) 	/**<  Control Register for CS 0 */
+#define SMC_SETUP1 	(0x0010) 	/**<  Setup Register for CS 1 */
+#define SMC_PULSE1 	(0x0014) 	/**<  Pulse Register for CS 1 */
+#define SMC_CYCLE1 	(0x0018) 	/**<  Cycle Register for CS 1 */
+#define SMC_CTRL1 	(0x001C) 	/**<  Control Register for CS 1 */
+#define SMC_SETUP2 	(0x0020) 	/**<  Setup Register for CS 2 */
+#define SMC_PULSE2 	(0x0024) 	/**<  Pulse Register for CS 2 */
+#define SMC_CYCLE2 	(0x0028) 	/**<  Cycle Register for CS 2 */
+#define SMC_CTRL2 	(0x002C) 	/**<  Control Register for CS 2 */
+#define SMC_SETUP3 	(0x0030) 	/**<  Setup Register for CS 3 */
+#define SMC_PULSE3 	(0x0034) 	/**<  Pulse Register for CS 3 */
+#define SMC_CYCLE3 	(0x0038) 	/**<  Cycle Register for CS 3 */
+#define SMC_CTRL3 	(0x003C) 	/**<  Control Register for CS 3 */
+#define SMC_SETUP4 	(0x0040) 	/**<  Setup Register for CS 4 */
+#define SMC_PULSE4 	(0x0044) 	/**<  Pulse Register for CS 4 */
+#define SMC_CYCLE4 	(0x0048) 	/**<  Cycle Register for CS 4 */
+#define SMC_CTRL4 	(0x004C) 	/**<  Control Register for CS 4 */
+#define SMC_SETUP5 	(0x0050) 	/**<  Setup Register for CS 5 */
+#define SMC_PULSE5 	(0x0054) 	/**<  Pulse Register for CS 5 */
+#define SMC_CYCLE5 	(0x0058) 	/**<  Cycle Register for CS 5 */
+#define SMC_CTRL5 	(0x005C) 	/**<  Control Register for CS 5 */
+#define SMC_SETUP6 	(0x0060) 	/**<  Setup Register for CS 6 */
+#define SMC_PULSE6 	(0x0064) 	/**<  Pulse Register for CS 6 */
+#define SMC_CYCLE6 	(0x0068) 	/**<  Cycle Register for CS 6 */
+#define SMC_CTRL6 	(0x006C) 	/**<  Control Register for CS 6 */
+#define SMC_SETUP7 	(0x0070) 	/**<  Setup Register for CS 7 */
+#define SMC_PULSE7 	(0x0074) 	/**<  Pulse Register for CS 7 */
+#define SMC_CYCLE7 	(0x0078) 	/**<  Cycle Register for CS 7 */
+#define SMC_CTRL7 	(0x007C) 	/**<  Control Register for CS 7 */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SMC hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+/* --- Register SMC_SETUP */
+#define AT91C_SMC_NWESETUP    (0x3F << 0 ) /**< (SMC) NWE Setup Length */
+#define AT91C_SMC_NCSSETUPWR  (0x3F << 8 ) /**< (SMC) NCS Setup Length in WRite Access */
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) /**< (SMC) NRD Setup Length */
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) /**< (SMC) NCS Setup Length in ReaD Access */
+/* --- Register SMC_PULSE */
+#define AT91C_SMC_NWEPULSE    (0x7F << 0 ) /**< (SMC) NWE Pulse Length */
+#define AT91C_SMC_NCSPULSEWR  (0x7F << 8 ) /**< (SMC) NCS Pulse Length in WRite Access */
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) /**< (SMC) NRD Pulse Length */
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) /**< (SMC) NCS Pulse Length in ReaD Access */
+/* --- Register SMC_CYC */
+#define AT91C_SMC_NWECYCLE    (0x1FF << 0 ) /**< (SMC) Total Write Cycle Length */
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) /**< (SMC) Total Read Cycle Length */
+/* --- Register SMC_CTRL */
+#define AT91C_SMC_READMODE    (0x1 << 0 ) /**< (SMC) Read Mode */
+#define AT91C_SMC_WRITEMODE   (0x1 << 1 ) /**< (SMC) Write Mode */
+#define AT91C_SMC_NWAITM      (0x3 << 5 ) /**< (SMC) NWAIT Mode */
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) /**< (SMC) External NWAIT disabled. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) /**< (SMC) External NWAIT enabled in frozen mode. */
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) /**< (SMC) External NWAIT enabled in ready mode. */
+#define AT91C_SMC_BAT         (0x1 << 8 ) /**< (SMC) Byte Access Type */
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) /**< (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3. */
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) /**< (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd. */
+#define AT91C_SMC_DBW         (0x3 << 12) /**< (SMC) Data Bus Width */
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) /**< (SMC) 8 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) /**< (SMC) 16 bits. */
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) /**< (SMC) 32 bits. */
+#define AT91C_SMC_TDF         (0xF << 16) /**< (SMC) Data Float Time. */
+#define AT91C_SMC_TDFEN       (0x1 << 20) /**< (SMC) TDF Enabled. */
+#define AT91C_SMC_PMEN        (0x1 << 24) /**< (SMC) Page Mode Enabled. */
+#define AT91C_SMC_PS          (0x3 << 28) /**< (SMC) Page Size */
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) /**< (SMC) 4 bytes. */
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) /**< (SMC) 8 bytes. */
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) /**< (SMC) 16 bytes. */
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) /**< (SMC) 32 bytes. */
+
+#endif /* __AT91SAM9262_SMC_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_spi.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_spi.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_spi.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,184 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_spi.h
+ * 
+ * Hardware definition for the spi peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from SPI_6088D V1.3
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_SPI_H
+#define __AT91SAM9262_SPI_H
+
+/* -------------------------------------------------------- */
+/* SPI ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SPI0
+#define AT91C_ID_SPI0  	14 /**< Serial Peripheral Interface 0 id */
+#endif /* AT91C_ID_SPI0 */
+#ifndef AT91C_ID_SPI1
+#define AT91C_ID_SPI1  	15 /**< Serial Peripheral Interface 1 id */
+#endif /* AT91C_ID_SPI1 */
+
+/* -------------------------------------------------------- */
+/* SPI Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_SPI0      	0xFFFA4000 /**< SPI0 base address */
+#define AT91C_BASE_SPI1      	0xFFFA8000 /**< SPI1 base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PA0_SPI0_MISO 	(1 << 0) /**<  */
+#define AT91C_PA1_SPI0_MOSI 	(1 << 1) /**<  */
+#define AT91C_PA5_SPI0_NPCS0 	(1 << 5) /**<  */
+#define AT91C_PA3_SPI0_NPCS1 	(1 << 3) /**<  */
+#define AT91C_PA4_SPI0_NPCS2A 	(1 << 4) /**<  */
+#define AT91C_PD0_SPI0_NPCS2D 	(1 << 0) /**<  */
+#define AT91C_PB11_SPI0_NPCS3B 	(1 << 11) /**<  */
+#define AT91C_PD1_SPI0_NPCS3D 	(1 << 1) /**<  */
+#define AT91C_PA2_SPI0_SPCK 	(1 << 2) /**<  */
+
+#define AT91C_PB12_SPI1_MISO 	(1 << 12) /**<  */
+#define AT91C_PB13_SPI1_MOSI 	(1 << 13) /**<  */
+#define AT91C_PB15_SPI1_NPCS0 	(1 << 15) /**<  */
+#define AT91C_PB16_SPI1_NPCS1 	(1 << 16) /**<  */
+#define AT91C_PB17_SPI1_NPCS2B 	(1 << 17) /**<  */
+#define AT91C_PD2_SPI1_NPCS2D 	(1 << 2) /**<  */
+#define AT91C_PB18_SPI1_NPCS3B 	(1 << 18) /**<  */
+#define AT91C_PD3_SPI1_NPCS3D 	(1 << 3) /**<  */
+#define AT91C_PB14_SPI1_SPCK 	(1 << 14) /**<  */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+#define SPI_CR 	(0x0000) 	/**< Control Register */
+#define SPI_MR 	(0x0004) 	/**< Mode Register */
+#define SPI_RDR 	(0x0008) 	/**< Receive Data Register */
+#define SPI_TDR 	(0x000C) 	/**< Transmit Data Register */
+#define SPI_SR 	(0x0010) 	/**< Status Register */
+#define SPI_IER 	(0x0014) 	/**< Interrupt Enable Register */
+#define SPI_IDR 	(0x0018) 	/**< Interrupt Disable Register */
+#define SPI_IMR 	(0x001C) 	/**< Interrupt Mask Register */
+#define SPI_CSR 	(0x0030) 	/**< Chip Select Register */
+#define SPI_RPR 	(0x0100) 	/**< Receive Pointer Register */
+#define SPI_RCR 	(0x0104) 	/**< Receive Counter Register */
+#define SPI_TPR 	(0x0108) 	/**< Transmit Pointer Register */
+#define SPI_TCR 	(0x010C) 	/**< Transmit Counter Register */
+#define SPI_RNPR 	(0x0110) 	/**< Receive Next Pointer Register */
+#define SPI_RNCR 	(0x0114) 	/**< Receive Next Counter Register */
+#define SPI_TNPR 	(0x0118) 	/**< Transmit Next Pointer Register */
+#define SPI_TNCR 	(0x011C) 	/**< Transmit Next Counter Register */
+#define SPI_PTCR 	(0x0120) 	/**< PDC Transfer Control Register */
+#define SPI_PTSR 	(0x0124) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SPI hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register SPI_CR */
+#define AT91C_SPI_SPIEN       (0x1 << 0 ) /**< (SPI) SPI Enable */
+#define AT91C_SPI_SPIDIS      (0x1 << 1 ) /**< (SPI) SPI Disable */
+#define AT91C_SPI_SWRST       (0x1 << 7 ) /**< (SPI) SPI Software reset */
+#define AT91C_SPI_LASTXFER    (0x1 << 24) /**< (SPI) SPI Last Transfer */
+/* --- Register SPI_MR */
+#define AT91C_SPI_MSTR        (0x1 << 0 ) /**< (SPI) Master/Slave Mode */
+#define AT91C_SPI_PS          (0x1 << 1 ) /**< (SPI) Peripheral Select */
+#define 	AT91C_SPI_PS_FIXED                (0x0 <<  1) /**< (SPI) Fixed Peripheral Select */
+#define 	AT91C_SPI_PS_VARIABLE             (0x1 <<  1) /**< (SPI) Variable Peripheral Select */
+#define AT91C_SPI_PCSDEC      (0x1 << 2 ) /**< (SPI) Chip Select Decode */
+#define AT91C_SPI_FDIV        (0x1 << 3 ) /**< (SPI) Clock Selection */
+#define AT91C_SPI_MODFDIS     (0x1 << 4 ) /**< (SPI) Mode Fault Detection */
+#define AT91C_SPI_LLB         (0x1 << 7 ) /**< (SPI) Clock Selection */
+#define AT91C_SPI_PCS         (0xF << 16) /**< (SPI) Peripheral Chip Select */
+#define AT91C_SPI_DLYBCS      (0xFF << 24) /**< (SPI) Delay Between Chip Selects */
+/* --- Register SPI_RDR */
+#define AT91C_SPI_RD          (0xFFFF << 0 ) /**< (SPI) Receive Data */
+#define AT91C_SPI_RPCS        (0xF << 16) /**< (SPI) Peripheral Chip Select Status */
+/* --- Register SPI_TDR */
+#define AT91C_SPI_TD          (0xFFFF << 0 ) /**< (SPI) Transmit Data */
+#define AT91C_SPI_TPCS        (0xF << 16) /**< (SPI) Peripheral Chip Select Status */
+#define AT91C_SPI_LASTXFER    (0x1 << 24) /**< (SPI) SPI Last Transfer */
+/* --- Register SPI_SR */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+#define AT91C_SPI_SPIENS      (0x1 << 16) /**< (SPI) Enable Status */
+/* --- Register SPI_IER */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+/* --- Register SPI_IDR */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+/* --- Register SPI_IMR */
+#define AT91C_SPI_RDRF        (0x1 << 0 ) /**< (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE        (0x1 << 1 ) /**< (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF        (0x1 << 2 ) /**< (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES       (0x1 << 3 ) /**< (SPI) Overrun Error Status */
+#define AT91C_SPI_ENDRX       (0x1 << 4 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_ENDTX       (0x1 << 5 ) /**< (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF      (0x1 << 6 ) /**< (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE      (0x1 << 7 ) /**< (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_NSSR        (0x1 << 8 ) /**< (SPI) NSSR Interrupt */
+#define AT91C_SPI_TXEMPTY     (0x1 << 9 ) /**< (SPI) TXEMPTY Interrupt */
+/* --- Register SPI_CSR */
+#define AT91C_SPI_CPOL        (0x1 << 0 ) /**< (SPI) Clock Polarity */
+#define AT91C_SPI_NCPHA       (0x1 << 1 ) /**< (SPI) Clock Phase */
+#define AT91C_SPI_CSAAT       (0x1 << 3 ) /**< (SPI) Chip Select Active After Transfer */
+#define AT91C_SPI_BITS        (0xF << 4 ) /**< (SPI) Bits Per Transfer */
+#define 	AT91C_SPI_BITS_8                    (0x0 <<  4) /**< (SPI) 8 Bits Per transfer */
+#define 	AT91C_SPI_BITS_9                    (0x1 <<  4) /**< (SPI) 9 Bits Per transfer */
+#define 	AT91C_SPI_BITS_10                   (0x2 <<  4) /**< (SPI) 10 Bits Per transfer */
+#define 	AT91C_SPI_BITS_11                   (0x3 <<  4) /**< (SPI) 11 Bits Per transfer */
+#define 	AT91C_SPI_BITS_12                   (0x4 <<  4) /**< (SPI) 12 Bits Per transfer */
+#define 	AT91C_SPI_BITS_13                   (0x5 <<  4) /**< (SPI) 13 Bits Per transfer */
+#define 	AT91C_SPI_BITS_14                   (0x6 <<  4) /**< (SPI) 14 Bits Per transfer */
+#define 	AT91C_SPI_BITS_15                   (0x7 <<  4) /**< (SPI) 15 Bits Per transfer */
+#define 	AT91C_SPI_BITS_16                   (0x8 <<  4) /**< (SPI) 16 Bits Per transfer */
+#define AT91C_SPI_SCBR        (0xFF << 8 ) /**< (SPI) Serial Clock Baud Rate */
+#define AT91C_SPI_DLYBS       (0xFF << 16) /**< (SPI) Delay Before SPCK */
+#define AT91C_SPI_DLYBCT      (0xFF << 24) /**< (SPI) Delay Between Consecutive Transfers */
+
+#endif /* __AT91SAM9262_SPI_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_sys.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_sys.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_sys.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_sys.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,401 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_sys.h
+ * 
+ * Hardware definition for the sys peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from SYS_SAM9262 V1.4
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_SYS_H
+#define __AT91SAM9262_SYS_H
+
+/* -------------------------------------------------------- */
+/* SYS ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_SYS
+#define AT91C_ID_SYS   	 1 /**< System Controller id */
+#endif /* AT91C_ID_SYS */
+
+/* -------------------------------------------------------- */
+/* SYS Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_SYS       	0xFFFFE000 /**< SYS base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for SYS hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for SYS hardware peripheral */
+/* -------------------------------------------------------- */
+#define SYS_ECC0 	(0x0000) 	/**< ECC 0 */
+#define SYS_SDRAMC0_MR 	(0x0200) 	/**< SDRAM Controller Mode Register */
+#define SYS_SDRAMC0_TR 	(0x0204) 	/**< SDRAM Controller Refresh Timer Register */
+#define SYS_SDRAMC0_CR 	(0x0208) 	/**< SDRAM Controller Configuration Register */
+#define SYS_SDRAMC0_HSR 	(0x020C) 	/**< SDRAM Controller High Speed Register */
+#define SYS_SDRAMC0_LPR 	(0x0210) 	/**< SDRAM Controller Low Power Register */
+#define SYS_SDRAMC0_IER 	(0x0214) 	/**< SDRAM Controller Interrupt Enable Register */
+#define SYS_SDRAMC0_IDR 	(0x0218) 	/**< SDRAM Controller Interrupt Disable Register */
+#define SYS_SDRAMC0_IMR 	(0x021C) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SYS_SDRAMC0_ISR 	(0x0220) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SYS_SDRAMC0_MDR 	(0x0224) 	/**< SDRAM Memory Device Register */
+#define SYS_SMC0_SETUP0 	(0x0400) 	/**<  Setup Register for CS 0 */
+#define SYS_SMC0_PULSE0 	(0x0404) 	/**<  Pulse Register for CS 0 */
+#define SYS_SMC0_CYCLE0 	(0x0408) 	/**<  Cycle Register for CS 0 */
+#define SYS_SMC0_CTRL0 	(0x040C) 	/**<  Control Register for CS 0 */
+#define SYS_SMC0_SETUP1 	(0x0410) 	/**<  Setup Register for CS 1 */
+#define SYS_SMC0_PULSE1 	(0x0414) 	/**<  Pulse Register for CS 1 */
+#define SYS_SMC0_CYCLE1 	(0x0418) 	/**<  Cycle Register for CS 1 */
+#define SYS_SMC0_CTRL1 	(0x041C) 	/**<  Control Register for CS 1 */
+#define SYS_SMC0_SETUP2 	(0x0420) 	/**<  Setup Register for CS 2 */
+#define SYS_SMC0_PULSE2 	(0x0424) 	/**<  Pulse Register for CS 2 */
+#define SYS_SMC0_CYCLE2 	(0x0428) 	/**<  Cycle Register for CS 2 */
+#define SYS_SMC0_CTRL2 	(0x042C) 	/**<  Control Register for CS 2 */
+#define SYS_SMC0_SETUP3 	(0x0430) 	/**<  Setup Register for CS 3 */
+#define SYS_SMC0_PULSE3 	(0x0434) 	/**<  Pulse Register for CS 3 */
+#define SYS_SMC0_CYCLE3 	(0x0438) 	/**<  Cycle Register for CS 3 */
+#define SYS_SMC0_CTRL3 	(0x043C) 	/**<  Control Register for CS 3 */
+#define SYS_SMC0_SETUP4 	(0x0440) 	/**<  Setup Register for CS 4 */
+#define SYS_SMC0_PULSE4 	(0x0444) 	/**<  Pulse Register for CS 4 */
+#define SYS_SMC0_CYCLE4 	(0x0448) 	/**<  Cycle Register for CS 4 */
+#define SYS_SMC0_CTRL4 	(0x044C) 	/**<  Control Register for CS 4 */
+#define SYS_SMC0_SETUP5 	(0x0450) 	/**<  Setup Register for CS 5 */
+#define SYS_SMC0_PULSE5 	(0x0454) 	/**<  Pulse Register for CS 5 */
+#define SYS_SMC0_CYCLE5 	(0x0458) 	/**<  Cycle Register for CS 5 */
+#define SYS_SMC0_CTRL5 	(0x045C) 	/**<  Control Register for CS 5 */
+#define SYS_SMC0_SETUP6 	(0x0460) 	/**<  Setup Register for CS 6 */
+#define SYS_SMC0_PULSE6 	(0x0464) 	/**<  Pulse Register for CS 6 */
+#define SYS_SMC0_CYCLE6 	(0x0468) 	/**<  Cycle Register for CS 6 */
+#define SYS_SMC0_CTRL6 	(0x046C) 	/**<  Control Register for CS 6 */
+#define SYS_SMC0_SETUP7 	(0x0470) 	/**<  Setup Register for CS 7 */
+#define SYS_SMC0_PULSE7 	(0x0474) 	/**<  Pulse Register for CS 7 */
+#define SYS_SMC0_CYCLE7 	(0x0478) 	/**<  Cycle Register for CS 7 */
+#define SYS_SMC0_CTRL7 	(0x047C) 	/**<  Control Register for CS 7 */
+#define SYS_ECC1 	(0x0600) 	/**< ECC 0 */
+#define SYS_SDRAMC1_MR 	(0x0800) 	/**< SDRAM Controller Mode Register */
+#define SYS_SDRAMC1_TR 	(0x0804) 	/**< SDRAM Controller Refresh Timer Register */
+#define SYS_SDRAMC1_CR 	(0x0808) 	/**< SDRAM Controller Configuration Register */
+#define SYS_SDRAMC1_HSR 	(0x080C) 	/**< SDRAM Controller High Speed Register */
+#define SYS_SDRAMC1_LPR 	(0x0810) 	/**< SDRAM Controller Low Power Register */
+#define SYS_SDRAMC1_IER 	(0x0814) 	/**< SDRAM Controller Interrupt Enable Register */
+#define SYS_SDRAMC1_IDR 	(0x0818) 	/**< SDRAM Controller Interrupt Disable Register */
+#define SYS_SDRAMC1_IMR 	(0x081C) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SYS_SDRAMC1_ISR 	(0x0820) 	/**< SDRAM Controller Interrupt Mask Register */
+#define SYS_SDRAMC1_MDR 	(0x0824) 	/**< SDRAM Memory Device Register */
+#define SYS_SMC1_SETUP0 	(0x0A00) 	/**<  Setup Register for CS 0 */
+#define SYS_SMC1_PULSE0 	(0x0A04) 	/**<  Pulse Register for CS 0 */
+#define SYS_SMC1_CYCLE0 	(0x0A08) 	/**<  Cycle Register for CS 0 */
+#define SYS_SMC1_CTRL0 	(0x0A0C) 	/**<  Control Register for CS 0 */
+#define SYS_SMC1_SETUP1 	(0x0A10) 	/**<  Setup Register for CS 1 */
+#define SYS_SMC1_PULSE1 	(0x0A14) 	/**<  Pulse Register for CS 1 */
+#define SYS_SMC1_CYCLE1 	(0x0A18) 	/**<  Cycle Register for CS 1 */
+#define SYS_SMC1_CTRL1 	(0x0A1C) 	/**<  Control Register for CS 1 */
+#define SYS_SMC1_SETUP2 	(0x0A20) 	/**<  Setup Register for CS 2 */
+#define SYS_SMC1_PULSE2 	(0x0A24) 	/**<  Pulse Register for CS 2 */
+#define SYS_SMC1_CYCLE2 	(0x0A28) 	/**<  Cycle Register for CS 2 */
+#define SYS_SMC1_CTRL2 	(0x0A2C) 	/**<  Control Register for CS 2 */
+#define SYS_SMC1_SETUP3 	(0x0A30) 	/**<  Setup Register for CS 3 */
+#define SYS_SMC1_PULSE3 	(0x0A34) 	/**<  Pulse Register for CS 3 */
+#define SYS_SMC1_CYCLE3 	(0x0A38) 	/**<  Cycle Register for CS 3 */
+#define SYS_SMC1_CTRL3 	(0x0A3C) 	/**<  Control Register for CS 3 */
+#define SYS_SMC1_SETUP4 	(0x0A40) 	/**<  Setup Register for CS 4 */
+#define SYS_SMC1_PULSE4 	(0x0A44) 	/**<  Pulse Register for CS 4 */
+#define SYS_SMC1_CYCLE4 	(0x0A48) 	/**<  Cycle Register for CS 4 */
+#define SYS_SMC1_CTRL4 	(0x0A4C) 	/**<  Control Register for CS 4 */
+#define SYS_SMC1_SETUP5 	(0x0A50) 	/**<  Setup Register for CS 5 */
+#define SYS_SMC1_PULSE5 	(0x0A54) 	/**<  Pulse Register for CS 5 */
+#define SYS_SMC1_CYCLE5 	(0x0A58) 	/**<  Cycle Register for CS 5 */
+#define SYS_SMC1_CTRL5 	(0x0A5C) 	/**<  Control Register for CS 5 */
+#define SYS_SMC1_SETUP6 	(0x0A60) 	/**<  Setup Register for CS 6 */
+#define SYS_SMC1_PULSE6 	(0x0A64) 	/**<  Pulse Register for CS 6 */
+#define SYS_SMC1_CYCLE6 	(0x0A68) 	/**<  Cycle Register for CS 6 */
+#define SYS_SMC1_CTRL6 	(0x0A6C) 	/**<  Control Register for CS 6 */
+#define SYS_SMC1_SETUP7 	(0x0A70) 	/**<  Setup Register for CS 7 */
+#define SYS_SMC1_PULSE7 	(0x0A74) 	/**<  Pulse Register for CS 7 */
+#define SYS_SMC1_CYCLE7 	(0x0A78) 	/**<  Cycle Register for CS 7 */
+#define SYS_SMC1_CTRL7 	(0x0A7C) 	/**<  Control Register for CS 7 */
+#define SYS_MATRIX_MCFG0 	(0x0C00) 	/**<  Master Configuration Register 0 (rom)      */
+#define SYS_MATRIX_MCFG1 	(0x0C04) 	/**<  Master Configuration Register 1 (htcm)     */
+#define SYS_MATRIX_MCFG2 	(0x0C08) 	/**<  Master Configuration Register 2 (gps_tcm)  */
+#define SYS_MATRIX_MCFG3 	(0x0C0C) 	/**<  Master Configuration Register 3 (hperiphs) */
+#define SYS_MATRIX_MCFG4 	(0x0C10) 	/**<  Master Configuration Register 4 (ebi0)     */
+#define SYS_MATRIX_MCFG5 	(0x0C14) 	/**<  Master Configuration Register 5 (ebi1)     */
+#define SYS_MATRIX_MCFG6 	(0x0C18) 	/**<  Master Configuration Register 6 (bridge)   */
+#define SYS_MATRIX_MCFG7 	(0x0C1C) 	/**<  Master Configuration Register 7 (gps)      */
+#define SYS_MATRIX_MCFG8 	(0x0C20) 	/**<  Master Configuration Register 8 (gps)      */
+#define SYS_MATRIX_SCFG0 	(0x0C40) 	/**<  Slave Configuration Register 0 */
+#define SYS_MATRIX_SCFG1 	(0x0C44) 	/**<  Slave Configuration Register 1 */
+#define SYS_MATRIX_SCFG2 	(0x0C48) 	/**<  Slave Configuration Register 2 */
+#define SYS_MATRIX_SCFG3 	(0x0C4C) 	/**<  Slave Configuration Register 3 */
+#define SYS_MATRIX_SCFG4 	(0x0C50) 	/**<  Slave Configuration Register 4 */
+#define SYS_MATRIX_SCFG5 	(0x0C54) 	/**<  Slave Configuration Register 5 */
+#define SYS_MATRIX_SCFG6 	(0x0C58) 	/**<  Slave Configuration Register 6 */
+#define SYS_MATRIX_SCFG7 	(0x0C5C) 	/**<  Slave Configuration Register 7 */
+#define SYS_MATRIX_PRAS0 	(0x0C80) 	/**<  PRAS0 */
+#define SYS_MATRIX_PRBS0 	(0x0C84) 	/**<  PRBS0 */
+#define SYS_MATRIX_PRAS1 	(0x0C88) 	/**<  PRAS1 */
+#define SYS_MATRIX_PRBS1 	(0x0C8C) 	/**<  PRBS1 */
+#define SYS_MATRIX_PRAS2 	(0x0C90) 	/**<  PRAS2 */
+#define SYS_MATRIX_PRBS2 	(0x0C94) 	/**<  PRBS2 */
+#define SYS_MATRIX_PRAS3 	(0x0C98) 	/**<  PRAS3 */
+#define SYS_MATRIX_PRBS3 	(0x0C9C) 	/**<  PRBS3 */
+#define SYS_MATRIX_PRAS4 	(0x0CA0) 	/**<  PRAS4 */
+#define SYS_MATRIX_PRBS4 	(0x0CA4) 	/**<  PRBS4 */
+#define SYS_MATRIX_PRAS5 	(0x0CA8) 	/**<  PRAS5 */
+#define SYS_MATRIX_PRBS5 	(0x0CAC) 	/**<  PRBS5 */
+#define SYS_MATRIX_PRAS6 	(0x0CB0) 	/**<  PRAS6 */
+#define SYS_MATRIX_PRBS6 	(0x0CB4) 	/**<  PRBS6 */
+#define SYS_MATRIX_PRAS7 	(0x0CB8) 	/**<  PRAS7 */
+#define SYS_MATRIX_PRBS7 	(0x0CBC) 	/**<  PRBS7 */
+#define SYS_MATRIX_MRCR 	(0x0D00) 	/**<  Master Remp Control Register  */
+#define SYS_DBGU_CR 	(0x0E00) 	/**< Control Register */
+#define SYS_DBGU_MR 	(0x0E04) 	/**< Mode Register */
+#define SYS_DBGU_IER 	(0x0E08) 	/**< Interrupt Enable Register */
+#define SYS_DBGU_IDR 	(0x0E0C) 	/**< Interrupt Disable Register */
+#define SYS_DBGU_IMR 	(0x0E10) 	/**< Interrupt Mask Register */
+#define SYS_DBGU_CSR 	(0x0E14) 	/**< Channel Status Register */
+#define SYS_DBGU_RHR 	(0x0E18) 	/**< Receiver Holding Register */
+#define SYS_DBGU_THR 	(0x0E1C) 	/**< Transmitter Holding Register */
+#define SYS_DBGU_BRGR 	(0x0E20) 	/**< Baud Rate Generator Register */
+#define SYS_DBGU_CIDR 	(0x0E40) 	/**< Chip ID Register */
+#define SYS_DBGU_EXID 	(0x0E44) 	/**< Chip ID Extension Register */
+#define SYS_DBGU_FNTR 	(0x0E48) 	/**< Force NTRST Register */
+#define SYS_DBGU_RPR 	(0x0F00) 	/**< Receive Pointer Register */
+#define SYS_DBGU_RCR 	(0x0F04) 	/**< Receive Counter Register */
+#define SYS_DBGU_TPR 	(0x0F08) 	/**< Transmit Pointer Register */
+#define SYS_DBGU_TCR 	(0x0F0C) 	/**< Transmit Counter Register */
+#define SYS_DBGU_RNPR 	(0x0F10) 	/**< Receive Next Pointer Register */
+#define SYS_DBGU_RNCR 	(0x0F14) 	/**< Receive Next Counter Register */
+#define SYS_DBGU_TNPR 	(0x0F18) 	/**< Transmit Next Pointer Register */
+#define SYS_DBGU_TNCR 	(0x0F1C) 	/**< Transmit Next Counter Register */
+#define SYS_DBGU_PTCR 	(0x0F20) 	/**< PDC Transfer Control Register */
+#define SYS_DBGU_PTSR 	(0x0F24) 	/**< PDC Transfer Status Register */
+#define SYS_AIC_SMR 	(0x1000) 	/**< Source Mode Register */
+#define SYS_AIC_SVR 	(0x1080) 	/**< Source Vector Register */
+#define SYS_AIC_IVR 	(0x1100) 	/**< IRQ Vector Register */
+#define SYS_AIC_FVR 	(0x1104) 	/**< FIQ Vector Register */
+#define SYS_AIC_ISR 	(0x1108) 	/**< Interrupt Status Register */
+#define SYS_AIC_IPR 	(0x110C) 	/**< Interrupt Pending Register */
+#define SYS_AIC_IMR 	(0x1110) 	/**< Interrupt Mask Register */
+#define SYS_AIC_CISR 	(0x1114) 	/**< Core Interrupt Status Register */
+#define SYS_AIC_IECR 	(0x1120) 	/**< Interrupt Enable Command Register */
+#define SYS_AIC_IDCR 	(0x1124) 	/**< Interrupt Disable Command Register */
+#define SYS_AIC_ICCR 	(0x1128) 	/**< Interrupt Clear Command Register */
+#define SYS_AIC_ISCR 	(0x112C) 	/**< Interrupt Set Command Register */
+#define SYS_AIC_EOICR 	(0x1130) 	/**< End of Interrupt Command Register */
+#define SYS_AIC_SPU 	(0x1134) 	/**< Spurious Vector Register */
+#define SYS_AIC_DCR 	(0x1138) 	/**< Debug Control Register (Protect) */
+#define SYS_AIC_FFER 	(0x1140) 	/**< Fast Forcing Enable Register */
+#define SYS_AIC_FFDR 	(0x1144) 	/**< Fast Forcing Disable Register */
+#define SYS_AIC_FFSR 	(0x1148) 	/**< Fast Forcing Status Register */
+#define SYS_PIOA_PER 	(0x1200) 	/**< PIO Enable Register */
+#define SYS_PIOA_PDR 	(0x1204) 	/**< PIO Disable Register */
+#define SYS_PIOA_PSR 	(0x1208) 	/**< PIO Status Register */
+#define SYS_PIOA_OER 	(0x1210) 	/**< Output Enable Register */
+#define SYS_PIOA_ODR 	(0x1214) 	/**< Output Disable Registerr */
+#define SYS_PIOA_OSR 	(0x1218) 	/**< Output Status Register */
+#define SYS_PIOA_IFER 	(0x1220) 	/**< Input Filter Enable Register */
+#define SYS_PIOA_IFDR 	(0x1224) 	/**< Input Filter Disable Register */
+#define SYS_PIOA_IFSR 	(0x1228) 	/**< Input Filter Status Register */
+#define SYS_PIOA_SODR 	(0x1230) 	/**< Set Output Data Register */
+#define SYS_PIOA_CODR 	(0x1234) 	/**< Clear Output Data Register */
+#define SYS_PIOA_ODSR 	(0x1238) 	/**< Output Data Status Register */
+#define SYS_PIOA_PDSR 	(0x123C) 	/**< Pin Data Status Register */
+#define SYS_PIOA_IER 	(0x1240) 	/**< Interrupt Enable Register */
+#define SYS_PIOA_IDR 	(0x1244) 	/**< Interrupt Disable Register */
+#define SYS_PIOA_IMR 	(0x1248) 	/**< Interrupt Mask Register */
+#define SYS_PIOA_ISR 	(0x124C) 	/**< Interrupt Status Register */
+#define SYS_PIOA_MDER 	(0x1250) 	/**< Multi-driver Enable Register */
+#define SYS_PIOA_MDDR 	(0x1254) 	/**< Multi-driver Disable Register */
+#define SYS_PIOA_MDSR 	(0x1258) 	/**< Multi-driver Status Register */
+#define SYS_PIOA_PPUDR 	(0x1260) 	/**< Pull-up Disable Register */
+#define SYS_PIOA_PPUER 	(0x1264) 	/**< Pull-up Enable Register */
+#define SYS_PIOA_PPUSR 	(0x1268) 	/**< Pull-up Status Register */
+#define SYS_PIOA_ASR 	(0x1270) 	/**< Select A Register */
+#define SYS_PIOA_BSR 	(0x1274) 	/**< Select B Register */
+#define SYS_PIOA_ABSR 	(0x1278) 	/**< AB Select Status Register */
+#define SYS_PIOA_OWER 	(0x12A0) 	/**< Output Write Enable Register */
+#define SYS_PIOA_OWDR 	(0x12A4) 	/**< Output Write Disable Register */
+#define SYS_PIOA_OWSR 	(0x12A8) 	/**< Output Write Status Register */
+#define SYS_PIOB_PER 	(0x1400) 	/**< PIO Enable Register */
+#define SYS_PIOB_PDR 	(0x1404) 	/**< PIO Disable Register */
+#define SYS_PIOB_PSR 	(0x1408) 	/**< PIO Status Register */
+#define SYS_PIOB_OER 	(0x1410) 	/**< Output Enable Register */
+#define SYS_PIOB_ODR 	(0x1414) 	/**< Output Disable Registerr */
+#define SYS_PIOB_OSR 	(0x1418) 	/**< Output Status Register */
+#define SYS_PIOB_IFER 	(0x1420) 	/**< Input Filter Enable Register */
+#define SYS_PIOB_IFDR 	(0x1424) 	/**< Input Filter Disable Register */
+#define SYS_PIOB_IFSR 	(0x1428) 	/**< Input Filter Status Register */
+#define SYS_PIOB_SODR 	(0x1430) 	/**< Set Output Data Register */
+#define SYS_PIOB_CODR 	(0x1434) 	/**< Clear Output Data Register */
+#define SYS_PIOB_ODSR 	(0x1438) 	/**< Output Data Status Register */
+#define SYS_PIOB_PDSR 	(0x143C) 	/**< Pin Data Status Register */
+#define SYS_PIOB_IER 	(0x1440) 	/**< Interrupt Enable Register */
+#define SYS_PIOB_IDR 	(0x1444) 	/**< Interrupt Disable Register */
+#define SYS_PIOB_IMR 	(0x1448) 	/**< Interrupt Mask Register */
+#define SYS_PIOB_ISR 	(0x144C) 	/**< Interrupt Status Register */
+#define SYS_PIOB_MDER 	(0x1450) 	/**< Multi-driver Enable Register */
+#define SYS_PIOB_MDDR 	(0x1454) 	/**< Multi-driver Disable Register */
+#define SYS_PIOB_MDSR 	(0x1458) 	/**< Multi-driver Status Register */
+#define SYS_PIOB_PPUDR 	(0x1460) 	/**< Pull-up Disable Register */
+#define SYS_PIOB_PPUER 	(0x1464) 	/**< Pull-up Enable Register */
+#define SYS_PIOB_PPUSR 	(0x1468) 	/**< Pull-up Status Register */
+#define SYS_PIOB_ASR 	(0x1470) 	/**< Select A Register */
+#define SYS_PIOB_BSR 	(0x1474) 	/**< Select B Register */
+#define SYS_PIOB_ABSR 	(0x1478) 	/**< AB Select Status Register */
+#define SYS_PIOB_OWER 	(0x14A0) 	/**< Output Write Enable Register */
+#define SYS_PIOB_OWDR 	(0x14A4) 	/**< Output Write Disable Register */
+#define SYS_PIOB_OWSR 	(0x14A8) 	/**< Output Write Status Register */
+#define SYS_PIOC_PER 	(0x1600) 	/**< PIO Enable Register */
+#define SYS_PIOC_PDR 	(0x1604) 	/**< PIO Disable Register */
+#define SYS_PIOC_PSR 	(0x1608) 	/**< PIO Status Register */
+#define SYS_PIOC_OER 	(0x1610) 	/**< Output Enable Register */
+#define SYS_PIOC_ODR 	(0x1614) 	/**< Output Disable Registerr */
+#define SYS_PIOC_OSR 	(0x1618) 	/**< Output Status Register */
+#define SYS_PIOC_IFER 	(0x1620) 	/**< Input Filter Enable Register */
+#define SYS_PIOC_IFDR 	(0x1624) 	/**< Input Filter Disable Register */
+#define SYS_PIOC_IFSR 	(0x1628) 	/**< Input Filter Status Register */
+#define SYS_PIOC_SODR 	(0x1630) 	/**< Set Output Data Register */
+#define SYS_PIOC_CODR 	(0x1634) 	/**< Clear Output Data Register */
+#define SYS_PIOC_ODSR 	(0x1638) 	/**< Output Data Status Register */
+#define SYS_PIOC_PDSR 	(0x163C) 	/**< Pin Data Status Register */
+#define SYS_PIOC_IER 	(0x1640) 	/**< Interrupt Enable Register */
+#define SYS_PIOC_IDR 	(0x1644) 	/**< Interrupt Disable Register */
+#define SYS_PIOC_IMR 	(0x1648) 	/**< Interrupt Mask Register */
+#define SYS_PIOC_ISR 	(0x164C) 	/**< Interrupt Status Register */
+#define SYS_PIOC_MDER 	(0x1650) 	/**< Multi-driver Enable Register */
+#define SYS_PIOC_MDDR 	(0x1654) 	/**< Multi-driver Disable Register */
+#define SYS_PIOC_MDSR 	(0x1658) 	/**< Multi-driver Status Register */
+#define SYS_PIOC_PPUDR 	(0x1660) 	/**< Pull-up Disable Register */
+#define SYS_PIOC_PPUER 	(0x1664) 	/**< Pull-up Enable Register */
+#define SYS_PIOC_PPUSR 	(0x1668) 	/**< Pull-up Status Register */
+#define SYS_PIOC_ASR 	(0x1670) 	/**< Select A Register */
+#define SYS_PIOC_BSR 	(0x1674) 	/**< Select B Register */
+#define SYS_PIOC_ABSR 	(0x1678) 	/**< AB Select Status Register */
+#define SYS_PIOC_OWER 	(0x16A0) 	/**< Output Write Enable Register */
+#define SYS_PIOC_OWDR 	(0x16A4) 	/**< Output Write Disable Register */
+#define SYS_PIOC_OWSR 	(0x16A8) 	/**< Output Write Status Register */
+#define SYS_PIOD_PER 	(0x1800) 	/**< PIO Enable Register */
+#define SYS_PIOD_PDR 	(0x1804) 	/**< PIO Disable Register */
+#define SYS_PIOD_PSR 	(0x1808) 	/**< PIO Status Register */
+#define SYS_PIOD_OER 	(0x1810) 	/**< Output Enable Register */
+#define SYS_PIOD_ODR 	(0x1814) 	/**< Output Disable Registerr */
+#define SYS_PIOD_OSR 	(0x1818) 	/**< Output Status Register */
+#define SYS_PIOD_IFER 	(0x1820) 	/**< Input Filter Enable Register */
+#define SYS_PIOD_IFDR 	(0x1824) 	/**< Input Filter Disable Register */
+#define SYS_PIOD_IFSR 	(0x1828) 	/**< Input Filter Status Register */
+#define SYS_PIOD_SODR 	(0x1830) 	/**< Set Output Data Register */
+#define SYS_PIOD_CODR 	(0x1834) 	/**< Clear Output Data Register */
+#define SYS_PIOD_ODSR 	(0x1838) 	/**< Output Data Status Register */
+#define SYS_PIOD_PDSR 	(0x183C) 	/**< Pin Data Status Register */
+#define SYS_PIOD_IER 	(0x1840) 	/**< Interrupt Enable Register */
+#define SYS_PIOD_IDR 	(0x1844) 	/**< Interrupt Disable Register */
+#define SYS_PIOD_IMR 	(0x1848) 	/**< Interrupt Mask Register */
+#define SYS_PIOD_ISR 	(0x184C) 	/**< Interrupt Status Register */
+#define SYS_PIOD_MDER 	(0x1850) 	/**< Multi-driver Enable Register */
+#define SYS_PIOD_MDDR 	(0x1854) 	/**< Multi-driver Disable Register */
+#define SYS_PIOD_MDSR 	(0x1858) 	/**< Multi-driver Status Register */
+#define SYS_PIOD_PPUDR 	(0x1860) 	/**< Pull-up Disable Register */
+#define SYS_PIOD_PPUER 	(0x1864) 	/**< Pull-up Enable Register */
+#define SYS_PIOD_PPUSR 	(0x1868) 	/**< Pull-up Status Register */
+#define SYS_PIOD_ASR 	(0x1870) 	/**< Select A Register */
+#define SYS_PIOD_BSR 	(0x1874) 	/**< Select B Register */
+#define SYS_PIOD_ABSR 	(0x1878) 	/**< AB Select Status Register */
+#define SYS_PIOD_OWER 	(0x18A0) 	/**< Output Write Enable Register */
+#define SYS_PIOD_OWDR 	(0x18A4) 	/**< Output Write Disable Register */
+#define SYS_PIOD_OWSR 	(0x18A8) 	/**< Output Write Status Register */
+#define SYS_PIOE_PER 	(0x1A00) 	/**< PIO Enable Register */
+#define SYS_PIOE_PDR 	(0x1A04) 	/**< PIO Disable Register */
+#define SYS_PIOE_PSR 	(0x1A08) 	/**< PIO Status Register */
+#define SYS_PIOE_OER 	(0x1A10) 	/**< Output Enable Register */
+#define SYS_PIOE_ODR 	(0x1A14) 	/**< Output Disable Registerr */
+#define SYS_PIOE_OSR 	(0x1A18) 	/**< Output Status Register */
+#define SYS_PIOE_IFER 	(0x1A20) 	/**< Input Filter Enable Register */
+#define SYS_PIOE_IFDR 	(0x1A24) 	/**< Input Filter Disable Register */
+#define SYS_PIOE_IFSR 	(0x1A28) 	/**< Input Filter Status Register */
+#define SYS_PIOE_SODR 	(0x1A30) 	/**< Set Output Data Register */
+#define SYS_PIOE_CODR 	(0x1A34) 	/**< Clear Output Data Register */
+#define SYS_PIOE_ODSR 	(0x1A38) 	/**< Output Data Status Register */
+#define SYS_PIOE_PDSR 	(0x1A3C) 	/**< Pin Data Status Register */
+#define SYS_PIOE_IER 	(0x1A40) 	/**< Interrupt Enable Register */
+#define SYS_PIOE_IDR 	(0x1A44) 	/**< Interrupt Disable Register */
+#define SYS_PIOE_IMR 	(0x1A48) 	/**< Interrupt Mask Register */
+#define SYS_PIOE_ISR 	(0x1A4C) 	/**< Interrupt Status Register */
+#define SYS_PIOE_MDER 	(0x1A50) 	/**< Multi-driver Enable Register */
+#define SYS_PIOE_MDDR 	(0x1A54) 	/**< Multi-driver Disable Register */
+#define SYS_PIOE_MDSR 	(0x1A58) 	/**< Multi-driver Status Register */
+#define SYS_PIOE_PPUDR 	(0x1A60) 	/**< Pull-up Disable Register */
+#define SYS_PIOE_PPUER 	(0x1A64) 	/**< Pull-up Enable Register */
+#define SYS_PIOE_PPUSR 	(0x1A68) 	/**< Pull-up Status Register */
+#define SYS_PIOE_ASR 	(0x1A70) 	/**< Select A Register */
+#define SYS_PIOE_BSR 	(0x1A74) 	/**< Select B Register */
+#define SYS_PIOE_ABSR 	(0x1A78) 	/**< AB Select Status Register */
+#define SYS_PIOE_OWER 	(0x1AA0) 	/**< Output Write Enable Register */
+#define SYS_PIOE_OWDR 	(0x1AA4) 	/**< Output Write Disable Register */
+#define SYS_PIOE_OWSR 	(0x1AA8) 	/**< Output Write Status Register */
+#define SYS_PMC_SCER 	(0x1C00) 	/**< System Clock Enable Register */
+#define SYS_PMC_SCDR 	(0x1C04) 	/**< System Clock Disable Register */
+#define SYS_PMC_SCSR 	(0x1C08) 	/**< System Clock Status Register */
+#define SYS_PMC_PCER 	(0x1C10) 	/**< Peripheral Clock Enable Register */
+#define SYS_PMC_PCDR 	(0x1C14) 	/**< Peripheral Clock Disable Register */
+#define SYS_PMC_PCSR 	(0x1C18) 	/**< Peripheral Clock Status Register */
+#define SYS_PMC_MOR 	(0x1C20) 	/**< Main Oscillator Register */
+#define SYS_PMC_MCFR 	(0x1C24) 	/**< Main Clock  Frequency Register */
+#define SYS_PMC_PLLAR 	(0x1C28) 	/**< PLL A Register */
+#define SYS_PMC_PLLBR 	(0x1C2C) 	/**< PLL B Register */
+#define SYS_PMC_MCKR 	(0x1C30) 	/**< Master Clock Register */
+#define SYS_PMC_PCKR 	(0x1C40) 	/**< Programmable Clock Register */
+#define SYS_PMC_IER 	(0x1C60) 	/**< Interrupt Enable Register */
+#define SYS_PMC_IDR 	(0x1C64) 	/**< Interrupt Disable Register */
+#define SYS_PMC_SR 	(0x1C68) 	/**< Status Register */
+#define SYS_PMC_IMR 	(0x1C6C) 	/**< Interrupt Mask Register */
+#define SYS_RSTC_RCR 	(0x1D00) 	/**< Reset Control Register */
+#define SYS_RSTC_RSR 	(0x1D04) 	/**< Reset Status Register */
+#define SYS_RSTC_RMR 	(0x1D08) 	/**< Reset Mode Register */
+#define SYS_SHDWC_SHCR 	(0x1D10) 	/**< Shut Down Control Register */
+#define SYS_SHDWC_SHMR 	(0x1D14) 	/**< Shut Down Mode Register */
+#define SYS_SHDWC_SHSR 	(0x1D18) 	/**< Shut Down Status Register */
+#define SYS_RTTC0_RTMR 	(0x1D20) 	/**< Real-time Mode Register */
+#define SYS_RTTC0_RTAR 	(0x1D24) 	/**< Real-time Alarm Register */
+#define SYS_RTTC0_RTVR 	(0x1D28) 	/**< Real-time Value Register */
+#define SYS_RTTC0_RTSR 	(0x1D2C) 	/**< Real-time Status Register */
+#define SYS_PITC_PIMR 	(0x1D30) 	/**< Period Interval Mode Register */
+#define SYS_PITC_PISR 	(0x1D34) 	/**< Period Interval Status Register */
+#define SYS_PITC_PIVR 	(0x1D38) 	/**< Period Interval Value Register */
+#define SYS_PITC_PIIR 	(0x1D3C) 	/**< Period Interval Image Register */
+#define SYS_WDTC_WDCR 	(0x1D40) 	/**< Watchdog Control Register */
+#define SYS_WDTC_WDMR 	(0x1D44) 	/**< Watchdog Mode Register */
+#define SYS_WDTC_WDSR 	(0x1D48) 	/**< Watchdog Status Register */
+#define SYS_RTTC1_RTMR 	(0x1D50) 	/**< Real-time Mode Register */
+#define SYS_RTTC1_RTAR 	(0x1D54) 	/**< Real-time Alarm Register */
+#define SYS_RTTC1_RTVR 	(0x1D58) 	/**< Real-time Value Register */
+#define SYS_RTTC1_RTSR 	(0x1D5C) 	/**< Real-time Status Register */
+#define SYS_GPBR 	(0x1D60) 	/**< General Purpose Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for SYS hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register GPBR */
+#define AT91C_GPBR_GPRV       (0x0 << 0 ) /**< (SYS) General Purpose Register Value */
+
+#endif /* __AT91SAM9262_SYS_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_uhp.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_uhp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_uhp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_uhp.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,78 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_uhp.h
+ * 
+ * Hardware definition for the uhp peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  12/09/2005 (11:54:20) AT91 SW Application Group from UHP_6127A V1.1
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_UHP_H
+#define __AT91SAM9262_UHP_H
+
+/* -------------------------------------------------------- */
+/* UHP ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_UHP
+#define AT91C_ID_UHP   	29 /**< USB Host Port id */
+#endif /* AT91C_ID_UHP */
+
+/* -------------------------------------------------------- */
+/* UHP Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_UHP       	0x00A00000 /**< UHP base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+#define UHP_HcRevision 	(0x0000) 	/**< Revision */
+#define UHP_HcControl 	(0x0004) 	/**< Operating modes for the Host Controller */
+#define UHP_HcCommandStatus 	(0x0008) 	/**< Command & status Register */
+#define UHP_HcInterruptStatus 	(0x000C) 	/**< Interrupt Status Register */
+#define UHP_HcInterruptEnable 	(0x0010) 	/**< Interrupt Enable Register */
+#define UHP_HcInterruptDisable 	(0x0014) 	/**< Interrupt Disable Register */
+#define UHP_HcHCCA 	(0x0018) 	/**< Pointer to the Host Controller Communication Area */
+#define UHP_HcPeriodCurrentED 	(0x001C) 	/**< Current Isochronous or Interrupt Endpoint Descriptor */
+#define UHP_HcControlHeadED 	(0x0020) 	/**< First Endpoint Descriptor of the Control list */
+#define UHP_HcControlCurrentED 	(0x0024) 	/**< Endpoint Control and Status Register */
+#define UHP_HcBulkHeadED 	(0x0028) 	/**< First endpoint register of the Bulk list */
+#define UHP_HcBulkCurrentED 	(0x002C) 	/**< Current endpoint of the Bulk list */
+#define UHP_HcBulkDoneHead 	(0x0030) 	/**< Last completed transfer descriptor */
+#define UHP_HcFmInterval 	(0x0034) 	/**< Bit time between 2 consecutive SOFs */
+#define UHP_HcFmRemaining 	(0x0038) 	/**< Bit time remaining in the current Frame */
+#define UHP_HcFmNumber 	(0x003C) 	/**< Frame number */
+#define UHP_HcPeriodicStart 	(0x0040) 	/**< Periodic Start */
+#define UHP_HcLSThreshold 	(0x0044) 	/**< LS Threshold */
+#define UHP_HcRhDescriptorA 	(0x0048) 	/**< Root Hub characteristics A */
+#define UHP_HcRhDescriptorB 	(0x004C) 	/**< Root Hub characteristics B */
+#define UHP_HcRhStatus 	(0x0050) 	/**< Root Hub Status register */
+#define UHP_HcRhPortStatus 	(0x0054) 	/**< Root Hub Port Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for UHP hardware peripheral */
+/* -------------------------------------------------------- */
+
+#endif /* __AT91SAM9262_UHP_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_usart.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_usart.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2_usart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2_usart.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,253 @@
+/* linux/include/asm-arm/arch-at91sam9262/at91sam9262_usart.h
+ * 
+ * Hardware definition for the usart peripheral in the ATMEL at91sam9262 processor
+ * 
+ * Generated  10/04/2005 (15:18:33) AT91 SW Application Group from  V
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AT91SAM9262_USART_H
+#define __AT91SAM9262_USART_H
+
+/* -------------------------------------------------------- */
+/* USART ID definitions for  AT91SAM9262           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_US0
+#define AT91C_ID_US0   	 7 /**< USART 0 id */
+#endif /* AT91C_ID_US0 */
+#ifndef AT91C_ID_US1
+#define AT91C_ID_US1   	 8 /**< USART 1 id */
+#endif /* AT91C_ID_US1 */
+#ifndef AT91C_ID_US2
+#define AT91C_ID_US2   	 9 /**< USART 2 id */
+#endif /* AT91C_ID_US2 */
+
+/* -------------------------------------------------------- */
+/* USART Base Address definitions for  AT91SAM9262   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_US0       	0xFFF8C000 /**< US0 base address */
+#define AT91C_BASE_US1       	0xFFF90000 /**< US1 base address */
+#define AT91C_BASE_US2       	0xFFF94000 /**< US2 base address */
+#define AT91C_BASE_DBGU      	0xFFFFEE00 /**< DBGU base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for USART hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PA29_CTS0     	(1 << 29) /**<  */
+#define AT91C_PA28_RTS0     	(1 << 28) /**<  */
+#define AT91C_PA27_RXD0     	(1 << 27) /**<  */
+#define AT91C_PA30_SCK0     	(1 << 30) /**<  */
+#define AT91C_PA26_TXD0     	(1 << 26) /**<  */
+
+#define AT91C_PD8_CTS1     	(1 << 8) /**<  */
+#define AT91C_PD7_RTS1     	(1 << 7) /**<  */
+#define AT91C_PD1_RXD1     	(1 << 1) /**<  */
+#define AT91C_PD10_SCK1     	(1 << 10) /**<  */
+#define AT91C_PD0_TXD1     	(1 << 0) /**<  */
+
+#define AT91C_PD6_CTS2     	(1 << 6) /**<  */
+#define AT91C_PD5_RTS2     	(1 << 5) /**<  */
+#define AT91C_PD3_RXD2     	(1 << 3) /**<  */
+#define AT91C_PD9_SCK2     	(1 << 9) /**<  */
+#define AT91C_PD2_TXD2     	(1 << 2) /**<  */
+
+#define AT91C_PC30_DRXD     	(1 << 30) /**<  */
+#define AT91C_PC31_DTXD     	(1 << 31) /**<  */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for USART hardware peripheral */
+/* -------------------------------------------------------- */
+#define US_CR 	(0x0000) 	/**< Control Register */
+#define US_MR 	(0x0004) 	/**< Mode Register */
+#define US_IER 	(0x0008) 	/**< Interrupt Enable Register */
+#define US_IDR 	(0x000C) 	/**< Interrupt Disable Register */
+#define US_IMR 	(0x0010) 	/**< Interrupt Mask Register */
+#define US_CSR 	(0x0014) 	/**< Channel Status Register */
+#define US_RHR 	(0x0018) 	/**< Receiver Holding Register */
+#define US_THR 	(0x001C) 	/**< Transmitter Holding Register */
+#define US_BRGR 	(0x0020) 	/**< Baud Rate Generator Register */
+#define US_RTOR 	(0x0024) 	/**< Receiver Time-out Register */
+#define US_TTGR 	(0x0028) 	/**< Transmitter Time-guard Register */
+#define US_FIDI 	(0x0040) 	/**< FI_DI_Ratio Register */
+#define US_NER 	(0x0044) 	/**< Nb Errors Register */
+#define US_IF 	(0x004C) 	/**< IRDA_FILTER Register */
+#define US_RPR 	(0x0100) 	/**< Receive Pointer Register */
+#define US_RCR 	(0x0104) 	/**< Receive Counter Register */
+#define US_TPR 	(0x0108) 	/**< Transmit Pointer Register */
+#define US_TCR 	(0x010C) 	/**< Transmit Counter Register */
+#define US_RNPR 	(0x0110) 	/**< Receive Next Pointer Register */
+#define US_RNCR 	(0x0114) 	/**< Receive Next Counter Register */
+#define US_TNPR 	(0x0118) 	/**< Transmit Next Pointer Register */
+#define US_TNCR 	(0x011C) 	/**< Transmit Next Counter Register */
+#define US_PTCR 	(0x0120) 	/**< PDC Transfer Control Register */
+#define US_PTSR 	(0x0124) 	/**< PDC Transfer Status Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for USART hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register US_CR */
+#define AT91C_US_RSTRX        (0x1 << 2 ) /**< (USART) Reset Receiver */
+#define AT91C_US_RSTTX        (0x1 << 3 ) /**< (USART) Reset Transmitter */
+#define AT91C_US_RXEN         (0x1 << 4 ) /**< (USART) Receiver Enable */
+#define AT91C_US_RXDIS        (0x1 << 5 ) /**< (USART) Receiver Disable */
+#define AT91C_US_TXEN         (0x1 << 6 ) /**< (USART) Transmitter Enable */
+#define AT91C_US_TXDIS        (0x1 << 7 ) /**< (USART) Transmitter Disable */
+#define AT91C_US_RSTSTA       (0x1 << 8 ) /**< (USART) Reset Status Bits */
+#define AT91C_US_STTBRK       (0x1 << 9 ) /**< (USART) Start Break */
+#define AT91C_US_STPBRK       (0x1 << 10) /**< (USART) Stop Break */
+#define AT91C_US_STTTO        (0x1 << 11) /**< (USART) Start Time-out */
+#define AT91C_US_SENDA        (0x1 << 12) /**< (USART) Send Address */
+#define AT91C_US_RSTIT        (0x1 << 13) /**< (USART) Reset Iterations */
+#define AT91C_US_RSTNACK      (0x1 << 14) /**< (USART) Reset Non Acknowledge */
+#define AT91C_US_RETTO        (0x1 << 15) /**< (USART) Rearm Time-out */
+#define AT91C_US_DTREN        (0x1 << 16) /**< (USART) Data Terminal ready Enable */
+#define AT91C_US_DTRDIS       (0x1 << 17) /**< (USART) Data Terminal ready Disable */
+#define AT91C_US_RTSEN        (0x1 << 18) /**< (USART) Request to Send enable */
+#define AT91C_US_RTSDIS       (0x1 << 19) /**< (USART) Request to Send Disable */
+/* --- Register US_MR */
+#define AT91C_US_USMODE       (0xF << 0 ) /**< (USART) Usart mode */
+#define 	AT91C_US_USMODE_NORMAL               0x0 /**< (USART) Normal */
+#define 	AT91C_US_USMODE_RS485                0x1 /**< (USART) RS485 */
+#define 	AT91C_US_USMODE_HWHSH                0x2 /**< (USART) Hardware Handshaking */
+#define 	AT91C_US_USMODE_MODEM                0x3 /**< (USART) Modem */
+#define 	AT91C_US_USMODE_ISO7816_0            0x4 /**< (USART) ISO7816 protocol: T = 0 */
+#define 	AT91C_US_USMODE_ISO7816_1            0x6 /**< (USART) ISO7816 protocol: T = 1 */
+#define 	AT91C_US_USMODE_IRDA                 0x8 /**< (USART) IrDA */
+#define 	AT91C_US_USMODE_SWHSH                0xC /**< (USART) Software Handshaking */
+#define AT91C_US_CLKS         (0x3 << 4 ) /**< (USART) Clock Selection (Baud Rate generator Input Clock */
+#define 	AT91C_US_CLKS_CLOCK                (0x0 <<  4) /**< (USART) Clock */
+#define 	AT91C_US_CLKS_FDIV1                (0x1 <<  4) /**< (USART) fdiv1 */
+#define 	AT91C_US_CLKS_SLOW                 (0x2 <<  4) /**< (USART) slow_clock (ARM) */
+#define 	AT91C_US_CLKS_EXT                  (0x3 <<  4) /**< (USART) External (SCK) */
+#define AT91C_US_CHRL         (0x3 << 6 ) /**< (USART) Clock Selection (Baud Rate generator Input Clock */
+#define 	AT91C_US_CHRL_5_BITS               (0x0 <<  6) /**< (USART) Character Length: 5 bits */
+#define 	AT91C_US_CHRL_6_BITS               (0x1 <<  6) /**< (USART) Character Length: 6 bits */
+#define 	AT91C_US_CHRL_7_BITS               (0x2 <<  6) /**< (USART) Character Length: 7 bits */
+#define 	AT91C_US_CHRL_8_BITS               (0x3 <<  6) /**< (USART) Character Length: 8 bits */
+#define AT91C_US_SYNC         (0x1 << 8 ) /**< (USART) Synchronous Mode Select */
+#define AT91C_US_PAR          (0x7 << 9 ) /**< (USART) Parity type */
+#define 	AT91C_US_PAR_EVEN                 (0x0 <<  9) /**< (USART) Even Parity */
+#define 	AT91C_US_PAR_ODD                  (0x1 <<  9) /**< (USART) Odd Parity */
+#define 	AT91C_US_PAR_SPACE                (0x2 <<  9) /**< (USART) Parity forced to 0 (Space) */
+#define 	AT91C_US_PAR_MARK                 (0x3 <<  9) /**< (USART) Parity forced to 1 (Mark) */
+#define 	AT91C_US_PAR_NONE                 (0x4 <<  9) /**< (USART) No Parity */
+#define 	AT91C_US_PAR_MULTI_DROP           (0x6 <<  9) /**< (USART) Multi-drop mode */
+#define AT91C_US_NBSTOP       (0x3 << 12) /**< (USART) Number of Stop bits */
+#define 	AT91C_US_NBSTOP_1_BIT                (0x0 << 12) /**< (USART) 1 stop bit */
+#define 	AT91C_US_NBSTOP_15_BIT               (0x1 << 12) /**< (USART) Asynchronous (SYNC=0) 2 stop bits Synchronous (SYNC=1) 2 stop bits */
+#define 	AT91C_US_NBSTOP_2_BIT                (0x2 << 12) /**< (USART) 2 stop bits */
+#define AT91C_US_CHMODE       (0x3 << 14) /**< (USART) Channel Mode */
+#define 	AT91C_US_CHMODE_NORMAL               (0x0 << 14) /**< (USART) Normal Mode: The USART channel operates as an RX/TX USART. */
+#define 	AT91C_US_CHMODE_AUTO                 (0x1 << 14) /**< (USART) Automatic Echo: Receiver Data Input is connected to the TXD pin. */
+#define 	AT91C_US_CHMODE_LOCAL                (0x2 << 14) /**< (USART) Local Loopback: Transmitter Output Signal is connected to Receiver Input Signal. */
+#define 	AT91C_US_CHMODE_REMOTE               (0x3 << 14) /**< (USART) Remote Loopback: RXD pin is internally connected to TXD pin. */
+#define AT91C_US_MSBF         (0x1 << 16) /**< (USART) Bit Order */
+#define AT91C_US_MODE9        (0x1 << 17) /**< (USART) 9-bit Character length */
+#define AT91C_US_CKLO         (0x1 << 18) /**< (USART) Clock Output Select */
+#define AT91C_US_OVER         (0x1 << 19) /**< (USART) Over Sampling Mode */
+#define AT91C_US_INACK        (0x1 << 20) /**< (USART) Inhibit Non Acknowledge */
+#define AT91C_US_DSNACK       (0x1 << 21) /**< (USART) Disable Successive NACK */
+#define AT91C_US_MAX_ITER     (0x1 << 24) /**< (USART) Number of Repetitions */
+#define AT91C_US_FILTER       (0x1 << 28) /**< (USART) Receive Line Filter */
+/* --- Register US_IER */
+#define AT91C_US_RXRDY        (0x1 << 0 ) /**< (USART) RXRDY Interrupt */
+#define AT91C_US_TXRDY        (0x1 << 1 ) /**< (USART) TXRDY Interrupt */
+#define AT91C_US_RXBRK        (0x1 << 2 ) /**< (USART) Break Received/End of Break */
+#define AT91C_US_ENDRX        (0x1 << 3 ) /**< (USART) End of Receive Transfer Interrupt */
+#define AT91C_US_ENDTX        (0x1 << 4 ) /**< (USART) End of Transmit Interrupt */
+#define AT91C_US_OVRE         (0x1 << 5 ) /**< (USART) Overrun Interrupt */
+#define AT91C_US_FRAME        (0x1 << 6 ) /**< (USART) Framing Error Interrupt */
+#define AT91C_US_PARE         (0x1 << 7 ) /**< (USART) Parity Error Interrupt */
+#define AT91C_US_TIMEOUT      (0x1 << 8 ) /**< (USART) Receiver Time-out */
+#define AT91C_US_TXEMPTY      (0x1 << 9 ) /**< (USART) TXEMPTY Interrupt */
+#define AT91C_US_ITERATION    (0x1 << 10) /**< (USART) Max number of Repetitions Reached */
+#define AT91C_US_TXBUFE       (0x1 << 11) /**< (USART) TXBUFE Interrupt */
+#define AT91C_US_RXBUFF       (0x1 << 12) /**< (USART) RXBUFF Interrupt */
+#define AT91C_US_NACK         (0x1 << 13) /**< (USART) Non Acknowledge */
+#define AT91C_US_RIIC         (0x1 << 16) /**< (USART) Ring INdicator Input Change Flag */
+#define AT91C_US_DSRIC        (0x1 << 17) /**< (USART) Data Set Ready Input Change Flag */
+#define AT91C_US_DCDIC        (0x1 << 18) /**< (USART) Data Carrier Flag */
+#define AT91C_US_CTSIC        (0x1 << 19) /**< (USART) Clear To Send Input Change Flag */
+/* --- Register US_IDR */
+#define AT91C_US_RXRDY        (0x1 << 0 ) /**< (USART) RXRDY Interrupt */
+#define AT91C_US_TXRDY        (0x1 << 1 ) /**< (USART) TXRDY Interrupt */
+#define AT91C_US_RXBRK        (0x1 << 2 ) /**< (USART) Break Received/End of Break */
+#define AT91C_US_ENDRX        (0x1 << 3 ) /**< (USART) End of Receive Transfer Interrupt */
+#define AT91C_US_ENDTX        (0x1 << 4 ) /**< (USART) End of Transmit Interrupt */
+#define AT91C_US_OVRE         (0x1 << 5 ) /**< (USART) Overrun Interrupt */
+#define AT91C_US_FRAME        (0x1 << 6 ) /**< (USART) Framing Error Interrupt */
+#define AT91C_US_PARE         (0x1 << 7 ) /**< (USART) Parity Error Interrupt */
+#define AT91C_US_TIMEOUT      (0x1 << 8 ) /**< (USART) Receiver Time-out */
+#define AT91C_US_TXEMPTY      (0x1 << 9 ) /**< (USART) TXEMPTY Interrupt */
+#define AT91C_US_ITERATION    (0x1 << 10) /**< (USART) Max number of Repetitions Reached */
+#define AT91C_US_TXBUFE       (0x1 << 11) /**< (USART) TXBUFE Interrupt */
+#define AT91C_US_RXBUFF       (0x1 << 12) /**< (USART) RXBUFF Interrupt */
+#define AT91C_US_NACK         (0x1 << 13) /**< (USART) Non Acknowledge */
+#define AT91C_US_RIIC         (0x1 << 16) /**< (USART) Ring INdicator Input Change Flag */
+#define AT91C_US_DSRIC        (0x1 << 17) /**< (USART) Data Set Ready Input Change Flag */
+#define AT91C_US_DCDIC        (0x1 << 18) /**< (USART) Data Carrier Flag */
+#define AT91C_US_CTSIC        (0x1 << 19) /**< (USART) Clear To Send Input Change Flag */
+/* --- Register US_IMR */
+#define AT91C_US_RXRDY        (0x1 << 0 ) /**< (USART) RXRDY Interrupt */
+#define AT91C_US_TXRDY        (0x1 << 1 ) /**< (USART) TXRDY Interrupt */
+#define AT91C_US_RXBRK        (0x1 << 2 ) /**< (USART) Break Received/End of Break */
+#define AT91C_US_ENDRX        (0x1 << 3 ) /**< (USART) End of Receive Transfer Interrupt */
+#define AT91C_US_ENDTX        (0x1 << 4 ) /**< (USART) End of Transmit Interrupt */
+#define AT91C_US_OVRE         (0x1 << 5 ) /**< (USART) Overrun Interrupt */
+#define AT91C_US_FRAME        (0x1 << 6 ) /**< (USART) Framing Error Interrupt */
+#define AT91C_US_PARE         (0x1 << 7 ) /**< (USART) Parity Error Interrupt */
+#define AT91C_US_TIMEOUT      (0x1 << 8 ) /**< (USART) Receiver Time-out */
+#define AT91C_US_TXEMPTY      (0x1 << 9 ) /**< (USART) TXEMPTY Interrupt */
+#define AT91C_US_ITERATION    (0x1 << 10) /**< (USART) Max number of Repetitions Reached */
+#define AT91C_US_TXBUFE       (0x1 << 11) /**< (USART) TXBUFE Interrupt */
+#define AT91C_US_RXBUFF       (0x1 << 12) /**< (USART) RXBUFF Interrupt */
+#define AT91C_US_NACK         (0x1 << 13) /**< (USART) Non Acknowledge */
+#define AT91C_US_RIIC         (0x1 << 16) /**< (USART) Ring INdicator Input Change Flag */
+#define AT91C_US_DSRIC        (0x1 << 17) /**< (USART) Data Set Ready Input Change Flag */
+#define AT91C_US_DCDIC        (0x1 << 18) /**< (USART) Data Carrier Flag */
+#define AT91C_US_CTSIC        (0x1 << 19) /**< (USART) Clear To Send Input Change Flag */
+/* --- Register US_CSR */
+#define AT91C_US_RXRDY        (0x1 << 0 ) /**< (USART) RXRDY Interrupt */
+#define AT91C_US_TXRDY        (0x1 << 1 ) /**< (USART) TXRDY Interrupt */
+#define AT91C_US_RXBRK        (0x1 << 2 ) /**< (USART) Break Received/End of Break */
+#define AT91C_US_ENDRX        (0x1 << 3 ) /**< (USART) End of Receive Transfer Interrupt */
+#define AT91C_US_ENDTX        (0x1 << 4 ) /**< (USART) End of Transmit Interrupt */
+#define AT91C_US_OVRE         (0x1 << 5 ) /**< (USART) Overrun Interrupt */
+#define AT91C_US_FRAME        (0x1 << 6 ) /**< (USART) Framing Error Interrupt */
+#define AT91C_US_PARE         (0x1 << 7 ) /**< (USART) Parity Error Interrupt */
+#define AT91C_US_TIMEOUT      (0x1 << 8 ) /**< (USART) Receiver Time-out */
+#define AT91C_US_TXEMPTY      (0x1 << 9 ) /**< (USART) TXEMPTY Interrupt */
+#define AT91C_US_ITERATION    (0x1 << 10) /**< (USART) Max number of Repetitions Reached */
+#define AT91C_US_TXBUFE       (0x1 << 11) /**< (USART) TXBUFE Interrupt */
+#define AT91C_US_RXBUFF       (0x1 << 12) /**< (USART) RXBUFF Interrupt */
+#define AT91C_US_NACK         (0x1 << 13) /**< (USART) Non Acknowledge */
+#define AT91C_US_RIIC         (0x1 << 16) /**< (USART) Ring INdicator Input Change Flag */
+#define AT91C_US_DSRIC        (0x1 << 17) /**< (USART) Data Set Ready Input Change Flag */
+#define AT91C_US_DCDIC        (0x1 << 18) /**< (USART) Data Carrier Flag */
+#define AT91C_US_CTSIC        (0x1 << 19) /**< (USART) Clear To Send Input Change Flag */
+#define AT91C_US_RI           (0x1 << 20) /**< (USART) Image of RI Input */
+#define AT91C_US_DSR          (0x1 << 21) /**< (USART) Image of DSR Input */
+#define AT91C_US_DCD          (0x1 << 22) /**< (USART) Image of DCD Input */
+#define AT91C_US_CTS          (0x1 << 23) /**< (USART) Image of CTS Input */
+
+#endif /* __AT91SAM9262_USART_H */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2vb.h linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2vb.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/nadia2vb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/nadia2vb.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/at91sam9261ek.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_NADIA2VB_H
+#define __ASM_ARCH_NADIA2VB_H
+
+
+/* AT91SAM9261 clocks */
+#define AT91C_MAIN_CLOCK	199667000	// from 18.432 MHz crystal (18432000 / 4 * 39)
+/* #define AT91C_MASTER_CLOCK	99840000 */
+#define AT91C_MASTER_CLOCK	48000000
+#define AT91C_SLOW_CLOCK	32768		/* slow clock */
+#define AT91_PLLB_VALUE		0x10483F0E	/* (18.432 / 14 * 73) /2 = 47.9714  */
+
+/* FLASH */
+#define AT91_NANDFLASH_BASE	0x40000000	// NCS0: Flash physical base address
+
+/* SDRAM */
+#define AT91_SDRAM_BASE		0x20000000	// NCS1: SDRAM physical base address
+
+/* Internal SRAM base address */
+#define AT91C_IRAM_BASE		0x00300000
+#define AT91C_IRAM_SIZE		0x00014000
+
+#define AT91C_CONSOLE_DEFAULT_BAUDRATE 115200	/* default serial console baud-rate */
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/param.h linux-2.6.15.4/include/asm-arm/arch-nadia2/param.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/param.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,3 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/param.h
+ */
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/pmc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/pmc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/pmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/pmc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/pmc.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _ASM_ARCH_PMC_H
+#define _ASM_ARCH_PMC_H
+
+extern void at91_disable_periph_clock(unsigned int irq);
+extern void at91_enable_periph_clock (unsigned int irq);
+extern void at91_disable_system_clock(unsigned int mask);
+extern void at91_enable_system_clock (unsigned int mask);
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/system.h linux-2.6.15.4/include/asm-arm/arch-nadia2/system.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/system.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/system.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/system.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/hardware.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+}
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/time.h linux-2.6.15.4/include/asm-arm/arch-nadia2/time.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/time.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/time.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/time.h
+ *
+ *  Copyright (c) 2005 M. Amine SAYA, ATMEL Rousset, France
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_TIME_H
+#define __ASM_ARCH_TIME_H
+
+
+#include <asm/mach/time.h>
+
+extern struct sys_timer nadia2_timer;
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/timex.h linux-2.6.15.4/include/asm-arm/arch-nadia2/timex.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/timex.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/timex.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <asm/arch/hardware.h>
+
+#define CLOCK_TICK_RATE		(AT91C_MASTER_CLOCK/16)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/uhp.h linux-2.6.15.4/include/asm-arm/arch-nadia2/uhp.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/uhp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/uhp.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * include/asm-arm/arch-nadia2/uhp.h
+ *
+ *  Copyright (C) 2005 M. Amine SAYA, ATMEL Rousset, France.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+
+#ifndef __ASM_ARCH_UHP_H
+#define __ASM_ARCH_UHP_H
+
+
+#include <asm/arch/nadia2_uhp.h>
+#include <asm/arch/pmc.h>
+
+
+
+// Clock management functions
+static inline void at91_uhp_clock_enable (void) 
+{
+       at91_enable_periph_clock(AT91C_ID_UHP);
+}
+
+
+static inline void at91_uhp_clock_disable (void) 
+{
+       at91_disable_periph_clock(AT91C_ID_UHP);
+}
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/uncompress.h linux-2.6.15.4/include/asm-arm/arch-nadia2/uncompress.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/uncompress.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/uncompress.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * linux/include/asm-arm/arch-at91sam9261/uncompress.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *  Revision 	  2005 Atmel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <asm/io.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/usart.h>
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	while (*s) {
+		while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXRDY)) {
+			barrier();
+		}
+		writel( *s, AT91C_BASE_DBGU + US_THR); 
+		if (*s == '\n')	{
+			while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXRDY)) {
+				barrier();
+			}
+			writel('\r', AT91C_BASE_DBGU + US_THR); 
+		}
+		s++;
+	}
+	/* wait for transmission to complete */
+	while (!(readl(AT91C_BASE_DBGU + US_CSR) & AT91C_US_TXEMPTY)) {
+		barrier();
+	}
+}
+
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/usart.h linux-2.6.15.4/include/asm-arm/arch-nadia2/usart.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/usart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/usart.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef __ASM_ARCH_USART_H
+#define __ASM_ARCH_USART_H
+
+
+#include <asm/arch/nadia2_usart.h>
+
+// PIO drive functions
+
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/vmalloc.h linux-2.6.15.4/include/asm-arm/arch-nadia2/vmalloc.h
--- linux-2.6.15.4-orig/include/asm-arm/arch-nadia2/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/arch-nadia2/vmalloc.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-arm/arch-nadia2/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END		(0xFF000000 - 0x00200000)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/asm-arm/mach/serial_at91.h linux-2.6.15.4/include/asm-arm/mach/serial_at91.h
--- linux-2.6.15.4-orig/include/asm-arm/mach/serial_at91.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/mach/serial_at91.h	2006-08-09 10:45:37.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/mach/serial_at91rm9200.h
+ *
+ *  Based on serial_sa1100.h  by Nicolas Pitre
+ *
+ *  Copyright (C) 2002 ATMEL Rousset
+ *
+ *  Low level machine dependent UART functions.
+ */
+#include <linux/config.h>
+
+struct uart_port;
+
+/*
+ * This is a temporary structure for registering these
+ * functions; it is intended to be discarded after boot.
+ */
+struct at91_port_fns {
+	void	(*set_mctrl)(struct uart_port *, u_int);
+	u_int	(*get_mctrl)(struct uart_port *);
+	void	(*enable_ms)(struct uart_port *);
+	void	(*pm)(struct uart_port *, u_int, u_int);
+	int	(*set_wake)(struct uart_port *, u_int);
+	int	(*open)(struct uart_port *);
+	void	(*close)(struct uart_port *);
+};
+
+#if defined(CONFIG_SERIAL_AT91)
+void at91_register_uart_fns(struct at91_port_fns *fns);
+void at91_register_uart(int idx, int port);
+#else
+#define at91_register_uart_fns(fns) do { } while (0)
+#define at91_register_uart(idx,port) do { } while (0)
+#endif
+
+
diff -Nur linux-2.6.15.4-orig/include/asm-arm/platform.h linux-2.6.15.4/include/asm-arm/platform.h
--- linux-2.6.15.4-orig/include/asm-arm/platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/asm-arm/platform.h	2006-08-09 10:45:38.000000000 +0200
@@ -0,0 +1,18 @@
+#ifndef __ASM_ARCH_PLATFORM_H
+#define __ASM_ARCH_PLATFORM_H
+/*
+ * The serial console needs to know the address and IRQ of the serial
+ * ports before the driver core has been initialized. This function
+ * allows the driver to get a sneak preview of what we have...
+ */
+extern const struct platform_device *platform_get_device(const char *name, int id);
+
+#define platform_num_resources(dev)     ((dev)->num_resources)
+#define platform_resource_start(dev, i) ((dev)->resource[(i)].start)
+#define platform_resource_end(dev, i)   ((dev)->resource[(i)].end)
+#define platform_resource_flags(dev, i) ((dev)->resource[(i)].flags)
+#define platform_resource_len(dev, i)                   \
+        (platform_resource_end((dev), (i)) -            \
+         platform_resource_start((dev), (i)) + 1)
+
+#endif
diff -Nur linux-2.6.15.4-orig/include/linux/serial_core.h linux-2.6.15.4/include/linux/serial_core.h
--- linux-2.6.15.4-orig/include/linux/serial_core.h	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/include/linux/serial_core.h	2006-08-09 10:45:43.000000000 +0200
@@ -67,6 +67,9 @@
 /* Parisc type numbers. */
 #define PORT_MUX	48
 
+/* Atmel AT91XXXXXX SoC */
+#define PORT_AT91       49
+
 /* Macintosh Zilog type numbers */
 #define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
 #define PORT_PMAC_ZILOG	51
diff -Nur linux-2.6.15.4-orig/include/linux/spi.h linux-2.6.15.4/include/linux/spi.h
--- linux-2.6.15.4-orig/include/linux/spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/include/linux/spi.h	2006-08-09 10:45:43.000000000 +0200
@@ -0,0 +1,214 @@
+/*
+ * Definitions for the SPI bus interface. This framework is modeled
+ * after the existing Linux i2c framework.
+ *
+ * Copyright (C) 2004 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+#ifndef _LINUX_SPI_H
+#define _LINUX_SPI_H
+
+struct spi_client_params {
+	/* baud rate in bits per second */
+	unsigned int	baud_rate;
+	/* delay between CS active and first SCK transition in nanoseconds */
+	unsigned int	sck_delay;
+	/* delay between consecutive transfers in nanoseconds */
+	unsigned int	xfer_delay;
+	char		clock_polarity;
+	char		clock_phase;
+	char		bits_per_transfer;
+	char		__padding;
+};
+
+/* SCK is low when inactive */
+#define SPI_CPOL_INACTIVE_LOW		0
+/* SCK is high when inactive */
+#define SPI_CPOL_INACTIVE_HIGH		1
+/* Data changed on leading edge, sampled on trailing edge of SCK */
+#define SPI_CPHASE_SAMPLE_TRAILING	0
+/* Data changed on trailing edge, sampled on leading edge of SCK */
+#define SPI_CPHASE_SAMPLE_LEADING	1
+
+// These two macros are defined to make diffrence bitween 
+// high speed SPI devices, where FDIV = 0, and low speed 
+// devices where FDIV = 1.
+#define LOW_SPEED                       1
+#define HIGH_SPEED                      0
+
+
+struct spi_adapter_params {
+	/* delay between CS inactive and new CS active in nanoseconds */
+	unsigned int	cs_delay;
+};
+
+struct spi_xfer_unit {
+  unsigned char *buffer;
+  unsigned int buf_len;
+};
+
+// Defines the number of PDC buffers to send in one atomic SPI send/receive action
+#define MAX_SPI_PDC_XFERS  8
+
+struct spi_xfer_desc {
+  struct spi_xfer_unit tx_xfer_units[MAX_SPI_PDC_XFERS];
+  struct spi_xfer_unit rx_xfer_units[MAX_SPI_PDC_XFERS];
+  unsigned int nr_xfers;
+  unsigned int curr_xfer;
+};
+
+#ifdef __KERNEL__
+
+#include <linux/device.h>
+
+struct spi_adapter;
+struct spi_client;
+struct spi_driver;
+
+/*
+ * SPI transfers are always bidirectional, so we don't need separate
+ * send- and receive functions.
+ */
+//extern int spi_master_xfer(struct spi_client *client, char *buffer, int n);
+extern int spi_master_xfer(struct spi_client *client, struct spi_xfer_desc *xfer_desc);
+
+/*
+ * A driver is capable of handling one or more physical SPI adapters.
+ */
+struct spi_driver {
+	struct module *owner;
+	char name[32];
+	int id;
+
+	int (*attach_adapter)(struct spi_adapter *);
+	int (*detach_adapter)(struct spi_adapter *);
+
+	struct device_driver driver;
+	struct list_head list;
+};
+#define to_spi_driver(d) container_of(d, struct spi_driver, driver)
+
+extern struct bus_type spi_bus_type;
+
+#define SPI_NAME_SIZE	50
+
+/*
+ * spi_client identifies a single device that is connected to a SPI bus.
+ */
+struct spi_client {
+	int id;
+	unsigned int addr;		/* identifies the CS line on
+					 * the adapter */
+        unsigned char speed;            /* identifies the category of the device
+					   is it a high speed spck >= MCK/255,
+					   or low speed spck <= MCK/255. In last case
+					   we should be able to activate FDIV in SPI
+					   mode register */
+	struct spi_adapter *adapter;
+	struct spi_driver *driver;
+
+	struct device dev;
+	struct list_head list;
+	struct completion released;
+	char name[SPI_NAME_SIZE];
+
+	struct spi_client_params params;
+};
+#define to_spi_client(d) container_of(d, struct spi_client, dev)
+
+static inline void *spi_get_clientdata(struct spi_client *client)
+{
+	return dev_get_drvdata(&client->dev);
+}
+
+static inline void spi_set_clientdata(struct spi_client *client,
+				      void *data)
+{
+	dev_set_drvdata(&client->dev, data);
+}
+
+/*
+ * spi_adapter identifies a physical SPI bus
+ */
+struct spi_adapter {
+	int nr;
+       	int max_num_slaves;
+
+	int (*master_xfer)(struct spi_client *client, struct spi_xfer_desc *xfer_desc);
+	int (*set_client_params)(struct spi_client *client,
+				 struct spi_client_params *params);
+	int (*set_adapter_params)(struct spi_adapter *adap,
+				 struct spi_adapter_params *params);
+        int (*set_adapter_mode)(struct spi_client *client);
+        void (*configure_chipselect_pio)(struct spi_client *client);
+
+	struct module *owner;
+	struct device dev;
+	struct class_device class_dev;
+
+	struct semaphore clist_lock;
+	struct list_head clients;
+	struct list_head list;
+	struct completion dev_released;
+	struct completion class_dev_released;
+	char name[SPI_NAME_SIZE];
+};
+#define dev_to_spi_adapter(d) container_of(d, struct spi_adapter, dev)
+#define class_dev_to_spi_adapter(d) container_of(d, struct spi_adapter, class_dev)
+
+static inline void *spi_get_adapdata(struct spi_adapter *adapter)
+{
+	return dev_get_drvdata(&adapter->dev);
+}
+
+static inline void spi_set_adapdata(struct spi_adapter *adapter, void *data)
+{
+	dev_set_drvdata(&adapter->dev, data);
+}
+
+/* ---- Functions exported by spi-core.o ---- */
+
+extern int  spi_add_adapter(struct spi_adapter *adap);
+extern int  spi_del_adapter(struct spi_adapter *adap);
+
+extern int  spi_add_driver(struct spi_driver *drv);
+extern void spi_remove_driver(struct spi_driver *drv);
+
+extern int  spi_attach_client(struct spi_client *client);
+extern int  spi_detach_client(struct spi_client *client);
+
+extern int  spi_set_client_params(struct spi_client *client,
+				 struct spi_client_params *params);
+extern int  spi_set_adapter_params(struct spi_adapter *adap,
+				  struct spi_adapter_params *params);
+
+extern int  spi_set_adapter_mode(struct spi_client *client);
+extern int  spi_cfgpio_chipselect(struct spi_client *client);
+extern struct spi_adapter *spi_get_adapter(struct spi_adapter *adap);
+extern void spi_put_adapter(struct spi_adapter *adap);
+
+#endif /* __KERNEL__ */
+
+/* ---- ioctl commands ---- */
+
+#define SPI_SET_CLIENT_PARAMS	_IOW('s', 0x00, struct spi_client_params)
+#define SPI_SET_ADAPTER_PARAMS	_IOW('s', 0x01, struct spi_adapter_params)
+
+#endif /* _LINUX_SPI_H */
diff -Nur linux-2.6.15.4-orig/kernel/sched.c linux-2.6.15.4/kernel/sched.c
--- linux-2.6.15.4-orig/kernel/sched.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/kernel/sched.c	2006-08-09 10:45:36.000000000 +0200
@@ -4316,7 +4316,7 @@
 		printk("?");
 #if (BITS_PER_LONG == 32)
 	if (state == TASK_RUNNING)
-		printk(" running ");
+		printk(" running  ");
 	else
 		printk(" %08lX ", thread_saved_pc(p));
 #else
@@ -4333,13 +4333,13 @@
 		free = (unsigned long)n - (unsigned long)end_of_stack(p);
 	}
 #endif
-	printk("%5lu %5d %6d ", free, p->pid, p->parent->pid);
+	printk("%5lu %5d %6d", free, p->pid, p->parent->pid);
 	if ((relative = eldest_child(p)))
-		printk("%5d ", relative->pid);
+		printk(" %5d", relative->pid);
 	else
 		printk("      ");
 	if ((relative = younger_sibling(p)))
-		printk("%7d", relative->pid);
+		printk(" %6d", relative->pid);
 	else
 		printk("       ");
 	if ((relative = older_sibling(p)))
@@ -4361,12 +4361,12 @@
 
 #if (BITS_PER_LONG == 32)
 	printk("\n"
-	       "                                               sibling\n");
-	printk("  task             PC      pid father child younger older\n");
+	       "                                                    sibling\n");
+	printk("  task             PC     free   pid parent child younger older\n");
 #else
 	printk("\n"
-	       "                                                       sibling\n");
-	printk("  task                 PC          pid father child younger older\n");
+	       "                                                            sibling\n");
+	printk("  task                 PC          free   pid parent child younger older\n");
 #endif
 	read_lock(&tasklist_lock);
 	do_each_thread(g, p) {
diff -Nur linux-2.6.15.4-orig/lib/gen_crc32table.c linux-2.6.15.4/lib/gen_crc32table.c
--- linux-2.6.15.4-orig/lib/gen_crc32table.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/lib/gen_crc32table.c	2006-08-09 10:44:47.000000000 +0200
@@ -1,6 +1,10 @@
 #include <stdio.h>
 #include "crc32defs.h"
+#if defined(__CYGWIN__)
+#include <sys/types.h>
+#else
 #include <inttypes.h>
+#endif
 
 #define ENTRIES_PER_LINE 4
 
diff -Nur linux-2.6.15.4-orig/Makefile linux-2.6.15.4/Makefile
--- linux-2.6.15.4-orig/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/Makefile	2006-08-09 10:45:36.000000000 +0200
@@ -191,7 +191,7 @@
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
 ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+CROSS_COMPILE	?= 
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
@@ -532,7 +532,10 @@
 include $(srctree)/arch/$(ARCH)/Makefile
 
 # arch Makefile may override CC so keep this after arch Makefile is included
-NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
+#NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
+NOSTDINC_FLAGS  = -nostdinc $(shell LANG=C $(CC) -print-search-dirs | \
+			sed -e 's%\(.*timesys.*\)-cygwin%\1-linux%g' | \
+			sed -ne 's/install: \(.*\)/-I \1include/gp')
 CHECKFLAGS     += $(NOSTDINC_FLAGS)
 
 # warn about C99 declaration after statement
@@ -1167,7 +1170,8 @@
 	$(call cmd,rmdirs)
 	@find $(KBUILD_EXTMOD) $(RCS_FIND_IGNORE) \
 	 	\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
-		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \) \
+		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
+		-o -name '#~' -o -name '.#~' -o -name '*~' -o -name '.*~'\) \
 		-type f -print | xargs rm -f
 
 help:
diff -Nur linux-2.6.15.4-orig/scripts/kallsyms.c linux-2.6.15.4/scripts/kallsyms.c
--- linux-2.6.15.4-orig/scripts/kallsyms.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/scripts/kallsyms.c	2006-08-09 10:45:36.000000000 +0200
@@ -350,6 +350,71 @@
 	table_cnt = pos;
 }
 
+#ifndef memmem
+/*-
+ * Copyright (c) 2005 Pascal Gloor <pascal.gloor@spale.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Find the first occurrence of the byte string s in byte string l.
+ */
+
+void *
+memmem(l, l_len, s, s_len)
+	const void *l; size_t l_len;
+	const void *s; size_t s_len;
+{
+	register char *cur, *last;
+	const char *cl = (const char *)l;
+	const char *cs = (const char *)s;
+
+	/* we need something to compare */
+	if (l_len == 0 || s_len == 0)
+		return NULL;
+
+	/* "s" must be smaller or equal to "l" */
+	if (l_len < s_len)
+		return NULL;
+
+	/* special case where s_len == 1 */
+	if (s_len == 1)
+		return memchr(l, (int)*cs, l_len);
+
+	/* the last position where its possible to find "s" in "l" */
+	last = (char *)cl + l_len - s_len;
+
+	for (cur = (char *)cl; cur <= last; cur++)
+		if (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)
+			return cur;
+
+	return NULL;
+}
+#endif /* ! memmem */
+
 /* replace a given token in all the valid symbols. Use the sampled symbols
  * to update the counts */
 static void compress_symbols(unsigned char *str, int idx)
diff -Nur linux-2.6.15.4-orig/scripts/kconfig/Makefile linux-2.6.15.4/scripts/kconfig/Makefile
--- linux-2.6.15.4-orig/scripts/kconfig/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/scripts/kconfig/Makefile	2006-08-09 10:45:36.000000000 +0200
@@ -67,6 +67,11 @@
 %_defconfig: $(obj)/conf
 	$(Q)$< -D arch/$(ARCH)/configs/$@ arch/$(ARCH)/Kconfig
 
+%.defconfig \
+%.devconfig \
+%.fastconfig: $(obj)/conf
+	$(Q)$< -D arch/$(ARCH)/configs/$@ arch/$(ARCH)/Kconfig
+
 # Help text used by make help
 help:
 	@echo  '  config	  - Update current config utilising a line-oriented program'
@@ -128,6 +133,11 @@
 # generated files seem to need this to find local include files
 HOSTCFLAGS_lex.zconf.o	:= -I$(src)
 HOSTCFLAGS_zconf.tab.o	:= -I$(src)
+BUILD_HOST := $(shell uname | tr '[A-Z]' '[a-z]')
+ifeq "$(findstring cygwin, $(BUILD_HOST))" "cygwin"
+HOSTLOADLIBES_mconf     := -lintl
+HOSTLOADLIBES_conf     := -lintl
+endif
 
 HOSTLOADLIBES_qconf	= $(KC_QT_LIBS) -ldl
 HOSTCXXFLAGS_qconf.o	= $(KC_QT_CFLAGS) -D LKC_DIRECT_LINK
diff -Nur linux-2.6.15.4-orig/scripts/Makefile.modpost linux-2.6.15.4/scripts/Makefile.modpost
--- linux-2.6.15.4-orig/scripts/Makefile.modpost	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/scripts/Makefile.modpost	2006-08-09 10:45:36.000000000 +0200
@@ -47,6 +47,20 @@
 
 _modpost: $(modules)
 
+#
+# XXX cygwin hosts have issues with the length of command line
+# parameters.  The if_changed macro expansion and the actual command
+# ends up exceeding the POSIX (?) limit of 32 K characters
+# so let's try running the command unconditionally
+#
+
+BUILD_HOST := $(shell uname | tr '[A-Z]' '[a-z]')
+
+ifeq "$(findstring cygwin, $(BUILD_HOST))" "cygwin"
+MODPOST_COMMAND = $(cmd_modpost)
+else
+MODPOST_COMMAND = $(call if_changed,modpost)
+endif
 
 # Step 2), invoke modpost
 #  Includes step 3,4
@@ -59,7 +73,7 @@
 
 .PHONY: __modpost
 __modpost: $(wildcard vmlinux) $(modules:.ko=.o) FORCE
-	$(call cmd,modpost)
+	$(MODPOST_COMMAND)
 
 # Declare generated files as targets for modpost
 $(symverfile):         __modpost ;
diff -Nur linux-2.6.15.4-orig/scripts/mkcompile_h linux-2.6.15.4/scripts/mkcompile_h
--- linux-2.6.15.4-orig/scripts/mkcompile_h	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/scripts/mkcompile_h	2006-08-09 10:45:36.000000000 +0200
@@ -37,6 +37,31 @@
 UTS_LEN=64
 UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}\).*/\1/"
 
+#
+# Strip trailing arguments from ${CC} but
+# keep any prefixed environment variables.
+#
+CCNOARGS=""
+for word in ${CC}; do
+    case $word in
+	*=* )
+	    if [ "${CCNOARGS}"x = x ]; then
+		CCNOARGS="${word}"
+	    else
+		CCNOARGS="${CCNOARGS} ${word}"
+	    fi
+	    ;;
+	* )
+	    break
+	    ;;
+    esac
+done
+if [ "${CCNOARGS}"x = x ]; then
+    CCNOARGS="${word}"
+else
+    CCNOARGS="${CCNOARGS} ${word}"
+fi
+
 # Generate a temporary compile.h
 
 ( echo /\* This file is auto generated, version $VERSION \*/
@@ -58,7 +83,7 @@
     echo \#define LINUX_COMPILE_DOMAIN
   fi
 
-  echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
+  echo \#define LINUX_COMPILER \"`$CCNOARGS -v 2>&1 | grep '^gcc version'`\"
 ) > .tmpcompile
 
 # Only replace the real compile.h if the new one is different,
diff -Nur linux-2.6.15.4-orig/scripts/mod/sumversion.c linux-2.6.15.4/scripts/mod/sumversion.c
--- linux-2.6.15.4-orig/scripts/mod/sumversion.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/scripts/mod/sumversion.c	2006-08-09 10:45:36.000000000 +0200
@@ -1,9 +1,11 @@
-#include <netinet/in.h>
-#ifdef __sun__
+#if defined(__CYGWIN__)
+#include <sys/types.h>
+#elif defined(__sun__)
 #include <inttypes.h>
 #else
 #include <stdint.h>
 #endif
+#include <netinet/in.h>
 #include <ctype.h>
 #include <errno.h>
 #include <string.h>
diff -Nur linux-2.6.15.4-orig/sound/arm/at91-ac97.c linux-2.6.15.4/sound/arm/at91-ac97.c
--- linux-2.6.15.4-orig/sound/arm/at91-ac97.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.15.4/sound/arm/at91-ac97.c	2006-08-09 10:45:04.000000000 +0200
@@ -0,0 +1,676 @@
+/* drivers/sound/arm/at91-ac97c.c 
+ *
+ * Driver for the Atmel AC97 Controller
+ *
+ * Copyright (C) 2005 Atmel Norway
+ */
+
+
+#undef DEBUG
+#include <linux/platform_device.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+
+#include <asm/io.h>
+#include <asm/platform.h>
+#include <asm/hardware.h>
+#include <asm/cacheflush.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/ac97c.h>
+
+
+/* module parameters */
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for AC97 controller");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for AC97 controller");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable AC97 controller");
+
+
+
+typedef struct at91_ac97 {
+	spinlock_t lock;
+	void *regs;
+	int period;
+
+	snd_pcm_substream_t *playback_substream;
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	ac97_t *ac97;
+	ac97_bus_t *ac97_bus;
+	int irq;
+	struct platform_device *pdev;
+} at91_ac97_t;
+
+
+
+
+#define get_chip(card) ((at91_ac97_t *)(card)->private_data)
+
+
+
+#define ac97c_writel(chip, reg, val)			\
+	writel((val), (chip)->regs + AC97C_##reg)
+
+#define ac97c_readl(chip, reg)				\
+	readl((chip)->regs + AC97C_##reg)
+
+
+static const char driver_name[] = "at91-ac97";
+/* PCM part */
+
+static snd_pcm_hardware_t snd_at91_ac97_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED
+				   | SNDRV_PCM_INFO_MMAP
+				   | SNDRV_PCM_INFO_MMAP_VALID
+                                   | SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	//.rates			= SNDRV_PCM_RATE_8000_48000,
+	.rates			= SNDRV_PCM_RATE_CONTINUOUS,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 256*1024,
+	.period_bytes_min	= 1024,
+	.period_bytes_max	= 4*1024,
+	.periods_min		= 1,
+	.periods_max		= 64,
+};
+
+static int snd_at91_ac97_playback_open(snd_pcm_substream_t *substream)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	runtime->hw = snd_at91_ac97_hw;
+	chip->playback_substream = substream;
+	chip->period = 0;
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_playback_open\n\r", driver_name);
+	
+	return 0;
+}
+
+static int snd_at91_ac97_playback_close(snd_pcm_substream_t *substream)
+{
+        at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+
+        chip->playback_substream = NULL;
+	return 0;
+}
+
+static int snd_at91_ac97_hw_params(snd_pcm_substream_t *substream,
+				    snd_pcm_hw_params_t *hw_params)
+{
+	int err;
+
+	err = snd_pcm_lib_malloc_pages(substream,
+				       params_buffer_bytes(hw_params));
+	return err;
+}
+
+static int snd_at91_ac97_hw_free(snd_pcm_substream_t *substream)
+{
+
+	snd_pcm_lib_free_pages(substream);
+
+	return 0;
+}
+
+static int snd_at91_ac97_playback_prepare(snd_pcm_substream_t *substream)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int block_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned long word = 0;
+
+	//clean_dcache_region(runtime->dma_area, block_size * 2);
+	snd_printd(KERN_DEBUG "%s : block_size = %d\n\r", driver_name, block_size);
+	
+	/* Assign slots to channels */
+	switch (substream->runtime->channels) {
+          /* TODO: Support more than two channels */
+        case 1:
+          word |= AT91C_AC97C_CHID3_CA;
+          break;
+	case 2:
+        default:
+          /* Assign Left and Right slots (3,4) to Channel A */
+          word |= AT91C_AC97C_CHID3_CA | AT91C_AC97C_CHID4_CA;
+          break;
+	}
+
+	ac97c_writel(chip, OCA, word);
+
+	/*
+	 * Configure sample format and size.
+	 * FIXME: Avoid conflicts with capture channel.
+	 */
+        word = AT91C_AC97C_PDCEN | AT91C_AC97C_SIZE_16_BITS;
+        
+        switch (runtime->format){
+        case SNDRV_PCM_FORMAT_S16_BE:
+          word |= AT91C_AC97C_CEM;
+          break;
+        case SNDRV_PCM_FORMAT_S16_LE:
+        default:
+          break;
+        }
+
+	ac97c_writel(chip, CAMR, word);
+	
+        /* Set variable rate if needed */
+        if ( runtime->rate != 48000 ){
+          word = ac97c_readl(chip, MR);
+          word |= AT91C_AC97C_VRA;
+          ac97c_writel(chip, MR, word);
+        } else {
+          /* Clear Variable Rate Bit */
+          word = ac97c_readl(chip, MR);
+          word &= ~AT91C_AC97C_VRA;
+          ac97c_writel(chip, MR, word);
+        }
+        
+        /* Set rate */
+        snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
+
+	snd_printd(KERN_DEBUG "%s : dma_addr = %x\n\r : dma_area = %x\n\r : dma_bytes = %d\n\r", 
+		   driver_name, runtime->dma_addr, runtime->dma_area, runtime->dma_bytes);
+
+	/* Initialize and start the PDC */
+        ac97c_writel(chip, TPR, runtime->dma_addr);
+	ac97c_writel(chip, TCR, block_size / 2);
+	ac97c_writel(chip, TNPR, runtime->dma_addr + block_size);
+	ac97c_writel(chip, TNCR, block_size / 2);
+
+	/* Enable Channel A interrupts */
+	ac97c_writel(chip, IER, AT91C_AC97C_CAEVT);
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_playback_prepare\n\r", driver_name);
+
+	return 0;
+}
+
+static int at91_ac97_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long camr, ptcr = 0, flags;
+	int err = 0;
+	
+	spin_lock_irqsave(&chip->lock, flags);
+	camr = ac97c_readl(chip, CAMR);
+	
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+          /* printk(KERN_WARNING
+             "AC97C: Starting playback\n"); */
+          camr |= (AT91C_AC97C_CEN | AT91C_AC97C_ENDTX);
+	  ptcr = AT91C_PDC_TXTEN;
+	  break;
+	case SNDRV_PCM_TRIGGER_STOP:
+          /* printk(KERN_WARNING
+             "AC97C: Stopping playback\n"); */
+          camr &= ~(AT91C_AC97C_CEN | AT91C_AC97C_ENDTX);
+	  ptcr = AT91C_PDC_TXTDIS;
+          break;
+	default:
+          err = -EINVAL;
+          break;
+	}
+	
+	ac97c_writel(chip, CAMR, camr);
+	ac97c_writel(chip, PTCR, ptcr);
+	
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_trigger\n\r", driver_name);
+
+	return err;
+}
+
+static snd_pcm_uframes_t snd_at91_ac97_pointer(snd_pcm_substream_t *substream)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	unsigned long bytes;
+
+	bytes = ac97c_readl(chip, TPR) - runtime->dma_addr;
+
+/*        printk(KERN_WARNING
+               "AC97C: snd_at91_ac97_pointer: Buffer start = 0x%x, byte offset = %i\n",
+               runtime->dma_area, bytes);  */
+
+	pos = bytes_to_frames(runtime, bytes);
+	if (pos >= runtime->buffer_size)
+		pos -= runtime->buffer_size;
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_pointer\n\r", driver_name);
+
+	return pos;
+}
+
+static snd_pcm_ops_t at91_ac97_playback_ops = {
+	.open		= snd_at91_ac97_playback_open,
+	.close		= snd_at91_ac97_playback_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_at91_ac97_hw_params,
+	.hw_free	= snd_at91_ac97_hw_free,
+	.prepare	= snd_at91_ac97_playback_prepare,
+	.trigger	= at91_ac97_trigger,
+	.pointer	= snd_at91_ac97_pointer,
+};
+
+
+static struct ac97_pcm at91_ac97_pcm_defs[] __devinitdata = {
+	/* Playback */
+	{
+		.exclusive = 1,
+		.r = { {
+			.slots = ((1 << AC97_SLOT_PCM_LEFT)
+				  | (1 << AC97_SLOT_PCM_RIGHT)),
+		} },
+	},
+};
+
+static int __devinit snd_at91_ac97_pcm_new(at91_ac97_t *chip)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	err = snd_ac97_pcm_assign(chip->ac97_bus, 1, at91_ac97_pcm_defs);
+	if (err)
+		return err;
+
+	err = snd_pcm_new(chip->card, "Atmel AC97", 0, 1, 0, &pcm);
+	if (err)
+		return err;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      &chip->pdev->dev,
+					      128 * 1024, 256 * 1024);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &at91_ac97_playback_ops);
+
+	pcm->private_data = chip;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "Atmel AC97");
+	chip->pcm = pcm;
+
+	return 0;
+}
+
+/* Mixer part */
+static int snd_at91_ac97_mixer_new(at91_ac97_t *chip)
+{
+	int err;
+	ac97_template_t template;
+
+	memset(&template, 0, sizeof(template));
+	template.private_data = chip;
+	template.num = 0;
+	template.addr = 0;
+	err = snd_ac97_mixer(chip->ac97_bus, &template, &chip->ac97);
+
+	return err;
+}
+
+
+static irqreturn_t snd_at91_ac97_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	at91_ac97_t *chip = dev_id;
+	unsigned long status;
+
+	status = ac97c_readl(chip, SR);
+
+	if (status & AT91C_AC97C_CAEVT) {
+		snd_pcm_runtime_t *runtime;
+		int offset, next_period, block_size;
+		unsigned long casr;
+
+		snd_printd(KERN_DEBUG "%s : snd_at91_ac97_interrupt\n\r", driver_name);
+
+		runtime = chip->playback_substream->runtime;
+		block_size = frames_to_bytes(runtime, runtime->period_size);
+
+		casr = ac97c_readl(chip, CASR);
+		
+		if (casr & AT91C_AC97C_ENDTX) {
+			chip->period++;
+			if (chip->period == runtime->periods)
+				chip->period = 0;
+			next_period = chip->period + 1;
+			if (next_period == runtime->periods)
+				next_period = 0;
+
+			offset = block_size * next_period;
+
+			ac97c_writel(chip, TNPR, runtime->dma_addr + offset);
+			ac97c_writel(chip, TNCR, block_size / 2);
+
+			snd_pcm_period_elapsed(chip->playback_substream);
+		} else {
+                  printk(KERN_WARNING
+                         "Spurious AC97A interrupt, status = 0x%08lx\n",
+                         (unsigned long)casr);
+		}
+	} else {
+		printk(KERN_WARNING
+		       "Spurious AC97 interrupt, status = 0x%08lx\n",
+		       status);
+	}
+
+	(volatile int)ac97c_readl(chip, SR);
+
+	return IRQ_HANDLED;
+}
+
+
+/* CODEC part */
+
+static void snd_at91_ac97_hard_reset(at91_ac97_t *chip)
+{
+       // Enable AC97 Controller.
+       // Perform a cold (hard) reset of the AC97 codec.
+       ac97c_writel(chip, MR, 0);
+       ac97c_writel(chip, MR, AT91C_AC97C_ENA);
+
+       at91_ac97c_drive_reset(0);
+       udelay(1);
+       at91_ac97c_drive_reset(1);
+       udelay(1);
+}
+
+
+static void snd_at91_ac97_write(ac97_t *ac97, unsigned short reg,
+				 unsigned short val)
+{
+	at91_ac97_t *chip = ac97->private_data;
+	unsigned long word;
+	int timeout = 40;
+
+	snd_printd(KERN_DEBUG "%s : Writing codec register 0x%x = 0x%x\n\r", driver_name, reg, val);
+	/* snd_printk(KERN_WARNING "atmel-ac97: Writing codec register 0x%x\n", reg);*/
+        /* snd_printk(KERN_WARNING "atmel-ac97: Value = 0x%x\n", val); */
+
+	
+	// All these if tests should disappear. We should set the codec 
+	// register values with a mixer tool.
+	/*
+	if (reg == AC97_MASTER)
+	  val = 0;
+
+	if (reg == AC97_GENERAL_PURPOSE)
+	  val |= 0x8000;
+
+	if (reg == AC97_PCM)
+	  val = 0x707;
+	*/
+
+	word = (reg & 0x7f) << 16 | val;
+	
+	do {
+		if (ac97c_readl(chip, COSR) & AT91C_AC97C_TXRDY) {
+			ac97c_writel(chip, COTHR, word);
+			return;
+		}
+		udelay(1);
+	} while (--timeout);
+
+	snd_printk(KERN_WARNING "at91-ac97: codec write timeout\n\r");
+}
+
+static unsigned short snd_at91_ac97_read(ac97_t *ac97,
+					  unsigned short reg)
+{
+	at91_ac97_t *chip = ac97->private_data;
+	unsigned long word;
+	int timeout = 40;
+
+	snd_printd(KERN_DEBUG "%s : Reading codec register 0x%x\n\r", driver_name, reg);
+        
+	word = (0x80 | (reg & 0x7f)) << 16;
+
+	do {
+                if (ac97c_readl(chip, COSR) & AT91C_AC97C_TXRDY){
+                     ac97c_writel(chip, COTHR, word);
+                     break;
+                }
+		udelay(1);
+	} while (--timeout);
+
+	if (!timeout)
+		goto timed_out;
+
+	timeout = 40;
+
+	do {
+                if (ac97c_readl(chip, COSR) & AT91C_AC97C_RXRDY){
+                     unsigned short val = (unsigned short) ac97c_readl(chip, CORHR);
+
+		     return val;
+		}
+		udelay(1);
+	} while (--timeout);
+	
+	if (!timeout)
+		goto timed_out;
+	
+timed_out:
+	snd_printk(KERN_WARNING "at91-ac97: codec read timeout\n\r");
+	return 0xffff;
+}
+
+
+static void snd_at91_ac97_init(ac97_t *ac97)
+{
+       unsigned short value;
+
+       // init AC97 codec registers.
+       snd_at91_ac97_write(ac97, AC97_MASTER, 0);
+       value = snd_at91_ac97_read(ac97, AC97_GENERAL_PURPOSE);
+       snd_at91_ac97_write(ac97, AC97_GENERAL_PURPOSE, 0x8000 | value);
+
+       snd_printd(KERN_DEBUG "%s : Init codec registers\n\r", driver_name);
+}
+
+
+static void snd_at91_ac97_warm_reset(ac97_t *ac97)
+{
+        at91_ac97_t *chip = ac97->private_data;
+	volatile unsigned int mr = ac97c_readl(chip, MR);
+
+	mr |= AT91C_AC97C_WRST;
+
+	ac97c_writel(chip, MR, mr);
+	udelay(1);
+	
+	mr &= ~AT91C_AC97C_WRST;
+	ac97c_writel(chip, MR, mr);
+}
+
+static void snd_at91_ac97_destroy(snd_card_t *card)
+{
+	at91_ac97_t *chip = get_chip(card);
+
+	if (chip->irq != -1)
+		free_irq(chip->irq, chip);
+
+	if (chip->regs)
+		iounmap(chip->regs);
+}
+
+static int __devinit snd_at91_ac97_create(snd_card_t *card,
+					   struct platform_device *pdev)
+{
+	static ac97_bus_ops_t ops = {
+		.write	= snd_at91_ac97_write,
+		.read	= snd_at91_ac97_read,
+		//.init   = snd_at91_ac97_init,
+		.reset  = snd_at91_ac97_warm_reset,
+	};
+
+	at91_ac97_t *chip = get_chip(card);
+	int irq, err = 0;
+
+
+
+	card->private_free = snd_at91_ac97_destroy;
+
+	spin_lock_init(&chip->lock);
+	chip->card = card;
+	chip->pdev = pdev;
+	chip->irq = -1;
+
+	if (!(platform_resource_flags(pdev, 0) & IORESOURCE_MEM)
+	    || !(platform_resource_flags(pdev, 1) & IORESOURCE_IRQ))
+		return -ENODEV;
+
+	irq = platform_resource_start(pdev, 1);
+
+	err = request_irq(irq, snd_at91_ac97_interrupt, 0, "ac97", chip);
+	if (err) {
+		snd_printk(KERN_WARNING "unable to request IRQ%d\n", irq);
+		return err;
+	}
+
+	chip->irq = irq;
+
+	chip->regs = ioremap(platform_resource_start(pdev, 0),
+			     platform_resource_len(pdev, 0));
+	if (!chip->regs) {
+	        snd_printk(KERN_WARNING "unable to remap AC97C io memory\n");
+		return -ENOMEM;
+	}
+
+	// Configure AC97 Controller assigned PIO lines
+	err = at91_device_pio_setup((struct at91_pioline *)pdev->dev.platform_data);
+	if (err) {
+	        snd_printk(KERN_WARNING "unable to configure PIO lines for AC97C\n");
+	        return err;
+	}
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);
+
+	return err;
+}
+
+static int __devinit snd_at91_ac97_probe(struct device *_dev)
+{
+	static int dev;
+	struct platform_device *pdev = to_platform_device(_dev);
+	snd_card_t *card;
+	at91_ac97_t *chip;
+	int err;
+
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+			    sizeof(at91_ac97_t));
+	if (!card)
+		return -ENOMEM;
+	chip = get_chip(card);
+
+	err = snd_at91_ac97_create(card, pdev);
+	if (err)
+		goto out_free_card;
+
+	// Enable AC97 Controller clock
+	at91_ac97c_clock_enable();
+
+	// Perform a codec hard reset. 
+	// This also enables the AC97 Controller.
+	snd_at91_ac97_hard_reset(chip);
+
+	err = snd_at91_ac97_mixer_new(chip);
+	if (err)
+		goto out_free_card;
+
+	err = snd_at91_ac97_pcm_new(chip);
+	if (err)
+		goto out_free_card;
+
+	strcpy(card->driver, "ac97c");
+	strcpy(card->shortname, "Atmel AC97");
+	sprintf(card->longname, "Atmel AC97 Controller at %#lx, irq %i",
+		platform_resource_start(pdev, 0), chip->irq);
+	
+	err = snd_card_register(card);
+	if (err)
+		goto out_free_card;
+
+	dev_set_drvdata(_dev, card);
+	dev++;
+	return 0;
+
+out_free_card:
+	snd_card_free(card);
+	return err;
+}
+
+static int __devexit snd_at91_ac97_remove(struct device *dev)
+{
+        snd_card_t *card = dev_get_drvdata(dev);
+	at91_ac97_t *chip = get_chip(card);
+
+
+	snd_card_free(card);
+
+	// Disable AC97 Controller
+	ac97c_writel(chip, MR, 0);
+
+	// Disable AC97 Controller clock
+	at91_ac97c_clock_disable();
+
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+static struct device_driver at91_ac97_driver = {
+	.name		= "ac97c",
+	.bus		= &platform_bus_type,
+	.probe		= snd_at91_ac97_probe,
+	.remove		= __devexit_p(snd_at91_ac97_remove),
+};
+
+static int __init at91_ac97_init(void)
+{
+	return driver_register(&at91_ac97_driver);
+}
+
+static void __exit at91_ac97_exit(void)
+{
+	driver_unregister(&at91_ac97_driver);
+}
+
+module_init(at91_ac97_init);
+module_exit(at91_ac97_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for Atmel AC97 Controller");
+MODULE_AUTHOR("Atmel Norway");
diff -Nur linux-2.6.15.4-orig/sound/arm/Kconfig linux-2.6.15.4/sound/arm/Kconfig
--- linux-2.6.15.4-orig/sound/arm/Kconfig	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/sound/arm/Kconfig	2006-08-09 10:45:04.000000000 +0200
@@ -34,4 +34,13 @@
 	  Say Y or M if you want to support any AC97 codec attached to
 	  the PXA2xx AC97 interface.
 
+config SND_AT91_AC97
+	tristate "AC97 Controller driver for SAM926X familly from ATMEL"
+	depends on SND && MACH_NADIA2VB
+	select SND_PCM
+	select SND_AC97_CODEC
+	help
+	  Say Y or M if you want to support any AC97 codec attached to
+	  the SAM926X AC97 Controller.
+
 endmenu
diff -Nur linux-2.6.15.4-orig/sound/arm/Makefile linux-2.6.15.4/sound/arm/Makefile
--- linux-2.6.15.4-orig/sound/arm/Makefile	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/sound/arm/Makefile	2006-08-09 10:45:04.000000000 +0200
@@ -13,3 +13,6 @@
 
 obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
 snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
+
+obj-$(CONFIG_SND_AT91_AC97)	+= snd-at91-ac97.o
+snd-at91-ac97-objs		:= at91-ac97.o
\ No newline at end of file
diff -Nur linux-2.6.15.4-orig/usr/gen_init_cpio.c linux-2.6.15.4/usr/gen_init_cpio.c
--- linux-2.6.15.4-orig/usr/gen_init_cpio.c	2006-02-10 08:22:48.000000000 +0100
+++ linux-2.6.15.4/usr/gen_init_cpio.c	2006-08-09 10:45:47.000000000 +0200
@@ -10,6 +10,12 @@
 #include <ctype.h>
 #include <limits.h>
 
+/* cygwins limits.h is broken */
+#ifdef __CYGWIN__
+#undef PATH_MAX
+#define PATH_MAX 259
+#endif
+
 /*
  * Original work by Jeff Garzik
  *
