diff -urNp linux-2.6.28-at91/arch/arm/mach-at91/at91sam9263_devices.c.rej linux-2.6.28-at91-ronetix/arch/arm/mach-at91/at91sam9263_devices.c.rej
--- linux-2.6.28-at91/arch/arm/mach-at91/at91sam9263_devices.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.28-at91-ronetix/arch/arm/mach-at91/at91sam9263_devices.c.rej	2009-01-12 16:00:42.000000000 +0100
@@ -0,0 +1,17 @@
+***************
+*** 645,651 ****
+  	if (data->reset_pin)
+  		at91_set_gpio_output(data->reset_pin, 0);
+  
+- 	ac97_data = *ek_data;
+  	platform_device_register(&at91sam9263_ac97_device);
+  }
+  #else
+--- 645,651 ----
+  	if (data->reset_pin)
+  		at91_set_gpio_output(data->reset_pin, 0);
+  
++ 	ac97_data = *data;
+  	platform_device_register(&at91sam9263_ac97_device);
+  }
+  #else
diff -urNp linux-2.6.28-at91/arch/arm/mach-at91/board-pm9263.c linux-2.6.28-at91-ronetix/arch/arm/mach-at91/board-pm9263.c
--- linux-2.6.28-at91/arch/arm/mach-at91/board-pm9263.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.28-at91-ronetix/arch/arm/mach-at91/board-pm9263.c	2009-01-12 16:00:42.000000000 +0100
@@ -0,0 +1,528 @@
+/*
+ * linux/arch/arm/mach-at91/board-pm9263.c
+ *
+ *  Copyright (C) 2008 Ronetix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/i2c/at24.h>
+#include <linux/fb.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/w1-gpio.h>
+
+#include <video/atmel_lcdc.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/at91_shdwc.h>
+#include <mach/at91sam9263_matrix.h>
+
+#include "sam9_smc.h"
+#include "generic.h"
+
+
+static void __init pm9263_map_io(void)
+{
+	/* Initialize processor: 18.432 MHz crystal */
+	at91sam9263_initialize(18432000);
+
+	/* DGBU on ttyS0. (Rx & Tx only) */
+	at91_register_uart(0, 0, 0);
+
+	/* USART0 on ttyS1. (Rx, Tx, RTS, CTS) */
+	at91_register_uart(AT91SAM9263_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS);
+
+	/* set serial console to ttyS0 (ie, DBGU) */
+	at91_set_serial_console(0);
+}
+
+static void __init pm9263_init_irq(void)
+{
+	at91sam9263_init_interrupts(NULL);
+}
+
+
+/*
+ * USB Host port
+ */
+static struct at91_usbh_data __initdata pm9263_usbh_data = {
+	.ports		= 2,
+	.vbus_pin	= { 0, 0 },
+};
+
+/*
+ * USB Device port
+ */
+static struct at91_udc_data __initdata pm9263_udc_data = {
+	.vbus_pin	= AT91_PIN_PA25,
+	.pullup_pin	= 0,		/* pull-up driven by UDC */
+};
+
+
+/*
+ * ADS7846 Touchscreen
+ */
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+static int ads7843_pendown_state(void)
+{
+	return !at91_get_gpio_value(AT91_PIN_PA15);	/* Touchscreen PENIRQ */
+}
+
+static struct ads7846_platform_data ads_info = {
+	.model			= 7843,
+	.x_min			= 150,
+	.x_max			= 3830,
+	.y_min			= 190,
+	.y_max			= 3830,
+	.vref_delay_usecs	= 100,
+	.x_plate_ohms		= 450,
+	.y_plate_ohms		= 250,
+	.pressure_max		= 15000,
+	.debounce_max		= 1,
+	.debounce_rep		= 0,
+	.debounce_tol		= (~0),
+	.get_pendown_state	= ads7843_pendown_state,
+};
+
+static void __init pm9263_add_device_ts(void)
+{
+	at91_set_B_periph(AT91_PIN_PA15, 1);	/* External IRQ1, with pullup */
+	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* Touchscreen BUSY signal */
+}
+#else
+static void __init pm9263_add_device_ts(void) {}
+#endif
+
+/*
+ * SPI devices.
+ */
+static struct spi_board_info pm9263_spi_devices[] = {
+#if defined(CONFIG_MTD_AT91_DATAFLASH_CARD)
+	{	/* DataFlash card */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+		.bus_num	= 0,
+	},
+#endif
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+	{
+		.modalias	= "ads7846",
+		.chip_select	= 0,
+		.max_speed_hz	= 125000 * 16,	/* max sample rate * clocks per sample */
+		.bus_num	= 1,
+		.platform_data	= &ads_info,
+		.irq		= AT91SAM9263_ID_IRQ1,
+	},
+#endif
+};
+
+
+/*
+ * MCI (SD/MMC)
+ */
+static struct at91_mmc_data __initdata pm9263_mmc_data = {
+	.wire4		= 1,
+	.det_pin	= AT91_PIN_PA21,
+	.wp_pin		= AT91_PIN_PA16,
+//	.vcc_pin	= ... not connected
+};
+
+
+/*
+ * MACB Ethernet device
+ */
+static struct at91_eth_data __initdata pm9263_macb_data = {
+	.phy_irq_pin	= AT91_PIN_PE31,
+	.is_rmii	= 1,
+};
+
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition __initdata pm9263_nand_partition[] = {
+	{
+		.name	= "Partition 1",
+		.offset	= 0,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(pm9263_nand_partition);
+	return pm9263_nand_partition;
+}
+
+static struct atmel_nand_data __initdata pm9263_nand_data = {
+	.ale		= 21,
+	.cle		= 22,
+//	.det_pin	= ... not connected
+	.rdy_pin	= AT91_PIN_PB30,
+	.enable_pin	= AT91_PIN_PD15,
+	.partition_info	= nand_partitions,
+#if defined(CONFIG_MTD_NAND_ATMEL_BUSWIDTH_16)
+	.bus_width_16	= 1,
+#else
+	.bus_width_16	= 0,
+#endif
+};
+
+static struct sam9_smc_config __initdata pm9263_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 1,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 1,
+
+	.ncs_read_pulse		= 3,
+	.nrd_pulse		= 3,
+	.ncs_write_pulse	= 3,
+	.nwe_pulse		= 3,
+
+	.read_cycle		= 5,
+	.write_cycle		= 5,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE,
+	.tdf_cycles		= 2,
+};
+
+static void __init pm9263_add_device_nand(void)
+{
+	/* setup bus-width (8 or 16) */
+	if (pm9263_nand_data.bus_width_16)
+		pm9263_nand_smc_config.mode |= AT91_SMC_DBW_16;
+	else
+		pm9263_nand_smc_config.mode |= AT91_SMC_DBW_8;
+
+	/* configure chip-select 3 (NAND) */
+	sam9_smc_configure(3, &pm9263_nand_smc_config);
+
+	at91_add_device_nand(&pm9263_nand_data);
+}
+
+
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+		.name		= "TX09D50VM1CCA @ 60",
+		.refresh	= 60,
+		.xres		= 240,		.yres		= 320,
+		.pixclock	= KHZ2PICOS(4965),
+
+		.left_margin	= 1,		.right_margin	= 33,
+		.upper_margin	= 1,		.lower_margin	= 0,
+		.hsync_len	= 5,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "HIT",
+	.monitor	= "TX09D70VM1CCA",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 15000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+
+#define AT91SAM9263_DEFAULT_LCDCON2 	(ATMEL_LCDC_MEMOR_LITTLE \
+					| ATMEL_LCDC_DISTYPE_TFT \
+					| ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+static void at91_lcdc_power_control(int on)
+{
+	at91_set_gpio_value(AT91_PIN_PA22, on);
+}
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata pm9263_lcdc_data = {
+	.lcdcon_is_backlight		= true,
+	.default_bpp			= 16,
+	.default_dmacon			= ATMEL_LCDC_DMAEN,
+	.default_lcdcon2		= AT91SAM9263_DEFAULT_LCDCON2,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.atmel_lcdfb_power_control	= at91_lcdc_power_control,
+	.guard_time			= 1,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata pm9263_lcdc_data;
+#endif
+
+
+/*
+ * GPIO Buttons
+ */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button pm9263_buttons[] = {
+	{	/* SW3 */
+		.code		= BTN_LEFT,
+		.gpio		= AT91_PIN_PC5,
+		.active_low	= 1,
+		.desc		= "SW3",
+		.wakeup		= 1,
+	},
+	{	/* SW4 */
+		.code		= BTN_RIGHT,
+		.gpio		= AT91_PIN_PC4,
+		.active_low	= 1,
+		.desc		= "SW4",
+		.wakeup		= 1,
+	}
+};
+
+static struct gpio_keys_platform_data pm9263_button_data = {
+	.buttons	= pm9263_buttons,
+	.nbuttons	= ARRAY_SIZE(pm9263_buttons),
+};
+
+static struct platform_device pm9263_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &pm9263_button_data,
+	}
+};
+
+static void __init pm9263_add_device_buttons(void)
+{
+	int i;
+
+	for (i = 0; i < pm9263_button_data.nbuttons; i ++) {
+		at91_set_gpio_input(pm9263_buttons[i].gpio, 1);
+		at91_set_deglitch(pm9263_buttons[i].gpio, 1);
+	}
+
+//	platform_device_register(&pm9263_button_device);
+}
+#else
+static void __init pm9263_add_device_buttons(void) {}
+#endif
+
+
+/*
+ * AC97
+ */
+static struct atmel_ac97_data pm9263_ac97_data = {
+	.reset_pin	= 0,
+};
+
+
+/*
+ * LEDs ... these could all be PWM-driven, for variable brightness
+ */
+static struct gpio_led pm9263_leds[] = {
+	{	/* "right" led, green, userled2 (could be driven by pwm2) */
+		.name			= "led0",
+		.gpio			= AT91_PIN_PB7,
+		.active_low		= 1,
+		.default_trigger	= "nand-disk",
+	},
+	{	/* "power" led, yellow (could be driven by pwm0) */
+		.name			= "led1",
+		.gpio			= AT91_PIN_PB8,
+		.active_low		= 1,
+		.default_trigger	= "heartbeat",
+	}
+};
+
+#if defined(CONFIG_W1_MASTER_GPIO) || defined(CONFIG_W1_MASTER_GPIO_MODULE)
+struct w1_gpio_platform_data pm926x_w1_platdata = {
+        .pin          = AT91_PIN_PB31,
+	.is_open_drain = 0,
+};
+
+static struct platform_device pm926x_w1_device = {
+	.name		= "w1-gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data 	= &pm926x_w1_platdata,
+	},
+};
+#endif
+
+#if defined(CONFIG_AT91_CF) || defined(CONFIG_AT91_CF_MODULE)
+static struct at91_cf_data pm9263_cf_data = {
+	.det_pin	= AT91_PIN_PA30,
+	.rst_pin	= AT91_PIN_PA23,
+	.irq_pin	= AT91_PIN_PA24,
+	// .vcc_pin	= ... always powered
+	.chipselect	= 4,
+};
+
+static struct resource pm9263_cf_resources[] = {
+	[0] = {
+		.start	= AT91_CHIPSELECT_4,
+		.end	= AT91_CHIPSELECT_4 + (0x10000000 - 1),
+		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8AND16BIT,
+	},
+};
+
+static struct platform_device pm9263_cf_device = {
+	.name		= "at91_cf",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &pm9263_cf_data,
+	},
+	.resource	= pm9263_cf_resources,
+	.num_resources	= ARRAY_SIZE(pm9263_cf_resources),
+};
+
+#define CF_NWE_SETUP	(9 << 0)
+#define CF_NCS_WR_SETUP	(2 << 8)
+#define CF_NRD_SETUP	(9 << 16)
+#define CF_NCS_RD_SETUP	(2 << 24)
+
+#define CF_NWE_PULSE 	(17 << 0)
+#define CF_NCS_WR_PULSE	(27 << 8)
+#define CF_NRD_PULSE	(17 << 16)
+#define CF_NCS_RD_PULSE	(27 << 24)
+
+#define CF_NWE_CYCLE 	(40 << 0)
+#define CF_NRD_CYCLE	(40 << 16)
+
+#define CF_TDF		(1 << 16)
+
+static void __init pm9263_add_device_cf(void) {
+struct at91_cf_data *data = & pm9263_cf_data;
+unsigned int csa;
+
+	// Setup Compact flash, first enable the address range of
+	// CS4 in HMATRIX user interface
+	csa = at91_sys_read(AT91_MATRIX_EBI0CSA);
+	at91_sys_write(AT91_MATRIX_EBI0CSA, csa | AT91_MATRIX_EBI0_CS4A_SMC_CF1);
+
+	/* Configure SMC CS4 */
+	at91_sys_write(AT91_SMC_SETUP(4),
+				(CF_NWE_SETUP |
+				CF_NCS_WR_SETUP |
+				CF_NRD_SETUP |
+				CF_NCS_RD_SETUP));
+
+	at91_sys_write(AT91_SMC_PULSE(4), (CF_NWE_PULSE |
+					CF_NCS_WR_PULSE |
+					CF_NRD_PULSE |
+					CF_NCS_RD_PULSE));
+	at91_sys_write(AT91_SMC_CYCLE(4), (CF_NWE_CYCLE | CF_NRD_CYCLE));
+	// 16 bit
+	at91_sys_write (AT91_SMC_MODE(4), (AT91_SMC_READMODE |
+					AT91_SMC_WRITEMODE |
+					AT91_SMC_EXNWMODE_DISABLE |
+					AT91_SMC_DBW_16 |
+					CF_TDF));
+
+	/* input/irq */
+	if (data->irq_pin) {
+		at91_set_gpio_input(data->irq_pin, 0);
+		at91_set_deglitch(data->irq_pin, 1);
+	}
+	at91_set_gpio_input(data->det_pin, 0);
+	at91_set_deglitch(data->det_pin, 1);
+
+	/* outputs, initially off */
+	if (data->vcc_pin)
+		at91_set_gpio_output(data->vcc_pin, 0);
+	if (data->rst_pin)
+		at91_set_gpio_output(data->rst_pin, 0);
+
+	/* force poweron defaults for these pins ... */
+	at91_set_A_periph(AT91_PIN_PD5, 0);	/* PD5/CF_NWAIT */
+	at91_set_A_periph(AT91_PIN_PD14, 0);	/* A25/CFRNW */
+	at91_set_A_periph(AT91_PIN_PD6, 0);	/* NCS4/CFCS0 */
+	at91_set_A_periph(AT91_PIN_PD8, 0);	/* PD8/CFCE1 */
+	at91_set_A_periph(AT91_PIN_PD9, 0);	/* PD9/CFCE2 */
+
+	platform_device_register(&pm9263_cf_device);
+}
+#else
+void __init pm9263_add_device_cf(void) {}
+#endif
+
+static void __init pm9263_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* USB Host */
+	at91_add_device_usbh(&pm9263_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&pm9263_udc_data);
+	/* SPI */
+	at91_add_device_spi(pm9263_spi_devices, ARRAY_SIZE(pm9263_spi_devices));
+	/* Touchscreen */
+	pm9263_add_device_ts();
+	/* MMC */
+	at91_add_device_mmc(1, &pm9263_mmc_data);
+	/* Ethernet */
+	at91_add_device_eth(&pm9263_macb_data);
+	/* NAND */
+	pm9263_add_device_nand();
+	/* LCD Controller */
+	at91_add_device_lcdc(&pm9263_lcdc_data);
+	/* Push Buttons */
+	pm9263_add_device_buttons();
+	/* AC97 */
+	at91_add_device_ac97(&pm9263_ac97_data);
+#if defined(CONFIG_W1_MASTER_GPIO) || defined(CONFIG_W1_MASTER_GPIO_MODULE)
+	platform_device_register(&pm926x_w1_device);
+#endif
+	/* Compact flash */
+	pm9263_add_device_cf();
+	/* LEDs */
+	at91_gpio_leds(pm9263_leds, ARRAY_SIZE(pm9263_leds));
+	/* shutdown controller, wakeup button (5 msec low) */
+	at91_sys_write(AT91_SHDW_MR, AT91_SHDW_CPTWK0_(10) | AT91_SHDW_WKMODE0_LOW
+				| AT91_SHDW_RTTWKEN);
+}
+
+MACHINE_START(PM9263, "Ronetix PM9263/BB9263")
+	/* Maintainer: Atmel */
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91sam926x_timer,
+	.map_io		= pm9263_map_io,
+	.init_irq	= pm9263_init_irq,
+	.init_machine	= pm9263_board_init,
+MACHINE_END
diff -urNp linux-2.6.28-at91/arch/arm/mach-at91/include/mach/at91_ac97c.h linux-2.6.28-at91-ronetix/arch/arm/mach-at91/include/mach/at91_ac97c.h
--- linux-2.6.28-at91/arch/arm/mach-at91/include/mach/at91_ac97c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.28-at91-ronetix/arch/arm/mach-at91/include/mach/at91_ac97c.h	2009-01-12 16:00:42.000000000 +0100
@@ -0,0 +1,282 @@
+/* linux/include/asm-arm/arch-at91rm9200/ac97c.h
+ *
+ * Hardware definition for the ac97c peripheral in the ATMEL at91sam926x processor
+ *
+ * Generated  12/09/2005 (11:54:20) AT91 SW Application Group from AC97C_XXXX V1.3
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AC97C_H
+#define __AC97C_H
+
+/* -------------------------------------------------------- */
+/* AC97C ID definitions for  AT91SAM926x           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_AC97C
+#define AT91C_ID_AC97C	18 /**< AC97 Controller id */
+#endif /* AT91C_ID_AC97C */
+
+/* -------------------------------------------------------- */
+/* AC97C Base Address definitions for  AT91SAM926x   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_AC97C     	0xFFFA0000 /**< AC97C base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PB1_AC97CK   	(1 << 1) /**<  */
+#define AT91C_PB0_AC97FS   	(1 << 0) /**<  */
+#define AT91C_PB3_AC97RX   	(1 << 3) /**<  */
+#define AT91C_PB2_AC97TX   	(1 << 2) /**<  */
+
+
+/* -------------------------------------------------------- */
+/* Register offset definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+#define AC97C_MR 	(0x0008) 	/**< Mode Register */
+#define AC97C_ICA 	(0x0010) 	/**< Input Channel AssignementRegister */
+#define AC97C_OCA 	(0x0014) 	/**< Output Channel Assignement Register */
+#define AC97C_CARHR 	(0x0020) 	/**< Channel A Receive Holding Register */
+#define AC97C_CATHR 	(0x0024) 	/**< Channel A Transmit Holding Register */
+#define AC97C_CASR 	(0x0028) 	/**< Channel A Status Register */
+#define AC97C_CAMR 	(0x002C) 	/**< Channel A Mode Register */
+#define AC97C_CBRHR 	(0x0030) 	/**< Channel B Receive Holding Register (optional) */
+#define AC97C_CBTHR 	(0x0034) 	/**< Channel B Transmit Holding Register (optional) */
+#define AC97C_CBSR 	(0x0038) 	/**< Channel B Status Register */
+#define AC97C_CBMR 	(0x003C) 	/**< Channel B Mode Register */
+#define AC97C_CORHR 	(0x0040) 	/**< COdec Transmit Holding Register */
+#define AC97C_COTHR 	(0x0044) 	/**< COdec Transmit Holding Register */
+#define AC97C_COSR 	(0x0048) 	/**< CODEC Status Register */
+#define AC97C_COMR 	(0x004C) 	/**< CODEC Mask Status Register */
+#define AC97C_SR 	(0x0050) 	/**< Status Register */
+#define AC97C_IER 	(0x0054) 	/**< Interrupt Enable Register */
+#define AC97C_IDR 	(0x0058) 	/**< Interrupt Disable Register */
+#define AC97C_IMR 	(0x005C) 	/**< Interrupt Mask Register */
+#define AC97C_VERSION 	(0x00FC) 	/**< Version Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register AC97C_MR */
+#define AT91C_AC97C_ENA       (0x1 << 0 ) /**< (AC97C) AC97 Controller Global Enable */
+#define AT91C_AC97C_WRST      (0x1 << 1 ) /**< (AC97C) Warm Reset */
+#define AT91C_AC97C_VRA       (0x1 << 2 ) /**< (AC97C) Variable RAte (for Data Slots) */
+/* --- Register AC97C_ICA */
+#define AT91C_AC97C_CHID3     (0x7 << 0 ) /**< (AC97C) Channel Id for the input slot 3 */
+#define 	AT91C_AC97C_CHID3_NONE                 0x0 /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CA                   0x1 /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CB                   0x2 /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CC                   0x3 /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID4     (0x7 << 3 ) /**< (AC97C) Channel Id for the input slot 4 */
+#define 	AT91C_AC97C_CHID4_NONE                 (0x0 <<  3) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CA                   (0x1 <<  3) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CB                   (0x2 <<  3) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CC                   (0x3 <<  3) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID5     (0x7 << 6 ) /**< (AC97C) Channel Id for the input slot 5 */
+#define 	AT91C_AC97C_CHID5_NONE                 (0x0 <<  6) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CA                   (0x1 <<  6) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CB                   (0x2 <<  6) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CC                   (0x3 <<  6) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID6     (0x7 << 9 ) /**< (AC97C) Channel Id for the input slot 6 */
+#define 	AT91C_AC97C_CHID6_NONE                 (0x0 <<  9) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CA                   (0x1 <<  9) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CB                   (0x2 <<  9) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CC                   (0x3 <<  9) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID7     (0x7 << 12) /**< (AC97C) Channel Id for the input slot 7 */
+#define 	AT91C_AC97C_CHID7_NONE                 (0x0 << 12) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CA                   (0x1 << 12) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CB                   (0x2 << 12) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CC                   (0x3 << 12) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID8     (0x7 << 15) /**< (AC97C) Channel Id for the input slot 8 */
+#define 	AT91C_AC97C_CHID8_NONE                 (0x0 << 15) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CA                   (0x1 << 15) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CB                   (0x2 << 15) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CC                   (0x3 << 15) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID9     (0x7 << 18) /**< (AC97C) Channel Id for the input slot 9 */
+#define 	AT91C_AC97C_CHID9_NONE                 (0x0 << 18) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CA                   (0x1 << 18) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CB                   (0x2 << 18) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CC                   (0x3 << 18) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID10    (0x7 << 21) /**< (AC97C) Channel Id for the input slot 10 */
+#define 	AT91C_AC97C_CHID10_NONE                 (0x0 << 21) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CA                   (0x1 << 21) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CB                   (0x2 << 21) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CC                   (0x3 << 21) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID11    (0x7 << 24) /**< (AC97C) Channel Id for the input slot 11 */
+#define 	AT91C_AC97C_CHID11_NONE                 (0x0 << 24) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CA                   (0x1 << 24) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CB                   (0x2 << 24) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CC                   (0x3 << 24) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID12    (0x7 << 27) /**< (AC97C) Channel Id for the input slot 12 */
+#define 	AT91C_AC97C_CHID12_NONE                 (0x0 << 27) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CA                   (0x1 << 27) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CB                   (0x2 << 27) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CC                   (0x3 << 27) /**< (AC97C) Channel C data will be transmitted during this slot */
+/* --- Register AC97C_OCA */
+#define AT91C_AC97C_CHID3     (0x7 << 0 ) /**< (AC97C) Channel Id for the input slot 3 */
+#define 	AT91C_AC97C_CHID3_NONE                 0x0 /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CA                   0x1 /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CB                   0x2 /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CC                   0x3 /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID4     (0x7 << 3 ) /**< (AC97C) Channel Id for the input slot 4 */
+#define 	AT91C_AC97C_CHID4_NONE                 (0x0 <<  3) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CA                   (0x1 <<  3) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CB                   (0x2 <<  3) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CC                   (0x3 <<  3) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID5     (0x7 << 6 ) /**< (AC97C) Channel Id for the input slot 5 */
+#define 	AT91C_AC97C_CHID5_NONE                 (0x0 <<  6) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CA                   (0x1 <<  6) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CB                   (0x2 <<  6) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CC                   (0x3 <<  6) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID6     (0x7 << 9 ) /**< (AC97C) Channel Id for the input slot 6 */
+#define 	AT91C_AC97C_CHID6_NONE                 (0x0 <<  9) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CA                   (0x1 <<  9) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CB                   (0x2 <<  9) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CC                   (0x3 <<  9) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID7     (0x7 << 12) /**< (AC97C) Channel Id for the input slot 7 */
+#define 	AT91C_AC97C_CHID7_NONE                 (0x0 << 12) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CA                   (0x1 << 12) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CB                   (0x2 << 12) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CC                   (0x3 << 12) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID8     (0x7 << 15) /**< (AC97C) Channel Id for the input slot 8 */
+#define 	AT91C_AC97C_CHID8_NONE                 (0x0 << 15) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CA                   (0x1 << 15) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CB                   (0x2 << 15) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CC                   (0x3 << 15) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID9     (0x7 << 18) /**< (AC97C) Channel Id for the input slot 9 */
+#define 	AT91C_AC97C_CHID9_NONE                 (0x0 << 18) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CA                   (0x1 << 18) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CB                   (0x2 << 18) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CC                   (0x3 << 18) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID10    (0x7 << 21) /**< (AC97C) Channel Id for the input slot 10 */
+#define 	AT91C_AC97C_CHID10_NONE                 (0x0 << 21) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CA                   (0x1 << 21) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CB                   (0x2 << 21) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CC                   (0x3 << 21) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID11    (0x7 << 24) /**< (AC97C) Channel Id for the input slot 11 */
+#define 	AT91C_AC97C_CHID11_NONE                 (0x0 << 24) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CA                   (0x1 << 24) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CB                   (0x2 << 24) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CC                   (0x3 << 24) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID12    (0x7 << 27) /**< (AC97C) Channel Id for the input slot 12 */
+#define 	AT91C_AC97C_CHID12_NONE                 (0x0 << 27) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CA                   (0x1 << 27) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CB                   (0x2 << 27) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CC                   (0x3 << 27) /**< (AC97C) Channel C data will be transmitted during this slot */
+/* --- Register AC97C_CARHR */
+#define AT91C_AC97C_RDATA     (0xFFFFF << 0 ) /**< (AC97C) Receive data */
+/* --- Register AC97C_CATHR */
+#define AT91C_AC97C_TDATA     (0xFFFFF << 0 ) /**< (AC97C) Transmit data */
+/* --- Register AC97C_CASR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_ENDTX     (0x1 << 10) /**< (AC97C)  */
+#define AT91C_AC97C_TXBUFE    (0x1 << 11) /**< (AC97C)  */
+#define AT91C_AC97C_ENDRX     (0x1 << 14) /**< (AC97C)  */
+#define AT91C_AC97C_RXBUFF    (0x1 << 15) /**< (AC97C)  */
+/* --- Register AC97C_CAMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_ENDTX     (0x1 << 10) /**< (AC97C)  */
+#define AT91C_AC97C_TXBUFE    (0x1 << 11) /**< (AC97C)  */
+#define AT91C_AC97C_ENDRX     (0x1 << 14) /**< (AC97C)  */
+#define AT91C_AC97C_RXBUFF    (0x1 << 15) /**< (AC97C)  */
+#define AT91C_AC97C_SIZE      (0x3 << 16) /**< (AC97C)  */
+#define 	AT91C_AC97C_SIZE_20_BITS              (0x0 << 16) /**< (AC97C) Data size is 20 bits */
+#define 	AT91C_AC97C_SIZE_18_BITS              (0x1 << 16) /**< (AC97C) Data size is 18 bits */
+#define 	AT91C_AC97C_SIZE_16_BITS              (0x2 << 16) /**< (AC97C) Data size is 16 bits */
+#define 	AT91C_AC97C_SIZE_10_BITS              (0x3 << 16) /**< (AC97C) Data size is 10 bits */
+#define AT91C_AC97C_CEM       (0x1 << 18) /**< (AC97C)  */
+#define AT91C_AC97C_CEN       (0x1 << 21) /**< (AC97C)  */
+#define AT91C_AC97C_PDCEN     (0x1 << 22) /**< (AC97C)  */
+/* --- Register AC97C_CBRHR */
+#define AT91C_AC97C_RDATA     (0xFFFFF << 0 ) /**< (AC97C) Receive data */
+/* --- Register AC97C_CBTHR */
+#define AT91C_AC97C_TDATA     (0xFFFFF << 0 ) /**< (AC97C) Transmit data */
+/* --- Register AC97C_CBSR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+/* --- Register AC97C_CBMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_SIZE      (0x3 << 16) /**< (AC97C)  */
+#define 	AT91C_AC97C_SIZE_20_BITS              (0x0 << 16) /**< (AC97C) Data size is 20 bits */
+#define 	AT91C_AC97C_SIZE_18_BITS              (0x1 << 16) /**< (AC97C) Data size is 18 bits */
+#define 	AT91C_AC97C_SIZE_16_BITS              (0x2 << 16) /**< (AC97C) Data size is 16 bits */
+#define 	AT91C_AC97C_SIZE_10_BITS              (0x3 << 16) /**< (AC97C) Data size is 10 bits */
+#define AT91C_AC97C_CEM       (0x1 << 18) /**< (AC97C)  */
+#define AT91C_AC97C_CEN       (0x1 << 21) /**< (AC97C)  */
+/* --- Register AC97C_CORHR */
+#define AT91C_AC97C_SDATA     (0xFFFF << 0 ) /**< (AC97C) Status Data */
+/* --- Register AC97C_COTHR */
+#define AT91C_AC97C_CDATA     (0xFFFF << 0 ) /**< (AC97C) Command Data */
+#define AT91C_AC97C_CADDR     (0x7F << 16) /**< (AC97C) COdec control register index */
+#define AT91C_AC97C_READ      (0x1 << 23) /**< (AC97C) Read/Write command */
+/* --- Register AC97C_COSR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_COMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_SR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IER */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IDR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IMR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+
+#endif /* __AC97C_H */
diff -urNp linux-2.6.28-at91/arch/arm/mach-at91/Kconfig linux-2.6.28-at91-ronetix/arch/arm/mach-at91/Kconfig
--- linux-2.6.28-at91/arch/arm/mach-at91/Kconfig	2009-01-12 15:59:27.000000000 +0100
+++ linux-2.6.28-at91-ronetix/arch/arm/mach-at91/Kconfig	2009-01-12 16:00:41.000000000 +0100
@@ -280,6 +280,13 @@ config MACH_NEOCORE926
 	help
 	  Select this if you are using the Adeneo Neocore 926 board.
 
+config MACH_PM9263
+	bool "Ronetix PM9263 Evaluation Kit"
+	depends on ARCH_AT91SAM9263
+	help
+	  Select this if you are using Ronetix's PM9263 board.
+	  <http://ronetix.at/starter_kit_9263.html>
+
 endif
 
 # ----------------------------------------------------------
@@ -347,13 +354,13 @@ comment "AT91 Board Options"
 
 config MTD_AT91_DATAFLASH_CARD
 	bool "Enable DataFlash Card support"
-	depends on (ARCH_AT91RM9200DK || MACH_AT91RM9200EK || MACH_AT91SAM9260EK || MACH_AT91SAM9261EK || MACH_AT91SAM9263EK || MACH_AT91SAM9G20EK || MACH_ECBAT91 || MACH_SAM9_L9260 || MACH_AT91CAP9ADK || MACH_TOTEMNOVA || MACH_NEOCORE926)
+	depends on (ARCH_AT91RM9200DK || MACH_AT91RM9200EK || MACH_AT91SAM9260EK || MACH_AT91SAM9261EK || MACH_AT91SAM9263EK || MACH_AT91SAM9G20EK || MACH_ECBAT91 || MACH_SAM9_L9260 || MACH_AT91CAP9ADK || MACH_TOTEMNOVA || MACH_NEOCORE926 || MACH_PM9263)
 	help
 	  Enable support for the DataFlash card.
 
 config MTD_NAND_ATMEL_BUSWIDTH_16
 	bool "Enable 16-bit data bus interface to NAND flash"
-	depends on (MACH_AT91SAM9260EK || MACH_AT91SAM9261EK || MACH_AT91SAM9263EK || MACH_AT91SAM9G20EK || MACH_AT91CAP9ADK)
+	depends on (MACH_AT91SAM9260EK || MACH_AT91SAM9261EK || MACH_AT91SAM9263EK || MACH_AT91SAM9G20EK || MACH_AT91CAP9ADK || MACH_PM9263)
 	help
 	  On AT91SAM926x boards both types of NAND flash can be present
 	  (8 and 16 bit data bus width).
diff -urNp linux-2.6.28-at91/arch/arm/mach-at91/Makefile linux-2.6.28-at91-ronetix/arch/arm/mach-at91/Makefile
--- linux-2.6.28-at91/arch/arm/mach-at91/Makefile	2009-01-12 15:59:27.000000000 +0100
+++ linux-2.6.28-at91-ronetix/arch/arm/mach-at91/Makefile	2009-01-12 16:00:41.000000000 +0100
@@ -54,6 +54,7 @@ obj-$(CONFIG_MACH_USB_A9263)	+= board-us
 obj-$(CONFIG_MACH_CSB737)	+= board-csb737.o
 obj-$(CONFIG_MACH_TOTEMNOVA)	+= board-totemnova.o
 obj-$(CONFIG_MACH_NEOCORE926)	+= board-neocore926.o
+obj-$(CONFIG_MACH_PM9263)	+= board-pm9263.o
 
 # AT91SAM9RL board-specific support
 obj-$(CONFIG_MACH_AT91SAM9RLEK)	+= board-sam9rlek.o
diff -urNp linux-2.6.28-at91/drivers/pcmcia/at91_cf.c linux-2.6.28-at91-ronetix/drivers/pcmcia/at91_cf.c
--- linux-2.6.28-at91/drivers/pcmcia/at91_cf.c	2009-01-12 15:59:27.000000000 +0100
+++ linux-2.6.28-at91-ronetix/drivers/pcmcia/at91_cf.c	2009-01-12 16:00:42.000000000 +0100
@@ -27,7 +27,7 @@
 
 #if defined(CONFIG_ARCH_AT91RM9200)
 #include <mach/at91rm9200_mc.h>
-#elif defined(CONFIG_ARCH_AT91SAM9260)
+#elif defined(CONFIG_ARCH_AT91SAM9260) || defined(CONFIG_ARCH_AT91SAM9263)
 #include <mach/at91sam9_smc.h>
 #else
 #error "Unsupported AT91 processor"
@@ -138,7 +138,8 @@ at91_cf_set_socket(struct pcmcia_socket 
 	}
 
 	/* toggle reset if needed */
-	gpio_set_value(cf->board->rst_pin, s->flags & SS_RESET);
+	if (cf->board->rst_pin)
+		gpio_set_value(cf->board->rst_pin, s->flags & SS_RESET);
 
 	pr_debug("%s: Vcc %d, io_irq %d, flags %04x csc %04x\n",
 		driver_name, s->Vcc, s->io_irq, s->flags, s->csc_mask);
diff -urNp linux-2.6.28-at91/drivers/pcmcia/Kconfig linux-2.6.28-at91-ronetix/drivers/pcmcia/Kconfig
--- linux-2.6.28-at91/drivers/pcmcia/Kconfig	2009-01-12 15:59:27.000000000 +0100
+++ linux-2.6.28-at91-ronetix/drivers/pcmcia/Kconfig	2009-01-12 16:00:42.000000000 +0100
@@ -270,7 +270,7 @@ config BFIN_CFPCMCIA
 
 config AT91_CF
 	tristate "AT91 CompactFlash Controller"
-	depends on PCMCIA && (ARCH_AT91RM9200 || ARCH_AT91SAM9260)
+	depends on PCMCIA && (ARCH_AT91RM9200 || ARCH_AT91SAM9260 || ARCH_AT91SAM9263)
 	help
 	  Say Y here to support the CompactFlash controller on AT91 chips.
 	  Or choose M to compile the driver as a module named "at91_cf".
diff -urNp linux-2.6.28-at91/sound/arm/at91-ac97.c.rej linux-2.6.28-at91-ronetix/sound/arm/at91-ac97.c.rej
--- linux-2.6.28-at91/sound/arm/at91-ac97.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.28-at91-ronetix/sound/arm/at91-ac97.c.rej	2009-01-12 16:00:43.000000000 +0100
@@ -0,0 +1,702 @@
+***************
+*** 0 ****
+--- 1,699 ----
++ /* drivers/sound/arm/at91-ac97c.c
++  *
++  * Driver for the Atmel AC97 Controller
++  *
++  * Copyright (C) 2005 Atmel Norway
++  */
++ 
++ #define CAPTURE	0
++ 
++ #define EXTRA_DEBUG	0
++ 
++ #undef DEBUG
++ #include <linux/platform_device.h>
++ #include <linux/module.h>
++ #include <linux/init.h>
++ #include <linux/interrupt.h>
++ #include <linux/delay.h>
++ #include <linux/clk.h>
++ #include <linux/atmel_pdc.h>
++ 
++ //#include <sound/driver.h>
++ #include <sound/core.h>
++ #include <sound/initval.h>
++ #include <sound/pcm.h>
++ #include <sound/ac97_codec.h>
++ 
++ #include <asm/io.h>
++ #include <mach/hardware.h>
++ #include <asm/cacheflush.h>
++ 
++ #include <mach/gpio.h>
++ #include <mach/at91_ac97c.h>
++ #include <mach/board.h>
++ 
++ #define platform_num_resources(dev)     ((dev)->num_resources)
++ #define platform_resource_start(dev, i) ((dev)->resource[(i)].start)
++ #define platform_resource_end(dev, i)   ((dev)->resource[(i)].end)
++ #define platform_resource_flags(dev, i) ((dev)->resource[(i)].flags)
++ #define platform_resource_len(dev, i)                   \
++         (platform_resource_end((dev), (i)) -            \
++          platform_resource_start((dev), (i)) + 1)
++ 
++ 
++ /* module parameters */
++ static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
++ static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
++ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
++ 
++ module_param_array(index, int, NULL, 0444);
++ MODULE_PARM_DESC(index, "Index value for AC97 controller");
++ module_param_array(id, charp, NULL, 0444);
++ MODULE_PARM_DESC(id, "ID string for AC97 controller");
++ module_param_array(enable, bool, NULL, 0444);
++ MODULE_PARM_DESC(enable, "Enable AC97 controller");
++ 
++ typedef struct at91_ac97 {
++ 	spinlock_t lock;
++ 	void *regs;
++ 	int period;
++ 	struct clk *ac97_clk;
++ 	struct snd_pcm_substream *playback_substream;
++ 	struct snd_card *card;
++ 	struct snd_pcm *pcm;
++ 	struct snd_ac97 *ac97;
++ 	struct snd_ac97_bus *ac97_bus;
++ 	int irq;
++ 	struct platform_device *pdev;
++ 	u8 reset_pin;
++ } at91_ac97_t;
++ 
++ #define get_chip(card) ((at91_ac97_t *)(card)->private_data)
++ 
++ #define ac97c_writel(chip, reg, val)			\
++ 	writel((val), (chip)->regs + AC97C_##reg)
++ 
++ #define ac97c_readl(chip, reg)				\
++ 	readl((chip)->regs + AC97C_##reg)
++ 
++ // PIO management functions
++ void at91_ac97c_drive_reset(at91_ac97_t *chip, unsigned int value)
++ {
++ 	if (chip->reset_pin)
++ 		at91_set_gpio_value(chip->reset_pin, value);
++ }
++ 
++ 
++ static const char driver_name[] = "at91-ac97";
++ 
++ /* PCM part */
++ 
++ static struct snd_pcm_hardware snd_at91_ac97_hw = {
++ 	.info			= (SNDRV_PCM_INFO_INTERLEAVED
++ 				   | SNDRV_PCM_INFO_MMAP
++ 				   | SNDRV_PCM_INFO_MMAP_VALID
++                                    | SNDRV_PCM_INFO_BLOCK_TRANSFER),
++ 	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
++ 	.rates			= SNDRV_PCM_RATE_CONTINUOUS,
++ 	.rate_min		= 8000,
++ 	.rate_max		= 48000,
++ 	.channels_min		= 2,
++ 	.channels_max		= 2,
++ 	.buffer_bytes_max	= 256*1024,
++ 	.period_bytes_min	= 1024,
++ 	.period_bytes_max	= 4*1024,
++ 	.periods_min		= 1,
++ 	.periods_max		= 64,
++ };
++ 
++ static int snd_at91_ac97_playback_open(struct snd_pcm_substream *substream)
++ {
++ 	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
++ 	struct snd_pcm_runtime *runtime = substream->runtime;
++ 
++ 	runtime->hw = snd_at91_ac97_hw;
++ 	chip->playback_substream = substream;
++ 	chip->period = 0;
++ 
++ 	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_playback_open\n\r", driver_name);
++ 
++ 	return 0;
++ }
++ 
++ static int snd_at91_ac97_playback_close(struct snd_pcm_substream *substream)
++ {
++         at91_ac97_t *chip = snd_pcm_substream_chip(substream);
++ 
++         chip->playback_substream = NULL;
++ 	return 0;
++ }
++ 
++ static int snd_at91_ac97_hw_params(struct snd_pcm_substream *substream,
++ 				    struct snd_pcm_hw_params *hw_params)
++ {
++ 	int err;
++ 
++ 	err = snd_pcm_lib_malloc_pages(substream,
++ 				       params_buffer_bytes(hw_params));
++ 	return err;
++ }
++ 
++ static int snd_at91_ac97_hw_free(struct snd_pcm_substream *substream)
++ {
++ 
++ 	snd_pcm_lib_free_pages(substream);
++ 
++ 	return 0;
++ }
++ 
++ static int snd_at91_ac97_playback_prepare(struct snd_pcm_substream *substream)
++ {
++ 	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
++ 	struct snd_pcm_runtime *runtime = substream->runtime;
++ 	int block_size = frames_to_bytes(runtime, runtime->period_size);
++ 	unsigned long word = 0;
++ 
++ 	//clean_dcache_region(runtime->dma_area, block_size * 2);
++ 	snd_printd(KERN_DEBUG "%s : block_size = %d\n\r", driver_name, block_size);
++ 
++ 	/* Assign slots to channels */
++ 	switch (substream->runtime->channels) {
++           /* TODO: Support more than two channels */
++         case 1:
++           word |= AT91C_AC97C_CHID3_CA;
++           break;
++ 	case 2:
++         default:
++           /* Assign Left and Right slots (3,4) to Channel A */
++           word |= AT91C_AC97C_CHID3_CA | AT91C_AC97C_CHID4_CA;
++           break;
++ 	}
++ 
++ 	ac97c_writel(chip, OCA, word);
++ 
++ 	/*
++ 	 * Configure sample format and size.
++ 	 * FIXME: Avoid conflicts with capture channel.
++ 	 */
++         word = AT91C_AC97C_PDCEN | AT91C_AC97C_SIZE_16_BITS;
++ 
++         switch (runtime->format){
++         case SNDRV_PCM_FORMAT_S16_BE:
++           word |= AT91C_AC97C_CEM;
++           break;
++         case SNDRV_PCM_FORMAT_S16_LE:
++         default:
++           break;
++         }
++ 
++ 	ac97c_writel(chip, CAMR, word);
++ 
++         /* Set variable rate if needed */
++         if ( runtime->rate != 48000 ){
++           word = ac97c_readl(chip, MR);
++           word |= AT91C_AC97C_VRA;
++           ac97c_writel(chip, MR, word);
++         } else {
++           /* Clear Variable Rate Bit */
++           word = ac97c_readl(chip, MR);
++           word &= ~AT91C_AC97C_VRA;
++           ac97c_writel(chip, MR, word);
++         }
++ 
++         /* Set rate */
++         snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
++ 
++ 	snd_printd(KERN_DEBUG
++ 		"%s : dma_addr = %x\n\r"
++ 		" : dma_area = %p\n\r"
++ 		" : dma_bytes = %d\n\r",
++ 		driver_name, runtime->dma_addr,
++ 		runtime->dma_area, runtime->dma_bytes);
++ 
++ 	/* Initialize and start the PDC */
++ 	writel(runtime->dma_addr, chip->regs + ATMEL_PDC_TPR);
++ 	writel(block_size / 2, chip->regs + ATMEL_PDC_TCR);
++ 	writel(runtime->dma_addr + block_size, chip->regs + ATMEL_PDC_TNPR);
++ 	writel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);
++ 
++ 	/* Enable Channel A interrupts */
++ 	ac97c_writel(chip, IER, AT91C_AC97C_CAEVT);
++ 
++ 	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_playback_prepare\n\r", driver_name);
++ 
++ 	return 0;
++ }
++ 
++ static int at91_ac97_trigger(struct snd_pcm_substream *substream, int cmd)
++ {
++ 	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
++ 	unsigned long camr, ptcr = 0, flags;
++ 	int err = 0;
++ 
++ 	spin_lock_irqsave(&chip->lock, flags);
++ 	camr = ac97c_readl(chip, CAMR);
++ 
++ 	switch (cmd) {
++ 	case SNDRV_PCM_TRIGGER_START:
++           camr |= (AT91C_AC97C_CEN | AT91C_AC97C_ENDTX);
++ 	  ptcr = ATMEL_PDC_TXTEN;
++ 	  break;
++ 	case SNDRV_PCM_TRIGGER_STOP:
++           camr &= ~(AT91C_AC97C_CEN | AT91C_AC97C_ENDTX);
++ 	  ptcr = ATMEL_PDC_TXTDIS;
++           break;
++ 	default:
++           err = -EINVAL;
++           break;
++ 	}
++ 
++ 	ac97c_writel(chip, CAMR, camr);
++ 	writel(ptcr, chip->regs + ATMEL_PDC_PTCR);
++ 
++ 	spin_unlock_irqrestore(&chip->lock, flags);
++ 
++ 	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_trigger\n\r", driver_name);
++ 
++ 	return err;
++ }
++ 
++ static snd_pcm_uframes_t snd_at91_ac97_pointer(struct snd_pcm_substream *substream)
++ {
++ 	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
++ 	struct snd_pcm_runtime *runtime = substream->runtime;
++ 	snd_pcm_uframes_t pos;
++ 	unsigned long bytes;
++ 
++ 	bytes = readl(chip->regs + ATMEL_PDC_TPR) - runtime->dma_addr;
++ 
++ 	pos = bytes_to_frames(runtime, bytes);
++ 	if (pos >= runtime->buffer_size)
++ 		pos -= runtime->buffer_size;
++ 
++ 	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_pointer\n\r", driver_name);
++ 
++ 	return pos;
++ }
++ 
++ static struct snd_pcm_ops at91_ac97_playback_ops = {
++ 	.open		= snd_at91_ac97_playback_open,
++ 	.close		= snd_at91_ac97_playback_close,
++ 	.ioctl		= snd_pcm_lib_ioctl,
++ 	.hw_params	= snd_at91_ac97_hw_params,
++ 	.hw_free	= snd_at91_ac97_hw_free,
++ 	.prepare	= snd_at91_ac97_playback_prepare,
++ 	.trigger	= at91_ac97_trigger,
++ 	.pointer	= snd_at91_ac97_pointer,
++ };
++ 
++ #if CAPTURE
++ static struct snd_pcm_ops at91_ac97_capture_ops = {
++ 	.open		= snd_at91_ac97_playback_open,
++ 	.close		= snd_at91_ac97_playback_close,
++ 	.ioctl		= snd_pcm_lib_ioctl,
++ 	.hw_params	= snd_at91_ac97_hw_params,
++ 	.hw_free	= snd_at91_ac97_hw_free,
++ 	.prepare	= snd_at91_ac97_playback_prepare,
++ 	.trigger	= at91_ac97_trigger,
++ 	.pointer	= snd_at91_ac97_pointer,
++ };
++ #endif
++ 
++ static struct ac97_pcm at91_ac97_pcm_defs[] __devinitdata = {
++ 	/* Playback */
++ 	{
++ 		.exclusive = 1,
++ 		.r = { {
++ 			.slots = ((1 << AC97_SLOT_PCM_LEFT)
++ 				  | (1 << AC97_SLOT_PCM_RIGHT)),
++ 		} },
++ 	},
++ #if CAPTURE
++ 	{	/* Mic in */
++ 		.stream = 1,
++ 		.exclusive = 1,
++ 		.r = {
++ 			[0] = {
++ 				.slots	= (1 << AC97_SLOT_MIC),
++ 			},
++ 		},
++ 	}
++ #endif
++ };
++ 
++ static int __devinit snd_at91_ac97_pcm_new(at91_ac97_t *chip)
++ {
++ 	struct snd_pcm *pcm;
++ 	int err;
++ 
++ 	err = snd_ac97_pcm_assign(chip->ac97_bus, 1, at91_ac97_pcm_defs);
++ 	if (err)
++ 		return err;
++ 
++ 	err = snd_pcm_new(chip->card, "Atmel AC97", 0, 1, 0, &pcm);
++ 	if (err)
++ 		return err;
++ 
++ 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
++ 					      &chip->pdev->dev,
++ 					      128 * 1024, 256 * 1024);
++ 
++ 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &at91_ac97_playback_ops);
++ #if CAPTURE
++ 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &at91_ac97_capture_ops);
++ #endif
++ 	pcm->private_data = chip;
++ 	pcm->info_flags = 0;
++ 	strcpy(pcm->name, "Atmel AC97");
++ 	chip->pcm = pcm;
++ 
++ 	return 0;
++ }
++ 
++ /* Mixer part */
++ static int snd_at91_ac97_mixer_new(at91_ac97_t *chip)
++ {
++ 	int err;
++ 	struct snd_ac97_template template;
++ 
++ 	memset(&template, 0, sizeof(template));
++ 	template.private_data = chip;
++ 	template.num = 0;
++ 	template.addr = 0;
++ 	err = snd_ac97_mixer(chip->ac97_bus, &template, &chip->ac97);
++ 
++ 	return err;
++ }
++ 
++ 
++ static irqreturn_t snd_at91_ac97_interrupt(int irq, void *dev_id)
++ {
++ 	at91_ac97_t *chip = dev_id;
++ 	unsigned long status;
++ 	unsigned long dummy;
++ 
++ 	status = ac97c_readl(chip, SR);
++ 
++ 	if (status & AT91C_AC97C_CAEVT) {
++ 		struct snd_pcm_runtime *runtime;
++ 		int offset, next_period, block_size;
++ 		unsigned long casr;
++ 
++ 		runtime = chip->playback_substream->runtime;
++ 		block_size = frames_to_bytes(runtime, runtime->period_size);
++ 
++ 		casr = ac97c_readl(chip, CASR);
++ 
++ 		if (casr & AT91C_AC97C_ENDTX) {
++ 			chip->period++;
++ 			if (chip->period == runtime->periods)
++ 				chip->period = 0;
++ 			next_period = chip->period + 1;
++ 			if (next_period == runtime->periods)
++ 				next_period = 0;
++ 
++ 			offset = block_size * next_period;
++ 
++ 			writel(runtime->dma_addr + offset, chip->regs + ATMEL_PDC_TNPR);
++ 			writel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);
++ 
++ 			snd_pcm_period_elapsed(chip->playback_substream);
++ 		} else {
++                   printk(KERN_WARNING
++                          "Spurious AC97A interrupt, status = 0x%08lx\n",
++                          (unsigned long)casr);
++ 		}
++ 	} else {
++ 		printk(KERN_WARNING
++ 		       "Spurious AC97 interrupt, status = 0x%08lx\n",
++ 		       status);
++ 	}
++ 
++ 	dummy = ac97c_readl(chip, SR);
++ 
++ 	return IRQ_HANDLED;
++ }
++ 
++ 
++ /* CODEC part */
++ 
++ static void snd_at91_ac97_hard_reset(at91_ac97_t *chip)
++ {
++        // Enable AC97 Controller.
++        // Perform a cold (hard) reset of the AC97 codec.
++        ac97c_writel(chip, MR, 0);
++        ac97c_writel(chip, MR, AT91C_AC97C_ENA);
++ 
++        at91_ac97c_drive_reset(chip, 0);
++        udelay(1);
++        at91_ac97c_drive_reset(chip, 1);
++        udelay(1);
++ }
++ 
++ 
++ static void snd_at91_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
++ 				 unsigned short val)
++ {
++ 	at91_ac97_t *chip = ac97->private_data;
++ 	unsigned long word;
++ 	int timeout = 0x100;
++ 
++ 	snd_printd(KERN_DEBUG "%s : Writing codec register 0x%x = 0x%x\n\r", driver_name, reg, val);
++ 
++ 	word = (reg & 0x7f) << 16 | val;
++ 
++ 	do {
++ 		if (ac97c_readl(chip, COSR) & AT91C_AC97C_TXRDY) {
++ 			ac97c_writel(chip, COTHR, word);
++ 			return;
++ 		}
++ 		udelay(1);
++ 	} while (--timeout);
++ 
++ 	snd_printk(KERN_WARNING "at91-ac97: codec write timeout\n\r");
++ }
++ 
++ static unsigned short snd_at91_ac97_read(struct snd_ac97 *ac97,
++ 					  unsigned short reg)
++ {
++ 	at91_ac97_t *chip = ac97->private_data;
++ 	unsigned long word;
++ 	int timeout = 0x100;
++ 
++ 
++ 	word = (0x80 | (reg & 0x7f)) << 16;
++ 
++ 	do {
++                 if (ac97c_readl(chip, COSR) & AT91C_AC97C_TXRDY){
++                      ac97c_writel(chip, COTHR, word);
++                      break;
++                 }
++ 		udelay(1);
++ 	} while (--timeout);
++ 
++ 	if (!timeout)
++ 		goto timed_out;
++ 
++ 	timeout = 0x100;
++ 
++ 	do {
++                 if (ac97c_readl(chip, COSR) & AT91C_AC97C_RXRDY){
++                      unsigned short val = (unsigned short) ac97c_readl(chip, CORHR);
++ 		     return val;
++ 		}
++ 		udelay(1);
++ 	} while (--timeout);
++ 
++ 	if (!timeout)
++ 		goto timed_out1;
++ 
++ timed_out:
++ 	snd_printk(KERN_WARNING "at91-ac97: codec read timeout\n\r");
++ 	return 0xffff;
++ 
++ timed_out1:
++ #if EXTRA_DEBUG
++ 	snd_printk(KERN_WARNING "at91-ac97: codec read timeout 1\n\r");
++ #endif
++ 	return 0xffff;
++ }
++ 
++ static void snd_at91_ac97_warm_reset(struct snd_ac97 *ac97)
++ {
++         at91_ac97_t *chip = ac97->private_data;
++ 	volatile unsigned int mr = ac97c_readl(chip, MR);
++ 
++ 	mr |= AT91C_AC97C_WRST;
++ 
++ 	ac97c_writel(chip, MR, mr);
++ 	udelay(1);
++ 
++ 	mr &= ~AT91C_AC97C_WRST;
++ 	ac97c_writel(chip, MR, mr);
++ }
++ 
++ static void snd_at91_ac97_destroy(struct snd_card *card)
++ {
++ 	at91_ac97_t *chip = get_chip(card);
++ 
++ #if 0
++ 	// Disable AC97 Controller
++ 	ac97c_writel(chip, MR, 0);
++ 
++ 	// Disable AC97 Controller clock
++ 	if (chip->ac97_clk) clk_disable(chip->ac97_clk);
++ #endif
++ 	if (chip->irq != -1) {
++ 		free_irq(chip->irq, chip);
++ 		chip->irq = -1;
++ 	}
++ 	if (chip->regs) {
++ 		iounmap(chip->regs);
++ 		chip->regs = NULL;
++ 	}
++ }
++ 
++ static int __devinit snd_at91_ac97_create(struct snd_card *card,
++ 					   struct platform_device *pdev)
++ {
++ 	static struct snd_ac97_bus_ops ops = {
++ 		.write	= snd_at91_ac97_write,
++ 		.read	= snd_at91_ac97_read,
++ 		.reset  = snd_at91_ac97_warm_reset,
++ 	};
++ 
++ 	at91_ac97_t *chip = get_chip(card);
++ 	int irq, err = 0;
++ 
++ 	card->private_free = snd_at91_ac97_destroy;
++ 
++ 	spin_lock_init(&chip->lock);
++ 	chip->card = card;
++ 	chip->pdev = pdev;
++ 	chip->irq = -1;
++ 
++ 	if (!(platform_resource_flags(pdev, 0) & IORESOURCE_MEM)
++ 	    || !(platform_resource_flags(pdev, 1) & IORESOURCE_IRQ))
++ 		return -ENODEV;
++ 
++ 	irq = platform_resource_start(pdev, 1);
++ 
++ 	err = request_irq(irq, snd_at91_ac97_interrupt, 0, "ac97", chip);
++ 	if (err) {
++ 		snd_printk(KERN_WARNING "unable to request IRQ%d\n", irq);
++ 		return err;
++ 	}
++ 
++ 	chip->irq = irq;
++ #if EXTRA_DEBUG
++ 	snd_printk(KERN_INFO "AC97C regs = %08X \n", platform_resource_start(pdev, 0));
++ 	snd_printk(KERN_INFO "AC97C irq  = %d \n",irq);
++ #endif
++ 
++ 	chip->regs = ioremap(platform_resource_start(pdev, 0),
++ 			     platform_resource_len(pdev, 0));
++ 	if (!chip->regs) {
++ 	        snd_printk(KERN_WARNING "unable to remap AC97C io memory\n");
++ 		return -ENOMEM;
++ 	}
++ 
++ 	snd_card_set_dev(card, &pdev->dev);
++ 
++ 	err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);
++ 
++ 	return err;
++ }
++ 
++ static int __devinit snd_at91_ac97_probe(struct platform_device *pdev)
++ {
++ 	static int dev;
++ 	struct atmel_ac97_data *pdata = pdev->dev.platform_data;
++ 	struct snd_card *card;
++ 	at91_ac97_t *chip;
++ 	int err;
++ 
++ 	if (dev >= SNDRV_CARDS)
++ 		return -ENODEV;
++ 	if (!enable[dev]) {
++ 		dev++;
++ 		return -ENOENT;
++ 	}
++ 	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
++ 			    sizeof(at91_ac97_t));
++ 	if (!card)
++ 		return -ENOMEM;
++ 	chip = get_chip(card);
++ 
++ 	err = snd_at91_ac97_create(card, pdev);
++ 	if (err)
++ 		goto out_free_card;
++ 
++ 	// Enable AC97 Controller clock
++ 	chip->reset_pin = pdata->reset_pin;
++ 	chip->ac97_clk = clk_get(NULL, "ac97_clk");
++ 	if(!chip->ac97_clk)
++ 		goto out_free_card;
++ 
++ 	clk_enable(chip->ac97_clk);
++ 
++ 	// Perform a codec hard reset.
++ 	// This also enables the AC97 Controller.
++ 	snd_at91_ac97_hard_reset(chip);
++ 
++ 	err = snd_at91_ac97_mixer_new(chip);
++ 	if (err)
++ 		goto out_free_card;
++ 
++ 	err = snd_at91_ac97_pcm_new(chip);
++ 	if (err)
++ 		goto out_free_card;
++ 
++ 
++ 	strcpy(card->driver, "ac97c");
++ 	strcpy(card->shortname, "Atmel AC97");
++ 	sprintf(card->longname, "Atmel AC97 Controller at %#lx, irq %i",
++ 		(unsigned long) platform_resource_start(pdev, 0), (int) chip->irq);
++ 
++ 	err = snd_card_register(card);
++ 	if (err)
++ 		goto out_free_card;
++ 
++ 	dev_set_drvdata(&pdev->dev, card);
++ 	dev++;
++ 	return 0;
++ 
++ out_free_card:
++ 	snd_card_free(card);
++ 	return err;
++ }
++ 
++ static int __devexit snd_at91_ac97_remove(struct  platform_device *pdev)
++ {
++ 	struct snd_card *card = dev_get_drvdata(&pdev->dev);
++ 	at91_ac97_t *chip;
++ 
++ 
++ 	if (! card) return 0;
++ 
++ 	chip = get_chip(card);
++ 
++ 	snd_card_free(card);
++ 
++ 	// Disable AC97 Controller
++ 	ac97c_writel(chip, MR, 0);
++ 
++ 	// Disable AC97 Controller clock
++ 	clk_disable(chip->ac97_clk);
++ 
++ 	dev_set_drvdata(&pdev->dev, NULL);
++ 
++ 	return 0;
++ }
++ 
++ static struct platform_driver at91_ac97_driver =
++ {
++ 	.probe      = snd_at91_ac97_probe,
++ 	.remove     = __devexit_p(snd_at91_ac97_remove),
++ 	.driver     =
++ 	{
++ 		.name       = "ac97c",
++ 	}
++ 	,
++ };
++ 
++ static int __init at91_ac97_init(void)
++ {
++ 	return platform_driver_register(&at91_ac97_driver);
++ }
++ 
++ static void __exit at91_ac97_exit(void)
++ {
++ 	platform_driver_unregister(&at91_ac97_driver);
++ }
++ 
++ module_init(at91_ac97_init);
++ module_exit(at91_ac97_exit);
++ 
++ MODULE_LICENSE("GPL");
++ MODULE_DESCRIPTION("Driver for Atmel AC97 Controller");
++ MODULE_AUTHOR("Atmel");
diff -urNp linux-2.6.28-at91/sound/arm/Kconfig linux-2.6.28-at91-ronetix/sound/arm/Kconfig
--- linux-2.6.28-at91/sound/arm/Kconfig	2009-01-12 15:59:32.000000000 +0100
+++ linux-2.6.28-at91-ronetix/sound/arm/Kconfig	2009-01-12 16:00:42.000000000 +0100
@@ -59,5 +59,14 @@ config SND_AT91_AC97
 	  Say Y or M if you want to support any AC97 codec attached to
 	  the SAM926X AC97 Controller.
 
+config SND_AT91_AC97
+	tristate "AC97 Controller driver for SAM926X familly from ATMEL"
+	depends on SND && ARCH_AT91SAM9263
+	select SND_PCM
+	select SND_AC97_CODEC
+	help
+	  Say Y or M if you want to support any AC97 codec attached to
+	  the SAM926X AC97 Controller.
+
 endif	# SND_ARM
 
diff -urNp linux-2.6.28-at91/sound/arm/Kconfig.orig linux-2.6.28-at91-ronetix/sound/arm/Kconfig.orig
--- linux-2.6.28-at91/sound/arm/Kconfig.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.28-at91-ronetix/sound/arm/Kconfig.orig	2009-01-12 16:00:31.000000000 +0100
@@ -0,0 +1,63 @@
+# ALSA ARM drivers
+
+menuconfig SND_ARM
+	bool "ARM sound devices"
+	depends on ARM
+	default y
+	help
+	  Support for sound devices specific to ARM architectures.
+	  Drivers that are implemented on ASoC can be found in
+	  "ALSA for SoC audio support" section.
+
+if SND_ARM
+
+config SND_SA11XX_UDA1341
+	tristate "SA11xx UDA1341TS driver (iPaq H3600)"
+	depends on ARCH_SA1100 && L3
+	select SND_PCM
+	help
+	  Say Y here if you have a Compaq iPaq H3x00 handheld computer
+	  and want to use its Philips UDA 1341 audio chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-sa11xx-uda1341.
+
+config SND_ARMAACI
+	tristate "ARM PrimeCell PL041 AC Link support"
+	depends on ARM_AMBA
+	select SND_PCM
+	select SND_AC97_CODEC
+
+config SND_PXA2XX_PCM
+	tristate
+	select SND_PCM
+
+config SND_PXA2XX_LIB
+	tristate
+	select SND_AC97_CODEC if SND_PXA2XX_LIB_AC97
+
+config SND_PXA2XX_LIB_AC97
+	bool
+
+config SND_PXA2XX_AC97
+	tristate "AC97 driver for the Intel PXA2xx chip"
+	depends on ARCH_PXA
+	select SND_PXA2XX_PCM
+	select SND_AC97_CODEC
+	select SND_PXA2XX_LIB
+	select SND_PXA2XX_LIB_AC97
+	help
+	  Say Y or M if you want to support any AC97 codec attached to
+	  the PXA2xx AC97 interface.
+
+config SND_AT91_AC97
+	tristate "AC97 Controller driver for SAM926X familly from ATMEL"
+	depends on SND && ARCH_AT91
+	select SND_PCM
+	select SND_AC97_CODEC
+	help
+	  Say Y or M if you want to support any AC97 codec attached to
+	  the SAM926X AC97 Controller.
+
+endif	# SND_ARM
+
diff -urNp linux-2.6.28-at91/sound/arm/Makefile.orig linux-2.6.28-at91-ronetix/sound/arm/Makefile.orig
--- linux-2.6.28-at91/sound/arm/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.28-at91-ronetix/sound/arm/Makefile.orig	2009-01-12 16:00:31.000000000 +0100
@@ -0,0 +1,23 @@
+#
+# Makefile for ALSA
+#
+
+obj-$(CONFIG_SND_SA11XX_UDA1341) += snd-sa11xx-uda1341.o 
+snd-sa11xx-uda1341-objs		:= sa11xx-uda1341.o
+
+obj-$(CONFIG_SND_ARMAACI)	+= snd-aaci.o
+snd-aaci-objs			:= aaci.o devdma.o
+
+obj-$(CONFIG_SND_PXA2XX_PCM)	+= snd-pxa2xx-pcm.o
+snd-pxa2xx-pcm-objs		:= pxa2xx-pcm.o
+
+obj-$(CONFIG_SND_PXA2XX_LIB)	+= snd-pxa2xx-lib.o
+snd-pxa2xx-lib-y		:= pxa2xx-pcm-lib.o
+snd-pxa2xx-lib-$(CONFIG_SND_PXA2XX_LIB_AC97)	+= pxa2xx-ac97-lib.o
+
+obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
+snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
+
+obj-$(CONFIG_SND_AT91_AC97)	+= snd-at91-ac97.o
+snd-at91-ac97-objs		:= at91-ac97.o
+
diff -urNp linux-2.6.28-at91/sound/arm/Makefile.rej linux-2.6.28-at91-ronetix/sound/arm/Makefile.rej
--- linux-2.6.28-at91/sound/arm/Makefile.rej	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.28-at91-ronetix/sound/arm/Makefile.rej	2009-01-12 16:00:42.000000000 +0100
@@ -0,0 +1,12 @@
+***************
+*** 17,19 ****
+  
+  obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
+  snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
+--- 17,22 ----
+  
+  obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
+  snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
++ 
++ obj-$(CONFIG_SND_AT91_AC97)	+= snd-at91-ac97.o
++ snd-at91-ac97-objs		:= at91-ac97.o
