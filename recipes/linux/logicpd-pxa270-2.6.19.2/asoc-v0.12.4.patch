Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/DAI.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/DAI.txt
@@ -0,0 +1,546 @@
+ASoC currently supports the three main Digital Audio Interfaces (DAI) found on
+SoC controllers and portable audio CODECS today, namely AC97, I2S and PCM.
+
+
+AC97
+====
+
+  AC97 is a five wire interface commonly found on many PC sound cards. It is
+now also popular in many portable devices. This DAI has a reset line and time
+multiplexes its data on its SDATA_OUT (playback) and SDATA_IN (capture) lines.
+The bit clock (BCLK) is always driven by the CODEC (usually 12.288MHz) and the
+frame (FRAME) (usually 48kHz) is always driven by the controller. Each AC97
+frame is 21uS long and is divided into 13 time slots.
+
+The AC97 specification can be found at :-
+http://www.intel.com/design/chipsets/audio/ac97_r23.pdf
+
+
+I2S
+===
+
+ I2S is a common 4 wire DAI used in HiFi, STB and portable devices. The Tx and
+Rx lines are used for audio transmision, whilst the bit clock (BCLK) and
+left/right clock (LRC) synchronise the link. I2S is flexible in that either the
+controller or CODEC can drive (master) the BCLK and LRC clock lines. Bit clock
+usually varies depending on the sample rate and the master system clock
+(SYSCLK). LRCLK is the same as the sample rate. A few devices support separate
+ADC and DAC LRCLK's, this allows for similtanious capture and playback at
+different sample rates.
+
+I2S has several different operating modes:-
+
+ o I2S - MSB is transmitted on the falling edge of the first BCLK after LRC
+         transition.
+
+ o Left Justified - MSB is transmitted on transition of LRC.
+
+ o Right Justified - MSB is transmitted sample size BCLK's before LRC
+                     transition.
+
+PCM
+===
+
+PCM is another 4 wire interface, very similar to I2S, that can support a more
+flexible protocol. It has bit clock (BCLK) and sync (SYNC) lines that are used
+to synchronise the link whilst the Tx and Rx lines are used to transmit and
+receive the audio data. Bit clock usually varies depending on sample rate
+whilst sync runs at the sample rate. PCM also supports Time Division
+Multiplexing (TDM) in that several devices can use the bus similtaniuosly (This
+is sometimes referred to as network mode).
+
+Common PCM operating modes:-
+
+ o Mode A - MSB is transmitted on falling edge of first BCLK after FRAME/SYNC.
+
+ o Mode B - MSB is transmitted on rising edge of FRAME/SYNC.
+
+
+ASoC DAI Configuration
+======================
+
+Every CODEC DAI and SoC DAI must have their capabilities defined in order to
+be configured together at runtime when the audio and clocking parameters are
+known. This is achieved by creating an array of struct snd_soc_hw_mode in the
+the CODEC and SoC interface drivers. Each element in the array describes a DAI
+mode and each mode is usually based upon the DAI system clock to sample rate
+ratio (FS).
+
+i.e. 48k sample rate @ 256 FS = sytem clock of 12.288 MHz
+     48000 * 256 = 12288000
+
+The CPU and Codec DAI modes are then ANDed together at runtime to determine the
+rutime DAI configuration for both the Codec and CPU.
+
+When creating a new codec or SoC DAI it's probably best to start of with a few
+sample rates first and then test your interface.
+
+struct snd_soc_dai_mode is defined (in soc.h) as:-
+
+/* SoC DAI mode */
+struct snd_soc_dai_mode {
+	u16 fmt;		/* SND_SOC_DAIFMT_* */
+	u16 tdm;		/* SND_SOC_HWTDM_* */
+	u64 pcmfmt; 	/* SNDRV_PCM_FMTBIT_* */
+	u16 pcmrate;	/* SND_SOC_HWRATE_* */
+	u16 pcmdir:2;	/* SND_SOC_HWDIR_* */
+	u16 flags:8;	/* hw flags */
+	u16 fs;			/* mclk to rate divider */
+	u64 bfs;		/* mclk to bclk dividers */
+	unsigned long priv;		/* private mode data */
+};
+
+fmt:
+----
+This field defines the DAI mode hardware format (e.g. I2S settings) and
+supports the following settings:-
+
+ 1) hardware DAI formats
+
+#define SND_SOC_DAIFMT_I2S        (1 << 0)	/* I2S mode */
+#define SND_SOC_DAIFMT_RIGHT_J    (1 << 1)	/* Right justified mode */
+#define SND_SOC_DAIFMT_LEFT_J     (1 << 2)	/* Left Justified mode */
+#define SND_SOC_DAIFMT_DSP_A      (1 << 3)	/* L data msb after FRM */
+#define SND_SOC_DAIFMT_DSP_B      (1 << 4)	/* L data msb during FRM */
+#define SND_SOC_DAIFMT_AC97       (1 << 5)	/* AC97 */
+
+ 2) hw DAI signal inversions
+
+#define SND_SOC_DAIFMT_NB_NF		(1 << 8)	/* normal bit clock + frame */
+#define SND_SOC_DAIFMT_NB_IF		(1 << 9)	/* normal bclk + inv frm */
+#define SND_SOC_DAIFMT_IB_NF		(1 << 10)	/* invert bclk + nor frm */
+#define SND_SOC_DAIFMT_IB_IF		(1 << 11)	/* invert bclk + frm */
+
+ 3) hw clock masters
+    This is wrt the codec, the inverse is true for the interface
+    i.e. if the codec is clk and frm master then the interface is
+    clk and frame slave.
+
+#define SND_SOC_DAIFMT_CBM_CFM		(1 << 12)	/* codec clk & frm master */
+#define SND_SOC_DAIFMT_CBS_CFM		(1 << 13)	/* codec clk slave & frm master */
+#define SND_SOC_DAIFMT_CBM_CFS		(1 << 14)	/* codec clk master & frame slave */
+#define SND_SOC_DAIFMT_CBS_CFS		(1 << 15)	/* codec clk & frm slave */
+
+At least one option from each section must be selected. Multiple selections are
+also supported e.g.
+
+ .fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF
+
+
+tdm:
+------
+This field defines the Time Division Multiplexing left and right word
+positions for the DAI mode if applicable. Set to SND_SOC_DAITDM_LRDW(0,0) for
+no TDM.
+
+
+pcmfmt:
+---------
+The hardware PCM format. This describes the PCM formats supported by the DAI
+mode e.g.
+
+ .pcmfmt = SNDRV_PCM_FORMAT_S16_LE | SNDRV_PCM_FORMAT_S20_3LE | \
+ 	SNDRV_PCM_FORMAT_S24_3LE
+
+pcmrate:
+----------
+The PCM sample rates supported by the DAI mode. e.g.
+
+ .pcmrate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000
+
+
+pcmdir:
+---------
+The stream directions supported by this mode. e.g. playback and capture
+
+
+flags:
+--------
+The DAI hardware flags supported by the mode.
+
+/* use bfs mclk divider mode (BCLK = MCLK / x) */
+#define SND_SOC_DAI_BFS_DIV		0x1
+/* use bfs rate mulitplier  (BCLK = RATE * x)*/
+#define SND_SOC_DAI_BFS_RATE	0x2
+/* use bfs rcw multiplier (BCLK = RATE * CHN * WORD SIZE) */
+#define SND_SOC_DAI_BFS_RCW		0x4
+/* capture and playback can use different clocks */
+#define SND_SOC_DAI_ASYNC		0x8
+
+NOTE: Bitclock division and mulitiplication modes can be safely matched by the
+core logic.
+
+
+fs:
+-----
+The FS supported by this DAI mode FS is the ratio between the system clock and
+the sample rate. See above
+
+bfs:
+------
+BFS is the ratio of BCLK to MCLK or the ratio of BCLK to sample rate (this
+depends on the codec or CPU DAI).
+
+The BFS supported by the DAI mode. This can either be the ratio between the
+bitclock (BCLK) and the sample rate OR the ratio between the system clock and
+the sample rate. Depends on the flags above.
+
+priv:
+-----
+private codec mode data.
+
+
+
+Examples
+========
+
+Note that Codec DAI and CPU DAI examples are interchangeable in these examples
+as long as the bus master is reversed. i.e.
+
+  SND_SOC_DAIFMT_CBM_CFM would become SND_SOC_DAIFMT_CBS_CFS
+  and vice versa.
+
+This applies to all SND_SOC_DAIFMT_CB*_CF*.
+
+Example 1
+---------
+
+Simple codec that only runs at 8k & 48k @ 256FS in master mode, can generate a
+BCLK of either MCLK/2 or MCLK/4.
+
+	/* codec master */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(2) | SND_SOC_FSBD(4),
+	}
+
+
+Example 2
+---------
+Simple codec that only runs at 8k & 48k @ 256FS in master mode, can generate a
+BCLK of either Rate * 32 or Rate * 64.
+
+	/* codec master */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 32,
+	},
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+
+
+Example 3
+---------
+Codec that runs at 8k & 48k @ 256FS in master mode, can generate a BCLK that
+is a multiple of Rate * channels * word size. (RCW) i.e.
+
+	BCLK = 8000 * 2 * 16 (8k, stereo, 16bit)
+	     = 256kHz
+
+This codecs supports a RCW multiple of 1,2
+
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1) | SND_SOC_FSBW(2),
+	}
+
+
+Example 4
+---------
+Codec that only runs at 8k & 48k @ 256FS in master mode, can generate a
+BCLK of either Rate * 32 or Rate * 64. Codec can also run in slave mode as long
+as BCLK is rate * 32 or rate * 64.
+
+	/* codec master */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 32,
+	},
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+
+	/* codec slave */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmdir = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = 32,
+	},
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmdir = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = 64,
+	},
+
+
+Example 5
+---------
+Codec that only runs at 8k, 16k, 32k, 48k, 96k @ 128FS, 192FS & 256FS in master
+mode and can generate a BCLK of MCLK / (1,2,4,8,16). Codec can also run in slave
+mode as and does not care about FS or BCLK (as long as there is enough bandwidth).
+
+	#define CODEC_FSB \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | \
+	SND_SOC_FSBD(8) | SND_SOC_FSBD(16))
+
+	#define CODEC_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 |\
+	 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000)
+
+	/* codec master @ 128, 192 & 256 FS */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = CODEC_RATES,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 128,
+		.bfs = CODEC_FSB,
+	},
+
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = CODEC_RATES,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 192,
+		.bfs = CODEC_FSB
+	},
+
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = CODEC_RATES,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = CODEC_FSB,
+	},
+
+	/* codec slave */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = CODEC_RATES,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+
+
+Example 6
+---------
+Codec that only runs at 8k, 44.1k, 48k @ different FS in master mode (for use
+with a fixed MCLK) and can generate a BCLK of MCLK / (1,2,4,8,16).
+Codec can also run in slave mode as and does not care about FS or BCLK (as long
+as there is enough bandwidth). Codec can support 16, 24 and 32 bit PCM sample
+sizes.
+
+	#define CODEC_FSB \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | \
+	SND_SOC_FSBD(8) | SND_SOC_FSBD(16))
+
+	#define CODEC_PCM_FORMATS \
+	(SNDRV_PCM_FORMAT_S16_LE | SNDRV_PCM_FORMAT_S20_3LE | \
+	SNDRV_PCM_FORMAT_S24_3LE | SNDRV_PCM_FORMAT_S24_LE | SNDRV_PCM_FORMAT_S32_LE)
+
+	/* codec master */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1536,
+		.bfs = CODEC_FSB,
+	},
+
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 272,
+		.bfs = CODEC_FSB,
+	},
+
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = CODEC_FSB,
+	},
+
+	/* codec slave */
+	{
+		.fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FORMAT_S16_LE,
+		.pcmrate = CODEC_RATES,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+
+
+Example 7
+---------
+AC97 Codec that does not support VRA (i.e only runs at 48k).
+
+	#define AC97_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+	#define AC97_PCM_FORMATS \
+	(SNDRV_PCM_FORMAT_S16_LE | SNDRV_PCM_FORMAT_S18_3LE | \
+	SNDRV_PCM_FORMAT_S20_3LE)
+
+	/* AC97 with no VRA */
+	{
+		.pcmfmt = AC97_PCM_FORMATS,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+	}
+
+
+Example 8
+---------
+
+CPU DAI that supports 8k - 48k @ 256FS and BCLK = MCLK / 4 in master mode.
+Slave mode (CPU DAI is FRAME master) supports 8k - 96k at any FS as long as
+BCLK = 64 * rate. (Intel XScale I2S controller).
+
+	#define PXA_I2S_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF)
+
+	#define PXA_I2S_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+	#define PXA_I2S_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+	/* priv is divider */
+	static struct snd_soc_dai_mode pxa2xx_i2s_modes[] = {
+	/* pxa2xx I2S frame and clock master modes */
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x48,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x34,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x24,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x1a,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0xd,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0xc,
+	},
+
+	/* pxa2xx I2S frame master and clock slave mode */
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = PXA_I2S_RATES,
+		.pcmdir = PXA_I2S_DIR,
+		.fs = SND_SOC_FS_ALL,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.bfs = 64,
+		.priv = 0x48,
+	},
+};
Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/clocking.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/clocking.txt
@@ -0,0 +1,314 @@
+Audio Clocking
+==============
+
+This text describes the audio clocking terms in ASoC and digital audio in
+general. Note: Audio clocking can be complex !
+
+
+Master Clock
+------------
+
+Every audio subsystem is driven by a master clock (sometimes refered to as MCLK
+or SYSCLK). This audio master clock can be derived from a number of sources
+(e.g. crystal, PLL, CPU clock) and is responsible for producing the correct
+audio playback and capture sample rates.
+
+Some master clocks (e.g. PLL's and CPU based clocks) are configuarble in that
+their speed can be altered by software (depending on the system use and to save
+power). Other master clocks are fixed at at set frequency (i.e. crystals).
+
+
+DAI Clocks
+----------
+The Digital Audio Interface is usually driven by a Bit Clock (often referred to
+as BCLK). This clock is used to drive the digital audio data across the link
+between the codec and CPU.
+
+The DAI also has a frame clock to signal the start of each audio frame. This
+clock is sometimes referred to as LRC (left right clock) or FRAME. This clock
+runs at exactly the sample rate (LRC = Rate).
+
+Bit Clock can be generated as follows:-
+
+BCLK = MCLK / x
+
+ or
+
+BCLK = LRC * x
+
+ or
+
+BCLK = LRC * Channels * Word Size
+
+This relationship depends on the codec or SoC CPU in particular. ASoC can quite
+easily match BCLK generated by division (SND_SOC_DAI_BFS_DIV) with BCLK by
+multiplication (SND_SOC_DAI_BFS_RATE) or BCLK generated  by
+Rate * Channels * Word size (RCW or SND_SOC_DAI_BFS_RCW).
+
+
+ASoC Clocking
+-------------
+
+The ASoC core determines the clocking for each particular configuration at
+runtime. This is to allow for dynamic audio clocking wereby the audio clock is
+variable and depends on the system state or device usage scenario. i.e. a voice
+call requires slower clocks (and hence less power) than MP3 playback.
+
+ASoC will call the config_sysclock() function for the target machine during the
+audio parameters configuration. The function is responsible for then clocking
+the machine audio subsytem and returning the audio clock speed to the core.
+This function should also call the codec and cpu DAI clock_config() functions
+to configure their respective internal clocking if required.
+
+
+ASoC Clocking Control Flow
+--------------------------
+
+The ASoC core will call the machine drivers config_sysclock() when most of the
+DAI capabilities are known. The machine driver is then responsible for calling
+the codec and/or CPU DAI drivers with the selected capabilities and the current
+MCLK. Note that the machine driver is also resonsible for setting the MCLK (and
+enabling it).
+
+   (1) Match Codec and CPU DAI capabilities. At this point we have
+       matched the majority of the DAI fields and now need to make sure this
+       mode is currently clockable.
+
+   (2) machine->config_sysclk() is now called with the matched DAI FS, sample
+       rate and BCLK master. This function then gets/sets the current audio
+       clock (depening on usage) and calls the codec and CPUI DAI drivers with
+       the FS, rate, BCLK master and MCLK.
+
+   (3) Codec/CPU DAI config_sysclock(). This function checks that the FS, rate,
+       BCLK master and MCLK are acceptable for the codec or CPU DAI. It also
+       sets the DAI internal state to work with said clocks.
+
+The config_sysclk() functions for CPU, codec and machine should return the MCLK
+on success and 0 on failure.
+
+
+Examples (b = BCLK, l = LRC)
+============================
+
+Example 1
+---------
+
+Simple codec that only runs at 48k @ 256FS in master mode.
+
+CPU only runs as slave DAI, however it generates a variable MCLK.
+
+             --------                 ---------
+            |        | <----mclk---  |         |
+            | Codec  |b -----------> |  CPU    |
+            |        |l -----------> |         |
+            |        |               |         |
+             --------                 ---------
+
+The codec driver has the following config_sysclock()
+
+	static unsigned int config_sysclk(struct snd_soc_codec_dai *dai,
+		struct snd_soc_clock_info *info, unsigned int clk)
+	{
+		/* make sure clock is 256 * rate */
+		if(info->rate << 8 == clk) {
+			dai->mclk = clk;
+			return clk;
+		}
+
+		return 0;
+	}
+
+The CPU I2S DAI driver has the following config_sysclk()
+
+	static unsigned int config_sysclk(struct snd_soc_codec_dai *dai,
+		struct snd_soc_clock_info *info, unsigned int clk)
+	{
+		/* can we support this clk */
+		if(set_audio_clk(clk) < 0)
+			return -EINVAL;
+
+		dai->mclk = clk;
+		return dai->clk;
+	}
+
+The machine driver config_sysclk() in this example is as follows:-
+
+	unsigned int machine_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+		struct snd_soc_clock_info *info)
+	{
+		int clk = info->rate * info->fs;
+
+		/* check that CPU can deliver clock */
+		if(rtd->cpu_dai->config_sysclk(rtd->cpu_dai, info, clk) < 0)
+			return -EINVAL;
+
+		/* can codec work with this clock */
+		return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, clk);
+	}
+
+
+Example 2
+---------
+
+Codec that can master at 8k and 48k at various FS (and hence supports a fixed
+set of input MCLK's) and can also be slave at various FS .
+
+The CPU can master at 8k and 48k @256 FS and can be slave at any FS.
+
+MCLK is a 12.288MHz crystal on this machine.
+
+             --------                 ---------
+            |        |  <---xtal---> |         |
+            | Codec  |b <----------> |  CPU    |
+            |        |l <----------> |         |
+            |        |               |         |
+             --------                 ---------
+
+
+The codec driver has the following config_sysclock()
+
+	/* supported input clocks */
+	const static int hifi_clks[] = {11289600, 12000000, 12288000,
+		16934400, 18432000};
+
+	static unsigned int config_hsysclk(struct snd_soc_codec_dai *dai,
+		struct snd_soc_clock_info *info, unsigned int clk)
+	{
+		int i;
+
+		/* is clk supported  */
+		for(i = 0; i < ARRAY_SIZE(hifi_clks); i++) {
+			if(clk == hifi_clks[i]) {
+				dai->mclk = clk;
+				return clk;
+			}
+		}
+
+		/* this clk is not supported */
+		return 0;
+	}
+
+The CPU I2S DAI driver has the following config_sysclk()
+
+	static unsigned int config_sysclk(struct snd_soc_codec_dai *dai,
+		struct snd_soc_clock_info *info, unsigned int clk)
+	{
+		/* are we master or slave */
+		if (info->bclk_master &
+			(SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS)) {
+
+			/* we can only master @ 256FS */
+			if(info->rate << 8 == clk) {
+				dai->mclk = clk;
+				return dai->mclk;
+			}
+		} else {
+			/* slave we can run at any FS */
+			dai->mclk = clk;
+			return dai->mclk;
+		}
+
+		/* not supported */
+		return dai->clk;
+	}
+
+The machine driver config_sysclk() in this example is as follows:-
+
+	unsigned int machine_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+		struct snd_soc_clock_info *info)
+	{
+		int clk = 12288000; /* 12.288MHz */
+
+		/* who's driving the link */
+		if (info->bclk_master &
+			(SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS)) {
+			/* codec master */
+
+			/* check that CPU can work with clock */
+			if(rtd->cpu_dai->config_sysclk(rtd->cpu_dai, info, clk) < 0)
+				return -EINVAL;
+
+			/* can codec work with this clock */
+			return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, clk);
+		} else {
+			/* cpu master */
+
+			/* check that codec can work with clock */
+			if(rtd->codec_dai->config_sysclk(rtd->codec_dai, info, clk) < 0)
+				return -EINVAL;
+
+			/* can CPU work with this clock */
+			return rtd->cpu_dai->config_sysclk(rtd->cpu_dai, info, clk);
+		}
+	}
+
+
+
+Example 3
+---------
+
+Codec that masters at 8k ... 48k @256 FS. Codec can also be slave and
+doesn't care about FS. The codec has an internal PLL and dividers to generate
+the necessary internal clocks (for 256FS).
+
+CPU can only be slave and doesn't care about FS.
+
+MCLK is a non controllable 13MHz clock from the CPU.
+
+
+             --------                 ---------
+            |        | <----mclk---  |         |
+            | Codec  |b <----------> |  CPU    |
+            |        |l <----------> |         |
+            |        |               |         |
+             --------                 ---------
+
+The codec driver has the following config_sysclock()
+
+	/* valid PCM clock dividers * 2 */
+	static int pcm_divs[] = {2, 6, 11, 4, 8, 12, 16};
+
+	static unsigned int config_vsysclk(struct snd_soc_codec_dai *dai,
+		struct snd_soc_clock_info *info, unsigned int clk)
+	{
+		int i, j, best_clk = info->fs * info->rate;
+
+		/* can we run at this clk without the PLL ? */
+		for (i = 0; i < ARRAY_SIZE(pcm_divs); i++) {
+			if ((best_clk >> 1) * pcm_divs[i] == clk) {
+				dai->pll_in = 0;
+				dai->clk_div = pcm_divs[i];
+				dai->mclk = best_clk;
+				return dai->mclk;
+			}
+		}
+
+		/* now check for PLL support */
+		for (i = 0; i < ARRAY_SIZE(pll_div); i++) {
+			if (pll_div[i].pll_in == clk) {
+				for (j = 0; j < ARRAY_SIZE(pcm_divs); j++) {
+					if (pll_div[i].pll_out == pcm_divs[j] * (best_clk >> 1)) {
+						dai->pll_in = clk;
+						dai->pll_out = pll_div[i].pll_out;
+						dai->clk_div = pcm_divs[j];
+						dai->mclk = best_clk;
+						return dai->mclk;
+					}
+				}
+			}
+		}
+
+		/* this clk is not supported */
+		return 0;
+	}
+
+
+The CPU I2S DAI driver has the does not need a config_sysclk() as it can slave
+at any FS.
+
+	unsigned int config_sysclk(struct snd_soc_pcm_runtime *rtd,
+		struct snd_soc_clock_info *info)
+	{
+		/* codec has pll that generates mclk from 13MHz xtal */
+		return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 13000000);
+	}
Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/codec.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/codec.txt
@@ -0,0 +1,232 @@
+ASoC Codec Driver
+=================
+
+The codec driver is generic and hardware independent code that configures the
+codec to provide audio capture and playback. It should contain no code that is
+specific to the target platform or machine. All platform and machine specific
+code should be added to the platform and machine drivers respectively.
+
+Each codec driver must provide the following features:-
+
+ 1) Digital audio interface (DAI) description
+ 2) Digital audio interface configuration
+ 3) PCM's description
+ 4) Codec control IO - using I2C, 3 Wire(SPI) or both API's
+ 5) Mixers and audio controls
+ 6) Sysclk configuration
+ 7) Codec audio operations
+
+Optionally, codec drivers can also provide:-
+
+ 8) DAPM description.
+ 9) DAPM event handler.
+10) DAC Digital mute control.
+
+It's probably best to use this guide in conjuction with the existing codec
+driver code in sound/soc/codecs/
+
+ASoC Codec driver breakdown
+===========================
+
+1 - Digital Audio Interface (DAI) description
+---------------------------------------------
+The DAI is a digital audio data transfer link between the codec and host SoC
+CPU. It typically has data transfer capabilities in both directions
+(playback and capture) and can run at a variety of different speeds.
+Supported interfaces currently include AC97, I2S and generic PCM style links.
+Please read DAI.txt for implementation information.
+
+
+2 - Digital Audio Interface (DAI) configuration
+-----------------------------------------------
+DAI configuration is handled by the codec_pcm_prepare function and is
+responsible for configuring and starting the DAI on the codec. This can be
+called multiple times and is atomic. It can access the runtime parameters.
+
+This usually consists of a large function with numerous switch statements to
+set up each configuration option. These options are set by the core at runtime.
+
+
+3 - Codec PCM's
+---------------
+Each codec must have it's PCM's defined. This defines the number of channels,
+stream names, callbacks and codec name. It is also used to register the DAI
+with the ASoC core. The PCM structure also associates the DAI capabilities with
+the ALSA PCM.
+
+e.g.
+
+static struct snd_soc_pcm_codec wm8731_pcm_client = {
+	.name = "WM8731",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = wm8731_config_sysclk,
+	.ops = {
+		.prepare = wm8731_pcm_prepare,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8731_hwfmt),
+		.modes = &wm8731_hwfmt[0],
+	},
+};
+
+
+4 - Codec control IO
+--------------------
+The codec can ususally be controlled via an I2C or SPI style interface (AC97
+combines control with data in the DAI). The codec drivers will have to provide
+functions to read and write the codec registers along with supplying a register
+cache:-
+
+	/* IO control data and register cache */
+    void *control_data; /* codec control (i2c/3wire) data */
+    void *reg_cache;
+
+Codec read/write should do any data formatting and call the hardware read write
+below to perform the IO. These functions are called by the core and alsa when
+performing DAPM or changing the mixer:-
+
+    unsigned int (*read)(struct snd_soc_codec *, unsigned int);
+    int (*write)(struct snd_soc_codec *, unsigned int, unsigned int);
+
+Codec hardware IO functions - usually points to either the I2C, SPI or AC97
+read/write:-
+
+	hw_write_t hw_write;
+	hw_read_t hw_read;
+
+
+5 - Mixers and audio controls
+-----------------------------
+All the codec mixers and audio controls can be defined using the convenience
+macros defined in soc.h.
+
+    #define SOC_SINGLE(xname, reg, shift, mask, invert)
+
+Defines a single control as follows:-
+
+  xname = Control name e.g. "Playback Volume"
+  reg = codec register
+  shift = control bit(s) offset in register
+  mask = control bit size(s) e.g. mask of 7 = 3 bits
+  invert = the control is inverted
+
+Other macros include:-
+
+    #define SOC_DOUBLE(xname, reg, shift_left, shift_right, mask, invert)
+
+A stereo control
+
+    #define SOC_DOUBLE_R(xname, reg_left, reg_right, shift, mask, invert)
+
+A stereo control spanning 2 registers
+
+    #define SOC_ENUM_SINGLE(xreg, xshift, xmask, xtexts)
+
+Defines an single enumerated control as follows:-
+
+   xreg = register
+   xshift = control bit(s) offset in register
+   xmask = control bit(s) size
+   xtexts = pointer to array of strings that describe each setting
+
+   #define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xtexts)
+
+Defines a stereo enumerated control
+
+
+6 - System clock configuration.
+-------------------------------
+The system clock that drives the audio subsystem can change depending on sample
+rate and the system power state. i.e.
+
+o Higher sample rates sometimes need a higher system clock.
+o Low system power states can sometimes limit the available clocks.
+
+This function is a callback that the machine driver can call to set and
+determine if the clock and sample rate combination is supported by the codec at
+the present time (and system state).
+
+NOTE: If the codec has a PLL then it has a lot more flexability wrt clock and
+sample rate combinations.
+
+Your config_sysclock function should return the MCLK if it's a valid
+combination for your codec else 0;
+
+Please read clocking.txt now.
+
+
+7 - Codec Audio Operations
+--------------------------
+The codec driver also supports the following alsa operations:-
+
+/* SoC audio ops */
+struct snd_soc_ops {
+	int (*startup)(snd_pcm_substream_t *);
+	void (*shutdown)(snd_pcm_substream_t *);
+	int (*hw_params)(snd_pcm_substream_t *, snd_pcm_hw_params_t *);
+	int (*hw_free)(snd_pcm_substream_t *);
+	int (*prepare)(snd_pcm_substream_t *);
+};
+
+Please refer to the alsa driver PCM documentation for details.
+http://www.alsa-project.org/~iwai/writing-an-alsa-driver/c436.htm
+
+
+8 - DAPM description.
+---------------------
+The Dynamic Audio Power Management description describes the codec's power
+components, their relationships and registers to the ASoC core. Please read
+dapm.txt for details of building the description.
+
+Please also see the examples in other codec drivers.
+
+
+9 - DAPM event handler
+----------------------
+This function is a callback that handles codec domain PM calls and system
+domain PM calls (e.g. suspend and resume). It's used to put the codec to sleep
+when not in use.
+
+Power states:-
+
+	SNDRV_CTL_POWER_D0: /* full On */
+	/* vref/mid, clk and osc on, active */
+
+	SNDRV_CTL_POWER_D1: /* partial On */
+	SNDRV_CTL_POWER_D2: /* partial On */
+
+	SNDRV_CTL_POWER_D3hot: /* Off, with power */
+	/* everything off except vref/vmid, inactive */
+
+	SNDRV_CTL_POWER_D3cold: /* Everything Off, without power */
+
+
+10 - Codec DAC digital mute control.
+------------------------------------
+Most codecs have a digital mute before the DAC's that can be used to minimise
+any system noise.  The mute stops any digital data from entering the DAC.
+
+A callback can be created that is called by the core for each codec DAI when the
+mute is applied or freed.
+
+i.e.
+
+static int wm8974_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8974_read_reg_cache(codec, WM8974_DAC) & 0xffbf;
+	if(mute)
+		wm8974_write(codec, WM8974_DAC, mute_reg | 0x40);
+	else
+		wm8974_write(codec, WM8974_DAC, mute_reg);
+	return 0;
+}
Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/dapm.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/dapm.txt
@@ -0,0 +1,297 @@
+Dynamic Audio Power Management for Portable Devices
+===================================================
+
+1. Description
+==============
+
+Dynamic Audio Power Management (DAPM) is designed to allow portable Linux devices
+to use the minimum amount of power within the audio subsystem at all times. It
+is independent of other kernel PM and as such, can easily co-exist with the
+other PM systems.
+
+DAPM is also completely transparent to all user space applications as all power
+switching is done within the ASoC core. No code changes or recompiling are
+required for user space applications. DAPM makes power switching descisions based
+upon any audio stream (capture/playback) activity and audio mixer settings
+within the device.
+
+DAPM spans the whole machine. It covers power control within the entire audio
+subsystem, this includes internal codec power blocks and machine level power
+systems.
+
+There are 4 power domains within DAPM
+
+   1. Codec domain - VREF, VMID (core codec and audio power)
+      Usually controlled at codec probe/remove and suspend/resume, although
+      can be set at stream time if power is not needed for sidetone, etc.
+
+   2. Platform/Machine domain - physically connected inputs and outputs
+      Is platform/machine and user action specific, is configured by the
+      machine driver and responds to asynchronous events e.g when HP
+      are inserted
+
+   3. Path domain - audio susbsystem signal paths
+      Automatically set when mixer and mux settings are changed by the user.
+      e.g. alsamixer, amixer.
+
+   4. Stream domain - DAC's and ADC's.
+      Enabled and disabled when stream playback/capture is started and
+      stopped respectively. e.g. aplay, arecord.
+
+All DAPM power switching descisons are made automatically by consulting an audio
+routing map of the whole machine. This map is specific to each machine and
+consists of the interconnections between every audio component (including
+internal codec components). All audio components that effect power are called
+widgets hereafter.
+
+
+2. DAPM Widgets
+===============
+
+Audio DAPM widgets fall into a number of types:-
+
+ o Mixer      - Mixes several analog signals into a single analog signal.
+ o Mux        - An analog switch that outputs only 1 of it's inputs.
+ o PGA        - A programmable gain amplifier or attenuation widget.
+ o ADC        - Analog to Digital Converter
+ o DAC        - Digital to Analog Converter
+ o Switch     - An analog switch
+ o Input      - A codec input pin
+ o Output     - A codec output pin
+ o Headphone  - Headphone (and optional Jack)
+ o Mic        - Mic (and optional Jack)
+ o Line       - Line Input/Output (and optional Jack)
+ o Speaker    - Speaker
+ o Pre        - Special PRE widget (exec before all others)
+ o Post       - Special POST widget (exec after all others)
+
+(Widgets are defined in include/sound/soc-dapm.h)
+
+Widgets are usually added in the codec driver and the machine driver. There are
+convience macros defined in soc-dapm.h that can be used to quickly build a
+list of widgets of the codecs and machines DAPM widgets.
+
+Most widgets have a name, register, shift and invert. Some widgets have extra
+parameters for stream name and kcontrols.
+
+
+2.1 Stream Domain Widgets
+-------------------------
+
+Stream Widgets relate to the stream power domain and only consist of ADC's
+(analog to digital converters) and DAC's (digital to analog converters).
+
+Stream widgets have the following format:-
+
+SND_SOC_DAPM_DAC(name, stream name, reg, shift, invert),
+
+NOTE: the stream name must match the corresponding stream name in your codecs
+snd_soc_codec_dai.
+
+e.g. stream widgets for HiFi playback and capture
+
+SND_SOC_DAPM_DAC("HiFi DAC", "HiFi Playback", REG, 3, 1),
+SND_SOC_DAPM_ADC("HiFi ADC", "HiFi Capture", REG, 2, 1),
+
+
+2.2 Path Domain Widgets
+-----------------------
+
+Path domain widgets have a ability to control or effect the audio signal or
+audio paths within the audio subsystem. They have the following form:-
+
+SND_SOC_DAPM_PGA(name, reg, shift, invert, controls, num_controls)
+
+Any widget kcontrols can be set using the controls and num_controls members.
+
+e.g. Mixer widget (the kcontrols are declared first)
+
+/* Output Mixer */
+static const snd_kcontrol_new_t wm8731_output_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8731_APANA, 3, 1, 0),
+SOC_DAPM_SINGLE("Mic Sidetone Switch", WM8731_APANA, 5, 1, 0),
+SOC_DAPM_SINGLE("HiFi Playback Switch", WM8731_APANA, 4, 1, 0),
+};
+
+SND_SOC_DAPM_MIXER("Output Mixer", WM8731_PWR, 4, 1, wm8731_output_mixer_controls,
+	ARRAY_SIZE(wm8731_output_mixer_controls)),
+
+
+2.3 Platform/Machine domain Widgets
+-----------------------------------
+
+Machine widgets are different from codec widgets in that they don't have a
+codec register bit associated with them. A machine widget is assigned to each
+machine audio component (non codec) that can be independently powered. e.g.
+
+ o Speaker Amp
+ o Microphone Bias
+ o Jack connectors
+
+A machine widget can have an optional call back.
+
+e.g. Jack connector widget for an external Mic that enables Mic Bias
+when the Mic is inserted:-
+
+static int spitz_mic_bias(struct snd_soc_dapm_widget* w, int event)
+{
+	if(SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&spitzscoop2_device.dev, SPITZ_SCP2_MIC_BIAS);
+	else
+		reset_scoop_gpio(&spitzscoop2_device.dev, SPITZ_SCP2_MIC_BIAS);
+
+	return 0;
+}
+
+SND_SOC_DAPM_MIC("Mic Jack", spitz_mic_bias),
+
+
+2.4 Codec Domain
+----------------
+
+The Codec power domain has no widgets and is handled by the codecs DAPM event
+handler. This handler is called when the codec powerstate is changed wrt to any
+stream event or by kernel PM events.
+
+
+2.5 Virtual Widgets
+-------------------
+
+Sometimes widgets exist in the codec or machine audio map that don't have any
+corresponding register bit for power control. In this case it's necessary to
+create a virtual widget - a widget with no control bits e.g.
+
+SND_SOC_DAPM_MIXER("AC97 Mixer", SND_SOC_DAPM_NOPM, 0, 0, NULL, 0),
+
+This can be used to merge to signal paths together in software.
+
+After all the widgets have been defined, they can then be added to the DAPM
+subsystem individually with a call to snd_soc_dapm_new_control().
+
+
+3. Codec Widget Interconnections
+================================
+
+Widgets are connected to each other within the codec and machine by audio
+paths (called interconnections). Each interconnection must be defined in order
+to create a map of all audio paths between widgets.
+This is easiest with a diagram of the codec (and schematic of the machine audio
+system), as it requires joining widgets together via their audio signal paths.
+
+i.e. from the WM8731 codec's output mixer (wm8731.c)
+
+The WM8731 output mixer has 3 inputs (sources)
+
+ 1. Line Bypass Input
+ 2. DAC (HiFi playback)
+ 3. Mic Sidetone Input
+
+Each input in this example has a kcontrol associated with it (defined in example
+above) and is connected to the output mixer via it's kcontrol name. We can now
+connect the destination widget (wrt audio signal) with it's source widgets.
+
+	/* output mixer */
+	{"Output Mixer", "Line Bypass Switch", "Line Input"},
+	{"Output Mixer", "HiFi Playback Switch", "DAC"},
+	{"Output Mixer", "Mic Sidetone Switch", "Mic Bias"},
+
+So we have :-
+
+	Destination Widget  <=== Path Name <=== Source Widget
+
+Or:-
+
+	Sink, Path, Source
+
+Or :-
+
+	"Output Mixer" is connected to the "DAC" via the "HiFi Playback Switch".
+
+When there is no path name connecting widgets (e.g. a direct connection) we
+pass NULL for the path name.
+
+Interconnections are created with a call to:-
+
+snd_soc_dapm_connect_input(codec, sink, path, source);
+
+Finally, snd_soc_dapm_new_widgets(codec) must be called after all widgets and
+interconnections have been registered with the core. This causes the core to
+scan the codec and machine so that the internal DAPM state matches the
+physical state of the machine.
+
+
+3.1 Machine Widget Interconnections
+-----------------------------------
+Machine widget interconnections are created in the same way as codec ones and
+directly connect the codec pins to machine level widgets.
+
+e.g. connects the speaker out codec pins to the internal speaker.
+
+	/* ext speaker connected to codec pins LOUT2, ROUT2  */
+	{"Ext Spk", NULL , "ROUT2"},
+	{"Ext Spk", NULL , "LOUT2"},
+
+This allows the DAPM to power on and off pins that are connected (and in use)
+and pins that are NC respectively.
+
+
+4 Endpoint Widgets
+===================
+An endpoint is a start or end point (widget) of an audio signal within the
+machine and includes the codec. e.g.
+
+ o Headphone Jack
+ o Internal Speaker
+ o Internal Mic
+ o Mic Jack
+ o Codec Pins
+
+When a codec pin is NC it can be marked as not used with a call to
+
+snd_soc_dapm_set_endpoint(codec, "Widget Name", 0);
+
+The last argument is 0 for inactive and 1 for active. This way the pin and its
+input widget will never be powered up and consume power.
+
+This also applies to machine widgets. e.g. if a headphone is connected to a
+jack then the jack can be marked active. If the headphone is removed, then
+the headphone jack can be marked inactive.
+
+
+5 DAPM Widget Events
+====================
+
+Some widgets can register their interest with the DAPM core in PM events.
+e.g. A Speaker with an amplifier registers a widget so the amplifier can be
+powered only when the spk is in use.
+
+/* turn speaker amplifier on/off depending on use */
+static int corgi_amp_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+	else
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+
+	return 0;
+}
+
+/* corgi machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets =
+	SND_SOC_DAPM_SPK("Ext Spk", corgi_amp_event);
+
+Please see soc-dapm.h for all other widgets that support events.
+
+
+5.1 Event types
+---------------
+
+The following event types are supported by event widgets.
+
+/* dapm event types */
+#define SND_SOC_DAPM_PRE_PMU	0x1 	/* before widget power up */
+#define SND_SOC_DAPM_POST_PMU	0x2		/* after widget power up */
+#define SND_SOC_DAPM_PRE_PMD	0x4 	/* before widget power down */
+#define SND_SOC_DAPM_POST_PMD	0x8		/* after widget power down */
+#define SND_SOC_DAPM_PRE_REG	0x10	/* before audio path setup */
+#define SND_SOC_DAPM_POST_REG	0x20	/* after audio path setup */
Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/machine.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/machine.txt
@@ -0,0 +1,114 @@
+ASoC Machine Driver
+===================
+
+The ASoC machine (or board) driver is the code that glues together the platform
+and codec drivers.
+
+The machine driver can contain codec and platform specific code. It registers
+the audio subsystem with the kernel as a platform device and is represented by
+the following struct:-
+
+/* SoC machine */
+struct snd_soc_machine {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+
+	/* the pre and post PM functions are used to do any PM work before and
+	 * after the codec and DAI's do any PM work. */
+	int (*suspend_pre)(struct platform_device *pdev, pm_message_t state);
+	int (*suspend_post)(struct platform_device *pdev, pm_message_t state);
+	int (*resume_pre)(struct platform_device *pdev);
+	int (*resume_post)(struct platform_device *pdev);
+
+	/* machine stream operations */
+	struct snd_soc_ops *ops;
+
+	/* CPU <--> Codec DAI links  */
+	struct snd_soc_dai_link *dai_link;
+	int num_links;
+};
+
+probe()/remove()
+----------------
+probe/remove are optional. Do any machine specific probe here.
+
+
+suspend()/resume()
+------------------
+The machine driver has pre and post versions of suspend and resume to take care
+of any machine audio tasks that have to be done before or after the codec, DAI's
+and DMA is suspended and resumed. Optional.
+
+
+Machine operations
+------------------
+The machine specific audio operations can be set here. Again this is optional.
+
+
+Machine DAI Configuration
+-------------------------
+The machine DAI configuration glues all the codec and CPU DAI's together. It can
+also be used to set up the DAI system clock and for any machine related DAI
+initialisation e.g. the machine audio map can be connected to the codec audio
+map, unconnnected codec pins can be set as such. Please see corgi.c, spitz.c
+for examples.
+
+struct snd_soc_dai_link is used to set up each DAI in your machine. e.g.
+
+/* corgi digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link corgi_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8731_dai,
+	.init = corgi_wm8731_init,
+	.config_sysclk = corgi_config_sysclk,
+};
+
+struct snd_soc_machine then sets up the machine with it's DAI's. e.g.
+
+/* corgi audio machine driver */
+static struct snd_soc_machine snd_soc_machine_corgi = {
+	.name = "Corgi",
+	.dai_link = &corgi_dai,
+	.num_links = 1,
+	.ops = &corgi_ops,
+};
+
+
+Machine Audio Subsystem
+-----------------------
+
+The machine soc device glues the platform, machine and codec driver together.
+Private data can also be set here. e.g.
+
+/* corgi audio private data */
+static struct wm8731_setup_data corgi_wm8731_setup = {
+	.i2c_address = 0x1b,
+};
+
+/* corgi audio subsystem */
+static struct snd_soc_device corgi_snd_devdata = {
+	.machine = &snd_soc_machine_corgi,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &corgi_wm8731_setup,
+};
+
+
+Machine Power Map
+-----------------
+
+The machine driver can optionally extend the codec power map and to become an
+audio power map of the audio subsystem. This allows for automatic power up/down
+of speaker/HP amplifiers, etc. Codec pins can be connected to the machines jack
+sockets in the machine init function. See soc/pxa/spitz.c and dapm.txt for
+details.
+
+
+Machine Controls
+----------------
+
+Machine specific audio mixer controls can be added in the dai init function.
\ No newline at end of file
Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/overview.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/overview.txt
@@ -0,0 +1,83 @@
+ALSA SoC Layer
+==============
+
+The overall project goal of the ALSA System on Chip (ASoC) layer is to provide
+better ALSA support for embedded system on chip procesors (e.g. pxa2xx, au1x00,
+iMX, etc) and portable audio codecs. Currently there is some support in the
+kernel for SoC audio, however it has some limitations:-
+
+  * Currently, codec drivers are often tightly coupled to the underlying SoC
+    cpu. This is not ideal and leads to code duplication i.e. Linux now has 4
+    different wm8731 drivers for 4 different SoC platforms.
+
+  * There is no standard method to signal user initiated audio events.
+    e.g. Headphone/Mic insertion, Headphone/Mic detection after an insertion
+    event. These are quite common events on portable devices and ofter require
+    machine specific code to re route audio, enable amps etc after such an event.
+
+  * Current drivers tend to power up the entire codec when playing
+    (or recording) audio. This is fine for a PC, but tends to waste a lot of
+    power on portable devices. There is also no support for saving power via
+    changing codec oversampling rates, bias currents, etc.
+
+
+ASoC Design
+===========
+
+The ASoC layer is designed to address these issues and provide the following
+features :-
+
+  * Codec independence. Allows reuse of codec drivers on other platforms
+    and machines.
+
+  * Easy I2S/PCM audio interface setup between codec and SoC. Each SoC interface
+    and codec registers it's audio interface capabilities with the core and are
+    subsequently matched and configured when the application hw params are known.
+
+  * Dynamic Audio Power Management (DAPM). DAPM automatically sets the codec to
+    it's minimum power state at all times. This includes powering up/down
+    internal power blocks depending on the internal codec audio routing and any
+    active streams.
+
+  * Pop and click reduction. Pops and clicks can be reduced by powering the
+    codec up/down in the correct sequence (including using digital mute). ASoC
+    signals the codec when to change power states.
+
+  * Machine specific controls: Allow machines to add controls to the sound card
+    e.g. volume control for speaker amp.
+
+To achieve all this, ASoC basically splits an embedded audio system into 3
+components :-
+
+  * Codec driver: The codec driver is platform independent and contains audio
+    controls, audio interface capabilities, codec dapm definition and codec IO
+    functions.
+
+  * Platform driver: The platform driver contains the audio dma engine and audio
+    interface drivers (e.g. I2S, AC97, PCM) for that platform.
+
+  * Machine driver: The machine driver handles any machine specific controls and
+    audio events. i.e. turing on an amp at start of playback.
+
+
+Documentation
+=============
+
+The documentation is spilt into the following sections:-
+
+overview.txt: This file.
+
+codec.txt: Codec driver internals.
+
+DAI.txt: Description of Digital Audio Interface standards and how to configure
+a DAI within your codec and CPU DAI drivers.
+
+dapm.txt: Dynamic Audio Power Management
+
+platform.txt: Platform audio DMA and DAI.
+
+machine.txt: Machine driver internals.
+
+pop_clicks.txt: How to minimise audio artifacts.
+
+clocking.txt: ASoC clocking for best power performance.
\ No newline at end of file
Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/platform.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/platform.txt
@@ -0,0 +1,58 @@
+ASoC Platform Driver
+====================
+
+An ASoC platform driver can be divided into audio DMA and SoC DAI configuration
+and control. The platform drivers only target the SoC CPU and must have no board
+specific code.
+
+Audio DMA
+=========
+
+The platform DMA driver optionally supports the following alsa operations:-
+
+/* SoC audio ops */
+struct snd_soc_ops {
+	int (*startup)(snd_pcm_substream_t *);
+	void (*shutdown)(snd_pcm_substream_t *);
+	int (*hw_params)(snd_pcm_substream_t *, snd_pcm_hw_params_t *);
+	int (*hw_free)(snd_pcm_substream_t *);
+	int (*prepare)(snd_pcm_substream_t *);
+	int (*trigger)(snd_pcm_substream_t *, int);
+};
+
+The platform driver exports it's DMA functionailty via struct snd_soc_platform:-
+
+struct snd_soc_platform {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev, struct snd_soc_cpu_dai *cpu_dai);
+	int (*resume)(struct platform_device *pdev, struct snd_soc_cpu_dai *cpu_dai);
+
+	/* pcm creation and destruction */
+	int (*pcm_new)(snd_card_t *, struct snd_soc_codec_dai *, snd_pcm_t *);
+	void (*pcm_free)(snd_pcm_t *);
+
+	/* platform stream ops */
+	snd_pcm_ops_t *pcm_ops;
+};
+
+Please refer to the alsa driver documentation for details of audio DMA.
+http://www.alsa-project.org/~iwai/writing-an-alsa-driver/c436.htm
+
+An example DMA driver is soc/pxa/pxa2xx-pcm.c
+
+
+SoC DAI Drivers
+===============
+
+Each SoC DAI driver must provide the following features:-
+
+ 1) Digital audio interface (DAI) description
+ 2) Digital audio interface configuration
+ 3) PCM's description
+ 4) Sysclk configuration
+ 5) Suspend and resume (optional)
+
+Please see codec.txt for a description of items 1 - 4.
Index: linux-2.6-pxa-new/Documentation/sound/alsa/soc/pops_clicks.txt
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/Documentation/sound/alsa/soc/pops_clicks.txt
@@ -0,0 +1,52 @@
+Audio Pops and Clicks
+=====================
+
+Pops and clicks are unwanted audio artifacts caused by the powering up and down
+of components within the audio subsystem. This is noticable on PC's when an audio
+module is either loaded or unloaded (at module load time the sound card is
+powered up and causes a popping noise on the speakers).
+
+Pops and clicks can be more frequent on portable systems with DAPM. This is because
+the components within the subsystem are being dynamically powered depending on
+the audio usage and this can subsequently cause a small pop or click every time a
+component power state is changed.
+
+
+Minimising Playback Pops and Clicks
+===================================
+
+Playback pops in portable audio subsystems cannot be completely eliminated atm,
+however future audio codec hardware will have better pop and click supression.
+Pops can be reduced within playback by powering the audio components in a
+specific order. This order is different for startup and shutdown and follows
+some basic rules:-
+
+ Startup Order :- DAC --> Mixers --> Output PGA --> Digital Unmute
+
+ Shutdown Order :- Digital Mute --> Output PGA --> Mixers --> DAC
+
+This assumes that the codec PCM output path from the DAC is via a mixer and then
+a PGA (programmable gain amplifier) before being output to the speakers.
+
+
+Minimising Capture Pops and Clicks
+==================================
+
+Capture artifacts are somewhat easier to get rid as we can delay activating the
+ADC until all the pops have occured. This follows similar power rules to
+playback in that components are powered in a sequence depending upon stream
+startup or shutdown.
+
+ Startup Order - Input PGA --> Mixers --> ADC
+
+ Shutdown Order - ADC --> Mixers --> Input PGA
+
+
+Zipper Noise
+============
+An unwanted zipper noise can occur within the audio playback or capture stream
+when a volume control is changed near its maximum gain value. The zipper noise
+is heard when the gain increase or decrease changes the mean audio signal
+amplitude too quickly. It can be minimised by enabling the zero cross setting
+for each volume control. The ZC forces the gain change to occur when the signal
+crosses the zero amplitude line.
Index: linux-2.6-pxa-new/include/sound/ac97_codec.h
===================================================================
--- linux-2.6-pxa-new.orig/include/sound/ac97_codec.h
+++ linux-2.6-pxa-new/include/sound/ac97_codec.h
@@ -425,6 +425,7 @@ struct snd_ac97_build_ops {
 
 struct snd_ac97_bus_ops {
 	void (*reset) (struct snd_ac97 *ac97);
+	void (*warm_reset)(struct snd_ac97 *ac97);
 	void (*write) (struct snd_ac97 *ac97, unsigned short reg, unsigned short val);
 	unsigned short (*read) (struct snd_ac97 *ac97, unsigned short reg);
 	void (*wait) (struct snd_ac97 *ac97);
Index: linux-2.6-pxa-new/include/sound/soc-dapm.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/include/sound/soc-dapm.h
@@ -0,0 +1,286 @@
+/*
+ * linux/sound/soc-dapm.h -- ALSA SoC Dynamic Audio Power Management
+ *
+ * Author:		Liam Girdwood
+ * Created:		Aug 11th 2005
+ * Copyright:	Wolfson Microelectronics. PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_DAPM_H
+#define __LINUX_SND_SOC_DAPM_H
+
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+
+/* widget has no PM register bit */
+#define SND_SOC_NOPM	-1
+
+/*
+ * SoC dynamic audio power managment
+ *
+ * We can have upto 4 power domains
+ * 	1. Codec domain - VREF, VMID
+ *     Usually controlled at codec probe/remove, although can be set
+ *     at stream time if power is not needed for sidetone, etc.
+ *  2. Platform/Machine domain - physically connected inputs and outputs
+ *     Is platform/machine and user action specific, is set in the machine
+ *     driver and by userspace e.g when HP are inserted
+ *  3. Path domain - Internal codec path mixers
+ *     Are automatically set when mixer and mux settings are
+ *     changed by the user.
+ *  4. Stream domain - DAC's and ADC's.
+ *     Enabled when stream playback/capture is started.
+ */
+
+/* codec domain */
+#define SND_SOC_DAPM_VMID(wname) \
+{	.id = snd_soc_dapm_vmid, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0}
+
+/* platform domain */
+#define SND_SOC_DAPM_INPUT(wname) \
+{	.id = snd_soc_dapm_input, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0}
+#define SND_SOC_DAPM_OUTPUT(wname) \
+{	.id = snd_soc_dapm_output, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0}
+#define SND_SOC_DAPM_MIC(wname, wevent) \
+{	.id = snd_soc_dapm_mic, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD}
+#define SND_SOC_DAPM_HP(wname, wevent) \
+{	.id = snd_soc_dapm_hp, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
+#define SND_SOC_DAPM_SPK(wname, wevent) \
+{	.id = snd_soc_dapm_spk, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
+#define SND_SOC_DAPM_LINE(wname, wevent) \
+{	.id = snd_soc_dapm_line, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
+
+/* path domain */
+#define SND_SOC_DAPM_PGA(wname, wreg, wshift, winvert,\
+	 wcontrols, wncontrols) \
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols}
+#define SND_SOC_DAPM_MIXER(wname, wreg, wshift, winvert, \
+	 wcontrols, wncontrols)\
+{	.id = snd_soc_dapm_mixer, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols}
+#define SND_SOC_DAPM_MICBIAS(wname, wreg, wshift, winvert) \
+{	.id = snd_soc_dapm_micbias, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = NULL, .num_kcontrols = 0}
+#define SND_SOC_DAPM_SWITCH(wname, wreg, wshift, winvert, wcontrols) \
+{	.id = snd_soc_dapm_switch, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1}
+#define SND_SOC_DAPM_MUX(wname, wreg, wshift, winvert, wcontrols) \
+{	.id = snd_soc_dapm_mux, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1}
+
+/* path domain with event - event handler must return 0 for success */
+#define SND_SOC_DAPM_PGA_E(wname, wreg, wshift, winvert, wcontrols, \
+	wncontrols, wevent, wflags) \
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols, \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_MIXER_E(wname, wreg, wshift, winvert, wcontrols, \
+	wncontrols, wevent, wflags) \
+{	.id = snd_soc_dapm_mixer, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols, \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_MICBIAS_E(wname, wreg, wshift, winvert, wevent, wflags) \
+{	.id = snd_soc_dapm_micbias, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = NULL, .num_kcontrols = 0, \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_SWITCH_E(wname, wreg, wshift, winvert, wcontrols, \
+	wevent, wflags) \
+{	.id = snd_soc_dapm_switch, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1 \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_MUX_E(wname, wreg, wshift, winvert, wcontrols, \
+	wevent, wflags) \
+{	.id = snd_soc_dapm_mux, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1, \
+	.event = wevent, .event_flags = wflags}
+
+/* events that are pre and post DAPM */
+#define SND_SOC_DAPM_PRE(wname, wevent) \
+{	.id = snd_soc_dapm_pre, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD}
+#define SND_SOC_DAPM_POST(wname, wevent) \
+{	.id = snd_soc_dapm_post, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD}
+
+/* stream domain */
+#define SND_SOC_DAPM_DAC(wname, stname, wreg, wshift, winvert) \
+{	.id = snd_soc_dapm_dac, .name = wname, .sname = stname, .reg = wreg, \
+	.shift = wshift, .invert = winvert}
+#define SND_SOC_DAPM_ADC(wname, stname, wreg, wshift, winvert) \
+{	.id = snd_soc_dapm_adc, .name = wname, .sname = stname, .reg = wreg, \
+	.shift = wshift, .invert = winvert}
+
+/* dapm kcontrol types */
+#define SOC_DAPM_SINGLE(xname, reg, shift, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, \
+	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, mask, invert) }
+#define SOC_DAPM_DOUBLE(xname, reg, shift_left, shift_right, mask, invert, \
+	power) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.info = snd_soc_info_volsw, \
+ 	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
+ 	.private_value = (reg) | ((shift_left) << 8) | ((shift_right) << 12) |\
+ 		 ((mask) << 16) | ((invert) << 24) }
+#define SOC_DAPM_ENUM(xname, xenum) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_enum_double, \
+ 	.get = snd_soc_dapm_get_enum_double, \
+ 	.put = snd_soc_dapm_put_enum_double, \
+  	.private_value = (unsigned long)&xenum }
+
+/* dapm stream operations */
+#define SND_SOC_DAPM_STREAM_NOP			0x0
+#define SND_SOC_DAPM_STREAM_START		0x1
+#define SND_SOC_DAPM_STREAM_STOP		0x2
+#define SND_SOC_DAPM_STREAM_SUSPEND		0x4
+#define SND_SOC_DAPM_STREAM_RESUME		0x8
+#define SND_SOC_DAPM_STREAM_PAUSE_PUSH	0x10
+#define SND_SOC_DAPM_STREAM_PAUSE_RELEASE	0x20
+
+/* dapm event types */
+#define SND_SOC_DAPM_PRE_PMU	0x1 	/* before widget power up */
+#define SND_SOC_DAPM_POST_PMU	0x2		/* after widget power up */
+#define SND_SOC_DAPM_PRE_PMD	0x4 	/* before widget power down */
+#define SND_SOC_DAPM_POST_PMD	0x8		/* after widget power down */
+#define SND_SOC_DAPM_PRE_REG	0x10	/* before audio path setup */
+#define SND_SOC_DAPM_POST_REG	0x20	/* after audio path setup */
+
+/* convenience event type detection */
+#define SND_SOC_DAPM_EVENT_ON(e)	\
+	(e & (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU))
+#define SND_SOC_DAPM_EVENT_OFF(e)	\
+	(e & (SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD))
+
+struct snd_soc_dapm_widget;
+enum snd_soc_dapm_type;
+struct snd_soc_dapm_path;
+struct snd_soc_dapm_pin;
+
+/* dapm controls */
+int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_new_control(struct snd_soc_codec *codec,
+	const struct snd_soc_dapm_widget *widget);
+
+/* dapm path setup */
+int snd_soc_dapm_connect_input(struct snd_soc_codec *codec,
+	const char *sink_name, const char *control_name, const char *src_name);
+int snd_soc_dapm_new_widgets(struct snd_soc_codec *codec);
+void snd_soc_dapm_free(struct snd_soc_device *socdev);
+
+/* dapm events */
+int snd_soc_dapm_stream_event(struct snd_soc_codec *codec, char *stream,
+	int event);
+
+/* dapm sys fs - used by the core */
+int snd_soc_dapm_sys_add(struct device *dev);
+
+/* dapm audio endpoint control */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+	char *pin, int status);
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec);
+
+/* dapm widget types */
+enum snd_soc_dapm_type {
+	snd_soc_dapm_input = 0,		/* input pin */
+	snd_soc_dapm_output,		/* output pin */
+	snd_soc_dapm_mux,			/* selects 1 analog signal from many inputs */
+	snd_soc_dapm_mixer,			/* mixes several analog signals together */
+	snd_soc_dapm_pga,			/* programmable gain/attenuation (volume) */
+	snd_soc_dapm_adc,			/* analog to digital converter */
+	snd_soc_dapm_dac,			/* digital to analog converter */
+	snd_soc_dapm_micbias,		/* microphone bias (power) */
+	snd_soc_dapm_mic,			/* microphone */
+	snd_soc_dapm_hp,			/* headphones */
+	snd_soc_dapm_spk,			/* speaker */
+	snd_soc_dapm_line,			/* line input/output */
+	snd_soc_dapm_switch,		/* analog switch */
+	snd_soc_dapm_vmid,			/* codec bias/vmid - to minimise pops */
+	snd_soc_dapm_pre,			/* machine specific pre widget - exec first */
+	snd_soc_dapm_post,			/* machine specific post widget - exec last */
+};
+
+/* dapm audio path between two widgets */
+struct snd_soc_dapm_path {
+	char *name;
+	char *long_name;
+
+	/* source (input) and sink (output) widgets */
+	struct snd_soc_dapm_widget *source;
+	struct snd_soc_dapm_widget *sink;
+	struct snd_kcontrol *kcontrol;
+
+	/* status */
+	u32 connect:1;	/* source and sink widgets are connected */
+	u32 walked:1;	/* path has been walked */
+
+	struct list_head list_source;
+	struct list_head list_sink;
+	struct list_head list;
+};
+
+/* dapm widget */
+struct snd_soc_dapm_widget {
+	enum snd_soc_dapm_type id;
+	char *name;		/* widget name */
+	char *sname;	/* stream name */
+	struct snd_soc_codec *codec;
+	struct list_head list;
+
+	/* dapm control */
+	short reg;						/* negative reg = no direct dapm */
+	unsigned char shift;			/* bits to shift */
+	unsigned int saved_value;		/* widget saved value */
+	unsigned int value;				/* widget current value */
+	unsigned char power:1;			/* block power status */
+	unsigned char invert:1;			/* invert the power bit */
+	unsigned char active:1;			/* active stream on DAC, ADC's */
+	unsigned char connected:1;		/* connected codec pin */
+	unsigned char new:1;			/* cnew complete */
+	unsigned char ext:1;			/* has external widgets */
+	unsigned char muted:1;			/* muted for pop reduction */
+	unsigned char suspend:1;		/* was active before suspend */
+	unsigned char pmdown:1;			/* waiting for timeout */
+
+	/* external events */
+	unsigned short event_flags;		/* flags to specify event types */
+	int (*event)(struct snd_soc_dapm_widget*, int);
+
+	/* kcontrols that relate to this widget */
+	int num_kcontrols;
+	const struct snd_kcontrol_new *kcontrols;
+
+	/* widget input and outputs */
+	struct list_head sources;
+	struct list_head sinks;
+};
+
+#endif
Index: linux-2.6-pxa-new/include/sound/soc.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/include/sound/soc.h
@@ -0,0 +1,487 @@
+/*
+ * linux/sound/soc.h -- ALSA SoC Layer
+ *
+ * Author:		Liam Girdwood
+ * Created:		Aug 11th 2005
+ * Copyright:	Wolfson Microelectronics. PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_H
+#define __LINUX_SND_SOC_H
+
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/ac97_codec.h>
+
+#define SND_SOC_VERSION "0.12.4"
+
+/*
+ * Convenience kcontrol builders
+ */
+#define SOC_SINGLE_VALUE(reg,shift,mask,invert) ((reg) | ((shift) << 8) |\
+	((shift) << 12) | ((mask) << 16) | ((invert) << 24))
+#define SOC_SINGLE_VALUE_EXT(reg,mask,invert) ((reg) | ((mask) << 16) |\
+	((invert) << 31))
+#define SOC_SINGLE(xname, reg, shift, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
+	.put = snd_soc_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, mask, invert) }
+#define SOC_DOUBLE(xname, reg, shift_left, shift_right, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
+	.put = snd_soc_put_volsw, \
+	.private_value = (reg) | ((shift_left) << 8) | \
+		((shift_right) << 12) | ((mask) << 16) | ((invert) << 24) }
+#define SOC_DOUBLE_R(xname, reg_left, reg_right, shift, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = snd_soc_put_volsw_2r, \
+	.private_value = (reg_left) | ((shift) << 8)  | \
+		((mask) << 12) | ((invert) << 20) | ((reg_right) << 24) }
+#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xtexts) \
+{	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
+	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM_SINGLE(xreg, xshift, xmask, xtexts) \
+	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xtexts)
+#define SOC_ENUM_SINGLE_EXT(xmask, xtexts) \
+{	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM(xname, xenum) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
+	.info = snd_soc_info_enum_double, \
+	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \
+	.private_value = (unsigned long)&xenum }
+#define SOC_SINGLE_EXT(xname, xreg, xmask, xinvert,\
+	 xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value =  SOC_SINGLE_VALUE_EXT(xreg, xmask, xinvert) }
+#define SOC_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_bool_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = xdata }
+#define SOC_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_enum_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&xenum }
+
+/*
+ * Digital Audio Interface (DAI) types
+ */
+#define SND_SOC_DAI_AC97	0x1
+#define SND_SOC_DAI_I2S		0x2
+#define SND_SOC_DAI_PCM		0x4
+
+/*
+ * DAI hardware audio formats
+ */
+#define SND_SOC_DAIFMT_I2S		(1 << 0)	/* I2S mode */
+#define SND_SOC_DAIFMT_RIGHT_J	(1 << 1)	/* Right justified mode */
+#define SND_SOC_DAIFMT_LEFT_J	(1 << 2)	/* Left Justified mode */
+#define SND_SOC_DAIFMT_DSP_A	(1 << 3)	/* L data msb after FRM or LRC */
+#define SND_SOC_DAIFMT_DSP_B	(1 << 4)	/* L data msb during FRM or LRC */
+#define SND_SOC_DAIFMT_AC97		(1 << 5)	/* AC97 */
+
+/*
+ * DAI hardware signal inversions
+ */
+#define SND_SOC_DAIFMT_NB_NF		(1 << 8)	/* normal bit clock + frame */
+#define SND_SOC_DAIFMT_NB_IF		(1 << 9)	/* normal bclk + inv frm */
+#define SND_SOC_DAIFMT_IB_NF		(1 << 10)	/* invert bclk + nor frm */
+#define SND_SOC_DAIFMT_IB_IF		(1 << 11)	/* invert bclk + frm */
+
+/*
+ * DAI hardware clock masters
+ * This is wrt the codec, the inverse is true for the interface
+ * i.e. if the codec is clk and frm master then the interface is
+ * clk and frame slave.
+ */
+#define SND_SOC_DAIFMT_CBM_CFM	(1 << 12) /* codec clk & frm master */
+#define SND_SOC_DAIFMT_CBS_CFM	(1 << 13) /* codec clk slave & frm master */
+#define SND_SOC_DAIFMT_CBM_CFS	(1 << 14) /* codec clk master & frame slave */
+#define SND_SOC_DAIFMT_CBS_CFS	(1 << 15) /* codec clk & frm slave */
+
+#define SND_SOC_DAIFMT_FORMAT_MASK		0x00ff
+#define SND_SOC_DAIFMT_INV_MASK			0x0f00
+#define SND_SOC_DAIFMT_CLOCK_MASK		0xf000
+
+/*
+ * DAI hardware audio direction
+ */
+#define SND_SOC_DAIDIR_PLAYBACK		0x1
+#define SND_SOC_DAIDIR_CAPTURE		0x2
+
+/*
+ * DAI hardware Time Division Multiplexing (TDM) Slots
+ * Left and Right data word positions
+ * This is measured in words (sample size) and not bits.
+ */
+#define SND_SOC_DAITDM_LRDW(l,r)	((l << 8) | r)
+
+/*
+ * DAI hardware clock ratios
+ * bit clock can either be a generated by dividing mclk or
+ * by multiplying sample rate, hence there are 2 definitions below
+ * depending on codec type.
+ */
+/* ratio of sample rate to mclk/sysclk */
+#define SND_SOC_FS_ALL			0xffff	/* all mclk supported */
+
+/* bit clock dividers */
+#define SND_SOC_FSBD(x)			(1 << (x - 1))	/* ratio mclk:bclk */
+#define SND_SOC_FSBD_REAL(x)	(ffs(x))
+
+/* bit clock ratio to (sample rate * channels * word size) */
+#define SND_SOC_FSBW(x)			(1 << (x - 1))
+#define SND_SOC_FSBW_REAL(x)		(ffs(x))
+/* all bclk ratios supported */
+#define SND_SOC_FSB_ALL			~0ULL
+
+/*
+ * DAI hardware flags
+ */
+/* use bfs mclk divider mode (BCLK = MCLK / x) */
+#define SND_SOC_DAI_BFS_DIV		0x1
+/* use bfs rate mulitplier  (BCLK = RATE * x)*/
+#define SND_SOC_DAI_BFS_RATE	0x2
+/* use bfs rcw multiplier (BCLK = RATE * CHN * WORD SIZE) */
+#define SND_SOC_DAI_BFS_RCW		0x4
+/* capture and playback can use different clocks */
+#define SND_SOC_DAI_ASYNC		0x8
+/* can use gated BCLK */
+#define SND_SOC_DAI_GATED		0x10
+
+/*
+ * AC97 codec ID's bitmask
+ */
+#define SND_SOC_DAI_AC97_ID0	(1 << 0)
+#define SND_SOC_DAI_AC97_ID1	(1 << 1)
+#define SND_SOC_DAI_AC97_ID2	(1 << 2)
+#define SND_SOC_DAI_AC97_ID3	(1 << 3)
+
+struct snd_soc_device;
+struct snd_soc_pcm_stream;
+struct snd_soc_ops;
+struct snd_soc_dai_mode;
+struct snd_soc_pcm_runtime;
+struct snd_soc_codec_dai;
+struct snd_soc_cpu_dai;
+struct snd_soc_codec;
+struct snd_soc_machine_config;
+struct soc_enum;
+struct snd_soc_ac97_ops;
+struct snd_soc_clock_info;
+
+typedef int (*hw_write_t)(void *,const char* ,int);
+typedef int (*hw_read_t)(void *,char* ,int);
+
+extern struct snd_ac97_bus_ops soc_ac97_ops;
+
+/* pcm <-> DAI connect */
+void snd_soc_free_pcms(struct snd_soc_device *socdev);
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid);
+int snd_soc_register_card(struct snd_soc_device *socdev);
+
+/* set runtime hw params */
+int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
+	const struct snd_pcm_hardware *hw);
+int snd_soc_get_rate(int rate);
+
+/* codec IO */
+#define snd_soc_read(codec, reg) codec->read(codec, reg)
+#define snd_soc_write(codec, reg, value) codec->write(codec, reg, value)
+
+/* codec register bit access */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value);
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value);
+
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num);
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec);
+
+/*
+ *Controls
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+	void *data, char *long_name);
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_bool_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+
+/* SoC PCM stream information */
+struct snd_soc_pcm_stream {
+	char *stream_name;
+	unsigned int rate_min;		/* min rate */
+	unsigned int rate_max;		/* max rate */
+	unsigned int channels_min;	/* min channels */
+	unsigned int channels_max;	/* max channels */
+	unsigned int active:1;		/* stream is in use */
+};
+
+/* SoC audio ops */
+struct snd_soc_ops {
+	int (*startup)(struct snd_pcm_substream *);
+	void (*shutdown)(struct snd_pcm_substream *);
+	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
+	int (*hw_free)(struct snd_pcm_substream *);
+	int (*prepare)(struct snd_pcm_substream *);
+	int (*trigger)(struct snd_pcm_substream *, int);
+};
+
+/* SoC DAI hardware mode */
+struct snd_soc_dai_mode {
+	u16 fmt;		/* SND_SOC_DAIFMT_* */
+	u16 tdm;		/* SND_SOC_HWTDM_* */
+	u64 pcmfmt; 	/* SNDRV_PCM_FMTBIT_* */
+	u16 pcmrate;	/* SND_SOC_HWRATE_* */
+	u16 pcmdir:2;	/* SND_SOC_HWDIR_* */
+	u16 flags:8;	/* hw flags */
+	u16 fs;			/* mclk to rate divider */
+	u64 bfs;		/* mclk to bclk dividers */
+	unsigned long priv;		/* private mode data */
+};
+
+/* DAI capabilities */
+struct snd_soc_dai_cap {
+	int num_modes;				/* number of DAI modes */
+	struct snd_soc_dai_mode *mode;	/* array of supported DAI modes */
+};
+
+/* SoC Codec DAI */
+struct snd_soc_codec_dai {
+	char *name;
+	int id;
+
+	/* DAI capabilities */
+	struct snd_soc_pcm_stream playback;
+	struct snd_soc_pcm_stream capture;
+	struct snd_soc_dai_cap caps;
+
+	/* DAI runtime info */
+	struct snd_soc_dai_mode dai_runtime;
+	struct snd_soc_ops ops;
+	unsigned int (*config_sysclk)(struct snd_soc_codec_dai*,
+		struct snd_soc_clock_info *info, unsigned int clk);
+	int (*digital_mute)(struct snd_soc_codec *,
+		struct snd_soc_codec_dai*, int);
+	unsigned int mclk;		/* the audio master clock */
+	unsigned int pll_in;	/* the PLL input clock */
+	unsigned int pll_out;	/* the PLL output clock */
+	unsigned int clk_div;	/* internal clock divider << 1 (for fractions) */
+	unsigned int active;
+	unsigned char pop_wait:1;
+
+	/* DAI private data */
+	void *private_data;
+};
+
+/* SoC CPU DAI */
+struct snd_soc_cpu_dai {
+
+	/* DAI description */
+	char *name;
+	unsigned int id;
+	unsigned char type;
+
+	/* DAI callbacks */
+	int (*probe)(struct platform_device *pdev);
+	void (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+	int (*resume)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+	unsigned int (*config_sysclk)(struct snd_soc_cpu_dai *cpu_dai,
+		struct snd_soc_clock_info *info, unsigned int clk);
+
+	/* DAI capabilities */
+	struct snd_soc_pcm_stream capture;
+	struct snd_soc_pcm_stream playback;
+	struct snd_soc_dai_cap caps;
+
+	/* DAI runtime info */
+	struct snd_soc_dai_mode dai_runtime;
+	struct snd_soc_ops ops;
+	struct snd_pcm_runtime *runtime;
+	unsigned char active:1;
+	unsigned int mclk;
+	void *dma_data;
+
+	/* DAI private data */
+	void *private_data;
+};
+
+/* SoC Audio Codec */
+struct snd_soc_codec {
+	char *name;
+	struct module *owner;
+	struct mutex mutex;
+
+	/* callbacks */
+	int (*dapm_event)(struct snd_soc_codec *codec, int event);
+
+	/* runtime */
+	struct snd_card *card;
+	struct snd_ac97 *ac97;  /* for ad-hoc ac97 devices */
+	unsigned int active;
+	unsigned int pcm_devs;
+	void *private_data;
+
+	/* codec IO */
+	void *control_data; /* codec control (i2c/3wire) data */
+	unsigned int (*read)(struct snd_soc_codec *, unsigned int);
+	int (*write)(struct snd_soc_codec *, unsigned int, unsigned int);
+	hw_write_t hw_write;
+	hw_read_t hw_read;
+	void *reg_cache;
+	short reg_cache_size;
+	short reg_cache_step;
+
+	/* dapm */
+	struct list_head dapm_widgets;
+	struct list_head dapm_paths;
+	unsigned int dapm_state;
+	unsigned int suspend_dapm_state;
+
+	/* codec DAI's */
+	struct snd_soc_codec_dai *dai;
+	unsigned int num_dai;
+};
+
+/* codec device */
+struct snd_soc_codec_device {
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev, pm_message_t state);
+	int (*resume)(struct platform_device *pdev);
+};
+
+/* SoC platform interface */
+struct snd_soc_platform {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+	int (*resume)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+
+	/* pcm creation and destruction */
+	int (*pcm_new)(struct snd_card *, struct snd_soc_codec_dai *,
+		struct snd_pcm *);
+	void (*pcm_free)(struct snd_pcm *);
+
+	/* platform stream ops */
+	struct snd_pcm_ops *pcm_ops;
+};
+
+/* SoC machine DAI configuration, glues a codec and cpu DAI together */
+struct snd_soc_dai_link  {
+	char *name;			/* Codec name */
+	char *stream_name;		/* Stream name */
+
+	/* DAI */
+	struct snd_soc_codec_dai *codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai;
+	u32 flags;			/* DAI config preference flags */
+
+	/* codec/machine specific init - e.g. add machine controls */
+	int (*init)(struct snd_soc_codec *codec);
+
+	/* audio sysclock configuration */
+	unsigned int (*config_sysclk)(struct snd_soc_pcm_runtime *rtd,
+		struct snd_soc_clock_info *info);
+};
+
+/* SoC machine */
+struct snd_soc_machine {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+
+	/* the pre and post PM functions are used to do any PM work before and
+	 * after the codec and DAI's do any PM work. */
+	int (*suspend_pre)(struct platform_device *pdev, pm_message_t state);
+	int (*suspend_post)(struct platform_device *pdev, pm_message_t state);
+	int (*resume_pre)(struct platform_device *pdev);
+	int (*resume_post)(struct platform_device *pdev);
+
+	/* machine stream operations */
+	struct snd_soc_ops *ops;
+
+	/* CPU <--> Codec DAI links  */
+	struct snd_soc_dai_link *dai_link;
+	int num_links;
+};
+
+/* SoC Device - the audio subsystem */
+struct snd_soc_device {
+	struct device *dev;
+	struct snd_soc_machine *machine;
+	struct snd_soc_platform *platform;
+	struct snd_soc_codec *codec;
+	struct snd_soc_codec_device *codec_dev;
+	void *codec_data;
+};
+
+/* runtime channel data */
+struct snd_soc_pcm_runtime {
+	struct snd_soc_codec_dai *codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai;
+	struct snd_soc_device *socdev;
+};
+
+/* enumerated kcontrol */
+struct soc_enum {
+	unsigned short reg;
+	unsigned short reg2;
+	unsigned char shift_l;
+	unsigned char shift_r;
+	unsigned int mask;
+	const char **texts;
+	void *dapm;
+};
+
+/* clocking configuration data */
+struct snd_soc_clock_info {
+	unsigned int rate;
+	unsigned int fs;
+	unsigned int bclk_master;
+};
+
+#endif
Index: linux-2.6-pxa-new/sound/Kconfig
===================================================================
--- linux-2.6-pxa-new.orig/sound/Kconfig
+++ linux-2.6-pxa-new/sound/Kconfig
@@ -76,6 +76,8 @@ source "sound/sparc/Kconfig"
 
 source "sound/parisc/Kconfig"
 
+source "sound/soc/Kconfig"
+
 endmenu
 
 menu "Open Sound System"
Index: linux-2.6-pxa-new/sound/soc/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/Kconfig
@@ -0,0 +1,37 @@
+#
+# SoC audio configuration
+#
+
+menu "SoC audio support"
+	depends on SND!=n
+
+config SND_SOC_AC97_BUS
+	bool
+
+config SND_SOC
+	tristate "SoC audio support"
+	---help---
+
+	  If you want SoC support, you should say Y here and also to the
+	  specific driver for your SoC below. You will also need to select the
+	  specific codec(s) attached to the SoC
+
+	  This SoC audio support can also be built as a module.  If so, the module
+	  will be called snd-soc-core.
+
+# All the supported Soc's
+menu "Soc Platforms"
+depends on SND_SOC
+source "sound/soc/pxa/Kconfig"
+source "sound/soc/at91/Kconfig"
+source "sound/soc/imx/Kconfig"
+source "sound/soc/s3c24xx/Kconfig"
+endmenu
+
+# Supported codecs
+menu "Soc Codecs"
+depends on SND_SOC
+source "sound/soc/codecs/Kconfig"
+endmenu
+
+endmenu
Index: linux-2.6-pxa-new/sound/soc/Makefile
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/Makefile
@@ -0,0 +1,4 @@
+snd-soc-core-objs := soc-core.o soc-dapm.o
+
+obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
+obj-$(CONFIG_SND_SOC)	+= pxa/ at91/ imx/ s3c24xx/ codecs/
Index: linux-2.6-pxa-new/sound/soc/codecs/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/Kconfig
@@ -0,0 +1,90 @@
+config SND_SOC_AC97_CODEC
+	tristate "SoC generic AC97 support"
+	depends SND_SOC
+	help
+	  Say Y or M if you want generic AC97 support. This is not required
+	  for the AC97 codecs listed below.
+
+config SND_SOC_WM8711
+	tristate "SoC driver for the WM8711 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8711 codec.
+
+config SND_SOC_WM8510
+	tristate "SoC driver for the WM8510 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8711 codec.
+
+config SND_SOC_WM8731
+	tristate "SoC driver for the WM8731 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8731 codec.
+
+config SND_SOC_WM8750
+	tristate "SoC driver for the WM8750 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8750 codec.
+
+config SND_SOC_WM8753
+	tristate "SoC driver for the WM8753 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8753 codec.
+
+config SND_SOC_WM8772
+	tristate "SoC driver for the WM8772 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8772 codec.
+
+config SND_SOC_WM8971
+	tristate "SoC driver for the WM8971 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8971 codec.
+
+config SND_SOC_WM8976
+	tristate "SoC driver for the WM8976 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8976 codec.
+
+config SND_SOC_WM8974
+	tristate "SoC driver for the WM8974 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8974 codec.
+
+config SND_SOC_WM8980
+	tristate "SoC driver for the WM8980 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM8980 codec.
+
+config SND_SOC_WM9713
+	tristate "SoC driver for the WM9713 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM9713 codec.
+
+config SND_SOC_WM9712
+	tristate "SoC driver for the WM9712 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the WM9712 codec.
+
+config SND_SOC_UDA1380
+	tristate "SoC driver for the UDA1380 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the UDA1380 codec.
+
+config SND_SOC_AK4535
+	tristate "SoC driver for the AK4535 codec"
+	depends SND_SOC
+	help
+	  Say Y or M if you want to support the AK4535 codec.
Index: linux-2.6-pxa-new/sound/soc/codecs/Makefile
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/Makefile
@@ -0,0 +1,31 @@
+snd-soc-ac97-objs := ac97.o
+snd-soc-wm8711-objs := wm8711.o
+snd-soc-wm8510-objs := wm8510.o
+snd-soc-wm8731-objs := wm8731.o
+snd-soc-wm8750-objs := wm8750.o
+snd-soc-wm8753-objs := wm8753.o
+snd-soc-wm8772-objs := wm8772.o
+snd-soc-wm8971-objs := wm8971.o
+snd-soc-wm8974-objs := wm8974.o
+snd-soc-wm8976-objs := wm8976.o
+snd-soc-wm8980-objs := wm8980.o
+snd-soc-uda1380-objs := uda1380.o
+snd-soc-ak4535-objs := ak4535.o
+snd-soc-wm9713-objs := wm9713.o
+snd-soc-wm9712-objs := wm9712.o
+
+obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
+obj-$(CONFIG_SND_SOC_WM8711)	+= snd-soc-wm8711.o
+obj-$(CONFIG_SND_SOC_WM8510)	+= snd-soc-wm8510.o
+obj-$(CONFIG_SND_SOC_WM8731)	+= snd-soc-wm8731.o
+obj-$(CONFIG_SND_SOC_WM8750)	+= snd-soc-wm8750.o
+obj-$(CONFIG_SND_SOC_WM8753)	+= snd-soc-wm8753.o
+obj-$(CONFIG_SND_SOC_WM8772)	+= snd-soc-wm8772.o
+obj-$(CONFIG_SND_SOC_WM8971)	+= snd-soc-wm8971.o
+obj-$(CONFIG_SND_SOC_WM8974)	+= snd-soc-wm8974.o
+obj-$(CONFIG_SND_SOC_WM8976)	+= snd-soc-wm8976.o
+obj-$(CONFIG_SND_SOC_WM8980)	+= snd-soc-wm8980.o
+obj-$(CONFIG_SND_SOC_UDA1380)	+= snd-soc-uda1380.o
+obj-$(CONFIG_SND_SOC_AK4535)	+= snd-soc-ak4535.o
+obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
+obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-wm9712.o
Index: linux-2.6-pxa-new/sound/soc/codecs/ac97.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/ac97.c
@@ -0,0 +1,167 @@
+/*
+ * ac97.c  --  ALSA Soc AC97 codec support
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    17th Oct 2005   Initial version.
+ *
+ * Generic AC97 support.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#define AC97_VERSION "0.5"
+
+#define AC97_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define AC97_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+/* may need to expand this */
+static struct snd_soc_dai_mode soc_ac97[] = {
+	{0, 0,	SNDRV_PCM_FMTBIT_S16_LE,	AC97_RATES},
+	{0, 0,	SNDRV_PCM_FMTBIT_S18_3LE,	AC97_RATES},
+	{0, 0,	SNDRV_PCM_FMTBIT_S20_3LE,	AC97_RATES},
+};
+
+static int ac97_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	int reg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		  AC97_PCM_FRONT_DAC_RATE : AC97_PCM_LR_ADC_RATE;
+	return snd_ac97_set_rate(codec->ac97, reg, runtime->rate);
+}
+
+static struct snd_soc_codec_dai ac97_dai = {
+	.name = "AC97 HiFi",
+	.playback = {
+		.stream_name = "AC97 Playback",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.stream_name = "AC97 Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.ops = {
+		.prepare = ac97_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(soc_ac97),
+		.mode = soc_ac97,},
+};
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	return soc_ac97_ops.read(codec->ac97, reg);
+}
+
+static int ac97_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int val)
+{
+	soc_ac97_ops.write(codec->ac97, reg, val);
+	return 0;
+}
+
+static int ac97_soc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	struct snd_ac97_bus *ac97_bus;
+	struct snd_ac97_template ac97_template;
+	int ret = 0;
+
+	printk(KERN_INFO "AC97 SoC Audio Codec %s\n", AC97_VERSION);
+
+	socdev->codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (socdev->codec == NULL)
+		return -ENOMEM;
+	codec = socdev->codec;
+	mutex_init(&codec->mutex);
+
+	codec->name = "AC97";
+	codec->owner = THIS_MODULE;
+	codec->dai = &ac97_dai;
+	codec->num_dai = 1;
+	codec->write = ac97_write;
+	codec->read = ac97_read;
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0)
+		goto err;
+
+	/* add codec as bus device for standard ac97 */
+	ret = snd_ac97_bus(codec->card, 0, &soc_ac97_ops, NULL, &ac97_bus);
+	if(ret < 0)
+		goto bus_err;
+
+	memset(&ac97_template, 0, sizeof(struct snd_ac97_template));
+	ret = snd_ac97_mixer(ac97_bus, &ac97_template, &codec->ac97);
+	if(ret < 0)
+		goto bus_err;
+
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0)
+		goto bus_err;
+	return 0;
+
+bus_err:
+	snd_soc_free_pcms(socdev);
+
+err:
+	kfree(socdev->codec->reg_cache);
+	kfree(socdev->codec);
+	socdev->codec = NULL;
+	return ret;
+}
+
+static int ac97_soc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if(codec == NULL)
+		return 0;
+
+	snd_soc_free_pcms(socdev);
+	kfree(socdev->codec->reg_cache);
+	kfree(socdev->codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_ac97= {
+	.probe = 	ac97_soc_probe,
+	.remove = 	ac97_soc_remove,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_ac97);
+
+MODULE_DESCRIPTION("Soc Generic AC97 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/ac97.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/ac97.h
@@ -0,0 +1,18 @@
+/*
+ * linux/sound/codecs/ac97.h -- ALSA SoC Layer
+ *
+ * Author:		Liam Girdwood
+ * Created:		Dec 1st 2005
+ * Copyright:	Wolfson Microelectronics. PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_AC97_H
+#define __LINUX_SND_SOC_AC97_H
+
+extern struct snd_soc_codec_device soc_codec_dev_ac97;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/ak4535.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/ak4535.c
@@ -0,0 +1,701 @@
+/*
+ * ak4535.c  --  AK4535 ALSA Soc Audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on wm8753.c by Liam Girdwood
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "ak4535.h"
+
+#define AUDIO_NAME "ak4535"
+#define AK4535_VERSION "0.3"
+
+struct snd_soc_codec_device soc_codec_dev_ak4535;
+
+/*
+ * ak4535 register cache
+ */
+static const u16 ak4535_reg[AK4535_CACHEREGNUM] = {
+    0x0000, 0x0080, 0x0000, 0x0003,
+    0x0002, 0x0000, 0x0011, 0x0001,
+    0x0000, 0x0040, 0x0036, 0x0010,
+    0x0000, 0x0000, 0x0057, 0x0000,
+};
+
+#define AK4535_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_CBS_CFS | \
+	SND_SOC_DAIFMT_NB_NF)
+
+#define AK4535_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define AK4535_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+static struct snd_soc_dai_mode ak4535_modes[] = {
+	/* codec frame and clock slave modes */
+	{
+		.fmt = AK4535_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = AK4535_RATES,
+		.pcmdir = AK4535_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+	{
+		.fmt = AK4535_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = AK4535_RATES,
+		.pcmdir = AK4535_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 32,
+	},
+};
+
+/*
+ * read ak4535 register cache
+ */
+static inline unsigned int ak4535_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= AK4535_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write ak4535 register cache
+ */
+static inline void ak4535_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= AK4535_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the AK4535 register space
+ */
+static int ak4535_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D8 AK4535 register offset
+	 *   D7...D0 register data
+	 */
+	data[0] = reg & 0xff;
+	data[1] = value & 0xff;
+
+	ak4535_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+static const char *ak4535_mono_gain[] = {"+6dB", "-17dB"};
+static const char *ak4535_mono_out[] = {"(L + R)/2", "Hi-Z"};
+static const char *ak4535_hp_out[] = {"Stereo", "Mono"};
+static const char *ak4535_deemp[] = {"44.1kHz", "Off", "48kHz", "32kHz"};
+static const char *ak4535_mic_select[] = {"Internal", "External"};
+
+static const struct soc_enum ak4535_enum[] = {
+	SOC_ENUM_SINGLE(AK4535_SIG1, 7, 2, ak4535_mono_gain),
+	SOC_ENUM_SINGLE(AK4535_SIG1, 6, 2, ak4535_mono_out),
+	SOC_ENUM_SINGLE(AK4535_MODE2, 2, 2, ak4535_hp_out),
+	SOC_ENUM_SINGLE(AK4535_DAC, 0, 4, ak4535_deemp),
+	SOC_ENUM_SINGLE(AK4535_MIC, 1, 2, ak4535_mic_select),
+};
+
+static const struct snd_kcontrol_new ak4535_snd_controls[] = {
+	SOC_SINGLE("ALC2 Switch", AK4535_SIG1, 1, 1, 0),
+	SOC_ENUM("Mono 1 Output", ak4535_enum[1]),
+	SOC_ENUM("Mono 1 Gain", ak4535_enum[0]),
+	SOC_ENUM("Headphone Output", ak4535_enum[2]),
+	SOC_ENUM("Playback Deemphasis", ak4535_enum[3]),
+	SOC_SINGLE("Bass Volume", AK4535_DAC, 2, 3, 0),
+	SOC_SINGLE("Mic Boost (+20dB) Switch", AK4535_MIC, 0, 1, 0),
+	SOC_ENUM("Mic Select", ak4535_enum[4]),
+	SOC_SINGLE("ALC Operation Time", AK4535_TIMER, 0, 3, 0),
+	SOC_SINGLE("ALC Recovery Time", AK4535_TIMER, 2, 3, 0),
+	SOC_SINGLE("ALC ZC Time", AK4535_TIMER, 4, 3, 0),
+	SOC_SINGLE("ALC 1 Switch", AK4535_ALC1, 5, 1, 0),
+	SOC_SINGLE("ALC 2 Switch", AK4535_ALC1, 6, 1, 0),
+	SOC_SINGLE("ALC Volume", AK4535_ALC2, 0, 127, 0),
+	SOC_SINGLE("Capture Volume", AK4535_PGA, 0, 127, 0),
+	SOC_SINGLE("Left Playback Volume", AK4535_LATT, 0, 127, 1),
+	SOC_SINGLE("Right Playback Volume", AK4535_RATT, 0, 127, 1),
+	SOC_SINGLE("AUX Bypass Volume", AK4535_VOL, 0, 15, 0),
+	SOC_SINGLE("Mic Sidetone Volume", AK4535_VOL, 4, 7, 0),
+};
+
+/* add non dapm controls */
+static int ak4535_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(ak4535_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&ak4535_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Mono 1 Mixer */
+static const struct snd_kcontrol_new ak4535_mono1_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Mic Sidetone Switch", AK4535_SIG1, 4, 1, 0),
+	SOC_DAPM_SINGLE("Mono Playback Switch", AK4535_SIG1, 5, 1, 0),
+};
+
+/* Stereo Mixer */
+static const struct snd_kcontrol_new ak4535_stereo_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Mic Sidetone Switch", AK4535_SIG2, 4, 1, 0),
+	SOC_DAPM_SINGLE("Playback Switch", AK4535_SIG2, 7, 1, 0),
+	SOC_DAPM_SINGLE("Aux Bypass Switch", AK4535_SIG2, 5, 1, 0),
+};
+
+/* Input Mixer */
+static const struct snd_kcontrol_new ak4535_input_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Mic Capture Switch", AK4535_MIC, 2, 1, 0),
+	SOC_DAPM_SINGLE("Aux Capture Switch", AK4535_MIC, 5, 1, 0),
+};
+
+/* Input mux */
+static const struct snd_kcontrol_new ak4535_input_mux_control =
+	SOC_DAPM_ENUM("Input Select", ak4535_enum[0]);
+
+/* HP L switch */
+static const struct snd_kcontrol_new ak4535_hpl_control =
+	SOC_DAPM_SINGLE("Switch", AK4535_SIG2, 1, 1, 1);
+
+/* HP R switch */
+static const struct snd_kcontrol_new ak4535_hpr_control =
+	SOC_DAPM_SINGLE("Switch", AK4535_SIG2, 0, 1, 1);
+
+/* Speaker switch */
+static const struct snd_kcontrol_new ak4535_spk_control =
+	SOC_DAPM_SINGLE("Switch", AK4535_MODE2, 0, 0, 0);
+
+/* mono 2 switch */
+static const struct snd_kcontrol_new ak4535_mono2_control =
+	SOC_DAPM_SINGLE("Switch", AK4535_SIG1, 0, 1, 0);
+
+/* Line out switch */
+static const struct snd_kcontrol_new ak4535_line_control =
+	SOC_DAPM_SINGLE("Switch", AK4535_SIG2, 6, 1, 0);
+
+/* ak4535 dapm widgets */
+static const struct snd_soc_dapm_widget ak4535_dapm_widgets[] = {
+	SND_SOC_DAPM_MIXER("Stereo Mixer", SND_SOC_NOPM, 0, 0,
+		&ak4535_stereo_mixer_controls[0],
+		ARRAY_SIZE(ak4535_stereo_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Mono1 Mixer", SND_SOC_NOPM, 0, 0,
+		&ak4535_mono1_mixer_controls[0],
+		ARRAY_SIZE(ak4535_mono1_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Input Mixer", SND_SOC_NOPM, 0, 0,
+		&ak4535_input_mixer_controls[0],
+		ARRAY_SIZE(ak4535_mono1_mixer_controls)),
+	SND_SOC_DAPM_MUX("Input Mux", SND_SOC_NOPM, 0, 0,
+		&ak4535_input_mux_control),
+	SND_SOC_DAPM_DAC("DAC", "Playback", AK4535_PM2, 0, 0),
+	SND_SOC_DAPM_SWITCH("Mono 2 Enable", SND_SOC_NOPM, 0, 0,
+		&ak4535_mono2_control),
+	SND_SOC_DAPM_SWITCH("Speaker Enable", SND_SOC_NOPM, 0, 0,
+		&ak4535_spk_control),
+	SND_SOC_DAPM_SWITCH("Line Out Enable", SND_SOC_NOPM, 0, 0,
+		&ak4535_line_control),
+	SND_SOC_DAPM_SWITCH("Left HP Enable", SND_SOC_NOPM, 0, 0,
+		&ak4535_hpl_control),
+	SND_SOC_DAPM_SWITCH("Right HP Enable", SND_SOC_NOPM, 0, 0,
+		&ak4535_hpr_control),
+	SND_SOC_DAPM_OUTPUT("LOUT"),
+	SND_SOC_DAPM_OUTPUT("HPL"),
+	SND_SOC_DAPM_OUTPUT("ROUT"),
+	SND_SOC_DAPM_OUTPUT("HPR"),
+	SND_SOC_DAPM_OUTPUT("SPP"),
+	SND_SOC_DAPM_OUTPUT("SPN"),
+	SND_SOC_DAPM_OUTPUT("MOUT1"),
+	SND_SOC_DAPM_OUTPUT("MOUT2"),
+	SND_SOC_DAPM_OUTPUT("MICOUT"),
+	SND_SOC_DAPM_ADC("ADC", "Capture", AK4535_PM1, 0, 1),
+	SND_SOC_DAPM_PGA("Spk Amp", AK4535_PM2, 3, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HP R Amp", AK4535_PM2, 1, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HP L Amp", AK4535_PM2, 2, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic", AK4535_PM1, 1, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Line Out", AK4535_PM1, 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mono Out", AK4535_PM1, 3, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("AUX In", AK4535_PM1, 2, 0, NULL, 0),
+
+	SND_SOC_DAPM_MICBIAS("Mic Int Bias", AK4535_MIC, 3, 0),
+	SND_SOC_DAPM_MICBIAS("Mic Ext Bias", AK4535_MIC, 4, 0),
+	SND_SOC_DAPM_INPUT("MICIN"),
+	SND_SOC_DAPM_INPUT("MICEXT"),
+	SND_SOC_DAPM_INPUT("AUX"),
+	SND_SOC_DAPM_INPUT("MIN"),
+	SND_SOC_DAPM_INPUT("AIN"),
+};
+
+static const char *audio_map[][3] = {
+	/*stereo mixer */
+	{"Stereo Mixer", "Playback Switch", "DAC"},
+	{"Stereo Mixer", "Mic Sidetone Switch", "Mic"},
+	{"Stereo Mixer", "Aux Bypass Switch", "AUX In"},
+
+	/* mono1 mixer */
+	{"Mono1 Mixer", "Mic Sidetone Switch", "Mic"},
+	{"Mono1 Mixer", "Mono Playback Switch", "DAC"},
+
+	/* mono2 mixer */
+	{"Mono2 Mixer", "Mono Playback Switch", "Stereo Mixer"},
+
+	/* Mic */
+	{"AIN", NULL, "Mic"},
+	{"Input Mux", "Internal", "Mic Int Bias"},
+	{"Input Mux", "External", "Mic Ext Bias"},
+	{"Mic Int Bias", NULL, "MICIN"},
+	{"Mic Ext Bias", NULL, "MICEXT"},
+	{"MICOUT", NULL, "Input Mux"},
+
+	/* line out */
+	{"LOUT", "Switch", "Line"},
+	{"ROUT", "Switch", "Line Out Enable"},
+	{"Line Out Enable", NULL, "Line Out"},
+	{"Line Out", NULL, "Stereo Mixer"},
+
+	/* mono1 out */
+	{"MOUT1", NULL, "Mono Out"},
+	{"Mono Out", NULL, "Mono Mixer"},
+
+	/* left HP */
+	{"HPL", "Switch", "Left HP Enable"},
+	{"Left HP Enable", NULL, "HP L Amp"},
+	{"HP L Amp", NULL, "Stereo Mixer"},
+
+	/* right HP */
+	{"HPR", "Switch", "Right HP Enable"},
+	{"Right HP Enable", NULL, "HP R Amp"},
+	{"HP R Amp", NULL, "Stereo Mixer"},
+
+	/* speaker */
+	{"SPP", "Switch", "Speaker Enable"},
+	{"SPN", "Switch", "Speaker Enable"},
+	{"Speaker Enable", NULL, "Spk Amp"},
+	{"Spk Amp", NULL, "MIN"},
+
+	/* mono 2 */
+	{"MOUT2", "Switch", "Mono 2 Enable"},
+	{"Mono 2 Enable", NULL, "Stereo Mixer"},
+
+	/* Aux In */
+	{"Aux In", NULL, "AUX"},
+
+	/* ADC */
+	{"ADC", NULL, "Input Mixer"},
+	{"Input Mixer", "Mic Capture Switch", "Mic"},
+	{"Input Mixer", "Aux Capture Switch", "Aux In"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int ak4535_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(ak4535_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &ak4535_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static int ak4535_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u8 mode = 0, mode2;
+	int bfs;
+
+	mode2 = ak4535_read_reg_cache(codec, AK4535_MODE2);
+	bfs = SND_SOC_FSBW_REAL(rtd->codec_dai->dai_runtime.bfs);
+	snd_assert(bfs, return -ENODEV);
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		mode = 0x0002;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		mode = 0x0001;
+		break;
+	}
+
+	/* set fs */
+	switch (rtd->codec_dai->dai_runtime.fs) {
+	case 1024:
+		mode2 |= (0x3 << 5);
+		break;
+	case 512:
+		mode2 |= (0x2 << 5);
+		break;
+	case 256:
+		mode2 |= (0x1 << 5);
+		break;
+	}
+
+	/* bfs */
+	if (bfs == 64)
+		mode |= 0x4;
+
+	/* set rate */
+	ak4535_write(codec, AK4535_MODE1, mode);
+	ak4535_write(codec, AK4535_MODE2, mode2);
+
+	return 0;
+}
+
+static unsigned int ak4535_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	if (info->fs != 256)
+		return 0;
+
+	/* we only support 256 FS atm */
+	if (info->rate * info->fs == clk) {
+		dai->mclk = clk;
+		return clk;
+	}
+
+	return 0;
+}
+
+static int ak4535_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = ak4535_read_reg_cache(codec, AK4535_DAC) & 0xffdf;
+	if (mute)
+		ak4535_write(codec, AK4535_DAC, mute_reg);
+	else
+		ak4535_write(codec, AK4535_DAC, mute_reg | 0x20);
+	return 0;
+}
+
+static int ak4535_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+	/* vref/mid, clk and osc on, dac unmute, active */
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, dac mute, inactive */
+		ak4535_write(codec, AK4535_PM1, 0x80);
+		ak4535_write(codec, AK4535_PM2, 0x0);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, inactive */
+		ak4535_write(codec, AK4535_PM1, 0x0);
+		ak4535_write(codec, AK4535_PM2, 0x80);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai ak4535_dai = {
+	.name = "AK4535",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = ak4535_config_sysclk,
+	.digital_mute = ak4535_mute,
+	.ops = {
+		.prepare = ak4535_pcm_prepare,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(ak4535_modes),
+		.mode = ak4535_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(ak4535_dai);
+
+static int ak4535_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	ak4535_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int ak4535_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(ak4535_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	ak4535_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	ak4535_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the AK4535 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int ak4535_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "AK4535";
+	codec->owner = THIS_MODULE;
+	codec->read = ak4535_read_reg_cache;
+	codec->write = ak4535_write;
+	codec->dapm_event = ak4535_dapm_event;
+	codec->dai = &ak4535_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(ak4535_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(ak4535_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, ak4535_reg,
+		sizeof(u16) * ARRAY_SIZE(ak4535_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(ak4535_reg);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	ak4535_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	ak4535_add_controls(codec);
+	ak4535_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *ak4535_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+#define I2C_DRIVERID_AK4535 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver ak4535_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static int ak4535_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = ak4535_socdev;
+	struct ak4535_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		printk(KERN_ERR "failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = ak4535_init(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "failed to initialise AK4535\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int ak4535_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec* codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+
+	return 0;
+}
+
+static int ak4535_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, ak4535_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver ak4535_i2c_driver = {
+	.driver = {
+		.name = "AK4535 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_AK4535,
+	.attach_adapter = ak4535_i2c_attach,
+	.detach_client =  ak4535_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "AK4535",
+	.driver = &ak4535_i2c_driver,
+};
+#endif
+
+static int ak4535_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct ak4535_setup_data *setup;
+	struct snd_soc_codec* codec;
+	int ret = 0;
+
+	printk(KERN_INFO "AK4535 Audio Codec %s", AK4535_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	ak4535_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&ak4535_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int ak4535_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec* codec = socdev->codec;
+
+	if (codec->control_data)
+		ak4535_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&ak4535_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_ak4535 = {
+	.probe = 	ak4535_probe,
+	.remove = 	ak4535_remove,
+	.suspend = 	ak4535_suspend,
+	.resume =	ak4535_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_ak4535);
+
+MODULE_DESCRIPTION("Soc AK4535 driver");
+MODULE_AUTHOR("Richard Purdie");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/ak4535.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/ak4535.h
@@ -0,0 +1,46 @@
+/*
+ * ak4535.h  --  AK4535 Soc Audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on wm8753.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _AK4535_H
+#define _AK4535_H
+
+/* AK4535 register space */
+
+#define AK4535_PM1		0x0
+#define AK4535_PM2		0x1
+#define AK4535_SIG1		0x2
+#define AK4535_SIG2		0x3
+#define AK4535_MODE1	0x4
+#define AK4535_MODE2	0x5
+#define AK4535_DAC		0x6
+#define AK4535_MIC		0x7
+#define AK4535_TIMER	0x8
+#define AK4535_ALC1		0x9
+#define AK4535_ALC2		0xa
+#define AK4535_PGA		0xb
+#define AK4535_LATT		0xc
+#define AK4535_RATT		0xd
+#define AK4535_VOL		0xe
+#define AK4535_STATUS	0xf
+
+#define AK4535_CACHEREGNUM 	0x10
+
+struct ak4535_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai ak4535_dai;
+extern struct snd_soc_codec_device soc_codec_dev_ak4535;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/uda1380.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/uda1380.c
@@ -0,0 +1,582 @@
+/*
+ * uda1380.c - Philips UDA1380 ALSA SoC audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Modified by Richard Purdie <richard@openedhand.com> to fit into SoC
+ * codec model.
+ *
+ * Copyright (c) 2005 Giorgio Padrin <giorgio@mandarinlogiq.org>
+ * Copyright 2005 Openedhand Ltd.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/info.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "uda1380.h"
+
+#define UDA1380_VERSION "0.4"
+
+/*
+ * uda1380 register cache
+ */
+static const u16 uda1380_reg[UDA1380_CACHEREGNUM] = {
+    0x0502, 0x0000, 0x0000, 0x3f3f,
+    0x0202, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0xff00, 0x0000, 0x4800,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x8000, 0x0002, 0x0000,
+};
+
+#define UDA1380_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_CBS_CFS | \
+	 SND_SOC_DAIFMT_NB_NF)
+
+#define UDA1380_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define UDA1380_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+static struct snd_soc_dai_mode uda1380_modes[] = {
+	/* slave rates capture & playback */
+	{
+		.fmt = UDA1380_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = UDA1380_RATES,
+		.pcmdir = UDA1380_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+
+	/* slave rates playback */
+	{
+		.fmt = UDA1380_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+};
+
+/*
+ * read uda1380 register cache
+ */
+static inline unsigned int uda1380_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == UDA1380_RESET)
+		return 0;
+	if (reg >= UDA1380_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write uda1380 register cache
+ */
+static inline void uda1380_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= UDA1380_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the UDA1380 register space
+ */
+static int uda1380_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[3];
+
+	/* data is
+	 *   data[0] is register offset
+	 *   data[1] is MS byte
+	 *   data[2] is LS byte
+	 */
+	data[0] = reg;
+	data[1] = (value & 0xff00) >> 8;
+	data[2] = value & 0x00ff;
+
+	uda1380_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 3) == 3)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define uda1380_reset(c)	uda1380_write(c, UDA1380_RESET, 0)
+
+/* declarations of ALSA reg_elem_REAL controls */
+static const char *uda1380_deemp[] = {"None", "32kHz", "44.1kHz", "48kHz",
+	"96kHz"};
+static const char *uda1380_input_sel[] = {"Line", "Mic"};
+
+static const struct soc_enum uda1380_enum[] = {
+	SOC_ENUM_DOUBLE(UDA1380_DEEMP, 0, 8, 5, uda1380_deemp),
+	SOC_ENUM_SINGLE(UDA1380_ADC, 3, 2, uda1380_input_sel),
+};
+
+static const struct snd_kcontrol_new uda1380_snd_controls[] = {
+	SOC_DOUBLE("Playback Volume", UDA1380_MVOL, 0, 8, 127, 0),
+	SOC_DOUBLE("Treble Volume", UDA1380_MODE, 4, 12, 3, 0),
+	SOC_DOUBLE("Bass Volume", UDA1380_MODE, 0, 8, 15, 0),
+	SOC_ENUM("Playback De-emphasis", uda1380_enum[0]),
+	SOC_DOUBLE("Capture Volume", UDA1380_DEC, 0, 8, 127, 0),
+	SOC_DOUBLE("Line Capture Volume", UDA1380_PGA, 0, 8, 15, 0),
+	SOC_SINGLE("Mic Capture Volume", UDA1380_PGA, 8, 11, 0),
+	SOC_DOUBLE("Playback Switch", UDA1380_DEEMP, 3, 11, 1, 0),
+	SOC_SINGLE("Capture Switch", UDA1380_PGA, 15, 1, 0),
+	SOC_SINGLE("AGC Timing", UDA1380_AGC, 8, 7, 0),
+	SOC_SINGLE("AGC Target level", UDA1380_AGC, 2, 3, 1),
+	SOC_SINGLE("AGC Switch", UDA1380_AGC, 0, 1, 0),
+};
+
+/* add non dapm controls */
+static int uda1380_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(uda1380_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&uda1380_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Input mux */
+static const struct snd_kcontrol_new uda1380_input_mux_control =
+	SOC_DAPM_ENUM("Input Select", uda1380_enum[1]);
+
+static const struct snd_soc_dapm_widget uda1380_dapm_widgets[] = {
+	SND_SOC_DAPM_MUX("Input Mux", SND_SOC_NOPM, 0, 0,
+		&uda1380_input_mux_control),
+	SND_SOC_DAPM_PGA("Left PGA", UDA1380_PM, 3, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right PGA", UDA1380_PM, 1, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic LNA", UDA1380_PM, 4, 0, NULL, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", UDA1380_PM, 2, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", UDA1380_PM, 0, 0),
+	SND_SOC_DAPM_INPUT("VINM"),
+	SND_SOC_DAPM_INPUT("VINL"),
+	SND_SOC_DAPM_INPUT("VINR"),
+	SND_SOC_DAPM_MIXER("Analog Mixer", UDA1380_PM, 6, 0, NULL, 0),
+	SND_SOC_DAPM_OUTPUT("VOUTLHP"),
+	SND_SOC_DAPM_OUTPUT("VOUTRHP"),
+	SND_SOC_DAPM_OUTPUT("VOUTL"),
+	SND_SOC_DAPM_OUTPUT("VOUTR"),
+	SND_SOC_DAPM_DAC("DAC", "Playback", UDA1380_PM, 10, 0),
+	SND_SOC_DAPM_PGA("HeadPhone Driver", UDA1380_PM, 13, 0, NULL, 0),
+};
+
+static const char *audio_map[][3] = {
+
+	/* analog mixer setup is different from diagram for dapm */
+	{"HeadPhone Driver", NULL, "Analog Mixer"},
+	{"VOUTR", NULL, "Analog Mixer"},
+	{"VOUTL", NULL, "Analog Mixer"},
+	{"Analog Mixer", NULL, "VINR"},
+	{"Analog Mixer", NULL, "VINL"},
+	{"Analog Mixer", NULL, "DAC"},
+
+	/* headphone driver */
+	{"VOUTLHP", NULL, "HeadPhone Driver"},
+	{"VOUTRHP", NULL, "HeadPhone Driver"},
+
+	/* input mux */
+	{"Left ADC", NULL, "Input Mux"},
+	{"Input Mux", "Mic", "Mic LNA"},
+	{"Input Mux", "Line", "Left PGA"},
+
+	/* right input */
+	{"Right ADC", NULL, "Right PGA"},
+
+	/* inputs */
+	{"Mic LNA", NULL, "VINM"},
+	{"Left PGA", NULL, "VINL"},
+	{"Right PGA", NULL, "VINR"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int uda1380_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(uda1380_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &uda1380_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static int uda1380_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		uda1380_write(codec, UDA1380_CLK, R00_EN_DAC | R00_EN_INT | clk);
+	else
+		uda1380_write(codec, UDA1380_CLK, R00_EN_ADC | R00_EN_DEC | clk);
+
+	return 0;
+}
+
+static void uda1380_pcm_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		uda1380_write(codec, UDA1380_CLK, ~(R00_EN_DAC | R00_EN_INT) & clk);
+	else
+		uda1380_write(codec, UDA1380_CLK, ~(R00_EN_ADC | R00_EN_DEC) & clk);
+}
+
+static unsigned int uda1380_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	if(info->fs != 256)
+		return 0;
+
+	/* we only support 256 FS atm */
+	if(info->rate * info->fs == clk) {
+		dai->mclk = clk;
+		return clk;
+	}
+
+	return 0;
+}
+
+static int uda1380_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = uda1380_read_reg_cache(codec, UDA1380_DEEMP) & 0xbfff;
+	if(mute)
+		uda1380_write(codec, UDA1380_DEEMP, mute_reg | 0x4000);
+	else
+		uda1380_write(codec, UDA1380_DEEMP, mute_reg);
+	return 0;
+}
+
+static int uda1380_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	switch (event) {
+		case SNDRV_CTL_POWER_D0: /* full On */
+		case SNDRV_CTL_POWER_D1: /* partial On */
+		case SNDRV_CTL_POWER_D2: /* partial On */
+		case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+			/* everything off except internal bias */
+			uda1380_write(codec, UDA1380_PM, R02_PON_BIAS);
+			break;
+		case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+			/* everything off, inactive */
+			uda1380_write(codec, UDA1380_PM, 0x0);
+			break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai uda1380_dai = {
+	.name = "UDA1380",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = uda1380_config_sysclk,
+	.digital_mute = uda1380_mute,
+	.ops = {
+		.prepare = uda1380_pcm_prepare,
+		.shutdown = uda1380_pcm_shutdown,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(uda1380_modes),
+		.mode = uda1380_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(uda1380_dai);
+
+static int uda1380_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	uda1380_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int uda1380_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(uda1380_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	uda1380_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	uda1380_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the UDA1380 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int uda1380_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "UDA1380";
+	codec->owner = THIS_MODULE;
+	codec->read = uda1380_read_reg_cache;
+	codec->write = uda1380_write;
+	codec->dapm_event = uda1380_dapm_event;
+	codec->dai = &uda1380_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(uda1380_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(uda1380_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, uda1380_reg,
+		sizeof(u16) * ARRAY_SIZE(uda1380_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(uda1380_reg);
+	uda1380_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	uda1380_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	uda1380_write(codec, UDA1380_CLK, 0);
+
+	/* uda1380 init */
+	uda1380_add_controls(codec);
+	uda1380_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if(ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *uda1380_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+#define I2C_DRIVERID_UDA1380 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver uda1380_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int uda1380_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = uda1380_socdev;
+	struct uda1380_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if(ret < 0) {
+		printk(KERN_ERR "failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = uda1380_init(socdev);
+	if(ret < 0) {
+		printk(KERN_ERR "failed to initialise UDA1380\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int uda1380_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec* codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int uda1380_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, uda1380_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver uda1380_i2c_driver = {
+	.driver = {
+		.name =  "UDA1380 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_UDA1380,
+	.attach_adapter = uda1380_i2c_attach,
+	.detach_client =  uda1380_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "UDA1380",
+	.driver = &uda1380_i2c_driver,
+};
+#endif
+
+static int uda1380_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct uda1380_setup_data *setup;
+	struct snd_soc_codec* codec;
+	int ret = 0;
+
+	printk(KERN_INFO "UDA1380 Audio Codec %s", UDA1380_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	uda1380_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&uda1380_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int uda1380_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec* codec = socdev->codec;
+
+	if (codec->control_data)
+		uda1380_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&uda1380_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_uda1380 = {
+	.probe = 	uda1380_probe,
+	.remove = 	uda1380_remove,
+	.suspend = 	uda1380_suspend,
+	.resume =	uda1380_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_uda1380);
+
+MODULE_AUTHOR("Giorgio Padrin");
+MODULE_DESCRIPTION("Audio support for codec Philips UDA1380");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/uda1380.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/uda1380.h
@@ -0,0 +1,56 @@
+/*
+ * Audio support for Philips UDA1380
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) 2005 Giorgio Padrin <giorgio@mandarinlogiq.org>
+ */
+
+#define UDA1380_CLK		0x00
+#define UDA1380_IFACE	0x01
+#define UDA1380_PM		0x02
+#define UDA1380_AMIX	0x03
+#define UDA1380_HP		0x04
+#define UDA1380_MVOL	0x10
+#define UDA1380_MIXVOL	0x11
+#define UDA1380_MODE	0x12
+#define UDA1380_DEEMP	0x13
+#define UDA1380_MIXER	0x14
+#define UDA1380_INTSTAT	0x18
+#define UDA1380_DEC		0x20
+#define UDA1380_PGA		0x21
+#define UDA1380_ADC		0x22
+#define UDA1380_AGC		0x23
+#define UDA1380_DECSTAT	0x28
+#define UDA1380_RESET	0x7f
+
+#define UDA1380_CACHEREGNUM 0x24
+
+/* Register flags */
+#define R00_EN_ADC	0x0800
+#define R00_EN_DEC	0x0400
+#define R00_EN_DAC	0x0200
+#define R00_EN_INT	0x0100
+#define R02_PON_HP	0x2000
+#define R02_PON_DAC	0x0400
+#define R02_PON_BIAS	0x0100
+#define R02_PON_LNA	0x0010
+#define R02_PON_PGAL	0x0008
+#define R02_PON_ADCL	0x0004
+#define R02_PON_PGAR	0x0002
+#define R02_PON_ADCR	0x0001
+#define R13_MTM		0x4000
+#define R21_MT_ADC	0x8000
+#define R22_SEL_LNA	0x0008
+#define R22_SEL_MIC	0x0004
+#define R22_SKIP_DCFIL	0x0002
+#define R23_AGC_EN	0x0001
+
+struct uda1380_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai uda1380_dai;
+extern struct snd_soc_codec_device soc_codec_dev_uda1380;
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8731.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8731.c
@@ -0,0 +1,886 @@
+/*
+ * wm8731.c  --  WM8731 ALSA SoC Audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on wm8753.c by Liam Girdwood
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8731.h"
+
+#define AUDIO_NAME "wm8731"
+#define WM8731_VERSION "0.12"
+
+/*
+ * Debug
+ */
+
+#define WM8731_DEBUG 0
+
+#ifdef WM8731_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+struct snd_soc_codec_device soc_codec_dev_wm8731;
+
+/*
+ * wm8731 register cache
+ * We can't read the WM8731 register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ * There is no point in caching the reset register
+ */
+static const u16 wm8731_reg[WM8731_CACHEREGNUM] = {
+    0x0097, 0x0097, 0x0079, 0x0079,
+    0x000a, 0x0008, 0x009f, 0x000a,
+    0x0000, 0x0000
+};
+
+#define WM8731_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF)
+
+#define WM8731_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8731_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define WM8731_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_mode wm8731_modes[] = {
+	/* codec frame and clock master modes */
+	/* 8k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 1536,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 2304,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 1408,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 2112,
+		.bfs = 64,
+	},
+
+	/* 32k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 576,
+		.bfs = 64,
+	},
+
+	/* 44.1k & 48k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+
+	/* 88.2 & 96k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 128,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 192,
+		.bfs = 64,
+	},
+
+	/* USB codec frame and clock master modes */
+	/* 8k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1500,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 44.1k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 272,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 48k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 250,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 88.2k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 136,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 96k */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 125,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8731_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8731_HIFI_BITS,
+		.pcmrate = WM8731_RATES,
+		.pcmdir = WM8731_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8731 register cache
+ */
+static inline unsigned int wm8731_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == WM8731_RESET)
+		return 0;
+	if (reg >= WM8731_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8731 register cache
+ */
+static inline void wm8731_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= WM8731_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8731 register space
+ */
+static int wm8731_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8731 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8731_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8731_reset(c)	wm8731_write(c, WM8731_RESET, 0)
+
+static const char *wm8731_input_select[] = {"Line In", "Mic"};
+static const char *wm8731_deemph[] = {"None", "32Khz", "44.1Khz", "48Khz"};
+
+static const struct soc_enum wm8731_enum[] = {
+	SOC_ENUM_SINGLE(WM8731_APANA, 2, 2, wm8731_input_select),
+	SOC_ENUM_SINGLE(WM8731_APDIGI, 1, 4, wm8731_deemph),
+};
+
+static const struct snd_kcontrol_new wm8731_snd_controls[] = {
+
+SOC_DOUBLE_R("Master Playback Volume", WM8731_LOUT1V, WM8731_ROUT1V,
+	0, 127, 0),
+SOC_DOUBLE_R("Master Playback ZC Switch", WM8731_LOUT1V, WM8731_ROUT1V,
+	7, 1, 0),
+
+SOC_DOUBLE_R("Capture Volume", WM8731_LINVOL, WM8731_RINVOL, 0, 31, 0),
+SOC_DOUBLE_R("Line Capture Switch", WM8731_LINVOL, WM8731_RINVOL, 7, 1, 1),
+
+SOC_SINGLE("Mic Boost (+20dB)", WM8731_APANA, 0, 1, 0),
+SOC_SINGLE("Capture Mic Switch", WM8731_APANA, 1, 1, 1),
+
+SOC_SINGLE("Sidetone Playback Volume", WM8731_APANA, 6, 3, 1),
+
+SOC_SINGLE("ADC High Pass Filter Switch", WM8731_APDIGI, 0, 1, 1),
+SOC_SINGLE("Store DC Offset Switch", WM8731_APDIGI, 4, 1, 0),
+
+SOC_ENUM("Playback De-emphasis", wm8731_enum[1]),
+};
+
+/* add non dapm controls */
+static int wm8731_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8731_snd_controls); i++) {
+		if ((err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8731_snd_controls[i],codec, NULL))) < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Output Mixer */
+static const struct snd_kcontrol_new wm8731_output_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8731_APANA, 3, 1, 0),
+SOC_DAPM_SINGLE("Mic Sidetone Switch", WM8731_APANA, 5, 1, 0),
+SOC_DAPM_SINGLE("HiFi Playback Switch", WM8731_APANA, 4, 1, 0),
+};
+
+/* Input mux */
+static const struct snd_kcontrol_new wm8731_input_mux_controls =
+SOC_DAPM_ENUM("Input Select", wm8731_enum[0]);
+
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+SND_SOC_DAPM_MIXER("Output Mixer", WM8731_PWR, 4, 1,
+	&wm8731_output_mixer_controls[0],
+	ARRAY_SIZE(wm8731_output_mixer_controls)),
+SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8731_PWR, 3, 1),
+SND_SOC_DAPM_OUTPUT("LOUT"),
+SND_SOC_DAPM_OUTPUT("LHPOUT"),
+SND_SOC_DAPM_OUTPUT("ROUT"),
+SND_SOC_DAPM_OUTPUT("RHPOUT"),
+SND_SOC_DAPM_ADC("ADC", "HiFi Capture", WM8731_PWR, 2, 1),
+SND_SOC_DAPM_MUX("Input Mux", SND_SOC_NOPM, 0, 0, &wm8731_input_mux_controls),
+SND_SOC_DAPM_PGA("Line Input", WM8731_PWR, 0, 1, NULL, 0),
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8731_PWR, 1, 1),
+SND_SOC_DAPM_INPUT("MICIN"),
+SND_SOC_DAPM_INPUT("RLINEIN"),
+SND_SOC_DAPM_INPUT("LLINEIN"),
+};
+
+static const char *intercon[][3] = {
+	/* output mixer */
+	{"Output Mixer", "Line Bypass Switch", "Line Input"},
+	{"Output Mixer", "HiFi Playback Switch", "DAC"},
+	{"Output Mixer", "Mic Sidetone Switch", "Mic Bias"},
+
+	/* outputs */
+	{"RHPOUT", NULL, "Output Mixer"},
+	{"ROUT", NULL, "Output Mixer"},
+	{"LHPOUT", NULL, "Output Mixer"},
+	{"LOUT", NULL, "Output Mixer"},
+
+	/* input mux */
+	{"Input Mux", "Line In", "Line Input"},
+	{"Input Mux", "Mic", "Mic Bias"},
+	{"ADC", NULL, "Input Mux"},
+
+	/* inputs */
+	{"Line Input", NULL, "LLINEIN"},
+	{"Line Input", NULL, "RLINEIN"},
+	{"Mic Bias", NULL, "MICIN"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8731_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8731_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8731_dapm_widgets[i]);
+	}
+
+	/* set up audio path interconnects */
+	for(i = 0; intercon[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, intercon[i][0],
+			intercon[i][1], intercon[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:4;
+	u8 bosr:1;
+	u8 usb:1;
+};
+
+/* codec mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 48k */
+	{12288000, 48000, 256, 0x0, 0x0, 0x0},
+	{18432000, 48000, 384, 0x0, 0x1, 0x0},
+	{12000000, 48000, 250, 0x0, 0x0, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0x6, 0x0, 0x0},
+	{18432000, 32000, 576, 0x6, 0x1, 0x0},
+
+	/* 8k */
+	{12288000, 8000, 1536, 0x3, 0x0, 0x0},
+	{18432000, 8000, 2304, 0x3, 0x1, 0x0},
+	{11289600, 8000, 1408, 0xb, 0x0, 0x0},
+	{16934400, 8000, 2112, 0xb, 0x1, 0x0},
+	{12000000, 8000, 1500, 0x3, 0x0, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0x7, 0x0, 0x0},
+	{18432000, 96000, 192, 0x7, 0x1, 0x0},
+	{12000000, 96000, 125, 0x7, 0x0, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x8, 0x0, 0x0},
+	{16934400, 44100, 384, 0x8, 0x1, 0x0},
+	{12000000, 44100, 272, 0x8, 0x1, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0xf, 0x0, 0x0},
+	{16934400, 88200, 192, 0xf, 0x1, 0x0},
+	{12000000, 88200, 136, 0xf, 0x1, 0x1},
+};
+
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+	return 0;
+}
+
+/* WM8731 supports numerous clocks per sample rate */
+static unsigned int wm8731_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	dai->mclk = 0;
+
+	/* check that the calculated FS and rate actually match a clock from
+	 * the machine driver */
+	if (info->fs * info->rate == clk)
+		dai->mclk = clk;
+
+	return dai->mclk;
+}
+
+static int wm8731_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 iface = 0, srate;
+	int i = get_coeff(rtd->codec_dai->mclk,
+		snd_soc_get_rate(rtd->codec_dai->dai_runtime.pcmrate));
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+	srate = (coeff_div[i].sr << 2) |
+		(coeff_div[i].bosr << 1) | coeff_div[i].usb;
+	wm8731_write(codec, WM8731_SRATE, srate);
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		iface |= 0x0004;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		iface |= 0x0008;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		iface |= 0x000c;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	}
+
+	/* set iface */
+	wm8731_write(codec, WM8731_IFACE, iface);
+
+	/* set active */
+	wm8731_write(codec, WM8731_ACTIVE, 0x0001);
+	return 0;
+}
+
+static void wm8731_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	/* deactivate */
+	if (!codec->active) {
+		udelay(50);
+		wm8731_write(codec, WM8731_ACTIVE, 0x0);
+	}
+}
+
+static int wm8731_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8731_read_reg_cache(codec, WM8731_APDIGI) & 0xfff7;
+	if (mute)
+		wm8731_write(codec, WM8731_APDIGI, mute_reg | 0x8);
+	else
+		wm8731_write(codec, WM8731_APDIGI, mute_reg);
+	return 0;
+}
+
+static int wm8731_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 reg = wm8731_read_reg_cache(codec, WM8731_PWR) & 0xff7f;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* vref/mid, osc on, dac unmute */
+		wm8731_write(codec, WM8731_PWR, reg);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, */
+		wm8731_write(codec, WM8731_PWR, reg | 0x0040);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, dac mute, inactive */
+		wm8731_write(codec, WM8731_ACTIVE, 0x0);
+		wm8731_write(codec, WM8731_PWR, 0xffff);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8731_dai = {
+	.name = "WM8731",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = wm8731_config_sysclk,
+	.digital_mute = wm8731_mute,
+	.ops = {
+		.prepare = wm8731_pcm_prepare,
+		.shutdown = wm8731_shutdown,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8731_modes),
+		.mode = wm8731_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8731_dai);
+
+static int wm8731_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8731_write(codec, WM8731_ACTIVE, 0x0);
+	wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8731_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8731_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8731_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8731 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8731_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8731";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8731_read_reg_cache;
+	codec->write = wm8731_write;
+	codec->dapm_event = wm8731_dapm_event;
+	codec->dai = &wm8731_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8731_reg);
+
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8731_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache,
+		wm8731_reg, sizeof(u16) * ARRAY_SIZE(wm8731_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8731_reg);
+
+	wm8731_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* set the update bits */
+	reg = wm8731_read_reg_cache(codec, WM8731_LOUT1V);
+	wm8731_write(codec, WM8731_LOUT1V, reg | 0x0100);
+	reg = wm8731_read_reg_cache(codec, WM8731_ROUT1V);
+	wm8731_write(codec, WM8731_ROUT1V, reg | 0x0100);
+	reg = wm8731_read_reg_cache(codec, WM8731_LINVOL);
+	wm8731_write(codec, WM8731_LINVOL, reg | 0x0100);
+	reg = wm8731_read_reg_cache(codec, WM8731_RINVOL);
+	wm8731_write(codec, WM8731_RINVOL, reg | 0x0100);
+
+	wm8731_add_controls(codec);
+	wm8731_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *wm8731_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8731 2 wire address is determined by GPIO5
+ * state during powerup.
+ *    low  = 0x1a
+ *    high = 0x1b
+ */
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8731_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int wm8731_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8731_socdev;
+	struct wm8731_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8731_init(socdev);
+	if (ret < 0) {
+		err("failed to initialise WM8731\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8731_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec* codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8731_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8731_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8731_i2c_driver = {
+	.driver = {
+		.name = "WM8731 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8731,
+	.attach_adapter = wm8731_i2c_attach,
+	.detach_client =  wm8731_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8731",
+	.driver = &wm8731_i2c_driver,
+};
+#endif
+
+static int wm8731_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8731_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8731 Audio Codec %s", WM8731_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8731_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8731_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8731_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8731_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8731 = {
+	.probe = 	wm8731_probe,
+	.remove = 	wm8731_remove,
+	.suspend = 	wm8731_suspend,
+	.resume =	wm8731_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8731);
+
+MODULE_DESCRIPTION("ASoC WM8731 driver");
+MODULE_AUTHOR("Richard Purdie");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8731.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8731.h
@@ -0,0 +1,41 @@
+/*
+ * wm8731.h  --  WM8731 Soc Audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on wm8753.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8731_H
+#define _WM8731_H
+
+/* WM8731 register space */
+
+#define WM8731_LINVOL   0x00
+#define WM8731_RINVOL   0x01
+#define WM8731_LOUT1V   0x02
+#define WM8731_ROUT1V   0x03
+#define WM8731_APANA    0x04
+#define WM8731_APDIGI   0x05
+#define WM8731_PWR      0x06
+#define WM8731_IFACE    0x07
+#define WM8731_SRATE    0x08
+#define WM8731_ACTIVE   0x09
+#define WM8731_RESET	0x0f
+
+#define WM8731_CACHEREGNUM 	10
+
+struct wm8731_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8731_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8731;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8750.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8750.c
@@ -0,0 +1,1282 @@
+/*
+ * wm8750.c -- WM8750 ALSA SoC audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on WM8753.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8750.h"
+
+#define AUDIO_NAME "WM8750"
+#define WM8750_VERSION "0.11"
+
+/*
+ * Debug
+ */
+
+#define WM8750_DEBUG 0
+
+#ifdef WM8750_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+static struct workqueue_struct *wm8750_workq = NULL;
+static struct work_struct wm8750_dapm_work;
+
+/*
+ * wm8750 register cache
+ * We can't read the WM8750 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8750_reg[] = {
+	0x0097, 0x0097, 0x0079, 0x0079,  /*  0 */
+	0x0000, 0x0008, 0x0000, 0x000a,  /*  4 */
+	0x0000, 0x0000, 0x00ff, 0x00ff,  /*  8 */
+	0x000f, 0x000f, 0x0000, 0x0000,  /* 12 */
+	0x0000, 0x007b, 0x0000, 0x0032,  /* 16 */
+	0x0000, 0x00c3, 0x00c3, 0x00c0,  /* 20 */
+	0x0000, 0x0000, 0x0000, 0x0000,  /* 24 */
+	0x0000, 0x0000, 0x0000, 0x0000,  /* 28 */
+	0x0000, 0x0000, 0x0050, 0x0050,  /* 32 */
+	0x0050, 0x0050, 0x0050, 0x0050,  /* 36 */
+	0x0079, 0x0079, 0x0079,          /* 40 */
+};
+
+#define WM8750_HIFI_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF)
+
+#define WM8750_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8750_HIFI_FSB \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | \
+	SND_SOC_FSBD(8) | SND_SOC_FSBD(16))
+
+#define WM8750_HIFI_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define WM8750_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_mode wm8750_modes[] = {
+	/* common codec frame and clock master modes */
+	/* 8k */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1536,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1408,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 2304,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 2112,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1500,
+		.bfs = WM8750_HIFI_FSB,
+	},
+
+	/* 11.025k */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1024,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1536,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1088,
+		.bfs = WM8750_HIFI_FSB,
+	},
+
+	/* 16k */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 768,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1152,
+		.bfs = WM8750_HIFI_FSB
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 750,
+		.bfs = WM8750_HIFI_FSB,
+	},
+
+	/* 22.05k */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 512,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 768,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 544,
+		.bfs = WM8750_HIFI_FSB,
+	},
+
+	/* 32k */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 384,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 576,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 375,
+		.bfs = WM8750_HIFI_FSB,
+	},
+
+	/* 44.1k & 48k */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 384,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 272,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 250,
+		.bfs = WM8750_HIFI_FSB,
+	},
+
+	/* 88.2k & 96k */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 128,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 192,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 136,
+		.bfs = WM8750_HIFI_FSB,
+	},
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 125,
+		.bfs = WM8750_HIFI_FSB,
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8750_HIFI_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8750_HIFI_BITS,
+		.pcmrate = WM8750_HIFI_RATES,
+		.pcmdir = WM8750_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8750 register cache
+ */
+static inline unsigned int wm8750_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg > WM8750_CACHE_REGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8750 register cache
+ */
+static inline void wm8750_write_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg > WM8750_CACHE_REGNUM)
+		return;
+	cache[reg] = value;
+}
+
+static int wm8750_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8753 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8750_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8750_reset(c)	wm8750_write(c, WM8750_RESET, 0)
+
+/*
+ * WM8750 Controls
+ */
+static const char *wm8750_bass[] = {"Linear Control", "Adaptive Boost"};
+static const char *wm8750_bass_filter[] = { "130Hz @ 48kHz", "200Hz @ 48kHz" };
+static const char *wm8750_treble[] = {"8kHz", "4kHz"};
+static const char *wm8750_3d_lc[] = {"200Hz", "500Hz"};
+static const char *wm8750_3d_uc[] = {"2.2kHz", "1.5kHz"};
+static const char *wm8750_3d_func[] = {"Capture", "Playback"};
+static const char *wm8750_alc_func[] = {"Off", "Right", "Left", "Stereo"};
+static const char *wm8750_ng_type[] = {"Constant PGA Gain",
+	"Mute ADC Output"};
+static const char *wm8750_line_mux[] = {"Line 1", "Line 2", "Line 3", "PGA",
+	"Differential"};
+static const char *wm8750_pga_sel[] = {"Line 1", "Line 2", "Line 3",
+	"Differential"};
+static const char *wm8750_out3[] = {"VREF", "ROUT1 + Vol", "MonoOut",
+	"ROUT1"};
+static const char *wm8750_diff_sel[] = {"Line 1", "Line 2"};
+static const char *wm8750_adcpol[] = {"Normal", "L Invert", "R Invert",
+	"L + R Invert"};
+static const char *wm8750_deemph[] = {"None", "32Khz", "44.1Khz", "48Khz"};
+static const char *wm8750_mono_mux[] = {"Stereo", "Mono (Left)",
+	"Mono (Right)", "Digital Mono"};
+
+static const struct soc_enum wm8750_enum[] = {
+SOC_ENUM_SINGLE(WM8750_BASS, 7, 2, wm8750_bass),
+SOC_ENUM_SINGLE(WM8750_BASS, 6, 2, wm8750_bass_filter),
+SOC_ENUM_SINGLE(WM8750_TREBLE, 6, 2, wm8750_treble),
+SOC_ENUM_SINGLE(WM8750_3D, 5, 2, wm8750_3d_lc),
+SOC_ENUM_SINGLE(WM8750_3D, 6, 2, wm8750_3d_uc),
+SOC_ENUM_SINGLE(WM8750_3D, 7, 2, wm8750_3d_func),
+SOC_ENUM_SINGLE(WM8750_ALC1, 7, 4, wm8750_alc_func),
+SOC_ENUM_SINGLE(WM8750_NGATE, 1, 2, wm8750_ng_type),
+SOC_ENUM_SINGLE(WM8750_LOUTM1, 0, 5, wm8750_line_mux),
+SOC_ENUM_SINGLE(WM8750_ROUTM1, 0, 5, wm8750_line_mux),
+SOC_ENUM_SINGLE(WM8750_LADCIN, 6, 4, wm8750_pga_sel), /* 10 */
+SOC_ENUM_SINGLE(WM8750_RADCIN, 6, 4, wm8750_pga_sel),
+SOC_ENUM_SINGLE(WM8750_ADCTL2, 7, 4, wm8750_out3),
+SOC_ENUM_SINGLE(WM8750_ADCIN, 8, 2, wm8750_diff_sel),
+SOC_ENUM_SINGLE(WM8750_ADCDAC, 5, 4, wm8750_adcpol),
+SOC_ENUM_SINGLE(WM8750_ADCDAC, 1, 4, wm8750_deemph),
+SOC_ENUM_SINGLE(WM8750_ADCIN, 6, 4, wm8750_mono_mux), /* 16 */
+
+};
+
+static const struct snd_kcontrol_new wm8750_snd_controls[] = {
+
+SOC_DOUBLE_R("Capture Volume", WM8750_LINVOL, WM8750_RINVOL, 0, 63, 0),
+SOC_DOUBLE_R("Capture ZC Switch", WM8750_LINVOL, WM8750_RINVOL, 6, 1, 0),
+SOC_DOUBLE_R("Capture Switch", WM8750_LINVOL, WM8750_RINVOL, 7, 1, 1),
+
+SOC_DOUBLE_R("Headphone Playback ZC Switch", WM8750_LOUT1V,
+	WM8750_ROUT1V, 7, 1, 0),
+SOC_DOUBLE_R("Speaker Playback ZC Switch", WM8750_LOUT2V,
+	WM8750_ROUT2V, 7, 1, 0),
+
+SOC_ENUM("Playback De-emphasis", wm8750_enum[15]),
+
+SOC_ENUM("Capture Polarity", wm8750_enum[14]),
+SOC_SINGLE("Playback 6dB Attenuate", WM8750_ADCDAC, 7, 1, 0),
+SOC_SINGLE("Capture 6dB Attenuate", WM8750_ADCDAC, 8, 1, 0),
+
+SOC_DOUBLE_R("PCM Volume", WM8750_LDAC, WM8750_RDAC, 0, 255, 0),
+
+SOC_ENUM("Bass Boost", wm8750_enum[0]),
+SOC_ENUM("Bass Filter", wm8750_enum[1]),
+SOC_SINGLE("Bass Volume", WM8750_BASS, 0, 15, 1),
+
+SOC_SINGLE("Treble Volume", WM8750_TREBLE, 0, 15, 0),
+SOC_ENUM("Treble Cut-off", wm8750_enum[2]),
+
+SOC_SINGLE("3D Switch", WM8750_3D, 0, 1, 0),
+SOC_SINGLE("3D Volume", WM8750_3D, 1, 15, 0),
+SOC_ENUM("3D Lower Cut-off", wm8750_enum[3]),
+SOC_ENUM("3D Upper Cut-off", wm8750_enum[4]),
+SOC_ENUM("3D Mode", wm8750_enum[5]),
+
+SOC_SINGLE("ALC Capture Target Volume", WM8750_ALC1, 0, 7, 0),
+SOC_SINGLE("ALC Capture Max Volume", WM8750_ALC1, 4, 7, 0),
+SOC_ENUM("ALC Capture Function", wm8750_enum[6]),
+SOC_SINGLE("ALC Capture ZC Switch", WM8750_ALC2, 7, 1, 0),
+SOC_SINGLE("ALC Capture Hold Time", WM8750_ALC2, 0, 15, 0),
+SOC_SINGLE("ALC Capture Decay Time", WM8750_ALC3, 4, 15, 0),
+SOC_SINGLE("ALC Capture Attack Time", WM8750_ALC3, 0, 15, 0),
+SOC_SINGLE("ALC Capture NG Threshold", WM8750_NGATE, 3, 31, 0),
+SOC_ENUM("ALC Capture NG Type", wm8750_enum[4]),
+SOC_SINGLE("ALC Capture NG Switch", WM8750_NGATE, 0, 1, 0),
+
+SOC_SINGLE("Left ADC Capture Volume", WM8750_LADC, 0, 255, 0),
+SOC_SINGLE("Right ADC Capture Volume", WM8750_RADC, 0, 255, 0),
+
+SOC_SINGLE("ZC Timeout Switch", WM8750_ADCTL1, 0, 1, 0),
+SOC_SINGLE("Playback Invert Switch", WM8750_ADCTL1, 1, 1, 0),
+
+SOC_SINGLE("Right Speaker Playback Invert Switch", WM8750_ADCTL2, 4, 1, 0),
+
+/* Unimplemented */
+/* ADCDAC Bit 0 - ADCHPD */
+/* ADCDAC Bit 4 - HPOR */
+/* ADCTL1 Bit 2,3 - DATSEL */
+/* ADCTL1 Bit 4,5 - DMONOMIX */
+/* ADCTL1 Bit 6,7 - VSEL */
+/* ADCTL2 Bit 2 - LRCM */
+/* ADCTL2 Bit 3 - TRI */
+/* ADCTL3 Bit 5 - HPFLREN */
+/* ADCTL3 Bit 6 - VROI */
+/* ADCTL3 Bit 7,8 - ADCLRM */
+/* ADCIN Bit 4 - LDCM */
+/* ADCIN Bit 5 - RDCM */
+
+SOC_DOUBLE_R("Mic Boost", WM8750_LADCIN, WM8750_RADCIN, 4, 3, 0),
+
+SOC_DOUBLE_R("Bypass Left Playback Volume", WM8750_LOUTM1,
+	WM8750_LOUTM2, 4, 7, 1),
+SOC_DOUBLE_R("Bypass Right Playback Volume", WM8750_ROUTM1,
+	WM8750_ROUTM2, 4, 7, 1),
+SOC_DOUBLE_R("Bypass Mono Playback Volume", WM8750_MOUTM1,
+	WM8750_MOUTM2, 4, 7, 1),
+
+SOC_SINGLE("Mono Playback ZC Switch", WM8750_MOUTV, 7, 1, 0),
+
+SOC_DOUBLE_R("Headphone Playback Volume", WM8750_LOUT1V, WM8750_ROUT1V,
+	0, 127, 0),
+SOC_DOUBLE_R("Speaker Playback Volume", WM8750_LOUT2V, WM8750_ROUT2V,
+	0, 127, 0),
+
+SOC_SINGLE("Mono Playback Volume", WM8750_MOUTV, 0, 127, 0),
+
+};
+
+/* add non dapm controls */
+static int wm8750_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8750_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8750_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/*
+ * DAPM Controls
+ */
+
+/* Left Mixer */
+static const struct snd_kcontrol_new wm8750_left_mixer_controls[] = {
+SOC_DAPM_SINGLE("Playback Switch", WM8750_LOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8750_LOUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8750_LOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8750_LOUTM2, 7, 1, 0),
+};
+
+/* Right Mixer */
+static const struct snd_kcontrol_new wm8750_right_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left Playback Switch", WM8750_ROUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8750_ROUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Playback Switch", WM8750_ROUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8750_ROUTM2, 7, 1, 0),
+};
+
+/* Mono Mixer */
+static const struct snd_kcontrol_new wm8750_mono_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left Playback Switch", WM8750_MOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8750_MOUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8750_MOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8750_MOUTM2, 7, 1, 0),
+};
+
+/* Left Line Mux */
+static const struct snd_kcontrol_new wm8750_left_line_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[8]);
+
+/* Right Line Mux */
+static const struct snd_kcontrol_new wm8750_right_line_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[9]);
+
+/* Left PGA Mux */
+static const struct snd_kcontrol_new wm8750_left_pga_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[10]);
+
+/* Right PGA Mux */
+static const struct snd_kcontrol_new wm8750_right_pga_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[11]);
+
+/* Out 3 Mux */
+static const struct snd_kcontrol_new wm8750_out3_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[12]);
+
+/* Differential Mux */
+static const struct snd_kcontrol_new wm8750_diffmux_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[13]);
+
+/* Mono ADC Mux */
+static const struct snd_kcontrol_new wm8750_monomux_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[16]);
+
+static const struct snd_soc_dapm_widget wm8750_dapm_widgets[] = {
+	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
+		&wm8750_left_mixer_controls[0],
+		ARRAY_SIZE(wm8750_left_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
+		&wm8750_right_mixer_controls[0],
+		ARRAY_SIZE(wm8750_right_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Mono Mixer", WM8750_PWR2, 2, 0,
+		&wm8750_mono_mixer_controls[0],
+		ARRAY_SIZE(wm8750_mono_mixer_controls)),
+
+	SND_SOC_DAPM_PGA("Right Out 2", WM8750_PWR2, 3, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 2", WM8750_PWR2, 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Out 1", WM8750_PWR2, 5, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 1", WM8750_PWR2, 6, 0, NULL, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8750_PWR2, 7, 0),
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8750_PWR2, 8, 0),
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", WM8750_PWR1, 1, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", WM8750_PWR1, 2, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", WM8750_PWR1, 3, 0),
+
+	SND_SOC_DAPM_MUX("Left PGA Mux", WM8750_PWR1, 5, 0,
+		&wm8750_left_pga_controls),
+	SND_SOC_DAPM_MUX("Right PGA Mux", WM8750_PWR1, 4, 0,
+		&wm8750_right_pga_controls),
+	SND_SOC_DAPM_MUX("Left Line Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_left_line_controls),
+	SND_SOC_DAPM_MUX("Right Line Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_right_line_controls),
+
+	SND_SOC_DAPM_MUX("Out3 Mux", SND_SOC_NOPM, 0, 0, &wm8750_out3_controls),
+	SND_SOC_DAPM_PGA("Out 3", WM8750_PWR2, 1, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mono Out 1", WM8750_PWR2, 2, 0, NULL, 0),
+
+	SND_SOC_DAPM_MUX("Differential Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_diffmux_controls),
+	SND_SOC_DAPM_MUX("Left ADC Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_monomux_controls),
+	SND_SOC_DAPM_MUX("Right ADC Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_monomux_controls),
+
+	SND_SOC_DAPM_OUTPUT("LOUT1"),
+	SND_SOC_DAPM_OUTPUT("ROUT1"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+	SND_SOC_DAPM_OUTPUT("MONO"),
+	SND_SOC_DAPM_OUTPUT("OUT3"),
+
+	SND_SOC_DAPM_INPUT("LINPUT1"),
+	SND_SOC_DAPM_INPUT("LINPUT2"),
+	SND_SOC_DAPM_INPUT("LINPUT3"),
+	SND_SOC_DAPM_INPUT("RINPUT1"),
+	SND_SOC_DAPM_INPUT("RINPUT2"),
+	SND_SOC_DAPM_INPUT("RINPUT3"),
+};
+
+static const char *audio_map[][3] = {
+	/* left mixer */
+	{"Left Mixer", "Playback Switch", "Left DAC"},
+	{"Left Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Left Mixer", "Right Playback Switch", "Right DAC"},
+	{"Left Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* right mixer */
+	{"Right Mixer", "Left Playback Switch", "Left DAC"},
+	{"Right Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Right Mixer", "Playback Switch", "Right DAC"},
+	{"Right Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* left out 1 */
+	{"Left Out 1", NULL, "Left Mixer"},
+	{"LOUT1", NULL, "Left Out 1"},
+
+	/* left out 2 */
+	{"Left Out 2", NULL, "Left Mixer"},
+	{"LOUT2", NULL, "Left Out 2"},
+
+	/* right out 1 */
+	{"Right Out 1", NULL, "Right Mixer"},
+	{"ROUT1", NULL, "Right Out 1"},
+
+	/* right out 2 */
+	{"Right Out 2", NULL, "Right Mixer"},
+	{"ROUT2", NULL, "Right Out 2"},
+
+	/* mono mixer */
+	{"Mono Mixer", "Left Playback Switch", "Left DAC"},
+	{"Mono Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Mono Mixer", "Right Playback Switch", "Right DAC"},
+	{"Mono Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* mono out */
+	{"Mono Out 1", NULL, "Mono Mixer"},
+	{"MONO1", NULL, "Mono Out 1"},
+
+	/* out 3 */
+	{"Out3 Mux", "VREF", "VREF"},
+	{"Out3 Mux", "ROUT1 + Vol", "ROUT1"},
+	{"Out3 Mux", "ROUT1", "Right Mixer"},
+	{"Out3 Mux", "MonoOut", "MONO1"},
+	{"Out 3", NULL, "Out3 Mux"},
+	{"OUT3", NULL, "Out 3"},
+
+	/* Left Line Mux */
+	{"Left Line Mux", "Line 1", "LINPUT1"},
+	{"Left Line Mux", "Line 2", "LINPUT2"},
+	{"Left Line Mux", "Line 3", "LINPUT3"},
+	{"Left Line Mux", "PGA", "Left PGA Mux"},
+	{"Left Line Mux", "Differential", "Differential Mux"},
+
+	/* Right Line Mux */
+	{"Right Line Mux", "Line 1", "RINPUT1"},
+	{"Right Line Mux", "Line 2", "RINPUT2"},
+	{"Right Line Mux", "Line 3", "RINPUT3"},
+	{"Right Line Mux", "PGA", "Right PGA Mux"},
+	{"Right Line Mux", "Differential", "Differential Mux"},
+
+	/* Left PGA Mux */
+	{"Left PGA Mux", "Line 1", "LINPUT1"},
+	{"Left PGA Mux", "Line 2", "LINPUT2"},
+	{"Left PGA Mux", "Line 3", "LINPUT3"},
+	{"Left PGA Mux", "Differential", "Differential Mux"},
+
+	/* Right PGA Mux */
+	{"Right PGA Mux", "Line 1", "RINPUT1"},
+	{"Right PGA Mux", "Line 2", "RINPUT2"},
+	{"Right PGA Mux", "Line 3", "RINPUT3"},
+	{"Right PGA Mux", "Differential", "Differential Mux"},
+
+	/* Differential Mux */
+	{"Differential Mux", "Line 1", "LINPUT1"},
+	{"Differential Mux", "Line 1", "RINPUT1"},
+	{"Differential Mux", "Line 2", "LINPUT2"},
+	{"Differential Mux", "Line 2", "RINPUT2"},
+
+	/* Left ADC Mux */
+	{"Left ADC Mux", "Stereo", "Left PGA Mux"},
+	{"Left ADC Mux", "Mono (Left)", "Left PGA Mux"},
+	{"Left ADC Mux", "Digital Mono", "Left PGA Mux"},
+
+	/* Right ADC Mux */
+	{"Right ADC Mux", "Stereo", "Right PGA Mux"},
+	{"Right ADC Mux", "Mono (Right)", "Right PGA Mux"},
+	{"Right ADC Mux", "Digital Mono", "Right PGA Mux"},
+
+	/* ADC */
+	{"Left ADC", NULL, "Left ADC Mux"},
+	{"Right ADC", NULL, "Right ADC Mux"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8750_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8750_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8750_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:5;
+	u8 usb:1;
+};
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 8k */
+	{12288000, 8000, 1536, 0x6, 0x0},
+	{11289600, 8000, 1408, 0x16, 0x0},
+	{18432000, 8000, 2304, 0x7, 0x0},
+	{16934400, 8000, 2112, 0x17, 0x0},
+	{12000000, 8000, 1500, 0x6, 0x1},
+
+	/* 11.025k */
+	{11289600, 11025, 1024, 0x18, 0x0},
+	{16934400, 11025, 1536, 0x19, 0x0},
+	{12000000, 11025, 1088, 0x19, 0x1},
+
+	/* 16k */
+	{12288000, 16000, 768, 0xa, 0x0},
+	{18432000, 16000, 1152, 0xb, 0x0},
+	{12000000, 16000, 750, 0xa, 0x1},
+
+	/* 22.05k */
+	{11289600, 22050, 512, 0x1a, 0x0},
+	{16934400, 22050, 768, 0x1b, 0x0},
+	{12000000, 22050, 544, 0x1b, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0xc, 0x0},
+	{18432000, 32000, 576, 0xd, 0x0},
+	{12000000, 32000, 375, 0xa, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x10, 0x0},
+	{16934400, 44100, 384, 0x11, 0x0},
+	{12000000, 44100, 272, 0x11, 0x1},
+
+	/* 48k */
+	{12288000, 48000, 256, 0x0, 0x0},
+	{18432000, 48000, 384, 0x1, 0x0},
+	{12000000, 48000, 250, 0x0, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0x1e, 0x0},
+	{16934400, 88200, 192, 0x1f, 0x0},
+	{12000000, 88200, 136, 0x1f, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0xe, 0x0},
+	{18432000, 96000, 192, 0xf, 0x0},
+	{12000000, 96000, 125, 0xe, 0x1},
+};
+
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+
+	printk(KERN_ERR "wm8750: could not get coeff for mclk %d @ rate %d\n",
+		mclk, rate);
+	return -EINVAL;
+}
+
+/* WM8750 supports numerous input clocks per sample rate */
+static unsigned int wm8750_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	dai->mclk = clk;
+	return dai->mclk;
+}
+
+static int wm8750_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 iface = 0, bfs, srate = 0;
+	int i = get_coeff(rtd->codec_dai->mclk,
+		snd_soc_get_rate(rtd->codec_dai->dai_runtime.pcmrate));
+
+	/* is coefficient valid ? */
+	if (i < 0)
+		return i;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface = 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		iface |= 0x0004;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		iface |= 0x0008;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		iface |= 0x000c;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	}
+
+	/* set bclk divisor rate */
+	switch (bfs) {
+	case 1:
+		break;
+	case 4:
+		srate |= (0x1 << 7);
+		break;
+	case 8:
+		srate |= (0x2 << 7);
+		break;
+	case 16:
+		srate |= (0x3 << 7);
+		break;
+	}
+
+	/* set iface & srate */
+	wm8750_write(codec, WM8750_IFACE, iface);
+	wm8750_write(codec, WM8750_SRATE, srate |
+		(coeff_div[i].sr << 1) | coeff_div[i].usb);
+
+	return 0;
+}
+
+static int wm8750_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8750_read_reg_cache(codec, WM8750_ADCDAC) & 0xfff7;
+	if (mute)
+		wm8750_write(codec, WM8750_ADCDAC, mute_reg | 0x8);
+	else
+		wm8750_write(codec, WM8750_ADCDAC, mute_reg);
+	return 0;
+}
+
+static int wm8750_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 pwr_reg = wm8750_read_reg_cache(codec, WM8750_PWR1) & 0xfe3e;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* set vmid to 50k and unmute dac */
+		wm8750_write(codec, WM8750_PWR1, pwr_reg | 0x00c0);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		/* set vmid to 5k for quick power up */
+		wm8750_write(codec, WM8750_PWR1, pwr_reg | 0x01c1);
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* mute dac and set vmid to 500k, enable VREF */
+		wm8750_write(codec, WM8750_PWR1, pwr_reg | 0x0141);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		wm8750_write(codec, WM8750_PWR1, 0x0001);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8750_dai = {
+	.name = "WM8750",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = wm8750_config_sysclk,
+	.digital_mute = wm8750_mute,
+	.ops = {
+		.prepare = wm8750_pcm_prepare,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8750_modes),
+		.mode = wm8750_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8750_dai);
+
+static void wm8750_work(void *data)
+{
+	struct snd_soc_codec *codec = (struct snd_soc_codec *)data;
+	wm8750_dapm_event(codec, codec->dapm_state);
+}
+
+static int wm8750_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8750_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8750_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8750_reg); i++) {
+		if (i == WM8750_RESET)
+			continue;
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+
+	wm8750_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* charge wm8750 caps */
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0) {
+		wm8750_dapm_event(codec, SNDRV_CTL_POWER_D2);
+		codec->dapm_state = SNDRV_CTL_POWER_D0;
+		queue_delayed_work(wm8750_workq, &wm8750_dapm_work,
+			 msecs_to_jiffies(1000));
+	}
+
+	return 0;
+}
+
+/*
+ * initialise the WM8750 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8750_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8750";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8750_read_reg_cache;
+	codec->write = wm8750_write;
+	codec->dapm_event = wm8750_dapm_event;
+	codec->dai = &wm8750_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8750_reg);
+
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8750_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8750_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8750_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8750_reg);
+
+	wm8750_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* charge output caps */
+	wm8750_dapm_event(codec, SNDRV_CTL_POWER_D2);
+	codec->dapm_state = SNDRV_CTL_POWER_D3hot;
+	queue_delayed_work(wm8750_workq, &wm8750_dapm_work,
+		msecs_to_jiffies(1000));
+
+	/* set the update bits */
+	reg = wm8750_read_reg_cache(codec, WM8750_LDAC);
+	wm8750_write(codec, WM8750_LDAC, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_RDAC);
+	wm8750_write(codec, WM8750_RDAC, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_LOUT1V);
+	wm8750_write(codec, WM8750_LOUT1V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_ROUT1V);
+	wm8750_write(codec, WM8750_ROUT1V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_LOUT2V);
+	wm8750_write(codec, WM8750_LOUT2V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_ROUT2V);
+	wm8750_write(codec, WM8750_ROUT2V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_LINVOL);
+	wm8750_write(codec, WM8750_LINVOL, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_RINVOL);
+	wm8750_write(codec, WM8750_RINVOL, reg | 0x0100);
+
+	wm8750_add_controls(codec);
+	wm8750_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static struct snd_soc_device *wm8750_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8731 2 wire address is determined by GPIO5
+ * state during powerup.
+ *    low  = 0x1a
+ *    high = 0x1b
+ */
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8750_i2c_driver;
+static struct i2c_client client_template;
+
+static int wm8750_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8750_socdev;
+	struct wm8750_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8750_init(socdev);
+	if (ret < 0) {
+	err("failed to initialise WM8750\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8750_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8750_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8750_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8750_i2c_driver = {
+	.driver = {
+		.name = "WM8750 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8750,
+	.attach_adapter = wm8750_i2c_attach,
+	.detach_client =  wm8750_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8750",
+	.driver = &wm8750_i2c_driver,
+};
+#endif
+
+static int wm8750_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8750_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8750 Audio Codec %s", WM8750_VERSION);
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	wm8750_socdev = socdev;
+	INIT_WORK(&wm8750_dapm_work, wm8750_work, codec);
+	wm8750_workq = create_workqueue("wm8750");
+	if (wm8750_workq == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8750_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+		/* Add other interfaces here */
+#endif
+
+	return ret;
+}
+
+/* power down chip */
+static int wm8750_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8750_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	if (wm8750_workq)
+		destroy_workqueue(wm8750_workq);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8750_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8750 = {
+	.probe = 	wm8750_probe,
+	.remove = 	wm8750_remove,
+	.suspend = 	wm8750_suspend,
+	.resume =	wm8750_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8750);
+
+MODULE_DESCRIPTION("ASoC WM8750 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8750.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8750.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on WM8753.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _WM8750_H
+#define _WM8750_H
+
+/* WM8750 register space */
+
+#define WM8750_LINVOL    0x00
+#define WM8750_RINVOL    0x01
+#define WM8750_LOUT1V    0x02
+#define WM8750_ROUT1V    0x03
+#define WM8750_ADCDAC    0x05
+#define WM8750_IFACE     0x07
+#define WM8750_SRATE     0x08
+#define WM8750_LDAC      0x0a
+#define WM8750_RDAC      0x0b
+#define WM8750_BASS      0x0c
+#define WM8750_TREBLE    0x0d
+#define WM8750_RESET     0x0f
+#define WM8750_3D        0x10
+#define WM8750_ALC1      0x11
+#define WM8750_ALC2      0x12
+#define WM8750_ALC3      0x13
+#define WM8750_NGATE     0x14
+#define WM8750_LADC      0x15
+#define WM8750_RADC      0x16
+#define WM8750_ADCTL1    0x17
+#define WM8750_ADCTL2    0x18
+#define WM8750_PWR1      0x19
+#define WM8750_PWR2      0x1a
+#define WM8750_ADCTL3    0x1b
+#define WM8750_ADCIN     0x1f
+#define WM8750_LADCIN    0x20
+#define WM8750_RADCIN    0x21
+#define WM8750_LOUTM1    0x22
+#define WM8750_LOUTM2    0x23
+#define WM8750_ROUTM1    0x24
+#define WM8750_ROUTM2    0x25
+#define WM8750_MOUTM1    0x26
+#define WM8750_MOUTM2    0x27
+#define WM8750_LOUT2V    0x28
+#define WM8750_ROUT2V    0x29
+#define WM8750_MOUTV     0x2a
+
+#define WM8750_CACHE_REGNUM 0x2a
+
+struct wm8750_setup_data {
+	unsigned short i2c_address;
+	unsigned int mclk;
+};
+
+extern struct snd_soc_codec_dai wm8750_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8750;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8753.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8753.c
@@ -0,0 +1,2128 @@
+/*
+ * wm8753.c  --  WM8753 ALSA Soc Audio driver
+ *
+ * Copyright 2003 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * Notes:
+ *  The WM8753 is a low power, high quality stereo codec with integrated PCM
+ *  codec designed for portable digital telephony applications.
+ *
+ * Dual DAI:-
+ *
+ * This driver support 2 DAI PCM's. This makes the default PCM available for
+ * HiFi audio (e.g. MP3, ogg) playback/capture and the other PCM available for
+ * voice.
+ *
+ * Please note that the voice PCM can be connected directly to a Bluetooth
+ * codec or GSM modem and thus cannot be read or written to, although it is
+ * available to be configured with snd_hw_params(), etc and kcontrols in the
+ * normal alsa manner.
+ *
+ * Fast DAI switching:-
+ *
+ * The driver can now fast switch between the DAI configurations via a
+ * an alsa kcontrol. This allows the PCM to remain open.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8753.h"
+
+#define AUDIO_NAME "wm8753"
+#define WM8753_VERSION "0.16"
+
+/*
+ * Debug
+ */
+
+#define WM8753_DEBUG 0
+
+#ifdef WM8753_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+static int caps_charge = 2000;
+module_param(caps_charge, int, 0);
+MODULE_PARM_DESC(caps_charge, "WM8753 cap charge time (msecs)");
+
+static struct workqueue_struct *wm8753_workq = NULL;
+static struct work_struct wm8753_dapm_work;
+static void wm8753_set_dai_mode(struct snd_soc_codec *codec,
+	unsigned int mode);
+
+/*
+ * wm8753 register cache
+ * We can't read the WM8753 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8753_reg[] = {
+	0x0008, 0x0000, 0x000a, 0x000a,
+	0x0033, 0x0000, 0x0007, 0x00ff,
+	0x00ff, 0x000f, 0x000f, 0x007b,
+	0x0000, 0x0032, 0x0000, 0x00c3,
+	0x00c3, 0x00c0, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0055,
+	0x0005, 0x0050, 0x0055, 0x0050,
+	0x0055, 0x0050, 0x0055, 0x0079,
+	0x0079, 0x0079, 0x0079, 0x0079,
+	0x0000, 0x0000, 0x0000, 0x0000,
+	0x0097, 0x0097, 0x0000, 0x0004,
+	0x0000, 0x0083, 0x0024, 0x01ba,
+	0x0000, 0x0083, 0x0024, 0x01ba,
+	0x0000, 0x0000
+};
+
+#define WM8753_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_DSP_B |  SND_SOC_DAIFMT_NB_NF | \
+	SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_IB_IF)
+
+#define WM8753_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8753_HIFI_FSB \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | \
+	SND_SOC_FSBD(8) | SND_SOC_FSBD(16))
+
+#define WM8753_HIFI_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define WM8753_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+/*
+ * HiFi modes
+ */
+static struct snd_soc_dai_mode wm8753_hifi_modes[] = {
+	/* codec frame and clock master modes */
+	/* 8k */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1536,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1408,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 2304,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 2112,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1500,
+		.bfs = WM8753_HIFI_FSB,
+	},
+
+	/* 11.025k */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1024,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1536,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1088,
+		.bfs = WM8753_HIFI_FSB,
+		},
+
+	/* 16k */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 768,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt= WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1152,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 750,
+		.bfs = WM8753_HIFI_FSB,
+	},
+
+	/* 22.05k */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 512,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 768,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 544,
+		.bfs = WM8753_HIFI_FSB,
+	},
+
+	/* 32k */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 384,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 576,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 375,
+		.bfs = WM8753_HIFI_FSB,
+	},
+
+	/* 44.1k & 48k */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 384,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 250,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 272,
+		.bfs = WM8753_HIFI_FSB,
+	},
+
+	/* 88.2k & 96k */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 128,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 192,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 136,
+		.bfs = WM8753_HIFI_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 125,
+		.bfs = WM8753_HIFI_FSB,
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = WM8753_HIFI_RATES,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+#define WM8753_VOICE_FSB \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | \
+	SND_SOC_FSBD(8) | SND_SOC_FSBD(16))
+
+#define WM8753_VOICE_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+#define WM8753_VOICE_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+/*
+ * Voice modes
+ */
+static struct snd_soc_dai_mode wm8753_voice_modes[] = {
+
+	/* master modes */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_VOICE_BITS,
+		.pcmrate = WM8753_VOICE_RATES,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = WM8753_VOICE_FSB,
+	},
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = WM8753_VOICE_BITS,
+		.pcmrate = WM8753_VOICE_RATES,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 384,
+		.bfs = WM8753_VOICE_FSB,
+	},
+
+	/* slave modes */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8753_VOICE_BITS,
+		.pcmrate = WM8753_VOICE_RATES,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+
+/*
+ * Mode 4
+ */
+static struct snd_soc_dai_mode wm8753_mixed_modes[] = {
+	/* slave modes */
+	{
+		.fmt = WM8753_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8753_HIFI_BITS,
+		.pcmrate = WM8753_HIFI_RATES,
+		.pcmdir = WM8753_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8753 register cache
+ */
+static inline unsigned int wm8753_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg < 1 || reg > (ARRAY_SIZE(wm8753_reg) + 1))
+		return -1;
+	return cache[reg - 1];
+}
+
+/*
+ * write wm8753 register cache
+ */
+static inline void wm8753_write_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg < 1 || reg > 0x3f)
+		return;
+	cache[reg - 1] = value;
+}
+
+/*
+ * write to the WM8753 register space
+ */
+static int wm8753_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8753 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8753_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8753_reset(c) wm8753_write(c, WM8753_RESET, 0)
+
+/*
+ * WM8753 Controls
+ */
+static const char *wm8753_base[] = {"Linear Control", "Adaptive Boost"};
+static const char *wm8753_base_filter[] =
+	{"130Hz @ 48kHz", "200Hz @ 48kHz", "100Hz @ 16kHz", "400Hz @ 48kHz",
+	"100Hz @ 8kHz", "200Hz @ 8kHz"};
+static const char *wm8753_treble[] = {"8kHz", "4kHz"};
+static const char *wm8753_alc_func[] = {"Off", "Right", "Left", "Stereo"};
+static const char *wm8753_ng_type[] = {"Constant PGA Gain", "Mute ADC Output"};
+static const char *wm8753_3d_func[] = {"Capture", "Playback"};
+static const char *wm8753_3d_uc[] = {"2.2kHz", "1.5kHz"};
+static const char *wm8753_3d_lc[] = {"200Hz", "500Hz"};
+static const char *wm8753_deemp[] = {"None", "32kHz", "44.1kHz", "48kHz"};
+static const char *wm8753_mono_mix[] = {"Stereo", "Left", "Right", "Mono"};
+static const char *wm8753_dac_phase[] = {"Non Inverted", "Inverted"};
+static const char *wm8753_line_mix[] = {"Line 1 + 2", "Line 1 - 2",
+	"Line 1", "Line 2"};
+static const char *wm8753_mono_mux[] = {"Line Mix", "Rx Mix"};
+static const char *wm8753_right_mux[] = {"Line 2", "Rx Mix"};
+static const char *wm8753_left_mux[] = {"Line 1", "Rx Mix"};
+static const char *wm8753_rxmsel[] = {"RXP - RXN", "RXP + RXN", "RXP", "RXN"};
+static const char *wm8753_sidetone_mux[] = {"Left PGA", "Mic 1", "Mic 2",
+	"Right PGA"};
+static const char *wm8753_mono2_src[] = {"Inverted Mono 1", "Left", "Right",
+	"Left + Right"};
+static const char *wm8753_out3[] = {"VREF", "ROUT2", "Left + Right"};
+static const char *wm8753_out4[] = {"VREF", "Capture ST", "LOUT2"};
+static const char *wm8753_radcsel[] = {"PGA", "Line or RXP-RXN", "Sidetone"};
+static const char *wm8753_ladcsel[] = {"PGA", "Line or RXP-RXN", "Line"};
+static const char *wm8753_mono_adc[] = {"Stereo", "Analogue Mix Left",
+	"Analogue Mix Right", "Digital Mono Mix"};
+static const char *wm8753_adc_hp[] = {"3.4Hz @ 48kHz", "82Hz @ 16k",
+	"82Hz @ 8kHz", "170Hz @ 8kHz"};
+static const char *wm8753_adc_filter[] = {"HiFi", "Voice"};
+static const char *wm8753_mic_sel[] = {"Mic 1", "Mic 2", "Mic 3"};
+static const char *wm8753_dai_mode[] = {"DAI 0", "DAI 1", "DAI 2", "DAI 3"};
+
+static const struct soc_enum wm8753_enum[] = {
+SOC_ENUM_SINGLE(WM8753_BASS, 7, 2, wm8753_base),		// 0
+SOC_ENUM_SINGLE(WM8753_BASS, 4, 6, wm8753_base_filter),	// 1
+SOC_ENUM_SINGLE(WM8753_TREBLE, 6, 2, wm8753_treble), 	// 2
+SOC_ENUM_SINGLE(WM8753_ALC1, 7, 4, wm8753_alc_func),	// 3
+SOC_ENUM_SINGLE(WM8753_NGATE, 1, 2, wm8753_ng_type),	// 4
+SOC_ENUM_SINGLE(WM8753_3D, 7, 2, wm8753_3d_func),		// 5
+SOC_ENUM_SINGLE(WM8753_3D, 6, 2, wm8753_3d_uc),			// 6
+SOC_ENUM_SINGLE(WM8753_3D, 5, 2, wm8753_3d_lc),			// 7
+SOC_ENUM_SINGLE(WM8753_DAC, 1, 4, wm8753_deemp),		// 8
+SOC_ENUM_SINGLE(WM8753_DAC, 4, 4, wm8753_mono_mix),		// 9
+SOC_ENUM_SINGLE(WM8753_DAC, 6, 2, wm8753_dac_phase),	// 10
+SOC_ENUM_SINGLE(WM8753_INCTL1, 3, 4, wm8753_line_mix),	// 11
+SOC_ENUM_SINGLE(WM8753_INCTL1, 2, 2, wm8753_mono_mux),	// 12
+SOC_ENUM_SINGLE(WM8753_INCTL1, 1, 2, wm8753_right_mux),	// 13
+SOC_ENUM_SINGLE(WM8753_INCTL1, 0, 2, wm8753_left_mux),	// 14
+SOC_ENUM_SINGLE(WM8753_INCTL2, 6, 4, wm8753_rxmsel),	// 15
+SOC_ENUM_SINGLE(WM8753_INCTL2, 4, 4, wm8753_sidetone_mux),// 16
+SOC_ENUM_SINGLE(WM8753_OUTCTL, 7, 4, wm8753_mono2_src),	// 17
+SOC_ENUM_SINGLE(WM8753_OUTCTL, 0, 3, wm8753_out3),		// 18
+SOC_ENUM_SINGLE(WM8753_ADCTL2, 7, 3, wm8753_out4),		// 19
+SOC_ENUM_SINGLE(WM8753_ADCIN, 2, 3, wm8753_radcsel),	// 20
+SOC_ENUM_SINGLE(WM8753_ADCIN, 0, 3, wm8753_ladcsel),	// 21
+SOC_ENUM_SINGLE(WM8753_ADCIN, 4, 4, wm8753_mono_adc),	// 22
+SOC_ENUM_SINGLE(WM8753_ADC, 2, 4, wm8753_adc_hp),		// 23
+SOC_ENUM_SINGLE(WM8753_ADC, 4, 2, wm8753_adc_filter),	// 24
+SOC_ENUM_SINGLE(WM8753_MICBIAS, 6, 3, wm8753_mic_sel),	// 25
+SOC_ENUM_SINGLE(WM8753_IOCTL, 2, 4, wm8753_dai_mode), // 26
+};
+
+
+static int wm8753_get_dai(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	int mode = wm8753_read_reg_cache(codec, WM8753_IOCTL);
+
+	ucontrol->value.integer.value[0] = (mode & 0xc) >> 2;
+	return 0;
+}
+
+static int wm8753_set_dai(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	int mode = wm8753_read_reg_cache(codec, WM8753_IOCTL);
+
+	if (((mode &0xc) >> 2) == ucontrol->value.integer.value[0])
+		return 0;
+
+	mode &= 0xfff3;
+	mode |= (ucontrol->value.integer.value[0] << 2);
+
+	wm8753_write(codec, WM8753_IOCTL, mode);
+	wm8753_set_dai_mode(codec, ucontrol->value.integer.value[0]);
+	return 1;
+}
+
+static const struct snd_kcontrol_new wm8753_snd_controls[] = {
+SOC_DOUBLE_R("PCM Volume", WM8753_LDAC, WM8753_RDAC, 0, 255, 0),
+
+SOC_DOUBLE_R("ADC Capture Volume", WM8753_LADC, WM8753_RADC, 0, 63, 0),
+SOC_DOUBLE_R("ADC Capture Switch", WM8753_LINVOL, WM8753_RINVOL, 7, 1, 0),
+SOC_DOUBLE_R("ADC Capture ZC Switch", WM8753_LINVOL, WM8753_RINVOL, 6, 1, 0),
+
+SOC_DOUBLE_R("Headphone Playback Volume", WM8753_LOUT1V, WM8753_ROUT1V, 0, 127, 0),
+SOC_DOUBLE_R("Speaker Playback Volume", WM8753_LOUT2V, WM8753_ROUT2V, 0, 127, 0),
+
+SOC_SINGLE("Mono Playback Volume", WM8753_MOUTV, 0, 127, 0),
+
+SOC_DOUBLE_R("Bypass Playback Volume", WM8753_LOUTM1, WM8753_ROUTM1, 4, 7, 1),
+SOC_DOUBLE_R("Sidetone Playback Volume", WM8753_LOUTM2, WM8753_ROUTM2, 4, 7, 1),
+SOC_DOUBLE_R("Voice Playback Volume", WM8753_LOUTM2, WM8753_ROUTM2, 0, 7, 1),
+
+SOC_DOUBLE_R("Headphone Playback ZC Switch", WM8753_LOUT1V, WM8753_ROUT1V, 7, 1, 0),
+SOC_DOUBLE_R("Speaker Playback ZC Switch", WM8753_LOUT2V, WM8753_ROUT2V, 7, 1, 0),
+
+SOC_SINGLE("Mono Bypass Playback Volume", WM8753_MOUTM1, 4, 7, 1),
+SOC_SINGLE("Mono Sidetone Playback Volume", WM8753_MOUTM2, 4, 7, 1),
+SOC_SINGLE("Mono Voice Playback Volume", WM8753_MOUTM2, 4, 7, 1),
+SOC_SINGLE("Mono Playback ZC Switch", WM8753_MOUTV, 7, 1, 0),
+
+SOC_ENUM("Bass Boost", wm8753_enum[0]),
+SOC_ENUM("Bass Filter", wm8753_enum[1]),
+SOC_SINGLE("Bass Volume", WM8753_BASS, 0, 7, 1),
+
+SOC_SINGLE("Treble Volume", WM8753_TREBLE, 0, 7, 0),
+SOC_ENUM("Treble Cut-off", wm8753_enum[2]),
+
+SOC_DOUBLE("Sidetone Capture Volume", WM8753_RECMIX1, 0, 4, 7, 1),
+SOC_SINGLE("Voice Sidetone Capture Volume", WM8753_RECMIX2, 0, 7, 1),
+
+SOC_DOUBLE_R("Capture Volume", WM8753_LINVOL, WM8753_RINVOL, 0, 63, 0),
+SOC_DOUBLE_R("Capture ZC Switch", WM8753_LINVOL, WM8753_RINVOL, 6, 1, 0),
+SOC_DOUBLE_R("Capture Switch", WM8753_LINVOL, WM8753_RINVOL, 7, 1, 0),
+
+SOC_ENUM("Capture Filter Select", wm8753_enum[23]),
+SOC_ENUM("Capture Filter Cut-off", wm8753_enum[24]),
+SOC_SINGLE("Capture Filter Switch", WM8753_ADC, 0, 1, 1),
+
+SOC_SINGLE("ALC Capture Target Volume", WM8753_ALC1, 0, 7, 0),
+SOC_SINGLE("ALC Capture Max Volume", WM8753_ALC1, 4, 7, 0),
+SOC_ENUM("ALC Capture Function", wm8753_enum[3]),
+SOC_SINGLE("ALC Capture ZC Switch", WM8753_ALC2, 8, 1, 0),
+SOC_SINGLE("ALC Capture Hold Time", WM8753_ALC2, 0, 15, 1),
+SOC_SINGLE("ALC Capture Decay Time", WM8753_ALC3, 4, 15, 1),
+SOC_SINGLE("ALC Capture Attack Time", WM8753_ALC3, 0, 15, 0),
+SOC_SINGLE("ALC Capture NG Threshold", WM8753_NGATE, 3, 31, 0),
+SOC_ENUM("ALC Capture NG Type", wm8753_enum[4]),
+SOC_SINGLE("ALC Capture NG Switch", WM8753_NGATE, 0, 1, 0),
+
+SOC_ENUM("3D Function", wm8753_enum[5]),
+SOC_ENUM("3D Upper Cut-off", wm8753_enum[6]),
+SOC_ENUM("3D Lower Cut-off", wm8753_enum[7]),
+SOC_SINGLE("3D Volume", WM8753_3D, 1, 15, 0),
+SOC_SINGLE("3D Switch", WM8753_3D, 0, 1, 0),
+
+SOC_SINGLE("Capture 6dB Attenuate", WM8753_ADCTL1, 2, 1, 0),
+SOC_SINGLE("Playback 6dB Attenuate", WM8753_ADCTL1, 1, 1, 0),
+
+SOC_ENUM("De-emphasis", wm8753_enum[8]),
+SOC_ENUM("Playback Mono Mix", wm8753_enum[9]),
+SOC_ENUM("Playback Phase", wm8753_enum[10]),
+
+SOC_SINGLE("Mic2 Capture Volume", WM8753_INCTL1, 7, 3, 0),
+SOC_SINGLE("Mic1 Capture Volume", WM8753_INCTL1, 5, 3, 0),
+
+SOC_ENUM_EXT("DAI Mode", wm8753_enum[26], wm8753_get_dai, wm8753_set_dai),
+};
+
+/* add non dapm controls */
+static int wm8753_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8753_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8753_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/*
+ * _DAPM_ Controls
+ */
+
+/* Left Mixer */
+static const struct snd_kcontrol_new wm8753_left_mixer_controls[] = {
+SOC_DAPM_SINGLE("Voice Playback Switch", WM8753_LOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Sidetone Playback Switch", WM8753_LOUTM2, 7, 1, 0),
+SOC_DAPM_SINGLE("Left Playback Switch", WM8753_LOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Bypass Playback Switch", WM8753_LOUTM1, 7, 1, 0),
+};
+
+/* Right mixer */
+static const struct snd_kcontrol_new wm8753_right_mixer_controls[] = {
+SOC_DAPM_SINGLE("Voice Playback Switch", WM8753_ROUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Sidetone Playback Switch", WM8753_ROUTM2, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8753_ROUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Bypass Playback Switch", WM8753_ROUTM1, 7, 1, 0),
+};
+
+/* Mono mixer */
+static const struct snd_kcontrol_new wm8753_mono_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left Playback Switch", WM8753_MOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8753_MOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Voice Playback Switch", WM8753_MOUTM2, 3, 1, 0),
+SOC_DAPM_SINGLE("Sidetone Playback Switch", WM8753_MOUTM2, 7, 1, 0),
+SOC_DAPM_SINGLE("Bypass Playback Switch", WM8753_MOUTM1, 7, 1, 0),
+};
+
+/* Mono 2 Mux */
+static const struct snd_kcontrol_new wm8753_mono2_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[17]);
+
+/* Out 3 Mux */
+static const struct snd_kcontrol_new wm8753_out3_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[18]);
+
+/* Out 4 Mux */
+static const struct snd_kcontrol_new wm8753_out4_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[19]);
+
+/* ADC Mono Mix */
+static const struct snd_kcontrol_new wm8753_adc_mono_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[22]);
+
+/* Record mixer */
+static const struct snd_kcontrol_new wm8753_record_mixer_controls[] = {
+SOC_DAPM_SINGLE("Voice Capture Switch", WM8753_RECMIX2, 3, 1, 0),
+SOC_DAPM_SINGLE("Left Capture Switch", WM8753_RECMIX1, 3, 1, 0),
+SOC_DAPM_SINGLE("Right Capture Switch", WM8753_RECMIX1, 7, 1, 0),
+};
+
+/* Left ADC mux */
+static const struct snd_kcontrol_new wm8753_adc_left_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[21]);
+
+/* Right ADC mux */
+static const struct snd_kcontrol_new wm8753_adc_right_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[20]);
+
+/* MIC mux */
+static const struct snd_kcontrol_new wm8753_mic_mux_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[16]);
+
+/* ALC mixer */
+static const struct snd_kcontrol_new wm8753_alc_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Capture Switch", WM8753_INCTL2, 3, 1, 0),
+SOC_DAPM_SINGLE("Mic2 Capture Switch", WM8753_INCTL2, 2, 1, 0),
+SOC_DAPM_SINGLE("Mic1 Capture Switch", WM8753_INCTL2, 1, 1, 0),
+SOC_DAPM_SINGLE("Rx Capture Switch", WM8753_INCTL2, 0, 1, 0),
+};
+
+/* Left Line mux */
+static const struct snd_kcontrol_new wm8753_line_left_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[14]);
+
+/* Right Line mux */
+static const struct snd_kcontrol_new wm8753_line_right_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[13]);
+
+/* Mono Line mux */
+static const struct snd_kcontrol_new wm8753_line_mono_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[12]);
+
+/* Line mux and mixer */
+static const struct snd_kcontrol_new wm8753_line_mux_mix_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[11]);
+
+/* Rx mux and mixer */
+static const struct snd_kcontrol_new wm8753_rx_mux_mix_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[15]);
+
+/* Mic Selector Mux */
+static const struct snd_kcontrol_new wm8753_mic_sel_mux_controls =
+SOC_DAPM_ENUM("Route", wm8753_enum[25]);
+
+static const struct snd_soc_dapm_widget wm8753_dapm_widgets[] = {
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8753_PWR1, 5, 0),
+SND_SOC_DAPM_MIXER("Left Mixer", WM8753_PWR4, 0, 0,
+	&wm8753_left_mixer_controls[0], ARRAY_SIZE(wm8753_left_mixer_controls)),
+SND_SOC_DAPM_PGA("Left Out 1", WM8753_PWR3, 8, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Left Out 2", WM8753_PWR3, 6, 0, NULL, 0),
+SND_SOC_DAPM_DAC("Left DAC", "Left HiFi Playback", WM8753_PWR1, 3, 0),
+SND_SOC_DAPM_OUTPUT("LOUT1"),
+SND_SOC_DAPM_OUTPUT("LOUT2"),
+SND_SOC_DAPM_MIXER("Right Mixer", WM8753_PWR4, 1, 0,
+	&wm8753_right_mixer_controls[0], ARRAY_SIZE(wm8753_right_mixer_controls)),
+SND_SOC_DAPM_PGA("Right Out 1", WM8753_PWR3, 7, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Right Out 2", WM8753_PWR3, 5, 0, NULL, 0),
+SND_SOC_DAPM_DAC("Right DAC", "Right HiFi Playback", WM8753_PWR1, 2, 0),
+SND_SOC_DAPM_OUTPUT("ROUT1"),
+SND_SOC_DAPM_OUTPUT("ROUT2"),
+SND_SOC_DAPM_MIXER("Mono Mixer", WM8753_PWR4, 2, 0,
+	&wm8753_mono_mixer_controls[0], ARRAY_SIZE(wm8753_mono_mixer_controls)),
+SND_SOC_DAPM_PGA("Mono Out 1", WM8753_PWR3, 2, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mono Out 2", WM8753_PWR3, 1, 0, NULL, 0),
+SND_SOC_DAPM_DAC("Voice DAC", "Voice Playback", WM8753_PWR1, 4, 0),
+SND_SOC_DAPM_OUTPUT("MONO1"),
+SND_SOC_DAPM_MUX("Mono 2 Mux", SND_SOC_NOPM, 0, 0, &wm8753_mono2_controls),
+SND_SOC_DAPM_OUTPUT("MONO2"),
+SND_SOC_DAPM_MIXER("Out3 Left + Right", -1, 0, 0, NULL, 0),
+SND_SOC_DAPM_MUX("Out3 Mux", SND_SOC_NOPM, 0, 0, &wm8753_out3_controls),
+SND_SOC_DAPM_PGA("Out 3", WM8753_PWR3, 4, 0, NULL, 0),
+SND_SOC_DAPM_OUTPUT("OUT3"),
+SND_SOC_DAPM_MUX("Out4 Mux", SND_SOC_NOPM, 0, 0, &wm8753_out4_controls),
+SND_SOC_DAPM_PGA("Out 4", WM8753_PWR3, 3, 0, NULL, 0),
+SND_SOC_DAPM_OUTPUT("OUT4"),
+SND_SOC_DAPM_MIXER("Playback Mixer", WM8753_PWR4, 3, 0,
+	&wm8753_record_mixer_controls[0],
+	ARRAY_SIZE(wm8753_record_mixer_controls)),
+SND_SOC_DAPM_ADC("Left ADC", "Left Voice Capture", WM8753_PWR2, 3, 0),
+SND_SOC_DAPM_ADC("Right ADC", "Right Voice Capture", WM8753_PWR2, 2, 0),
+SND_SOC_DAPM_MUX("Capture Left Mixer", SND_SOC_NOPM, 0, 0,
+	&wm8753_adc_mono_controls),
+SND_SOC_DAPM_MUX("Capture Right Mixer", SND_SOC_NOPM, 0, 0,
+	&wm8753_adc_mono_controls),
+SND_SOC_DAPM_MUX("Capture Left Mux", SND_SOC_NOPM, 0, 0,
+	&wm8753_adc_left_controls),
+SND_SOC_DAPM_MUX("Capture Right Mux", SND_SOC_NOPM, 0, 0,
+	&wm8753_adc_right_controls),
+SND_SOC_DAPM_MUX("Mic Sidetone Mux", SND_SOC_NOPM, 0, 0,
+	&wm8753_mic_mux_controls),
+SND_SOC_DAPM_PGA("Left Capture Volume", WM8753_PWR2, 5, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Right Capture Volume", WM8753_PWR2, 4, 0, NULL, 0),
+SND_SOC_DAPM_MIXER("ALC Mixer", WM8753_PWR2, 6, 0,
+	&wm8753_alc_mixer_controls[0], ARRAY_SIZE(wm8753_alc_mixer_controls)),
+SND_SOC_DAPM_MUX("Line Left Mux", SND_SOC_NOPM, 0, 0,
+	&wm8753_line_left_controls),
+SND_SOC_DAPM_MUX("Line Right Mux", SND_SOC_NOPM, 0, 0,
+	&wm8753_line_right_controls),
+SND_SOC_DAPM_MUX("Line Mono Mux", SND_SOC_NOPM, 0, 0,
+	&wm8753_line_mono_controls),
+SND_SOC_DAPM_MUX("Line Mixer", SND_SOC_NOPM, 0, 0,
+	&wm8753_line_mux_mix_controls),
+SND_SOC_DAPM_MUX("Rx Mixer", SND_SOC_NOPM, 0, 0,
+	&wm8753_rx_mux_mix_controls),
+SND_SOC_DAPM_PGA("Mic 1 Volume", WM8753_PWR2, 8, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mic 2 Volume", WM8753_PWR2, 7, 0, NULL, 0),
+SND_SOC_DAPM_MUX("Mic Selection Mux", SND_SOC_NOPM, 0, 0,
+	&wm8753_mic_sel_mux_controls),
+SND_SOC_DAPM_INPUT("LINE1"),
+SND_SOC_DAPM_INPUT("LINE2"),
+SND_SOC_DAPM_INPUT("RXP"),
+SND_SOC_DAPM_INPUT("RXN"),
+SND_SOC_DAPM_INPUT("ACIN"),
+SND_SOC_DAPM_INPUT("ACOP"),
+SND_SOC_DAPM_INPUT("MIC1N"),
+SND_SOC_DAPM_INPUT("MIC1"),
+SND_SOC_DAPM_INPUT("MIC2N"),
+SND_SOC_DAPM_INPUT("MIC2"),
+SND_SOC_DAPM_VMID("VREF"),
+};
+
+static const char *audio_map[][3] = {
+	/* left mixer */
+	{"Left Mixer", "Left Playback Switch", "Left DAC"},
+	{"Left Mixer", "Voice Playback Switch", "Voice DAC"},
+	{"Left Mixer", "Sidetone Playback Switch", "Mic Sidetone Mux"},
+	{"Left Mixer", "Bypass Playback Switch", "Line Left Mux"},
+
+	/* right mixer */
+	{"Right Mixer", "Right Playback Switch", "Right DAC"},
+	{"Right Mixer", "Voice Playback Switch", "Voice DAC"},
+	{"Right Mixer", "Sidetone Playback Switch", "Mic Sidetone Mux"},
+	{"Right Mixer", "Bypass Playback Switch", "Line Right Mux"},
+
+	/* mono mixer */
+	{"Mono Mixer", "Voice Playback Switch", "Voice DAC"},
+	{"Mono Mixer", "Left Playback Switch", "Left DAC"},
+	{"Mono Mixer", "Right Playback Switch", "Right DAC"},
+	{"Mono Mixer", "Sidetone Playback Switch", "Mic Sidetone Mux"},
+	{"Mono Mixer", "Bypass Playback Switch", "Line Mono Mux"},
+
+	/* left out */
+	{"Left Out 1", NULL, "Left Mixer"},
+	{"Left Out 2", NULL, "Left Mixer"},
+	{"LOUT1", NULL, "Left Out 1"},
+	{"LOUT2", NULL, "Left Out 2"},
+
+	/* right out */
+	{"Right Out 1", NULL, "Right Mixer"},
+	{"Right Out 2", NULL, "Right Mixer"},
+	{"ROUT1", NULL, "Right Out 1"},
+	{"ROUT2", NULL, "Right Out 2"},
+
+	/* mono 1 out */
+	{"Mono Out 1", NULL, "Mono Mixer"},
+	{"MONO1", NULL, "Mono Out 1"},
+
+	/* mono 2 out */
+	{"Mono 2 Mux", "Left + Right", "Out3 Left + Right"},
+	{"Mono 2 Mux", "Inverted Mono 1", "MONO1"},
+	{"Mono 2 Mux", "Left", "Left Mixer"},
+	{"Mono 2 Mux", "Right", "Right Mixer"},
+	{"Mono Out 2", NULL, "Mono 2 Mux"},
+	{"MONO2", NULL, "Mono Out 2"},
+
+	/* out 3 */
+	{"Out3 Left + Right", NULL, "Left Mixer"},
+	{"Out3 Left + Right", NULL, "Right Mixer"},
+	{"Out3 Mux", "VREF", "VREF"},
+	{"Out3 Mux", "Left + Right", "Out3 Left + Right"},
+	{"Out3 Mux", "ROUT2", "ROUT2"},
+	{"Out 3", NULL, "Out3 Mux"},
+	{"OUT3", NULL, "Out 3"},
+
+	/* out 4 */
+	{"Out4 Mux", "VREF", "VREF"},
+	{"Out4 Mux", "Capture ST", "Capture ST Mixer"},
+	{"Out4 Mux", "LOUT2", "LOUT2"},
+	{"Out 4", NULL, "Out4 Mux"},
+	{"OUT4", NULL, "Out 4"},
+
+	/* record mixer  */
+	{"Playback Mixer", "Left Capture Switch", "Left Mixer"},
+	{"Playback Mixer", "Voice Capture Switch", "Mono Mixer"},
+	{"Playback Mixer", "Right Capture Switch", "Right Mixer"},
+
+	/* Mic/SideTone Mux */
+	{"Mic Sidetone Mux", "Left PGA", "Left Capture Volume"},
+	{"Mic Sidetone Mux", "Right PGA", "Right Capture Volume"},
+	{"Mic Sidetone Mux", "Mic 1", "Mic 1 Volume"},
+	{"Mic Sidetone Mux", "Mic 2", "Mic 2 Volume"},
+
+	/* Capture Left Mux */
+	{"Capture Left Mux", "PGA", "Left Capture Volume"},
+	{"Capture Left Mux", "Line or RXP-RXN", "Line Left Mux"},
+	{"Capture Left Mux", "Line", "LINE1"},
+
+	/* Capture Right Mux */
+	{"Capture Right Mux", "PGA", "Right Capture Volume"},
+	{"Capture Right Mux", "Line or RXP-RXN", "Line Right Mux"},
+	{"Capture Right Mux", "Sidetone", "Capture ST Mixer"},
+
+	/* Mono Capture mixer-mux */
+	{"Capture Right Mixer", "Stereo", "Capture Right Mux"},
+	{"Capture Left Mixer", "Analogue Mix Left", "Capture Left Mux"},
+	{"Capture Left Mixer", "Analogue Mix Left", "Capture Right Mux"},
+	{"Capture Right Mixer", "Analogue Mix Right", "Capture Left Mux"},
+	{"Capture Right Mixer", "Analogue Mix Right", "Capture Right Mux"},
+	{"Capture Left Mixer", "Digital Mono Mix", "Capture Left Mux"},
+	{"Capture Left Mixer", "Digital Mono Mix", "Capture Right Mux"},
+	{"Capture Right Mixer", "Digital Mono Mix", "Capture Left Mux"},
+	{"Capture Right Mixer", "Digital Mono Mix", "Capture Right Mux"},
+
+	/* ADC */
+	{"Left ADC", NULL, "Capture Left Mixer"},
+	{"Right ADC", NULL, "Capture Right Mixer"},
+
+	/* Left Capture Volume */
+	{"Left Capture Volume", NULL, "ACIN"},
+
+	/* Right Capture Volume */
+	{"Right Capture Volume", NULL, "Mic 2 Volume"},
+
+	/* ALC Mixer */
+	{"ALC Mixer", "Line Capture Switch", "Line Mixer"},
+	{"ALC Mixer", "Mic2 Capture Switch", "Mic 2 Volume"},
+	{"ALC Mixer", "Mic1 Capture Switch", "Mic 1 Volume"},
+	{"ALC Mixer", "Rx Capture Switch", "Rx Mixer"},
+
+	/* Line Left Mux */
+	{"Line Left Mux", "Line 1", "LINE1"},
+	{"Line Left Mux", "Rx Mix", "Rx Mixer"},
+
+	/* Line Right Mux */
+	{"Line Right Mux", "Line 2", "LINE2"},
+	{"Line Right Mux", "Rx Mix", "Rx Mixer"},
+
+	/* Line Mono Mux */
+	{"Line Mono Mux", "Line Mix", "Line Mixer"},
+	{"Line Mono Mux", "Rx Mix", "Rx Mixer"},
+
+	/* Line Mixer/Mux */
+	{"Line Mixer", "Line 1 + 2", "LINE1"},
+	{"Line Mixer", "Line 1 - 2", "LINE1"},
+	{"Line Mixer", "Line 1 + 2", "LINE2"},
+	{"Line Mixer", "Line 1 - 2", "LINE2"},
+	{"Line Mixer", "Line 1", "LINE1"},
+	{"Line Mixer", "Line 2", "LINE2"},
+
+	/* Rx Mixer/Mux */
+	{"Rx Mixer", "RXP - RXN", "RXP"},
+	{"Rx Mixer", "RXP + RXN", "RXP"},
+	{"Rx Mixer", "RXP - RXN", "RXN"},
+	{"Rx Mixer", "RXP + RXN", "RXN"},
+	{"Rx Mixer", "RXP", "RXP"},
+	{"Rx Mixer", "RXN", "RXN"},
+
+	/* Mic 1 Volume */
+	{"Mic 1 Volume", NULL, "MIC1N"},
+	{"Mic 1 Volume", NULL, "Mic Selection Mux"},
+
+	/* Mic 2 Volume */
+	{"Mic 2 Volume", NULL, "MIC2N"},
+	{"Mic 2 Volume", NULL, "MIC2"},
+
+	/* Mic Selector Mux */
+	{"Mic Selection Mux", "Mic 1", "MIC1"},
+	{"Mic Selection Mux", "Mic 2", "MIC2N"},
+	{"Mic Selection Mux", "Mic 3", "MIC2"},
+
+	/* ACOP */
+	{"ACOP", NULL, "ALC Mixer"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8753_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8753_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8753_dapm_widgets[i]);
+	}
+
+	/* set up the WM8753 audio map */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+/* PLL divisors */
+struct _pll_div {
+	u32 pll_in;		/* ext clock input */
+	u32 pll_out;	/* pll out freq */
+	u32 div2:1;
+	u32 n:4;
+	u32 k:24;
+};
+
+/*
+ * PLL divisors -
+ */
+static const struct _pll_div pll_div[] = {
+   {13000000,	12288000,	0,	0x7,    0x23F54A},
+   {13000000,	11289600,	0,	0x6,    0x3CA2F5},
+   {12000000,	12288000,	0,	0x8,    0x0C49BA},
+   {12000000,	11289600,	0,	0x7,    0x21B08A},
+   {24000000,	12288000,	1,	0x8,    0x0C49BA},
+   {24000000,	11289600,	1,	0x7,    0x21B08A},
+   {12288000,	11289600,	0,	0x7,	0x166667},
+   {26000000,	11289600,	1,	0x6,	0x3CA2F5},
+   {26000000,	12288000,	1,	0x7,	0x23F54A},
+};
+
+static u32 wm8753_config_pll(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int pll)
+{
+	u16 reg;
+	int found = 0;
+
+    if (pll == 1) {
+		reg = wm8753_read_reg_cache(codec, WM8753_CLOCK) & 0xffef;
+        if (!dai->pll_in || !dai->mclk) {
+            /* disable PLL1  */
+            wm8753_write(codec, WM8753_PLL1CTL1, 0x0026);
+			wm8753_write(codec, WM8753_CLOCK, reg);
+			return 0;
+        } else {
+            u16 value = 0;
+            int i = 0;
+
+            /* if we cant match, then use good values for N and K */
+            for (;i < ARRAY_SIZE(pll_div); i++) {
+                if (pll_div[i].pll_out == dai->pll_out &&
+                	pll_div[i].pll_in == dai->pll_in) {
+                	found = 1;
+                    break;
+                }
+            }
+
+			if (!found)
+				goto err;
+
+            /* set up N and K PLL divisor ratios */
+            /* bits 8:5 = PLL_N, bits 3:0 = PLL_K[21:18] */
+            value = (pll_div[i].n << 5) + ((pll_div[i].k & 0x3c0000) >> 18);
+            wm8753_write(codec, WM8753_PLL1CTL2, value);
+
+            /* bits 8:0 = PLL_K[17:9] */
+            value = (pll_div[i].k & 0x03fe00) >> 9;
+            wm8753_write(codec, WM8753_PLL1CTL3, value);
+
+            /* bits 8:0 = PLL_K[8:0] */
+            value = pll_div[i].k & 0x0001ff;
+            wm8753_write(codec, WM8753_PLL1CTL4, value);
+
+            /* set PLL1 as input and enable */
+            wm8753_write(codec, WM8753_PLL1CTL1, 0x0027 |
+            	(pll_div[i].div2 << 3));
+			wm8753_write(codec, WM8753_CLOCK, reg | 0x0010);
+        }
+    } else {
+		reg = wm8753_read_reg_cache(codec, WM8753_CLOCK) & 0xfff7;
+        if (!dai->pll_in || !dai->mclk) {
+            /* disable PLL2  */
+            wm8753_write(codec, WM8753_PLL2CTL1, 0x0026);
+			wm8753_write(codec, WM8753_CLOCK, reg);
+			return 0;
+        } else {
+            u16 value = 0;
+            int i = 0;
+
+            /* if we cant match, then use good values for N and K */
+            for (;i < ARRAY_SIZE(pll_div); i++) {
+                if (pll_div[i].pll_out == dai->pll_out &&
+                	pll_div[i].pll_in == dai->pll_in) {
+                		found = 1;
+                		break;
+                }
+            }
+
+			if (!found)
+				goto err;
+
+            /* set up N and K PLL divisor ratios */
+            /* bits 8:5 = PLL_N, bits 3:0 = PLL_K[21:18] */
+            value = (pll_div[i].n << 5) + ((pll_div[i].k & 0x3c0000) >> 18);
+            wm8753_write(codec, WM8753_PLL2CTL2, value);
+
+            /* bits 8:0 = PLL_K[17:9] */
+            value = (pll_div[i].k & 0x03fe00) >> 9;
+            wm8753_write(codec, WM8753_PLL2CTL3, value);
+
+            /* bits 8:0 = PLL_K[8:0] */
+            value = pll_div[i].k & 0x0001ff;
+            wm8753_write(codec, WM8753_PLL2CTL4, value);
+
+            /* set PLL1 as input and enable */
+            wm8753_write(codec, WM8753_PLL2CTL1, 0x0027 |
+            	(pll_div[i].div2 << 3));
+			wm8753_write(codec, WM8753_CLOCK, reg | 0x0008);
+        }
+    }
+
+    return dai->pll_in;
+err:
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:5;
+	u8 usb:1;
+};
+
+/* codec hifi mclk (after PLL) clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 8k */
+	{12288000, 8000, 1536, 0x6, 0x0},
+	{11289600, 8000, 1408, 0x16, 0x0},
+	{18432000, 8000, 2304, 0x7, 0x0},
+	{16934400, 8000, 2112, 0x17, 0x0},
+	{12000000, 8000, 1500, 0x6, 0x1},
+
+	/* 11.025k */
+	{11289600, 11025, 1024, 0x18, 0x0},
+	{16934400, 11025, 1536, 0x19, 0x0},
+	{12000000, 11025, 1088, 0x19, 0x1},
+
+	/* 16k */
+	{12288000, 16000, 768, 0xa, 0x0},
+	{18432000, 16000, 1152, 0xb, 0x0},
+	{12000000, 16000, 750, 0xa, 0x1},
+
+	/* 22.05k */
+	{11289600, 22050, 512, 0x1a, 0x0},
+	{16934400, 22050, 768, 0x1b, 0x0},
+	{12000000, 22050, 544, 0x1b, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0xc, 0x0},
+	{18432000, 32000, 576, 0xd, 0x0},
+	{12000000, 32000, 375, 0xa, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x10, 0x0},
+	{16934400, 44100, 384, 0x11, 0x0},
+	{12000000, 44100, 272, 0x11, 0x1},
+
+	/* 48k */
+	{12288000, 48000, 256, 0x0, 0x0},
+	{18432000, 48000, 384, 0x1, 0x0},
+	{12000000, 48000, 250, 0x0, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0x1e, 0x0},
+	{16934400, 88200, 192, 0x1f, 0x0},
+	{12000000, 88200, 136, 0x1f, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0xe, 0x0},
+	{18432000, 96000, 192, 0xf, 0x0},
+	{12000000, 96000, 125, 0xe, 0x1},
+};
+
+static int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+	return -EINVAL;
+}
+
+/* supported HiFi input clocks (that don't use PLL) */
+const static int hifi_clks[] = {11289600, 12000000, 12288000,
+	16934400, 18432000};
+
+/* The HiFi interface can be clocked in one of two ways:-
+ *  o No PLL - MCLK is used directly.
+ *  o PLL    - PLL is used to generate audio MCLK from input clock.
+ *
+ * We use the direct method if we can as it saves power.
+ */
+static unsigned int wm8753_config_i2s_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	int i, pll_out;
+
+	/* is clk supported without the PLL */
+	for(i = 0; i < ARRAY_SIZE(hifi_clks); i++) {
+		if (clk == hifi_clks[i]) {
+			dai->mclk = clk;
+			dai->pll_in = dai->pll_out = 0;
+			dai->clk_div = 1;
+			return clk;
+		}
+	}
+
+	/* determine best PLL output speed */
+	if (info->bclk_master &
+		(SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS)) {
+		pll_out = info->fs * info->rate;
+	} else {
+		/* calc slave clock */
+		switch (info->rate){
+			case 11025:
+			case 22050:
+			case 44100:
+			case 88200:
+				pll_out = 11289600;
+				break;
+			default:
+				pll_out = 12288000;
+				break;
+		}
+	}
+
+	/* are input & output clocks supported by PLL */
+	for (i = 0;i < ARRAY_SIZE(pll_div); i++) {
+		if (pll_div[i].pll_in == clk && pll_div[i].pll_out == pll_out) {
+			dai->pll_in = clk;
+			dai->pll_out = dai->mclk = pll_out;
+			return pll_out;
+		}
+	}
+
+	/* this clk is not supported */
+	return 0;
+}
+
+/* valid PCM clock dividers * 2 */
+static int pcm_divs[] = {2, 6, 11, 4, 8, 12, 16};
+
+/* The Voice interface can be clocked in one of four ways:-
+ *  o No PLL - MCLK is used directly.
+ *  o Div    - MCLK is directly divided.
+ *  o PLL    - PLL is used to generate audio MCLK from input clock.
+ *  o PLL & Div - PLL and post divider are used.
+ *
+ * We use the non PLL methods if we can, as it saves power.
+ */
+
+static unsigned int wm8753_config_pcm_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	int i, j, best_clk = info->fs * info->rate;
+
+	/* can we run at this clk without the PLL ? */
+	for (i = 0; i < ARRAY_SIZE(pcm_divs); i++) {
+		if ((best_clk >> 1) * pcm_divs[i] == clk) {
+			dai->pll_in = 0;
+			dai->clk_div = pcm_divs[i];
+			dai->mclk = best_clk;
+			return dai->mclk;
+		}
+	}
+
+	/* now check for PLL support */
+	for (i = 0; i < ARRAY_SIZE(pll_div); i++) {
+		if (pll_div[i].pll_in == clk) {
+			for (j = 0; j < ARRAY_SIZE(pcm_divs); j++) {
+				if (pll_div[i].pll_out == pcm_divs[j] * (best_clk >> 1)) {
+					dai->pll_in = clk;
+					dai->pll_out = pll_div[i].pll_out;
+					dai->clk_div = pcm_divs[j];
+					dai->mclk = best_clk;
+					return dai->mclk;
+				}
+			}
+		}
+	}
+
+	/* this clk is not supported */
+	return 0;
+}
+
+/* set the format and bit size for ADC and Voice DAC */
+static void wm8753_adc_vdac_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 voice = wm8753_read_reg_cache(codec, WM8753_PCM) & 0x01e0;
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		voice |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		voice |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		voice |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		voice |= 0x0013;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		voice |= 0x0004;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		voice |= 0x0008;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		voice |= 0x000c;
+		break;
+	}
+
+	wm8753_write(codec, WM8753_PCM, voice);
+}
+
+/* configure PCM DAI */
+static int wm8753_pcm_dai_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 voice, ioctl, srate, srate2, fs, bfs, clock;
+	unsigned int rate;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+	fs = rtd->codec_dai->dai_runtime.fs;
+	rate = snd_soc_get_rate(rtd->codec_dai->dai_runtime.pcmrate);
+	voice = wm8753_read_reg_cache(codec, WM8753_PCM) & 0x001f;
+
+	/* set master/slave audio interface */
+	ioctl = wm8753_read_reg_cache(codec, WM8753_IOCTL) & 0x01fd;
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		ioctl |= 0x0002;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		voice |= 0x0040;
+		break;
+	}
+
+	/* do we need to enable the PLL */
+	if (rtd->codec_dai->pll_in) {
+		if (wm8753_config_pll(codec, rtd->codec_dai, 2) !=
+			rtd->codec_dai->pll_in) {
+			err("could not set pll to %d --> %d",
+				rtd->codec_dai->pll_in, rtd->codec_dai->pll_out);
+			return -ENODEV;
+		}
+	}
+
+	/* set up PCM divider */
+	clock = wm8753_read_reg_cache(codec, WM8753_CLOCK) & 0x003f;
+	switch (rtd->codec_dai->clk_div) {
+	case 2: /* 1 */
+		break;
+	case 6: /* 3 */
+		clock |= (0x2 << 6);
+		break;
+	case 11: /* 5.5 */
+		clock |= (0x3 << 6);
+		break;
+	case 4: /* 2 */
+		clock |= (0x4 << 6);
+		break;
+	case 8: /* 4 */
+		clock |= (0x5 << 6);
+		break;
+	case 12: /* 6 */
+		clock |= (0x6 << 6);
+		break;
+	case 16: /* 8 */
+		clock |= (0x7 << 6);
+		break;
+	default:
+		printk(KERN_ERR "wm8753: invalid PCM clk divider %d\n",
+			rtd->codec_dai->clk_div);
+		break;
+	}
+	wm8753_write(codec, WM8753_CLOCK, clock);
+
+	/* set bclk divisor rate */
+	srate2 = wm8753_read_reg_cache(codec, WM8753_SRATE2) & 0x003f;
+	switch (bfs) {
+	case 1:
+		break;
+	case 2:
+		srate2 |= (0x1 << 6);
+		break;
+	case 4:
+		srate2 |= (0x2 << 6);
+		break;
+	case 8:
+		srate2 |= (0x3 << 6);
+		break;
+	case 16:
+		srate2 |= (0x4 << 6);
+		break;
+	}
+	wm8753_write(codec, WM8753_SRATE2, srate2);
+
+	srate = wm8753_read_reg_cache(codec, WM8753_SRATE1) & 0x017f;
+	if (rtd->codec_dai->dai_runtime.fs == 384)
+		srate |= 0x80;
+	wm8753_write(codec, WM8753_SRATE1, srate);
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		voice |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		voice |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		voice |= 0x0010;
+		break;
+	}
+	//printk("voice %x %x ioctl %x %x srate2 %x %x srate1 %x %x\n",
+	//WM8753_PCM, voice, WM8753_IOCTL, ioctl, WM8753_SRATE2,
+	//srate2, WM8753_SRATE1, srate);
+
+	wm8753_write(codec, WM8753_IOCTL, ioctl);
+	wm8753_write(codec, WM8753_PCM, voice);
+	return 0;
+}
+
+/* configure hifi DAC wordlength and format */
+static void wm8753_hdac_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 hifi = wm8753_read_reg_cache(codec, WM8753_HIFI) & 0x01e0;
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		hifi |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		hifi |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		hifi |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		hifi |= 0x0013;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		hifi |= 0x0004;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		hifi |= 0x0008;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		hifi |= 0x000c;
+		break;
+	}
+
+	wm8753_write(codec, WM8753_HIFI, hifi);
+}
+
+/* configure i2s (hifi) DAI clocking */
+static int wm8753_i2s_dai_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 srate, bfs, hifi, ioctl;
+	unsigned int rate;
+	int i = 0;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+	rate = snd_soc_get_rate(rtd->codec_dai->dai_runtime.pcmrate);
+	hifi = wm8753_read_reg_cache(codec, WM8753_HIFI) & 0x001f;
+
+	/* is coefficient valid ? */
+	if ((i = get_coeff(rtd->codec_dai->mclk, rate)) < 0)
+		return i;
+
+	srate = wm8753_read_reg_cache(codec, WM8753_SRATE1) & 0x01c0;
+	wm8753_write(codec, WM8753_SRATE1, srate | (coeff_div[i].sr << 1) |
+		coeff_div[i].usb);
+
+	/* do we need to enable the PLL */
+	if (rtd->codec_dai->pll_in) {
+		if (wm8753_config_pll(codec, rtd->codec_dai, 1) !=
+			rtd->codec_dai->pll_in) {
+			err("could not set pll to %d --> %d",
+				rtd->codec_dai->pll_in, rtd->codec_dai->pll_out);
+			return -ENODEV;
+		}
+	}
+
+	/* set bclk divisor rate */
+	srate = wm8753_read_reg_cache(codec, WM8753_SRATE2) & 0x01c7;
+	switch (bfs) {
+	case 1:
+		break;
+	case 2:
+		srate |= (0x1 << 3);
+		break;
+	case 4:
+		srate |= (0x2 << 3);
+		break;
+	case 8:
+		srate |= (0x3 << 3);
+		break;
+	case 16:
+		srate |= (0x4 << 3);
+		break;
+	}
+	wm8753_write(codec, WM8753_SRATE2, srate);
+
+	/* set master/slave audio interface */
+	ioctl = wm8753_read_reg_cache(codec, WM8753_IOCTL) & 0x00fe;
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		ioctl |= 0x0001;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		hifi |= 0x0040;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		hifi |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		hifi |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		hifi |= 0x0010;
+		break;
+	}
+	wm8753_write(codec, WM8753_IOCTL, ioctl);
+	wm8753_write(codec, WM8753_HIFI, hifi);
+	return 0;
+}
+
+static int wm8753_mode1v_prepare (struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 clock;
+
+	/* set clk source as pcmclk */
+	clock = wm8753_read_reg_cache(codec, WM8753_CLOCK) & 0xfffb;
+	wm8753_write(codec, WM8753_CLOCK, clock);
+
+	wm8753_adc_vdac_prepare(substream);
+	return wm8753_pcm_dai_prepare(substream);
+}
+
+static int wm8753_mode1h_prepare (struct snd_pcm_substream *substream)
+{
+	wm8753_hdac_prepare(substream);
+	return wm8753_i2s_dai_prepare(substream);
+}
+
+static int wm8753_mode2_prepare (struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 clock;
+
+	/* set clk source as pcmclk */
+	clock = wm8753_read_reg_cache(codec, WM8753_CLOCK) & 0xfffb;
+	wm8753_write(codec, WM8753_CLOCK, clock);
+
+	wm8753_adc_vdac_prepare(substream);
+	return wm8753_i2s_dai_prepare(substream);
+}
+
+static int wm8753_mode3_prepare (struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 clock;
+
+	/* set clk source as mclk */
+	clock = wm8753_read_reg_cache(codec, WM8753_CLOCK) & 0xfffb;
+	wm8753_write(codec, WM8753_CLOCK, clock | 0x4);
+
+	wm8753_hdac_prepare(substream);
+	wm8753_adc_vdac_prepare(substream);
+	return wm8753_i2s_dai_prepare(substream);
+}
+
+static int wm8753_mode4_prepare (struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 clock;
+
+	/* set clk source as mclk */
+	clock = wm8753_read_reg_cache(codec, WM8753_CLOCK) & 0xfffb;
+	wm8753_write(codec, WM8753_CLOCK, clock | 0x4);
+
+	wm8753_hdac_prepare(substream);
+	wm8753_adc_vdac_prepare(substream);
+	return wm8753_i2s_dai_prepare(substream);
+}
+
+static int wm8753_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8753_read_reg_cache(codec, WM8753_DAC) & 0xfff7;
+
+	/* the digital mute covers the HiFi and Voice DAC's on the WM8753.
+	 * make sure we check if they are not both active when we mute */
+	if (mute && dai->id == 1) {
+		if (!wm8753_dai[WM8753_DAI_VOICE].playback.active ||
+			!wm8753_dai[WM8753_DAI_HIFI].playback.active)
+			wm8753_write(codec, WM8753_DAC, mute_reg | 0x8);
+	} else {
+		if (mute)
+			wm8753_write(codec, WM8753_DAC, mute_reg | 0x8);
+		else
+			wm8753_write(codec, WM8753_DAC, mute_reg);
+	}
+
+	return 0;
+}
+
+static int wm8753_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 pwr_reg = wm8753_read_reg_cache(codec, WM8753_PWR1) & 0xfe3e;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* set vmid to 50k and unmute dac */
+		wm8753_write(codec, WM8753_PWR1, pwr_reg | 0x00c0);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		/* set vmid to 5k for quick power up */
+		wm8753_write(codec, WM8753_PWR1, pwr_reg | 0x01c1);
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* mute dac and set vmid to 500k, enable VREF */
+		wm8753_write(codec, WM8753_PWR1, pwr_reg | 0x0141);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		wm8753_write(codec, WM8753_PWR1, 0x0001);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+/*
+ * The WM8753 supports upto 4 different and mutually exclusive DAI
+ * configurations. This gives 2 PCM's available for use, hifi and voice.
+ * NOTE: The Voice PCM cannot play or caputure audio to the CPU as it's DAI
+ * is connected between the wm8753 and a BT codec or GSM modem.
+ *
+ * 1. Voice over PCM DAI - HIFI DAC over HIFI DAI
+ * 2. Voice over HIFI DAI - HIFI disabled
+ * 3. Voice disabled - HIFI over HIFI
+ * 4. Voice disabled - HIFI over HIFI, uses voice DAI LRC for capture
+ */
+static const struct snd_soc_codec_dai wm8753_all_dai[] = {
+/* DAI HiFi mode 1 */
+{	.name = "WM8753 HiFi",
+	.id = 1,
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = { /* dummy for fast DAI switching */
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.config_sysclk = wm8753_config_i2s_sysclk,
+	.digital_mute = wm8753_mute,
+	.ops = {
+		.prepare = wm8753_mode1h_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8753_hifi_modes),
+		.mode = wm8753_hifi_modes,},
+},
+/* DAI Voice mode 1 */
+{	.name = "WM8753 Voice",
+	.id = 1,
+	.playback = {
+		.stream_name = "Voice Playback",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.capture = {
+		.stream_name = "Voice Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.config_sysclk = wm8753_config_pcm_sysclk,
+	.digital_mute = wm8753_mute,
+	.ops = {
+		.prepare = wm8753_mode1v_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8753_voice_modes),
+		.mode = wm8753_voice_modes,},
+},
+/* DAI HiFi mode 2 - dummy */
+{	.name = "WM8753 HiFi",
+	.id = 2,
+},
+/* DAI Voice mode 2 */
+{	.name = "WM8753 Voice",
+	.id = 2,
+	.playback = {
+		.stream_name = "Voice Playback",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.capture = {
+		.stream_name = "Voice Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.config_sysclk = wm8753_config_i2s_sysclk,
+	.digital_mute = wm8753_mute,
+	.ops = {
+		.prepare = wm8753_mode2_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8753_voice_modes),
+		.mode = wm8753_voice_modes,},
+},
+/* DAI HiFi mode 3 */
+{	.name = "WM8753 HiFi",
+	.id = 3,
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.config_sysclk = wm8753_config_i2s_sysclk,
+	.digital_mute = wm8753_mute,
+	.ops = {
+		.prepare = wm8753_mode3_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8753_hifi_modes),
+		.mode = wm8753_hifi_modes,},
+},
+/* DAI Voice mode 3 - dummy */
+{	.name = "WM8753 Voice",
+	.id = 3,
+},
+/* DAI HiFi mode 4 */
+{	.name = "WM8753 HiFi",
+	.id = 4,
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.config_sysclk = wm8753_config_i2s_sysclk,
+	.digital_mute = wm8753_mute,
+	.ops = {
+		.prepare = wm8753_mode4_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8753_mixed_modes),
+		.mode = wm8753_mixed_modes,},
+},
+/* DAI Voice mode 4 - dummy */
+{	.name = "WM8753 Voice",
+	.id = 4,
+},
+};
+
+struct snd_soc_codec_dai wm8753_dai[2];
+EXPORT_SYMBOL_GPL(wm8753_dai);
+
+static void wm8753_set_dai_mode(struct snd_soc_codec *codec, unsigned int mode)
+{
+	if (mode < 4) {
+		wm8753_dai[0] = wm8753_all_dai[mode << 1];
+		wm8753_dai[1] = wm8753_all_dai[(mode << 1) + 1];
+	}
+}
+
+static void wm8753_work(void *data)
+{
+	struct snd_soc_codec *codec = (struct snd_soc_codec *)data;
+	wm8753_dapm_event(codec, codec->dapm_state);
+}
+
+static int wm8753_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8753_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8753_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8753_reg); i++) {
+		if (i + 1 == WM8753_RESET)
+			continue;
+		data[0] = ((i + 1) << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+
+	wm8753_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* charge wm8753 caps */
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0) {
+		wm8753_dapm_event(codec, SNDRV_CTL_POWER_D2);
+		codec->dapm_state = SNDRV_CTL_POWER_D0;
+		queue_delayed_work(wm8753_workq, &wm8753_dapm_work,
+			msecs_to_jiffies(caps_charge));
+	}
+
+	return 0;
+}
+
+/*
+ * initialise the WM8753 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8753_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8753";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8753_read_reg_cache;
+	codec->write = wm8753_write;
+	codec->dapm_event = wm8753_dapm_event;
+	codec->dai = wm8753_dai;
+	codec->num_dai = 2;
+	codec->reg_cache_size = ARRAY_SIZE(wm8753_reg);
+
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8753_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8753_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8753_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8753_reg);
+	wm8753_set_dai_mode(codec, 0);
+
+	wm8753_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* charge output caps */
+	wm8753_dapm_event(codec, SNDRV_CTL_POWER_D2);
+	codec->dapm_state = SNDRV_CTL_POWER_D3hot;
+	queue_delayed_work(wm8753_workq,
+		&wm8753_dapm_work, msecs_to_jiffies(caps_charge));
+
+	/* set the update bits */
+	reg = wm8753_read_reg_cache(codec, WM8753_LDAC);
+	wm8753_write(codec, WM8753_LDAC, reg | 0x0100);
+	reg = wm8753_read_reg_cache(codec, WM8753_RDAC);
+	wm8753_write(codec, WM8753_RDAC, reg | 0x0100);
+	reg = wm8753_read_reg_cache(codec, WM8753_LOUT1V);
+	wm8753_write(codec, WM8753_LOUT1V, reg | 0x0100);
+	reg = wm8753_read_reg_cache(codec, WM8753_ROUT1V);
+	wm8753_write(codec, WM8753_ROUT1V, reg | 0x0100);
+	reg = wm8753_read_reg_cache(codec, WM8753_LOUT2V);
+	wm8753_write(codec, WM8753_LOUT2V, reg | 0x0100);
+	reg = wm8753_read_reg_cache(codec, WM8753_ROUT2V);
+	wm8753_write(codec, WM8753_ROUT2V, reg | 0x0100);
+	reg = wm8753_read_reg_cache(codec, WM8753_LINVOL);
+	wm8753_write(codec, WM8753_LINVOL, reg | 0x0100);
+	reg = wm8753_read_reg_cache(codec, WM8753_RINVOL);
+	wm8753_write(codec, WM8753_RINVOL, reg | 0x0100);
+
+	wm8753_add_controls(codec);
+	wm8753_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static struct snd_soc_device *wm8753_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8753 2 wire address is determined by GPIO5
+ * state during powerup.
+ *    low  = 0x1a
+ *    high = 0x1b
+ */
+#define I2C_DRIVERID_WM8753 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8753_i2c_driver;
+static struct i2c_client client_template;
+
+static int wm8753_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8753_socdev;
+	struct wm8753_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8753_init(socdev);
+	if (ret < 0) {
+		err("failed to initialise WM8753\n");
+		goto err;
+	}
+
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8753_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8753_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8753_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8753_i2c_driver = {
+	.driver = {
+		.name = "WM8753 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8753,
+	.attach_adapter = wm8753_i2c_attach,
+	.detach_client =  wm8753_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8753",
+	.driver = &wm8753_i2c_driver,
+};
+#endif
+
+static int wm8753_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8753_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8753 Audio Codec %s", WM8753_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	wm8753_socdev = socdev;
+	INIT_WORK(&wm8753_dapm_work, wm8753_work, codec);
+	wm8753_workq = create_workqueue("wm8753");
+	if (wm8753_workq == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8753_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+		/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8753_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8753_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	if (wm8753_workq)
+		destroy_workqueue(wm8753_workq);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8753_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8753 = {
+	.probe = 	wm8753_probe,
+	.remove = 	wm8753_remove,
+	.suspend = 	wm8753_suspend,
+	.resume =	wm8753_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8753);
+
+MODULE_DESCRIPTION("ASoC WM8753 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8753.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8753.h
@@ -0,0 +1,91 @@
+/*
+ * wm8753.h  --  audio driver for WM8753
+ *
+ * Copyright 2003 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef _WM8753_H
+#define _WM8753_H
+
+/* WM8753 register space */
+
+#define WM8753_DAC		0x01
+#define WM8753_ADC		0x02
+#define WM8753_PCM		0x03
+#define WM8753_HIFI		0x04
+#define WM8753_IOCTL	0x05
+#define WM8753_SRATE1	0x06
+#define WM8753_SRATE2	0x07
+#define WM8753_LDAC		0x08
+#define WM8753_RDAC		0x09
+#define WM8753_BASS		0x0a
+#define WM8753_TREBLE	0x0b
+#define WM8753_ALC1		0x0c
+#define WM8753_ALC2		0x0d
+#define WM8753_ALC3		0x0e
+#define WM8753_NGATE	0x0f
+#define WM8753_LADC		0x10
+#define WM8753_RADC		0x11
+#define WM8753_ADCTL1	0x12
+#define WM8753_3D		0x13
+#define WM8753_PWR1		0x14
+#define WM8753_PWR2		0x15
+#define WM8753_PWR3		0x16
+#define WM8753_PWR4		0x17
+#define WM8753_ID		0x18
+#define WM8753_INTPOL	0x19
+#define WM8753_INTEN	0x1a
+#define WM8753_GPIO1	0x1b
+#define WM8753_GPIO2	0x1c
+#define WM8753_RESET	0x1f
+#define WM8753_RECMIX1	0x20
+#define WM8753_RECMIX2	0x21
+#define WM8753_LOUTM1	0x22
+#define WM8753_LOUTM2	0x23
+#define WM8753_ROUTM1	0x24
+#define WM8753_ROUTM2	0x25
+#define WM8753_MOUTM1	0x26
+#define WM8753_MOUTM2	0x27
+#define WM8753_LOUT1V	0x28
+#define WM8753_ROUT1V	0x29
+#define WM8753_LOUT2V	0x2a
+#define WM8753_ROUT2V	0x2b
+#define WM8753_MOUTV	0x2c
+#define WM8753_OUTCTL	0x2d
+#define WM8753_ADCIN	0x2e
+#define WM8753_INCTL1	0x2f
+#define WM8753_INCTL2	0x30
+#define WM8753_LINVOL	0x31
+#define WM8753_RINVOL	0x32
+#define WM8753_MICBIAS	0x33
+#define WM8753_CLOCK	0x34
+#define WM8753_PLL1CTL1	0x35
+#define WM8753_PLL1CTL2	0x36
+#define WM8753_PLL1CTL3	0x37
+#define WM8753_PLL1CTL4	0x38
+#define WM8753_PLL2CTL1	0x39
+#define WM8753_PLL2CTL2	0x3a
+#define WM8753_PLL2CTL3	0x3b
+#define WM8753_PLL2CTL4	0x3c
+#define WM8753_BIASCTL	0x3d
+#define WM8753_ADCTL2	0x3f
+
+struct wm8753_setup_data {
+	unsigned short i2c_address;
+};
+
+#define WM8753_DAI_HIFI		0
+#define WM8753_DAI_VOICE	1
+
+extern struct snd_soc_codec_dai wm8753_dai[2];
+extern struct snd_soc_codec_device soc_codec_dev_wm8753;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8772.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8772.c
@@ -0,0 +1,806 @@
+/*
+ * wm8772.c  --  WM8772 ALSA Soc Audio driver
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8772.h"
+
+#define AUDIO_NAME "WM8772"
+#define WM8772_VERSION "0.3"
+
+/*
+ * wm8772 register cache
+ * We can't read the WM8772 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8772_reg[] = {
+	0x00ff, 0x00ff, 0x0120, 0x0000,  /*  0 */
+	0x00ff, 0x00ff, 0x00ff, 0x00ff,  /*  4 */
+	0x00ff, 0x0000, 0x0080, 0x0040,  /*  8 */
+	0x0000
+};
+
+#define WM8772_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	 SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_IB_NF)
+
+#define WM8772_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8772_PRATES \
+	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
+	 SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
+
+#define WM8772_CRATES \
+	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
+	 SNDRV_PCM_RATE_96000)
+
+static struct snd_soc_dai_mode wm8772_modes[] = {
+	/* common codec frame and clock master modes */
+	/* 32k */
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 768,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 512,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 192,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 128,
+		.bfs = 64,
+	},
+
+	/* 	44.1k */
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 768,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 512,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 192,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 128,
+		.bfs = 64,
+	},
+
+	/* 48k */
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 768,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 512,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 192,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 128,
+		.bfs = 64,
+	},
+
+	/* 96k */
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8772_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 192,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8772_DIR,
+		.pcmrate = SND_SOC_DAI_BFS_RATE,
+		.fs = 128,
+		.bfs = 64,
+	},
+
+	/* 192k */
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_192000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 192,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8772_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_192000,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 128,
+		.bfs = 64,
+	},
+
+	/* slave mode */
+	{
+		.fmt = WM8772_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = WM8772_PRATES,
+		.pcmdir = SND_SOC_DAIDIR_PLAYBACK,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+	{
+		.fmt = WM8772_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = WM8772_CRATES,
+		.pcmdir = SND_SOC_DAIDIR_CAPTURE,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8772 register cache
+ */
+static inline unsigned int wm8772_read_reg_cache(struct snd_soc_codec * codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg > WM8772_CACHE_REGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8772 register cache
+ */
+static inline void wm8772_write_reg_cache(struct snd_soc_codec * codec,
+	unsigned int reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg > WM8772_CACHE_REGNUM)
+		return;
+	cache[reg] = value;
+}
+
+static int wm8772_write(struct snd_soc_codec * codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8772 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8772_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -1;
+}
+
+#define wm8772_reset(c)	wm8772_write(c, WM8772_RESET, 0)
+
+/*
+ * WM8772 Controls
+ */
+static const char *wm8772_zero_flag[] = {"All Ch", "Ch 1", "Ch 2", "Ch3"};
+
+static const struct soc_enum wm8772_enum[] = {
+SOC_ENUM_SINGLE(WM8772_DACCTRL, 0, 4, wm8772_zero_flag),
+};
+
+static const struct snd_kcontrol_new wm8772_snd_controls[] = {
+
+SOC_SINGLE("Left1 Playback Volume", WM8772_LDAC1VOL, 0, 255, 0),
+SOC_SINGLE("Left2 Playback Volume", WM8772_LDAC2VOL, 0, 255, 0),
+SOC_SINGLE("Left3 Playback Volume", WM8772_LDAC3VOL, 0, 255, 0),
+SOC_SINGLE("Right1 Playback Volume", WM8772_RDAC1VOL, 0, 255, 0),
+SOC_SINGLE("Right1 Playback Volume", WM8772_RDAC2VOL, 0, 255, 0),
+SOC_SINGLE("Right1 Playback Volume", WM8772_RDAC3VOL, 0, 255, 0),
+SOC_SINGLE("Master Playback Volume", WM8772_MDACVOL, 0, 255, 0),
+
+SOC_SINGLE("Playback Switch", WM8772_DACCH, 0, 1, 0),
+SOC_SINGLE("Capture Switch", WM8772_ADCCTRL, 2, 1, 0),
+
+SOC_SINGLE("Demp1 Playback Switch", WM8772_DACCTRL, 6, 1, 0),
+SOC_SINGLE("Demp2 Playback Switch", WM8772_DACCTRL, 7, 1, 0),
+SOC_SINGLE("Demp3 Playback Switch", WM8772_DACCTRL, 8, 1, 0),
+
+SOC_SINGLE("Phase Invert 1 Switch", WM8772_IFACE, 6, 1, 0),
+SOC_SINGLE("Phase Invert 2 Switch", WM8772_IFACE, 7, 1, 0),
+SOC_SINGLE("Phase Invert 3 Switch", WM8772_IFACE, 8, 1, 0),
+
+SOC_SINGLE("Playback ZC Switch", WM8772_DACCTRL, 0, 1, 0),
+
+SOC_SINGLE("Capture High Pass Switch", WM8772_ADCCTRL, 3, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm8772_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8772_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8772_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/* valid wm8772 mclk frequencies */
+static const int freq_table[5][6] = {
+	{4096000, 6144000, 8192000, 12288000, 16384000, 24576000},
+	{5644800, 8467000, 11289600, 16934000, 22579200, 33868800},
+	{6144000, 9216000, 12288000, 18432000, 24576000, 36864000},
+	{12288000, 18432000, 24576000, 36864000, 0, 0},
+	{24576000, 36864000, 0, 0, 0},
+};
+
+static unsigned int check_freq(int rate, unsigned int freq)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		if(freq == freq_table[i][rate])
+			return freq;
+	}
+	return 0;
+}
+
+static unsigned int wm8772_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	switch (info->rate){
+	case 32000:
+		dai->mclk = check_freq(0, clk);
+		break;
+	case 44100:
+		dai->mclk = check_freq(1, clk);
+		break;
+	case 48000:
+		dai->mclk = check_freq(2, clk);
+		break;
+	case 96000:
+		dai->mclk = check_freq(3, clk);
+		break;
+	case 192000:
+		dai->mclk = check_freq(4, clk);
+		break;
+	default:
+		dai->mclk = 0;
+	}
+	return dai->mclk;
+}
+
+static int wm8772_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 diface = wm8772_read_reg_cache(codec, WM8772_IFACE) & 0xffc0;
+	u16 diface_ctrl = wm8772_read_reg_cache(codec, WM8772_DACRATE) & 0xfe1f;
+	u16 aiface = 0;
+	u16 aiface_ctrl = wm8772_read_reg_cache(codec, WM8772_ADCCTRL) & 0xfcff;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+		/* set master/slave audio interface */
+		switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+		case SND_SOC_DAIFMT_CBM_CFM:
+			diface_ctrl |= 0x0010;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:
+			break;
+		}
+
+		/* interface format */
+		switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			diface |= 0x0002;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			diface |= 0x0001;
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+			diface |= 0x0003;
+			break;
+		case SND_SOC_DAIFMT_DSP_B:
+			diface |= 0x0007;
+			break;
+		}
+
+		/* bit size */
+		switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+		case SNDRV_PCM_FMTBIT_S16_LE:
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			diface |= 0x0010;
+			break;
+		case SNDRV_PCM_FORMAT_S24_3LE:
+			diface |= 0x0020;
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			diface |= 0x0030;
+			break;
+		}
+
+		/* clock inversion */
+		switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			diface |= 0x0008;
+			break;
+		}
+
+		/* set rate */
+		switch (rtd->codec_dai->dai_runtime.fs) {
+		case 768:
+			diface_ctrl |= (0x5 << 6);
+			break;
+		case 512:
+			diface_ctrl |= (0x4 << 6);
+			break;
+		case 384:
+			diface_ctrl |= (0x3 << 6);
+			break;
+		case 256:
+			diface_ctrl |= (0x2 << 6);
+			break;
+		case 192:
+			diface_ctrl |= (0x1 << 6);
+			break;
+		}
+
+		wm8772_write(codec, WM8772_DACRATE, diface_ctrl);
+		wm8772_write(codec, WM8772_IFACE, diface);
+
+	} else {
+
+		/* set master/slave audio interface */
+		switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+		case SND_SOC_DAIFMT_CBM_CFM:
+			aiface |= 0x0010;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:
+			break;
+		}
+
+		/* interface format */
+		switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			aiface |= 0x0002;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			aiface |= 0x0001;
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+			aiface |= 0x0003;
+			break;
+		case SND_SOC_DAIFMT_DSP_B:
+			aiface |= 0x0003;
+			aiface_ctrl |= 0x0010;
+			break;
+		}
+
+		/* bit size */
+		switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+		case SNDRV_PCM_FMTBIT_S16_LE:
+			break;
+		case SNDRV_PCM_FMTBIT_S20_3LE:
+			aiface |= 0x0004;
+			break;
+		case SNDRV_PCM_FMTBIT_S24_LE:
+			aiface |= 0x0008;
+			break;
+		case SNDRV_PCM_FMTBIT_S32_LE:
+			aiface |= 0x000c;
+			break;
+		}
+
+		/* clock inversion */
+		switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			aiface_ctrl |= 0x0020;
+			break;
+		}
+
+		/* set rate */
+		switch (rtd->codec_dai->dai_runtime.fs) {
+		case 768:
+			aiface |= (0x5 << 5);
+			break;
+		case 512:
+			aiface |= (0x4 << 5);
+			break;
+		case 384:
+			aiface |= (0x3 << 5);
+			break;
+		case 256:
+			aiface |= (0x2 << 5);
+			break;
+		}
+
+		wm8772_write(codec, WM8772_ADCCTRL, aiface_ctrl);
+		wm8772_write(codec, WM8772_ADCRATE, aiface);
+	}
+
+	return 0;
+}
+
+static int wm8772_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 master = wm8772_read_reg_cache(codec, WM8772_DACRATE) & 0xffe0;
+
+	switch (event) {
+		case SNDRV_CTL_POWER_D0: /* full On */
+			/* vref/mid, clk and osc on, dac unmute, active */
+			wm8772_write(codec, WM8772_DACRATE, master);
+			break;
+		case SNDRV_CTL_POWER_D1: /* partial On */
+		case SNDRV_CTL_POWER_D2: /* partial On */
+			break;
+		case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+			/* everything off except vref/vmid, dac mute, inactive */
+			wm8772_write(codec, WM8772_DACRATE, master | 0x0f);
+			break;
+		case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+			/* everything off, dac mute, inactive */
+			wm8772_write(codec, WM8772_DACRATE, master | 0x1f);
+			break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8772_dai = {
+	.name = "WM8772",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 6,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = wm8772_config_sysclk,
+	.ops = {
+		.prepare = wm8772_pcm_prepare,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8772_modes),
+		.mode = wm8772_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8772_dai);
+
+static int wm8772_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8772_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8772_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8772_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8772_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8772_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8772 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8772_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8772";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8772_read_reg_cache;
+	codec->write = wm8772_write;
+	codec->dapm_event = wm8772_dapm_event;
+	codec->dai = &wm8772_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8772_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8772_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8772_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8772_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8772_reg);
+
+	wm8772_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	wm8772_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* set the update bits */
+	reg = wm8772_read_reg_cache(codec, WM8772_MDACVOL);
+	wm8772_write(codec, WM8772_MDACVOL, reg | 0x0100);
+	reg = wm8772_read_reg_cache(codec, WM8772_LDAC1VOL);
+	wm8772_write(codec, WM8772_LDAC1VOL, reg | 0x0100);
+	reg = wm8772_read_reg_cache(codec, WM8772_LDAC2VOL);
+	wm8772_write(codec, WM8772_LDAC2VOL, reg | 0x0100);
+	reg = wm8772_read_reg_cache(codec, WM8772_LDAC3VOL);
+	wm8772_write(codec, WM8772_LDAC3VOL, reg | 0x0100);
+	reg = wm8772_read_reg_cache(codec, WM8772_RDAC1VOL);
+	wm8772_write(codec, WM8772_RDAC1VOL, reg | 0x0100);
+	reg = wm8772_read_reg_cache(codec, WM8772_RDAC2VOL);
+	wm8772_write(codec, WM8772_RDAC2VOL, reg | 0x0100);
+	reg = wm8772_read_reg_cache(codec, WM8772_RDAC3VOL);
+	wm8772_write(codec, WM8772_RDAC3VOL, reg | 0x0100);
+
+	wm8772_add_controls(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *wm8772_socdev;
+
+static int wm8772_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8772_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	printk(KERN_INFO "WM8772 Audio Codec %s", WM8772_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8772_socdev = socdev;
+
+	/* Add other interfaces here */
+#warning do SPI device probe here and then call wm8772_init()
+
+	return ret;
+}
+
+/* power down chip */
+static int wm8772_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8772_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8772 = {
+	.probe = 	wm8772_probe,
+	.remove = 	wm8772_remove,
+	.suspend = 	wm8772_suspend,
+	.resume =	wm8772_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8772);
+
+MODULE_DESCRIPTION("ASoC WM8772 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8772.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8772.h
@@ -0,0 +1,40 @@
+/*
+ * wm8772.h  --  audio driver for WM8772
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef _WM8772_H
+#define _WM8772_H
+
+/* WM8772 register space */
+
+#define WM8772_LDAC1VOL   0x00
+#define WM8772_RDAC1VOL   0x01
+#define WM8772_DACCH      0x02
+#define WM8772_IFACE      0x03
+#define WM8772_LDAC2VOL   0x04
+#define WM8772_RDAC2VOL   0x05
+#define WM8772_LDAC3VOL   0x06
+#define WM8772_RDAC3VOL   0x07
+#define WM8772_MDACVOL    0x08
+#define WM8772_DACCTRL    0x09
+#define WM8772_DACRATE    0x0a
+#define WM8772_ADCRATE    0x0b
+#define WM8772_ADCCTRL    0x0c
+#define WM8772_RESET	  0x1f
+
+#define WM8772_CACHE_REGNUM 	10
+
+extern struct snd_soc_codec_dai wm8772_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8772;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8971.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8971.c
@@ -0,0 +1,1214 @@
+/*
+ * wm8971.c  --  WM8971 ALSA SoC Audio driver
+ *
+ * Copyright 2005 Lab126, Inc.
+ *
+ * Author: Kenneth Kiraly <kiraly@lab126.com>
+ *
+ * Based on wm8753.c by Liam Girdwood
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8971.h"
+
+#define AUDIO_NAME "wm8971"
+#define WM8971_VERSION "0.8"
+
+#undef	WM8971_DEBUG
+
+#ifdef WM8971_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+#define	WM8971_REG_COUNT		43
+
+static struct workqueue_struct *wm8971_workq = NULL;
+static struct work_struct wm8971_dapm_work;
+
+/*
+ * wm8971 register cache
+ * We can't read the WM8971 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8971_reg[] = {
+	0x0097, 0x0097, 0x0079, 0x0079,  /*  0 */
+	0x0000, 0x0008, 0x0000, 0x000a,  /*  4 */
+	0x0000, 0x0000, 0x00ff, 0x00ff,  /*  8 */
+	0x000f, 0x000f, 0x0000, 0x0000,  /* 12 */
+	0x0000, 0x007b, 0x0000, 0x0032,  /* 16 */
+	0x0000, 0x00c3, 0x00c3, 0x00c0,  /* 20 */
+	0x0000, 0x0000, 0x0000, 0x0000,  /* 24 */
+	0x0000, 0x0000, 0x0000, 0x0000,  /* 28 */
+	0x0000, 0x0000, 0x0050, 0x0050,  /* 32 */
+	0x0050, 0x0050, 0x0050, 0x0050,  /* 36 */
+	0x0079, 0x0079, 0x0079,          /* 40 */
+};
+
+#define WM8971_HIFI_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF)
+
+#define WM8971_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8971_HIFI_FSB \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | \
+	SND_SOC_FSBD(8) | SND_SOC_FSBD(16))
+
+#define WM8971_HIFI_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define WM8971_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_mode wm8971_modes[] = {
+	/* common codec frame and clock master modes */
+	/* 8k */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1536,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1408,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 2304,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 2112,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1500,
+		.bfs = WM8971_HIFI_FSB,
+	},
+
+	/* 11.025k */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1024,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1536,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1088,
+		.bfs = WM8971_HIFI_FSB,
+	},
+
+	/* 16k */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 768,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1152,
+		.bfs = WM8971_HIFI_FSB
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 750,
+		.bfs = WM8971_HIFI_FSB,
+	},
+
+	/* 22.05k */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 512,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 768,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 544,
+		.bfs = WM8971_HIFI_FSB,
+	},
+
+	/* 32k */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 384,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 576,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 375,
+		.bfs = WM8971_HIFI_FSB,
+	},
+
+	/* 44.1k & 48k */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 384,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 272,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 250,
+		.bfs = WM8971_HIFI_FSB,
+	},
+
+	/* 88.2k & 96k */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 128,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 192,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 136,
+		.bfs = WM8971_HIFI_FSB,
+	},
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 125,
+		.bfs = WM8971_HIFI_FSB,
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8971_HIFI_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8971_HIFI_BITS,
+		.pcmrate = WM8971_HIFI_RATES,
+		.pcmdir = WM8971_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+static inline unsigned int wm8971_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg < WM8971_REG_COUNT)
+		return cache[reg];
+
+	return -1;
+}
+
+static inline void wm8971_write_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg < WM8971_REG_COUNT)
+		cache[reg] = value;
+}
+
+static int wm8971_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8753 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8971_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8971_reset(c)	wm8971_write(c, WM8971_RESET, 0)
+
+/* WM8971 Controls */
+static const char *wm8971_bass[] = { "Linear Control", "Adaptive Boost" };
+static const char *wm8971_bass_filter[] = { "130Hz @ 48kHz",
+	"200Hz @ 48kHz" };
+static const char *wm8971_treble[] = { "8kHz", "4kHz" };
+static const char *wm8971_alc_func[] = { "Off", "Right", "Left", "Stereo" };
+static const char *wm8971_ng_type[] = { "Constant PGA Gain",
+	"Mute ADC Output" };
+static const char *wm8971_deemp[] = { "None", "32kHz", "44.1kHz", "48kHz" };
+static const char *wm8971_mono_mux[] = {"Stereo", "Mono (Left)",
+	"Mono (Right)", "Digital Mono"};
+static const char *wm8971_dac_phase[] = { "Non Inverted", "Inverted" };
+static const char *wm8971_lline_mux[] = {"Line", "NC", "NC", "PGA",
+	"Differential"};
+static const char *wm8971_rline_mux[] = {"Line", "Mic", "NC", "PGA",
+	"Differential"};
+static const char *wm8971_lpga_sel[] = {"Line", "NC", "NC", "Differential"};
+static const char *wm8971_rpga_sel[] = {"Line", "Mic", "NC", "Differential"};
+static const char *wm8971_adcpol[] = {"Normal", "L Invert", "R Invert",
+	"L + R Invert"};
+
+static const struct soc_enum wm8971_enum[] = {
+	SOC_ENUM_SINGLE(WM8971_BASS, 7, 2, wm8971_bass),			/* 0 */
+	SOC_ENUM_SINGLE(WM8971_BASS, 6, 2, wm8971_bass_filter),
+	SOC_ENUM_SINGLE(WM8971_TREBLE, 6, 2, wm8971_treble),
+	SOC_ENUM_SINGLE(WM8971_ALC1, 7, 4, wm8971_alc_func),
+	SOC_ENUM_SINGLE(WM8971_NGATE, 1, 2, wm8971_ng_type),        /* 4 */
+	SOC_ENUM_SINGLE(WM8971_ADCDAC, 1, 4, wm8971_deemp),
+	SOC_ENUM_SINGLE(WM8971_ADCTL1, 4, 4, wm8971_mono_mux),
+	SOC_ENUM_SINGLE(WM8971_ADCTL1, 1, 2, wm8971_dac_phase),
+	SOC_ENUM_SINGLE(WM8971_LOUTM1, 0, 5, wm8971_lline_mux),     /* 8 */
+	SOC_ENUM_SINGLE(WM8971_ROUTM1, 0, 5, wm8971_rline_mux),
+	SOC_ENUM_SINGLE(WM8971_LADCIN, 6, 4, wm8971_lpga_sel),
+	SOC_ENUM_SINGLE(WM8971_RADCIN, 6, 4, wm8971_rpga_sel),
+	SOC_ENUM_SINGLE(WM8971_ADCDAC, 5, 4, wm8971_adcpol),        /* 12 */
+	SOC_ENUM_SINGLE(WM8971_ADCIN, 6, 4, wm8971_mono_mux),
+};
+
+static const struct snd_kcontrol_new wm8971_snd_controls[] = {
+	SOC_DOUBLE_R("Capture Volume", WM8971_LINVOL, WM8971_RINVOL, 0, 63, 0),
+	SOC_DOUBLE_R("Capture ZC Switch", WM8971_LINVOL, WM8971_RINVOL, 6, 1, 0),
+	SOC_DOUBLE_R("Capture Switch", WM8971_LINVOL, WM8971_RINVOL, 7, 1, 1),
+
+	SOC_DOUBLE_R("Headphone Playback ZC Switch", WM8971_LOUT1V,
+		WM8971_ROUT1V, 7, 1, 0),
+	SOC_DOUBLE_R("Speaker Playback ZC Switch", WM8971_LOUT2V,
+		WM8971_ROUT2V, 7, 1, 0),
+	SOC_SINGLE("Mono Playback ZC Switch", WM8971_MOUTV, 7, 1, 0),
+
+	SOC_DOUBLE_R("PCM Volume", WM8971_LDAC, WM8971_RDAC, 0, 255, 0),
+
+	SOC_DOUBLE_R("Bypass Left Playback Volume", WM8971_LOUTM1,
+		WM8971_LOUTM2, 4, 7, 1),
+	SOC_DOUBLE_R("Bypass Right Playback Volume", WM8971_ROUTM1,
+		WM8971_ROUTM2, 4, 7, 1),
+	SOC_DOUBLE_R("Bypass Mono Playback Volume", WM8971_MOUTM1,
+		WM8971_MOUTM2, 4, 7, 1),
+
+	SOC_DOUBLE_R("Headphone Playback Volume", WM8971_LOUT1V,
+		WM8971_ROUT1V, 0, 127, 0),
+	SOC_DOUBLE_R("Speaker Playback Volume", WM8971_LOUT2V,
+		WM8971_ROUT2V, 0, 127, 0),
+
+	SOC_ENUM("Bass Boost", wm8971_enum[0]),
+	SOC_ENUM("Bass Filter", wm8971_enum[1]),
+	SOC_SINGLE("Bass Volume", WM8971_BASS, 0, 7, 1),
+
+	SOC_SINGLE("Treble Volume", WM8971_TREBLE, 0, 7, 0),
+	SOC_ENUM("Treble Cut-off", wm8971_enum[2]),
+
+	SOC_SINGLE("Capture Filter Switch", WM8971_ADCDAC, 0, 1, 1),
+
+	SOC_SINGLE("ALC Target Volume", WM8971_ALC1, 0, 7, 0),
+	SOC_SINGLE("ALC Max Volume", WM8971_ALC1, 4, 7, 0),
+
+	SOC_SINGLE("ALC Capture Target Volume", WM8971_ALC1, 0, 7, 0),
+	SOC_SINGLE("ALC Capture Max Volume", WM8971_ALC1, 4, 7, 0),
+	SOC_ENUM("ALC Capture Function", wm8971_enum[3]),
+	SOC_SINGLE("ALC Capture ZC Switch", WM8971_ALC2, 7, 1, 0),
+	SOC_SINGLE("ALC Capture Hold Time", WM8971_ALC2, 0, 15, 0),
+	SOC_SINGLE("ALC Capture Decay Time", WM8971_ALC3, 4, 15, 0),
+	SOC_SINGLE("ALC Capture Attack Time", WM8971_ALC3, 0, 15, 0),
+	SOC_SINGLE("ALC Capture NG Threshold", WM8971_NGATE, 3, 31, 0),
+	SOC_ENUM("ALC Capture NG Type", wm8971_enum[4]),
+	SOC_SINGLE("ALC Capture NG Switch", WM8971_NGATE, 0, 1, 0),
+
+	SOC_SINGLE("Capture 6dB Attenuate", WM8971_ADCDAC, 8, 1, 0),
+	SOC_SINGLE("Playback 6dB Attenuate", WM8971_ADCDAC, 7, 1, 0),
+
+    SOC_ENUM("Playback De-emphasis", wm8971_enum[5]),
+	SOC_ENUM("Playback Function", wm8971_enum[6]),
+	SOC_ENUM("Playback Phase", wm8971_enum[7]),
+
+	SOC_DOUBLE_R("Mic Boost", WM8971_LADCIN, WM8971_RADCIN, 4, 3, 0),
+};
+
+/* add non-DAPM controls */
+static int wm8971_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8971_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8971_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/*
+ * DAPM Controls
+ */
+
+/* Left Mixer */
+static const struct snd_kcontrol_new wm8971_left_mixer_controls[] = {
+SOC_DAPM_SINGLE("Playback Switch", WM8971_LOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8971_LOUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8971_LOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8971_LOUTM2, 7, 1, 0),
+};
+
+/* Right Mixer */
+static const struct snd_kcontrol_new wm8971_right_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left Playback Switch", WM8971_ROUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8971_ROUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Playback Switch", WM8971_ROUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8971_ROUTM2, 7, 1, 0),
+};
+
+/* Mono Mixer */
+static const struct snd_kcontrol_new wm8971_mono_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left Playback Switch", WM8971_MOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8971_MOUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8971_MOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8971_MOUTM2, 7, 1, 0),
+};
+
+/* Left Line Mux */
+static const struct snd_kcontrol_new wm8971_left_line_controls =
+SOC_DAPM_ENUM("Route", wm8971_enum[8]);
+
+/* Right Line Mux */
+static const struct snd_kcontrol_new wm8971_right_line_controls =
+SOC_DAPM_ENUM("Route", wm8971_enum[9]);
+
+/* Left PGA Mux */
+static const struct snd_kcontrol_new wm8971_left_pga_controls =
+SOC_DAPM_ENUM("Route", wm8971_enum[10]);
+
+/* Right PGA Mux */
+static const struct snd_kcontrol_new wm8971_right_pga_controls =
+SOC_DAPM_ENUM("Route", wm8971_enum[11]);
+
+/* Mono ADC Mux */
+static const struct snd_kcontrol_new wm8971_monomux_controls =
+SOC_DAPM_ENUM("Route", wm8971_enum[13]);
+
+static const struct snd_soc_dapm_widget wm8971_dapm_widgets[] = {
+	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
+		&wm8971_left_mixer_controls[0],
+		ARRAY_SIZE(wm8971_left_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
+		&wm8971_right_mixer_controls[0],
+		ARRAY_SIZE(wm8971_right_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Mono Mixer", WM8971_PWR2, 2, 0,
+		&wm8971_mono_mixer_controls[0],
+		ARRAY_SIZE(wm8971_mono_mixer_controls)),
+
+	SND_SOC_DAPM_PGA("Right Out 2", WM8971_PWR2, 3, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 2", WM8971_PWR2, 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Out 1", WM8971_PWR2, 5, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 1", WM8971_PWR2, 6, 0, NULL, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8971_PWR2, 7, 0),
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8971_PWR2, 8, 0),
+	SND_SOC_DAPM_PGA("Mono Out 1", WM8971_PWR2, 2, 0, NULL, 0),
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", WM8971_PWR1, 1, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", WM8971_PWR1, 2, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", WM8971_PWR1, 3, 0),
+
+	SND_SOC_DAPM_MUX("Left PGA Mux", WM8971_PWR1, 5, 0,
+		&wm8971_left_pga_controls),
+	SND_SOC_DAPM_MUX("Right PGA Mux", WM8971_PWR1, 4, 0,
+		&wm8971_right_pga_controls),
+	SND_SOC_DAPM_MUX("Left Line Mux", SND_SOC_NOPM, 0, 0,
+		&wm8971_left_line_controls),
+	SND_SOC_DAPM_MUX("Right Line Mux", SND_SOC_NOPM, 0, 0,
+		&wm8971_right_line_controls),
+
+	SND_SOC_DAPM_MUX("Left ADC Mux", SND_SOC_NOPM, 0, 0,
+		&wm8971_monomux_controls),
+	SND_SOC_DAPM_MUX("Right ADC Mux", SND_SOC_NOPM, 0, 0,
+		&wm8971_monomux_controls),
+
+	SND_SOC_DAPM_OUTPUT("LOUT1"),
+	SND_SOC_DAPM_OUTPUT("ROUT1"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+	SND_SOC_DAPM_OUTPUT("MONO"),
+
+	SND_SOC_DAPM_INPUT("LINPUT1"),
+	SND_SOC_DAPM_INPUT("RINPUT1"),
+	SND_SOC_DAPM_INPUT("MIC"),
+};
+
+static const char *audio_map[][3] = {
+	/* left mixer */
+	{"Left Mixer", "Playback Switch", "Left DAC"},
+	{"Left Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Left Mixer", "Right Playback Switch", "Right DAC"},
+	{"Left Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* right mixer */
+	{"Right Mixer", "Left Playback Switch", "Left DAC"},
+	{"Right Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Right Mixer", "Playback Switch", "Right DAC"},
+	{"Right Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* left out 1 */
+	{"Left Out 1", NULL, "Left Mixer"},
+	{"LOUT1", NULL, "Left Out 1"},
+
+	/* left out 2 */
+	{"Left Out 2", NULL, "Left Mixer"},
+	{"LOUT2", NULL, "Left Out 2"},
+
+	/* right out 1 */
+	{"Right Out 1", NULL, "Right Mixer"},
+	{"ROUT1", NULL, "Right Out 1"},
+
+	/* right out 2 */
+	{"Right Out 2", NULL, "Right Mixer"},
+	{"ROUT2", NULL, "Right Out 2"},
+
+	/* mono mixer */
+	{"Mono Mixer", "Left Playback Switch", "Left DAC"},
+	{"Mono Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Mono Mixer", "Right Playback Switch", "Right DAC"},
+	{"Mono Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* mono out */
+	{"Mono Out", NULL, "Mono Mixer"},
+	{"MONO1", NULL, "Mono Out"},
+
+	/* Left Line Mux */
+	{"Left Line Mux", "Line", "LINPUT1"},
+	{"Left Line Mux", "PGA", "Left PGA Mux"},
+	{"Left Line Mux", "Differential", "Differential Mux"},
+
+	/* Right Line Mux */
+	{"Right Line Mux", "Line", "RINPUT1"},
+	{"Right Line Mux", "Mic", "MIC"},
+	{"Right Line Mux", "PGA", "Right PGA Mux"},
+	{"Right Line Mux", "Differential", "Differential Mux"},
+
+	/* Left PGA Mux */
+	{"Left PGA Mux", "Line", "LINPUT1"},
+	{"Left PGA Mux", "Differential", "Differential Mux"},
+
+	/* Right PGA Mux */
+	{"Right PGA Mux", "Line", "RINPUT1"},
+	{"Right PGA Mux", "Differential", "Differential Mux"},
+
+	/* Differential Mux */
+	{"Differential Mux", "Line", "LINPUT1"},
+	{"Differential Mux", "Line", "RINPUT1"},
+
+	/* Left ADC Mux */
+	{"Left ADC Mux", "Stereo", "Left PGA Mux"},
+	{"Left ADC Mux", "Mono (Left)", "Left PGA Mux"},
+	{"Left ADC Mux", "Digital Mono", "Left PGA Mux"},
+
+	/* Right ADC Mux */
+	{"Right ADC Mux", "Stereo", "Right PGA Mux"},
+	{"Right ADC Mux", "Mono (Right)", "Right PGA Mux"},
+	{"Right ADC Mux", "Digital Mono", "Right PGA Mux"},
+
+	/* ADC */
+	{"Left ADC", NULL, "Left ADC Mux"},
+	{"Right ADC", NULL, "Right ADC Mux"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8971_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8971_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8971_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:5;
+	u8 usb:1;
+};
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 8k */
+	{12288000, 8000, 1536, 0x6, 0x0},
+	{11289600, 8000, 1408, 0x16, 0x0},
+	{18432000, 8000, 2304, 0x7, 0x0},
+	{16934400, 8000, 2112, 0x17, 0x0},
+	{12000000, 8000, 1500, 0x6, 0x1},
+
+	/* 11.025k */
+	{11289600, 11025, 1024, 0x18, 0x0},
+	{16934400, 11025, 1536, 0x19, 0x0},
+	{12000000, 11025, 1088, 0x19, 0x1},
+
+	/* 16k */
+	{12288000, 16000, 768, 0xa, 0x0},
+	{18432000, 16000, 1152, 0xb, 0x0},
+	{12000000, 16000, 750, 0xa, 0x1},
+
+	/* 22.05k */
+	{11289600, 22050, 512, 0x1a, 0x0},
+	{16934400, 22050, 768, 0x1b, 0x0},
+	{12000000, 22050, 544, 0x1b, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0xc, 0x0},
+	{18432000, 32000, 576, 0xd, 0x0},
+	{12000000, 32000, 375, 0xa, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x10, 0x0},
+	{16934400, 44100, 384, 0x11, 0x0},
+	{12000000, 44100, 272, 0x11, 0x1},
+
+	/* 48k */
+	{12288000, 48000, 256, 0x0, 0x0},
+	{18432000, 48000, 384, 0x1, 0x0},
+	{12000000, 48000, 250, 0x0, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0x1e, 0x0},
+	{16934400, 88200, 192, 0x1f, 0x0},
+	{12000000, 88200, 136, 0x1f, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0xe, 0x0},
+	{18432000, 96000, 192, 0xf, 0x0},
+	{12000000, 96000, 125, 0xe, 0x1},
+};
+
+static int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+	return -EINVAL;
+}
+
+/* WM8971 supports numerous input clocks per sample rate */
+static unsigned int wm8971_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	dai->mclk = 0;
+
+	/* check that the calculated FS and rate actually match a clock from
+	 * the machine driver */
+	if (info->fs * info->rate == clk)
+		dai->mclk = clk;
+
+	return dai->mclk;
+}
+
+static int wm8971_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 iface = 0, bfs, srate = 0;
+	int i = get_coeff(rtd->codec_dai->mclk,
+		snd_soc_get_rate(rtd->codec_dai->dai_runtime.pcmrate));
+
+	/* is coefficient valid ? */
+	if (i < 0)
+		return i;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		iface |= 0x0004;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		iface |= 0x0008;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		iface |= 0x000c;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	}
+
+	/* set bclk divisor rate */
+	switch (bfs) {
+	case 1:
+		break;
+	case 4:
+		srate |= (0x1 << 7);
+		break;
+	case 8:
+		srate |= (0x2 << 7);
+		break;
+	case 16:
+		srate |= (0x3 << 7);
+		break;
+	}
+
+	/* set iface & srate */
+	wm8971_write(codec, WM8971_AUDIO, iface);
+	wm8971_write(codec, WM8971_SRATE, srate |
+		(coeff_div[i].sr << 1) | coeff_div[i].usb);
+	return 0;
+}
+
+static int wm8971_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8971_read_reg_cache(codec, WM8971_ADCDAC) & 0xfff7;
+	if (mute)
+		wm8971_write(codec, WM8971_ADCDAC, mute_reg | 0x8);
+	else
+		wm8971_write(codec, WM8971_ADCDAC, mute_reg);
+	return 0;
+}
+
+static int wm8971_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 pwr_reg = wm8971_read_reg_cache(codec, WM8971_PWR1) & 0xfe3e;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* set vmid to 50k and unmute dac */
+		wm8971_write(codec, WM8971_PWR1, pwr_reg | 0x00c1);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		/* set vmid to 5k for quick power up */
+		wm8971_write(codec, WM8971_PWR1, pwr_reg | 0x01c0);
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* mute dac and set vmid to 500k, enable VREF */
+		wm8971_write(codec, WM8971_PWR1, pwr_reg | 0x0140);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		wm8971_write(codec, WM8971_PWR1, 0x0001);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8971_dai = {
+	.name = "WM8971",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = wm8971_config_sysclk,
+	.digital_mute = wm8971_mute,
+	.ops = {
+		.prepare = wm8971_pcm_prepare,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8971_modes),
+		.mode = wm8971_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8971_dai);
+
+static void wm8971_work(void *data)
+{
+	struct snd_soc_codec *codec = (struct snd_soc_codec *)data;
+	wm8971_dapm_event(codec, codec->dapm_state);
+}
+
+static int wm8971_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8971_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8971_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8971_reg); i++) {
+		if (i + 1 == WM8971_RESET)
+			continue;
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+
+	wm8971_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* charge wm8971 caps */
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0) {
+		wm8971_dapm_event(codec, SNDRV_CTL_POWER_D2);
+		codec->dapm_state = SNDRV_CTL_POWER_D0;
+		queue_delayed_work(wm8971_workq, &wm8971_dapm_work,
+			msecs_to_jiffies(1000));
+	}
+
+	return 0;
+}
+
+static int wm8971_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8971";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8971_read_reg_cache;
+	codec->write = wm8971_write;
+	codec->dapm_event = wm8971_dapm_event;
+	codec->dai = &wm8971_dai;
+	codec->reg_cache_size = ARRAY_SIZE(wm8971_reg);
+	codec->num_dai = 1;
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8971_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8971_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8971_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8971_reg);
+
+	wm8971_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* charge output caps */
+	wm8971_dapm_event(codec, SNDRV_CTL_POWER_D2);
+	codec->dapm_state = SNDRV_CTL_POWER_D3hot;
+	queue_delayed_work(wm8971_workq, &wm8971_dapm_work,
+		msecs_to_jiffies(1000));
+
+	/* set the update bits */
+	reg = wm8971_read_reg_cache(codec, WM8971_LDAC);
+	wm8971_write(codec, WM8971_LDAC, reg | 0x0100);
+	reg = wm8971_read_reg_cache(codec, WM8971_RDAC);
+	wm8971_write(codec, WM8971_RDAC, reg | 0x0100);
+
+	reg = wm8971_read_reg_cache(codec, WM8971_LOUT1V);
+	wm8971_write(codec, WM8971_LOUT1V, reg | 0x0100);
+	reg = wm8971_read_reg_cache(codec, WM8971_ROUT1V);
+	wm8971_write(codec, WM8971_ROUT1V, reg | 0x0100);
+
+	reg = wm8971_read_reg_cache(codec, WM8971_LOUT2V);
+	wm8971_write(codec, WM8971_LOUT2V, reg | 0x0100);
+	reg = wm8971_read_reg_cache(codec, WM8971_ROUT2V);
+	wm8971_write(codec, WM8971_ROUT2V, reg | 0x0100);
+
+	reg = wm8971_read_reg_cache(codec, WM8971_LINVOL);
+	wm8971_write(codec, WM8971_LINVOL, reg | 0x0100);
+	reg = wm8971_read_reg_cache(codec, WM8971_RINVOL);
+	wm8971_write(codec, WM8971_RINVOL, reg | 0x0100);
+
+	wm8971_add_controls(codec);
+	wm8971_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static struct snd_soc_device *wm8971_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8731 2 wire address is determined by GPIO5
+ * state during powerup.
+ *    low  = 0x1a
+ *    high = 0x1b
+ */
+#define I2C_DRIVERID_WM8971 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8971_i2c_driver;
+static struct i2c_client client_template;
+
+static int wm8971_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8971_socdev;
+	struct wm8971_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+
+	i2c_set_clientdata(i2c, codec);
+
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8971_init(socdev);
+	if (ret < 0) {
+		err("failed to initialise WM8971\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8971_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec* codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8971_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8971_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8971_i2c_driver = {
+	.driver = {
+		.name = "WM8971 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8971,
+	.attach_adapter = wm8971_i2c_attach,
+	.detach_client =  wm8971_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8971",
+	.driver = &wm8971_i2c_driver,
+};
+#endif
+
+static int wm8971_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8971_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8971 Audio Codec %s", WM8971_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	wm8971_socdev = socdev;
+
+	INIT_WORK(&wm8971_dapm_work, wm8971_work, codec);
+	wm8971_workq = create_workqueue("wm8971");
+	if (wm8971_workq == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8971_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+		/* Add other interfaces here */
+#endif
+
+	return ret;
+}
+
+/* power down chip */
+static int wm8971_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8971_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	if (wm8971_workq)
+		destroy_workqueue(wm8971_workq);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8971_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8971 = {
+	.probe = 	wm8971_probe,
+	.remove = 	wm8971_remove,
+	.suspend = 	wm8971_suspend,
+	.resume =	wm8971_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8971);
+
+MODULE_DESCRIPTION("ASoC WM8971 driver");
+MODULE_AUTHOR("Lab126");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8971.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8971.h
@@ -0,0 +1,61 @@
+/*
+ * wm8971.h  --  audio driver for WM8971
+ *
+ * Copyright 2005 Lab126, Inc.
+ *
+ * Author: Kenneth Kiraly <kiraly@lab126.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _WM8971_H
+#define _WM8971_H
+
+#define WM8971_LINVOL	0x00
+#define WM8971_RINVOL	0x01
+#define WM8971_LOUT1V	0x02
+#define WM8971_ROUT1V	0x03
+#define WM8971_ADCDAC	0x05
+#define WM8971_AUDIO	0x07
+#define WM8971_SRATE	0x08
+#define WM8971_LDAC		0x0a
+#define WM8971_RDAC		0x0b
+#define WM8971_BASS		0x0c
+#define WM8971_TREBLE	0x0d
+#define WM8971_RESET	0x0f
+#define WM8971_ALC1		0x11
+#define	WM8971_ALC2		0x12
+#define	WM8971_ALC3		0x13
+#define WM8971_NGATE	0x14
+#define WM8971_LADC		0x15
+#define WM8971_RADC		0x16
+#define	WM8971_ADCTL1	0x17
+#define	WM8971_ADCTL2	0x18
+#define WM8971_PWR1		0x19
+#define WM8971_PWR2		0x1a
+#define	WM8971_ADCTL3	0x1b
+#define WM8971_ADCIN	0x1f
+#define	WM8971_LADCIN	0x20
+#define	WM8971_RADCIN	0x21
+#define WM8971_LOUTM1	0x22
+#define WM8971_LOUTM2	0x23
+#define WM8971_ROUTM1	0x24
+#define WM8971_ROUTM2	0x25
+#define WM8971_MOUTM1	0x26
+#define WM8971_MOUTM2	0x27
+#define WM8971_LOUT2V	0x28
+#define WM8971_ROUT2V	0x29
+#define WM8971_MOUTV	0x2A
+
+struct wm8971_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8971_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8971;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8974.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8974.c
@@ -0,0 +1,935 @@
+/*
+ * wm8974.c  --  WM8974 ALSA Soc Audio driver
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8974.h"
+
+#define AUDIO_NAME "wm8974"
+#define WM8974_VERSION "0.5"
+
+/*
+ * Debug
+ */
+
+#define WM8974_DEBUG 0
+
+#ifdef WM8974_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+struct snd_soc_codec_device soc_codec_dev_wm8974;
+
+/*
+ * wm8974 register cache
+ * We can't read the WM8974 register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8974_reg[WM8974_CACHEREGNUM] = {
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0050, 0x0000, 0x0140, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x00ff,
+    0x0000, 0x0000, 0x0100, 0x00ff,
+    0x0000, 0x0000, 0x012c, 0x002c,
+    0x002c, 0x002c, 0x002c, 0x0000,
+    0x0032, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0038, 0x000b, 0x0032, 0x0000,
+    0x0008, 0x000c, 0x0093, 0x00e9,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0003, 0x0010, 0x0000, 0x0000,
+    0x0000, 0x0002, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0039, 0x0000,
+    0x0000,
+};
+
+#define WM8974_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF)
+
+#define WM8974_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8974_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+#define WM8794_BCLK \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | SND_SOC_FSBD(8) |\
+	 SND_SOC_FSBD(16) | SND_SOC_FSBD(32))
+
+#define WM8794_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_mode wm8974_modes[] = {
+	/* codec frame and clock master modes */
+	{
+		.fmt = WM8974_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8794_HIFI_BITS,
+		.pcmrate = WM8974_RATES,
+		.pcmdir = WM8974_DIR,
+		.fs = 256,
+		.bfs = WM8794_BCLK,
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8974_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8794_HIFI_BITS,
+		.pcmrate = WM8974_RATES,
+		.pcmdir = WM8974_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8974 register cache
+ */
+static inline unsigned int wm8974_read_reg_cache(struct snd_soc_codec * codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == WM8974_RESET)
+		return 0;
+	if (reg >= WM8974_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8974 register cache
+ */
+static inline void wm8974_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= WM8974_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8974 register space
+ */
+static int wm8974_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8974 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8974_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8974_reset(c)	wm8974_write(c, WM8974_RESET, 0)
+
+static const char *wm8974_companding[] = {"Off", "NC", "u-law", "A-law" };
+static const char *wm8974_deemp[] = {"None", "32kHz", "44.1kHz", "48kHz" };
+static const char *wm8974_eqmode[] = {"Capture", "Playback" };
+static const char *wm8974_bw[] = {"Narrow", "Wide" };
+static const char *wm8974_eq1[] = {"80Hz", "105Hz", "135Hz", "175Hz" };
+static const char *wm8974_eq2[] = {"230Hz", "300Hz", "385Hz", "500Hz" };
+static const char *wm8974_eq3[] = {"650Hz", "850Hz", "1.1kHz", "1.4kHz" };
+static const char *wm8974_eq4[] = {"1.8kHz", "2.4kHz", "3.2kHz", "4.1kHz" };
+static const char *wm8974_eq5[] = {"5.3kHz", "6.9kHz", "9kHz", "11.7kHz" };
+static const char *wm8974_alc[] = {"ALC", "Limiter" };
+
+static const struct soc_enum wm8974_enum[] = {
+	SOC_ENUM_SINGLE(WM8974_COMP, 1, 4, wm8974_companding), /* adc */
+	SOC_ENUM_SINGLE(WM8974_COMP, 3, 4, wm8974_companding), /* dac */
+	SOC_ENUM_SINGLE(WM8974_DAC,  4, 4, wm8974_deemp),
+	SOC_ENUM_SINGLE(WM8974_EQ1,  8, 2, wm8974_eqmode),
+
+	SOC_ENUM_SINGLE(WM8974_EQ1,  5, 4, wm8974_eq1),
+	SOC_ENUM_SINGLE(WM8974_EQ2,  8, 2, wm8974_bw),
+	SOC_ENUM_SINGLE(WM8974_EQ2,  5, 4, wm8974_eq2),
+	SOC_ENUM_SINGLE(WM8974_EQ3,  8, 2, wm8974_bw),
+
+	SOC_ENUM_SINGLE(WM8974_EQ3,  5, 4, wm8974_eq3),
+	SOC_ENUM_SINGLE(WM8974_EQ4,  8, 2, wm8974_bw),
+	SOC_ENUM_SINGLE(WM8974_EQ4,  5, 4, wm8974_eq4),
+	SOC_ENUM_SINGLE(WM8974_EQ5,  8, 2, wm8974_bw),
+
+	SOC_ENUM_SINGLE(WM8974_EQ5,  5, 4, wm8974_eq5),
+	SOC_ENUM_SINGLE(WM8974_ALC3,  8, 2, wm8974_alc),
+};
+
+static const struct snd_kcontrol_new wm8974_snd_controls[] = {
+
+SOC_SINGLE("Digital Loopback Switch", WM8974_COMP, 0, 1, 0),
+
+SOC_ENUM("DAC Companding", wm8974_enum[1]),
+SOC_ENUM("ADC Companding", wm8974_enum[0]),
+
+SOC_ENUM("Playback De-emphasis", wm8974_enum[2]),
+SOC_SINGLE("DAC Inversion Switch", WM8974_DAC, 0, 1, 0),
+
+SOC_SINGLE("PCM Volume", WM8974_DACVOL, 0, 127, 0),
+
+SOC_SINGLE("High Pass Filter Switch", WM8974_ADC, 8, 1, 0),
+SOC_SINGLE("High Pass Cut Off", WM8974_ADC, 4, 7, 0),
+SOC_SINGLE("ADC Inversion Switch", WM8974_COMP, 0, 1, 0),
+
+SOC_SINGLE("Capture Volume", WM8974_ADCVOL,  0, 127, 0),
+
+SOC_ENUM("Equaliser Function", wm8974_enum[3]),
+SOC_ENUM("EQ1 Cut Off", wm8974_enum[4]),
+SOC_SINGLE("EQ1 Volume", WM8974_EQ1,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ2 Bandwith", wm8974_enum[5]),
+SOC_ENUM("EQ2 Cut Off", wm8974_enum[6]),
+SOC_SINGLE("EQ2 Volume", WM8974_EQ2,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ3 Bandwith", wm8974_enum[7]),
+SOC_ENUM("EQ3 Cut Off", wm8974_enum[8]),
+SOC_SINGLE("EQ3 Volume", WM8974_EQ3,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ4 Bandwith", wm8974_enum[9]),
+SOC_ENUM("EQ4 Cut Off", wm8974_enum[10]),
+SOC_SINGLE("EQ4 Volume", WM8974_EQ4,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ5 Bandwith", wm8974_enum[11]),
+SOC_ENUM("EQ5 Cut Off", wm8974_enum[12]),
+SOC_SINGLE("EQ5 Volume", WM8974_EQ5,  0, 31, 1),
+
+SOC_SINGLE("DAC Playback Limiter Switch", WM8974_DACLIM1,  8, 1, 0),
+SOC_SINGLE("DAC Playback Limiter Decay", WM8974_DACLIM1,  4, 15, 0),
+SOC_SINGLE("DAC Playback Limiter Attack", WM8974_DACLIM1,  0, 15, 0),
+
+SOC_SINGLE("DAC Playback Limiter Threshold", WM8974_DACLIM2,  4, 7, 0),
+SOC_SINGLE("DAC Playback Limiter Boost", WM8974_DACLIM2,  0, 15, 0),
+
+SOC_SINGLE("ALC Enable Switch", WM8974_ALC1,  8, 1, 0),
+SOC_SINGLE("ALC Capture Max Gain", WM8974_ALC1,  3, 7, 0),
+SOC_SINGLE("ALC Capture Min Gain", WM8974_ALC1,  0, 7, 0),
+
+SOC_SINGLE("ALC Capture ZC Switch", WM8974_ALC2,  8, 1, 0),
+SOC_SINGLE("ALC Capture Hold", WM8974_ALC2,  4, 7, 0),
+SOC_SINGLE("ALC Capture Target", WM8974_ALC2,  0, 15, 0),
+
+SOC_ENUM("ALC Capture Mode", wm8974_enum[13]),
+SOC_SINGLE("ALC Capture Decay", WM8974_ALC3,  4, 15, 0),
+SOC_SINGLE("ALC Capture Attack", WM8974_ALC3,  0, 15, 0),
+
+SOC_SINGLE("ALC Capture Noise Gate Switch", WM8974_NGATE,  3, 1, 0),
+SOC_SINGLE("ALC Capture Noise Gate Threshold", WM8974_NGATE,  0, 7, 0),
+
+SOC_SINGLE("Capture PGA ZC Switch", WM8974_INPPGA,  7, 1, 0),
+SOC_SINGLE("Capture PGA Volume", WM8974_INPPGA,  0, 63, 0),
+
+SOC_SINGLE("Speaker Playback ZC Switch", WM8974_SPKVOL,  7, 1, 0),
+SOC_SINGLE("Speaker Playback Switch", WM8974_SPKVOL,  6, 1, 1),
+SOC_SINGLE("Speaker Playback Volume", WM8974_SPKVOL,  0, 63, 0),
+
+SOC_SINGLE("Capture Boost(+20dB)", WM8974_ADCBOOST,  8, 1, 0),
+SOC_SINGLE("Mono Playback Switch", WM8974_MONOMIX, 6, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm8974_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8974_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8974_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Speaker Output Mixer */
+static const struct snd_kcontrol_new wm8974_speaker_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8974_SPKMIX, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8974_SPKMIX, 5, 1, 0),
+SOC_DAPM_SINGLE("PCM Playback Switch", WM8974_SPKMIX, 0, 1, 1),
+};
+
+/* Mono Output Mixer */
+static const struct snd_kcontrol_new wm8974_mono_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8974_MONOMIX, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8974_MONOMIX, 2, 1, 0),
+SOC_DAPM_SINGLE("PCM Playback Switch", WM8974_MONOMIX, 0, 1, 1),
+};
+
+/* AUX Input boost vol */
+static const struct snd_kcontrol_new wm8974_aux_boost_controls =
+SOC_DAPM_SINGLE("Aux Volume", WM8974_ADCBOOST, 0, 7, 0);
+
+/* Mic Input boost vol */
+static const struct snd_kcontrol_new wm8974_mic_boost_controls =
+SOC_DAPM_SINGLE("Mic Volume", WM8974_ADCBOOST, 4, 7, 0);
+
+/* Capture boost switch */
+static const struct snd_kcontrol_new wm8974_capture_boost_controls =
+SOC_DAPM_SINGLE("Capture Boost Switch", WM8974_INPPGA,  6, 1, 0);
+
+/* Aux In to PGA */
+static const struct snd_kcontrol_new wm8974_aux_capture_boost_controls =
+SOC_DAPM_SINGLE("Aux Capture Boost Switch", WM8974_INPPGA,  2, 1, 0);
+
+/* Mic P In to PGA */
+static const struct snd_kcontrol_new wm8974_micp_capture_boost_controls =
+SOC_DAPM_SINGLE("Mic P Capture Boost Switch", WM8974_INPPGA,  0, 1, 0);
+
+/* Mic N In to PGA */
+static const struct snd_kcontrol_new wm8974_micn_capture_boost_controls =
+SOC_DAPM_SINGLE("Mic N Capture Boost Switch", WM8974_INPPGA,  1, 1, 0);
+
+static const struct snd_soc_dapm_widget wm8974_dapm_widgets[] = {
+SND_SOC_DAPM_MIXER("Speaker Mixer", WM8974_POWER3, 2, 0,
+	&wm8974_speaker_mixer_controls[0],
+	ARRAY_SIZE(wm8974_speaker_mixer_controls)),
+SND_SOC_DAPM_MIXER("Mono Mixer", WM8974_POWER3, 3, 0,
+	&wm8974_mono_mixer_controls[0],
+	ARRAY_SIZE(wm8974_mono_mixer_controls)),
+SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8974_POWER3, 0, 0),
+SND_SOC_DAPM_ADC("ADC", "HiFi Capture", WM8974_POWER3, 0, 0),
+SND_SOC_DAPM_PGA("Aux Input", WM8974_POWER1, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkN Out", WM8974_POWER3, 5, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkP Out", WM8974_POWER3, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mono Out", WM8974_POWER3, 7, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mic PGA", WM8974_POWER2, 2, 0, NULL, 0),
+
+SND_SOC_DAPM_PGA("Aux Boost", SND_SOC_NOPM, 0, 0,
+	&wm8974_aux_boost_controls, 1),
+SND_SOC_DAPM_PGA("Mic Boost", SND_SOC_NOPM, 0, 0,
+	&wm8974_mic_boost_controls, 1),
+SND_SOC_DAPM_SWITCH("Capture Boost", SND_SOC_NOPM, 0, 0,
+	&wm8974_capture_boost_controls),
+
+SND_SOC_DAPM_MIXER("Boost Mixer", WM8974_POWER2, 4, 0, NULL, 0),
+
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8974_POWER1, 4, 0),
+
+SND_SOC_DAPM_INPUT("MICN"),
+SND_SOC_DAPM_INPUT("MICP"),
+SND_SOC_DAPM_INPUT("AUX"),
+SND_SOC_DAPM_OUTPUT("MONOOUT"),
+SND_SOC_DAPM_OUTPUT("SPKOUTP"),
+SND_SOC_DAPM_OUTPUT("SPKOUTN"),
+};
+
+static const char *audio_map[][3] = {
+	/* Mono output mixer */
+	{"Mono Mixer", "PCM Playback Switch", "DAC"},
+	{"Mono Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Mono Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Speaker output mixer */
+	{"Speaker Mixer", "PCM Playback Switch", "DAC"},
+	{"Speaker Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Speaker Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Outputs */
+	{"Mono Out", NULL, "Mono Mixer"},
+	{"MONOOUT", NULL, "Mono Out"},
+	{"SpkN Out", NULL, "Speaker Mixer"},
+	{"SpkP Out", NULL, "Speaker Mixer"},
+	{"SPKOUTN", NULL, "SpkN Out"},
+	{"SPKOUTP", NULL, "SpkP Out"},
+
+	/* Boost Mixer */
+	{"Boost Mixer", NULL, "ADC"},
+    {"Capture Boost Switch", "Aux Capture Boost Switch", "AUX"},
+	{"Aux Boost", "Aux Volume", "Boost Mixer"},
+    {"Capture Boost", "Capture Switch", "Boost Mixer"},
+	{"Mic Boost", "Mic Volume", "Boost Mixer"},
+
+	/* Inputs */
+	{"MICP", NULL, "Mic Boost"},
+	{"MICN", NULL, "Mic PGA"},
+	{"Mic PGA", NULL, "Capture Boost"},
+	{"AUX", NULL, "Aux Input"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8974_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8974_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8974_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct pll_ {
+	unsigned int in_hz, out_hz;
+	unsigned int pre:4; /* prescale - 1 */
+	unsigned int n:4;
+	unsigned int k;
+};
+
+struct pll_ pll[] = {
+	{12000000, 11289600, 0, 7, 0x86c220},
+	{12000000, 12288000, 0, 8, 0x3126e8},
+	{13000000, 11289600, 0, 6, 0xf28bd4},
+	{13000000, 12288000, 0, 7, 0x8fd525},
+	{12288000, 11289600, 0, 7, 0x59999a},
+	{11289600, 12288000, 0, 8, 0x80dee9},
+	/* liam - add more entries */
+};
+
+static int set_pll(struct snd_soc_codec *codec, unsigned int in,
+	unsigned int out)
+{
+	int i;
+	u16 reg;
+
+	if(out == 0) {
+		reg = wm8974_read_reg_cache(codec, WM8974_POWER1);
+		wm8974_write(codec, WM8974_POWER1, reg & 0x1df);
+		return 0;
+	}
+
+	for(i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (in == pll[i].in_hz && out == pll[i].out_hz) {
+			wm8974_write(codec, WM8974_PLLN, (pll[i].pre << 4) | pll[i].n);
+			wm8974_write(codec, WM8974_PLLK1, pll[i].k >> 18);
+			wm8974_write(codec, WM8974_PLLK1, (pll[i].k >> 9) && 0x1ff);
+			wm8974_write(codec, WM8974_PLLK1, pll[i].k && 0x1ff);
+			reg = wm8974_read_reg_cache(codec, WM8974_POWER1);
+			wm8974_write(codec, WM8974_POWER1, reg | 0x020);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/* mclk dividers * 2 */
+static unsigned char mclk_div[] = {2, 3, 4, 6, 8, 12, 16, 24};
+
+/* we need 256FS to drive the DAC's and ADC's */
+static unsigned int wm8974_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	int i, j, best_clk = info->fs * info->rate;
+
+	/* can we run at this clk without the PLL ? */
+	for (i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if ((best_clk >> 1) * mclk_div[i] == clk) {
+			dai->pll_in = 0;
+			dai->clk_div = mclk_div[i];
+			dai->mclk = best_clk;
+			return dai->mclk;
+		}
+	}
+
+	/* now check for PLL support */
+	for (i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (pll[i].in_hz == clk) {
+			for (j = 0; j < ARRAY_SIZE(mclk_div); j++) {
+				if (pll[i].out_hz == mclk_div[j] * (best_clk >> 1)) {
+					dai->pll_in = clk;
+					dai->pll_out = pll[i].out_hz;
+					dai->clk_div = mclk_div[j];
+					dai->mclk = best_clk;
+					return dai->mclk;
+				}
+			}
+		}
+	}
+
+	/* this clk is not supported */
+	return 0;
+}
+
+static int wm8974_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *dai = rtd->codec_dai;
+	u16 iface = 0, bfs, clk = 0, adn;
+	int fs = 48000 << 7, i;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+	switch (bfs) {
+	case 2:
+		clk |= 0x1 << 2;
+		break;
+	case 4:
+		clk |= 0x2 << 2;
+		break;
+	case 8:
+		clk |= 0x3 << 2;
+		break;
+	case 16:
+		clk |= 0x4 << 2;
+		break;
+	case 32:
+		clk |= 0x5 << 2;
+		break;
+	}
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clk |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0010;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0008;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x00018;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		iface |= 0x0020;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		iface |= 0x0040;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		iface |= 0x0060;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0180;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0100;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0080;
+		break;
+	}
+
+	/* filter coefficient */
+	adn = wm8974_read_reg_cache(codec, WM8974_ADD) & 0x1f1;
+	switch (rtd->codec_dai->dai_runtime.pcmrate) {
+	case SNDRV_PCM_RATE_8000:
+		adn |= 0x5 << 1;
+		fs = 8000 << 7;
+		break;
+	case SNDRV_PCM_RATE_11025:
+		adn |= 0x4 << 1;
+		fs = 11025 << 7;
+		break;
+	case SNDRV_PCM_RATE_16000:
+		adn |= 0x3 << 1;
+		fs = 16000 << 7;
+		break;
+	case SNDRV_PCM_RATE_22050:
+		adn |= 0x2 << 1;
+		fs = 22050 << 7;
+		break;
+	case SNDRV_PCM_RATE_32000:
+		adn |= 0x1 << 1;
+		fs = 32000 << 7;
+		break;
+	case SNDRV_PCM_RATE_44100:
+		fs = 44100 << 7;
+		break;
+	}
+
+	/* do we need to enable the PLL */
+	if(dai->pll_in)
+		set_pll(codec, dai->pll_in, dai->pll_out);
+
+	/* divide the clock to 256 fs */
+	for(i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if (dai->clk_div == mclk_div[i]) {
+			clk |= i << 5;
+			clk &= 0xff;
+			goto set;
+		}
+	}
+
+set:
+	/* set iface */
+	wm8974_write(codec, WM8974_IFACE, iface);
+	wm8974_write(codec, WM8974_CLOCK, clk);
+
+	return 0;
+}
+
+static int wm8974_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	set_pll(codec, 0, 0);
+	return 0;
+}
+
+static int wm8974_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8974_read_reg_cache(codec, WM8974_DAC) & 0xffbf;
+	if(mute)
+		wm8974_write(codec, WM8974_DAC, mute_reg | 0x40);
+	else
+		wm8974_write(codec, WM8974_DAC, mute_reg);
+	return 0;
+}
+
+/* liam need to make this lower power with dapm */
+static int wm8974_dapm_event(struct snd_soc_codec *codec, int event)
+{
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* vref/mid, clk and osc on, dac unmute, active */
+		wm8974_write(codec, WM8974_POWER1, 0x1ff);
+		wm8974_write(codec, WM8974_POWER2, 0x1ff);
+		wm8974_write(codec, WM8974_POWER3, 0x1ff);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, dac mute, inactive */
+
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, dac mute, inactive */
+		wm8974_write(codec, WM8974_POWER1, 0x0);
+		wm8974_write(codec, WM8974_POWER2, 0x0);
+		wm8974_write(codec, WM8974_POWER3, 0x0);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8974_dai = {
+	.name = "WM8974 HiFi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 1,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+	},
+	.config_sysclk = wm8974_config_sysclk,
+	.digital_mute = wm8974_mute,
+	.ops = {
+		.prepare = wm8974_pcm_prepare,
+		.hw_free = wm8974_hw_free,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8974_modes),
+		.mode = wm8974_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8974_dai);
+
+static int wm8974_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8974_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8974_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8974_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8974_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8974_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8974 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8974_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "WM8974";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8974_read_reg_cache;
+	codec->write = wm8974_write;
+	codec->dapm_event = wm8974_dapm_event;
+	codec->dai = &wm8974_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8974_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8974_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8974_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8974_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8974_reg);
+
+	wm8974_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	wm8974_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8974_add_controls(codec);
+	wm8974_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if(ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *wm8974_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8974 2 wire address is 0x1a
+ */
+#define I2C_DRIVERID_WM8974 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8974_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int wm8974_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8974_socdev;
+	struct wm8974_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if(ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8974_init(socdev);
+	if(ret < 0) {
+		err("failed to initialise WM8974\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8974_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8974_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8974_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8974_i2c_driver = {
+	.driver = {
+		.name = "WM8974 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8974,
+	.attach_adapter = wm8974_i2c_attach,
+	.detach_client =  wm8974_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8974",
+	.driver = &wm8974_i2c_driver,
+};
+#endif
+
+static int wm8974_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8974_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8974 Audio Codec %s", WM8974_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8974_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8974_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8974_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8974_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8974_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8974 = {
+	.probe = 	wm8974_probe,
+	.remove = 	wm8974_remove,
+	.suspend = 	wm8974_suspend,
+	.resume =	wm8974_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8974);
+
+MODULE_DESCRIPTION("ASoC WM8974 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8974.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8974.h
@@ -0,0 +1,64 @@
+/*
+ * wm8974.h  --  WM8974 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8974_H
+#define _WM8974_H
+
+/* WM8974 register space */
+
+#define WM8974_RESET		0x0
+#define WM8974_POWER1		0x1
+#define WM8974_POWER2		0x2
+#define WM8974_POWER3		0x3
+#define WM8974_IFACE		0x4
+#define WM8974_COMP			0x5
+#define WM8974_CLOCK		0x6
+#define WM8974_ADD			0x7
+#define WM8974_GPIO			0x8
+#define WM8974_DAC			0xa
+#define WM8974_DACVOL		0xb
+#define WM8974_ADC			0xe
+#define WM8974_ADCVOL		0xf
+#define WM8974_EQ1			0x12
+#define WM8974_EQ2			0x13
+#define WM8974_EQ3			0x14
+#define WM8974_EQ4			0x15
+#define WM8974_EQ5			0x16
+#define WM8974_DACLIM1		0x18
+#define WM8974_DACLIM2		0x19
+#define WM8974_NOTCH1		0x1b
+#define WM8974_NOTCH2		0x1c
+#define WM8974_NOTCH3		0x1d
+#define WM8974_NOTCH4		0x1e
+#define WM8974_ALC1			0x20
+#define WM8974_ALC2			0x21
+#define WM8974_ALC3			0x22
+#define WM8974_NGATE		0x23
+#define WM8974_PLLN			0x24
+#define WM8974_PLLK1		0x25
+#define WM8974_PLLK2		0x26
+#define WM8974_PLLK3		0x27
+#define WM8974_ATTEN		0x28
+#define WM8974_INPUT		0x2c
+#define WM8974_INPPGA		0x2d
+#define WM8974_ADCBOOST		0x2f
+#define WM8974_OUTPUT		0x31
+#define WM8974_SPKMIX		0x32
+#define WM8974_SPKVOL		0x36
+#define WM8974_MONOMIX		0x38
+
+#define WM8974_CACHEREGNUM 	57
+
+struct wm8974_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8974_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8974;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm9712.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm9712.c
@@ -0,0 +1,781 @@
+/*
+ * wm9712.c  --  ALSA Soc WM9712 codec support
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    4th Feb 2006   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#define WM9712_VERSION "0.4"
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg);
+static int ac97_write(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int val);
+
+#define AC97_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define AC97_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+/* may need to expand this */
+static struct snd_soc_dai_mode ac97_modes[] = {
+	{
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE,
+		.pcmrate = AC97_RATES,
+		.pcmdir = AC97_DIR,
+	},
+};
+
+/*
+ * WM9712 register cache
+ */
+static const u16 wm9712_reg[] = {
+	0x6174, 0x8000, 0x8000, 0x8000, // 6
+	0xf0f0, 0xaaa0, 0xc008, 0x6808, // e
+	0xe808, 0xaaa0, 0xad00, 0x8000, // 16
+	0xe808, 0x3000, 0x8000, 0x0000, // 1e
+	0x0000, 0x0000, 0x0000, 0x000f, // 26
+	0x0405, 0x0410, 0xbb80, 0xbb80, // 2e
+	0x0000, 0xbb80, 0x0000, 0x0000, // 36
+	0x0000, 0x2000, 0x0000, 0x0000, // 3e
+	0x0000, 0x0000, 0x0000, 0x0000, // 46
+	0x0000, 0x0000, 0xf83e, 0xffff, // 4e
+	0x0000, 0x0000, 0x0000, 0xf83e, // 56
+	0x0008, 0x0000, 0x0000, 0x0000, // 5e
+	0xb032, 0x3e00, 0x0000, 0x0000, // 66
+	0x0000, 0x0000, 0x0000, 0x0000, // 6e
+	0x0000, 0x0000, 0x0000, 0x0006, // 76
+	0x0001, 0x0000, 0x574d, 0x4c12, // 7e
+	0x0000, 0x0000 // virtual hp mixers
+};
+
+/* virtual HP mixers regs */
+#define HPL_MIXER	0x80
+#define HPR_MIXER	0x82
+
+static const char *wm9712_alc_select[] = {"None", "Left", "Right", "Stereo"};
+static const char *wm9712_alc_mux[] = {"Stereo", "Left", "Right", "None"};
+static const char *wm9712_out3_src[] = {"Left", "VREF", "Left + Right",
+	"Mono"};
+static const char *wm9712_spk_src[] = {"Speaker Mix", "Headphone Mix"};
+static const char *wm9712_rec_adc[] = {"Stereo", "Left", "Right", "Mute"};
+static const char *wm9712_base[] = {"Linear Control", "Adaptive Boost"};
+static const char *wm9712_rec_gain[] = {"+1.5dB Steps", "+0.75dB Steps"};
+static const char *wm9712_mic[] = {"Mic 1", "Differential", "Mic 2",
+	"Stereo"};
+static const char *wm9712_rec_sel[] = {"Mic", "NC", "NC", "Speaker Mixer",
+	"Line", "Headphone Mixer", "Phone Mixer", "Phone"};
+static const char *wm9712_ng_type[] = {"Constant Gain", "Mute"};
+static const char *wm9712_diff_sel[] = {"Mic", "Line"};
+
+static const struct soc_enum wm9712_enum[] = {
+SOC_ENUM_SINGLE(AC97_PCI_SVID, 14, 4, wm9712_alc_select),
+SOC_ENUM_SINGLE(AC97_VIDEO, 12, 4, wm9712_alc_mux),
+SOC_ENUM_SINGLE(AC97_AUX, 9, 4, wm9712_out3_src),
+SOC_ENUM_SINGLE(AC97_AUX, 8, 2, wm9712_spk_src),
+SOC_ENUM_SINGLE(AC97_REC_SEL, 12, 4, wm9712_rec_adc),
+SOC_ENUM_SINGLE(AC97_MASTER_TONE, 15, 2, wm9712_base),
+SOC_ENUM_DOUBLE(AC97_REC_GAIN, 14, 6, 2, wm9712_rec_gain),
+SOC_ENUM_SINGLE(AC97_MIC, 5, 4, wm9712_mic),
+SOC_ENUM_SINGLE(AC97_REC_SEL, 8, 8, wm9712_rec_sel),
+SOC_ENUM_SINGLE(AC97_REC_SEL, 0, 8, wm9712_rec_sel),
+SOC_ENUM_SINGLE(AC97_PCI_SVID, 5, 2, wm9712_ng_type),
+SOC_ENUM_SINGLE(0x5c, 8, 2, wm9712_diff_sel),
+};
+
+static const struct snd_kcontrol_new wm9712_snd_ac97_controls[] = {
+SOC_DOUBLE("Speaker Playback Volume", AC97_MASTER, 8, 0, 31, 1),
+SOC_SINGLE("Speaker Playback Switch", AC97_MASTER, 15, 1, 1),
+SOC_DOUBLE("Headphone Playback Volume", AC97_HEADPHONE, 8, 0, 31, 1),
+SOC_SINGLE("Headphone Playback Switch", AC97_HEADPHONE,15, 1, 1),
+
+SOC_SINGLE("Speaker Playback ZC Switch", AC97_MASTER, 7, 1, 0),
+SOC_SINGLE("Speaker Playback Invert Switch", AC97_MASTER, 6, 1, 0),
+SOC_SINGLE("Headphone Playback ZC Switch", AC97_HEADPHONE, 7, 1, 0),
+SOC_SINGLE("Mono Playback ZC Switch", AC97_MASTER_MONO, 7, 1, 0),
+SOC_SINGLE("Mono Playback Volume", AC97_MASTER_MONO, 0, 31, 0),
+
+SOC_SINGLE("ALC Target Volume", AC97_CODEC_CLASS_REV, 12, 15, 0),
+SOC_SINGLE("ALC Hold Time", AC97_CODEC_CLASS_REV, 8, 15, 0),
+SOC_SINGLE("ALC Decay Time", AC97_CODEC_CLASS_REV, 4, 15, 0),
+SOC_SINGLE("ALC Attack Time", AC97_CODEC_CLASS_REV, 0, 15, 0),
+SOC_ENUM("ALC Function", wm9712_enum[0]),
+SOC_SINGLE("ALC Max Volume", AC97_PCI_SVID, 11, 7, 0),
+SOC_SINGLE("ALC ZC Timeout", AC97_PCI_SVID, 9, 3, 1),
+SOC_SINGLE("ALC ZC Switch", AC97_PCI_SVID, 8, 1, 0),
+SOC_SINGLE("ALC NG Switch", AC97_PCI_SVID, 7, 1, 0),
+SOC_ENUM("ALC NG Type", wm9712_enum[10]),
+SOC_SINGLE("ALC NG Threshold", AC97_PCI_SVID, 0, 31, 1),
+
+SOC_SINGLE("Mic Headphone  Volume", AC97_VIDEO, 12, 7, 1),
+SOC_SINGLE("ALC Headphone Volume", AC97_VIDEO, 7, 7, 1),
+
+SOC_SINGLE("Out3 Switch", AC97_AUX, 15, 1, 1),
+SOC_SINGLE("Out3 ZC Switch", AC97_AUX, 7, 1, 1),
+SOC_SINGLE("Out3 Volume", AC97_AUX, 0, 31, 1),
+
+SOC_SINGLE("PCBeep Bypass Headphone Volume", AC97_PC_BEEP, 12, 7, 1),
+SOC_SINGLE("PCBeep Bypass Speaker Volume", AC97_PC_BEEP, 8, 7, 1),
+SOC_SINGLE("PCBeep Bypass Phone Volume", AC97_PC_BEEP, 4, 7, 1),
+
+SOC_SINGLE("Aux Playback Headphone Volume", AC97_CD, 12, 7, 1),
+SOC_SINGLE("Aux Playback Speaker Volume", AC97_CD, 8, 7, 1),
+SOC_SINGLE("Aux Playback Phone Volume", AC97_CD, 4, 7, 1),
+
+SOC_SINGLE("Phone Volume", AC97_PHONE, 0, 15, 0),
+SOC_DOUBLE("Line Capture Volume", AC97_LINE, 8, 0, 31, 1),
+
+SOC_SINGLE("Capture 20dB Boost Switch", AC97_REC_SEL, 14, 1, 0),
+SOC_SINGLE("Capture to Phone 20dB Boost Switch", AC97_REC_SEL, 11, 1, 1),
+
+SOC_SINGLE("3D Upper Cut-off Switch", AC97_3D_CONTROL, 5, 1, 1),
+SOC_SINGLE("3D Lower Cut-off Switch", AC97_3D_CONTROL, 4, 1, 1),
+SOC_SINGLE("3D Playback Volume", AC97_3D_CONTROL, 0, 15, 0),
+
+SOC_ENUM("Bass Control", wm9712_enum[5]),
+SOC_SINGLE("Bass Cut-off Switch", AC97_MASTER_TONE, 12, 1, 1),
+SOC_SINGLE("Tone Cut-off Switch", AC97_MASTER_TONE, 4, 1, 1),
+SOC_SINGLE("Playback Attenuate (-6dB) Switch", AC97_MASTER_TONE, 6, 1, 0),
+SOC_SINGLE("Bass Volume", AC97_MASTER_TONE, 8, 15, 0),
+SOC_SINGLE("Treble Volume", AC97_MASTER_TONE, 0, 15, 0),
+
+SOC_SINGLE("Capture ADC Switch", AC97_REC_GAIN, 15, 1, 1),
+SOC_ENUM("Capture Volume Steps", wm9712_enum[6]),
+SOC_DOUBLE("Capture Volume", AC97_REC_GAIN, 8, 0, 63, 1),
+SOC_SINGLE("Capture ZC Switch", AC97_REC_GAIN, 7, 1, 0),
+
+SOC_SINGLE("Mic 1 Volume", AC97_MIC, 8, 31, 1),
+SOC_SINGLE("Mic 2 Volume", AC97_MIC, 0, 31, 1),
+SOC_SINGLE("Mic 20dB Boost Switch", AC97_MIC, 7, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm9712_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm9712_snd_ac97_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm9712_snd_ac97_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/* We have to create a fake left and right HP mixers because
+ * the codec only has a single control that is shared by both channels.
+ * This makes it impossible to determine the audio path.
+ */
+static int mixer_event (struct snd_soc_dapm_widget *w, int event)
+{
+	u16 l, r, beep, line, phone, mic, pcm, aux;
+
+	l = ac97_read(w->codec, HPL_MIXER);
+	r = ac97_read(w->codec, HPR_MIXER);
+	beep = ac97_read(w->codec, AC97_PC_BEEP);
+	mic = ac97_read(w->codec, AC97_VIDEO);
+	phone = ac97_read(w->codec, AC97_PHONE);
+	line = ac97_read(w->codec, AC97_LINE);
+	pcm = ac97_read(w->codec, AC97_PCM);
+	aux = ac97_read(w->codec, AC97_CD);
+
+	if (l & 0x1 || r & 0x1)
+		ac97_write(w->codec, AC97_VIDEO, mic & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_VIDEO, mic | 0x8000);
+
+	if (l & 0x2 || r & 0x2)
+		ac97_write(w->codec, AC97_PCM, pcm & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PCM, pcm | 0x8000);
+
+	if (l & 0x4 || r & 0x4)
+		ac97_write(w->codec, AC97_LINE, line & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_LINE, line | 0x8000);
+
+	if (l & 0x8 || r & 0x8)
+		ac97_write(w->codec, AC97_PHONE, phone & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PHONE, phone | 0x8000);
+
+	if (l & 0x10 || r & 0x10)
+		ac97_write(w->codec, AC97_CD, aux & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_CD, aux | 0x8000);
+
+	if (l & 0x20 || r & 0x20)
+		ac97_write(w->codec, AC97_PC_BEEP, beep & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PC_BEEP, beep | 0x8000);
+
+	return 0;
+}
+
+/* Left Headphone Mixers */
+static const struct snd_kcontrol_new wm9712_hpl_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", HPL_MIXER, 5, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", HPL_MIXER, 4, 1, 0),
+	SOC_DAPM_SINGLE("Phone Bypass Switch", HPL_MIXER, 3, 1, 0),
+	SOC_DAPM_SINGLE("Line Bypass Switch", HPL_MIXER, 2, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", HPL_MIXER, 1, 1, 0),
+	SOC_DAPM_SINGLE("Mic Sidetone Switch", HPL_MIXER, 0, 1, 0),
+};
+
+/* Right Headphone Mixers */
+static const struct snd_kcontrol_new wm9712_hpr_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", HPR_MIXER, 5, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", HPR_MIXER, 4, 1, 0),
+	SOC_DAPM_SINGLE("Phone Bypass Switch", HPR_MIXER, 3, 1, 0),
+	SOC_DAPM_SINGLE("Line Bypass Switch", HPR_MIXER, 2, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", HPR_MIXER, 1, 1, 0),
+	SOC_DAPM_SINGLE("Mic Sidetone Switch", HPR_MIXER, 0, 1, 0),
+};
+
+/* Speaker Mixer */
+static const struct snd_kcontrol_new wm9712_speaker_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", AC97_PC_BEEP, 11, 1, 1),
+	SOC_DAPM_SINGLE("Aux Playback Switch", AC97_CD, 11, 1, 1),
+	SOC_DAPM_SINGLE("Phone Bypass Switch", AC97_PHONE, 14, 1, 1),
+	SOC_DAPM_SINGLE("Line Bypass Switch", AC97_LINE, 14, 1, 1),
+	SOC_DAPM_SINGLE("PCM Playback Switch", AC97_PCM, 14, 1, 1),
+};
+
+/* Phone Mixer */
+static const struct snd_kcontrol_new wm9712_phone_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", AC97_PC_BEEP, 7, 1, 1),
+	SOC_DAPM_SINGLE("Aux Playback Switch", AC97_CD, 7, 1, 1),
+	SOC_DAPM_SINGLE("Line Bypass Switch", AC97_LINE, 13, 1, 1),
+	SOC_DAPM_SINGLE("PCM Playback Switch", AC97_PCM, 13, 1, 1),
+	SOC_DAPM_SINGLE("Mic 1 Sidetone Switch", AC97_MIC, 14, 1, 1),
+	SOC_DAPM_SINGLE("Mic 2 Sidetone Switch", AC97_MIC, 13, 1, 1),
+};
+
+/* ALC headphone mux */
+static const struct snd_kcontrol_new wm9712_alc_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[1]);
+
+/* out 3 mux */
+static const struct snd_kcontrol_new wm9712_out3_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[2]);
+
+/* spk mux */
+static const struct snd_kcontrol_new wm9712_spk_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[3]);
+
+/* Capture to Phone mux */
+static const struct snd_kcontrol_new wm9712_capture_phone_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[4]);
+
+/* Capture left select */
+static const struct snd_kcontrol_new wm9712_capture_selectl_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[8]);
+
+/* Capture right select */
+static const struct snd_kcontrol_new wm9712_capture_selectr_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[9]);
+
+/* Mic select */
+static const struct snd_kcontrol_new wm9712_mic_src_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[7]);
+
+/* diff select */
+static const struct snd_kcontrol_new wm9712_diff_sel_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[11]);
+
+static const struct snd_soc_dapm_widget wm9712_dapm_widgets[] = {
+SND_SOC_DAPM_MUX("ALC Sidetone Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_alc_mux_controls),
+SND_SOC_DAPM_MUX("Out3 Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_out3_mux_controls),
+SND_SOC_DAPM_MUX("Speaker Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_spk_mux_controls),
+SND_SOC_DAPM_MUX("Capture Phone Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_capture_phone_mux_controls),
+SND_SOC_DAPM_MUX("Left Capture Select", SND_SOC_NOPM, 0, 0,
+	&wm9712_capture_selectl_controls),
+SND_SOC_DAPM_MUX("Right Capture Select", SND_SOC_NOPM, 0, 0,
+	&wm9712_capture_selectr_controls),
+SND_SOC_DAPM_MUX("Mic Select Source", SND_SOC_NOPM, 0, 0,
+	&wm9712_mic_src_controls),
+SND_SOC_DAPM_MUX("Differential Source", SND_SOC_NOPM, 0, 0,
+	&wm9712_diff_sel_controls),
+SND_SOC_DAPM_MIXER("AC97 Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+SND_SOC_DAPM_MIXER_E("Left HP Mixer", AC97_INT_PAGING, 9, 1,
+	&wm9712_hpl_mixer_controls[0], ARRAY_SIZE(wm9712_hpl_mixer_controls),
+	mixer_event, SND_SOC_DAPM_POST_REG),
+SND_SOC_DAPM_MIXER_E("Right HP Mixer", AC97_INT_PAGING, 8, 1,
+	&wm9712_hpr_mixer_controls[0], ARRAY_SIZE(wm9712_hpr_mixer_controls),
+	 mixer_event, SND_SOC_DAPM_POST_REG),
+SND_SOC_DAPM_MIXER("Phone Mixer", AC97_INT_PAGING, 6, 1,
+	&wm9712_phone_mixer_controls[0], ARRAY_SIZE(wm9712_phone_mixer_controls)),
+SND_SOC_DAPM_MIXER("Speaker Mixer", AC97_INT_PAGING, 7, 1,
+	&wm9712_speaker_mixer_controls[0],
+	ARRAY_SIZE(wm9712_speaker_mixer_controls)),
+SND_SOC_DAPM_MIXER("Mono Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+SND_SOC_DAPM_DAC("Left DAC", "Left HiFi Playback", AC97_INT_PAGING, 14, 1),
+SND_SOC_DAPM_DAC("Right DAC", "Right HiFi Playback", AC97_INT_PAGING, 13, 1),
+SND_SOC_DAPM_DAC("Aux DAC", "Aux Playback", SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_ADC("Left ADC", "Left HiFi Capture", AC97_INT_PAGING, 12, 1),
+SND_SOC_DAPM_ADC("Right ADC", "Right HiFi Capture", AC97_INT_PAGING, 11, 1),
+SND_SOC_DAPM_PGA("Headphone PGA", AC97_INT_PAGING, 4, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Speaker PGA", AC97_INT_PAGING, 3, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Out 3 PGA", AC97_INT_PAGING, 5, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Line PGA", AC97_INT_PAGING, 2, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Phone PGA", AC97_INT_PAGING, 1, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mic PGA", AC97_INT_PAGING, 0, 1, NULL, 0),
+SND_SOC_DAPM_MICBIAS("Mic Bias", AC97_INT_PAGING, 10, 1),
+SND_SOC_DAPM_OUTPUT("MONOOUT"),
+SND_SOC_DAPM_OUTPUT("HPOUTL"),
+SND_SOC_DAPM_OUTPUT("HPOUTR"),
+SND_SOC_DAPM_OUTPUT("LOUT2"),
+SND_SOC_DAPM_OUTPUT("ROUT2"),
+SND_SOC_DAPM_OUTPUT("OUT3"),
+SND_SOC_DAPM_INPUT("LINEINL"),
+SND_SOC_DAPM_INPUT("LINEINR"),
+SND_SOC_DAPM_INPUT("PHONE"),
+SND_SOC_DAPM_INPUT("PCBEEP"),
+SND_SOC_DAPM_INPUT("MIC1"),
+SND_SOC_DAPM_INPUT("MIC2"),
+};
+
+static const char *audio_map[][3] = {
+	/* virtual mixer - mixes left & right channels for spk and mono */
+	{"AC97 Mixer", NULL, "Left DAC"},
+	{"AC97 Mixer", NULL, "Right DAC"},
+
+	/* Left HP mixer */
+	{"Left HP Mixer", "PCBeep Bypass Switch", "PCBEEP"},
+	{"Left HP Mixer", "Aux Playback Switch",  "Aux DAC"},
+	{"Left HP Mixer", "Phone Bypass Switch",  "Phone PGA"},
+	{"Left HP Mixer", "Line Bypass Switch",   "Line PGA"},
+	{"Left HP Mixer", "PCM Playback Switch",  "Left DAC"},
+	{"Left HP Mixer", "Mic Sidetone Switch",  "Mic PGA"},
+	{"Left HP Mixer", NULL,  "ALC Sidetone Mux"},
+	//{"Right HP Mixer", NULL, "HP Mixer"},
+
+	/* Right HP mixer */
+	{"Right HP Mixer", "PCBeep Bypass Switch", "PCBEEP"},
+	{"Right HP Mixer", "Aux Playback Switch",  "Aux DAC"},
+	{"Right HP Mixer", "Phone Bypass Switch",  "Phone PGA"},
+	{"Right HP Mixer", "Line Bypass Switch",   "Line PGA"},
+	{"Right HP Mixer", "PCM Playback Switch",  "Right DAC"},
+	{"Right HP Mixer", "Mic Sidetone Switch",  "Mic PGA"},
+	{"Right HP Mixer", NULL,  "ALC Sidetone Mux"},
+
+	/* speaker mixer */
+	{"Speaker Mixer", "PCBeep Bypass Switch", "PCBEEP"},
+	{"Speaker Mixer", "Line Bypass Switch",   "Line PGA"},
+	{"Speaker Mixer", "PCM Playback Switch",  "AC97 Mixer"},
+	{"Speaker Mixer", "Phone Bypass Switch",  "Phone PGA"},
+	{"Speaker Mixer", "Aux Playback Switch",  "Aux DAC"},
+
+	/* Phone mixer */
+	{"Phone Mixer", "PCBeep Bypass Switch",  "PCBEEP"},
+	{"Phone Mixer", "Line Bypass Switch",    "Line PGA"},
+	{"Phone Mixer", "Aux Playback Switch",   "Aux DAC"},
+	{"Phone Mixer", "PCM Playback Switch",   "AC97 Mixer"},
+	{"Phone Mixer", "Mic 1 Sidetone Switch", "Mic PGA"},
+	{"Phone Mixer", "Mic 2 Sidetone Switch", "Mic PGA"},
+
+	/* inputs */
+	{"Line PGA", NULL, "LINEINL"},
+	{"Line PGA", NULL, "LINEINR"},
+	{"Phone PGA", NULL, "PHONE"},
+	{"Mic PGA", NULL, "MIC1"},
+	{"Mic PGA", NULL, "MIC2"},
+
+	/* left capture selector */
+	{"Left Capture Select", "Mic", "MIC1"},
+	{"Left Capture Select", "Speaker Mixer", "Speaker Mixer"},
+	{"Left Capture Select", "Line", "LINEINL"},
+	{"Left Capture Select", "Headphone Mixer", "Left HP Mixer"},
+	{"Left Capture Select", "Phone Mixer", "Phone Mixer"},
+	{"Left Capture Select", "Phone", "PHONE"},
+
+	/* right capture selector */
+	{"Right Capture Select", "Mic", "MIC2"},
+	{"Right Capture Select", "Speaker Mixer", "Speaker Mixer"},
+	{"Right Capture Select", "Line", "LINEINR"},
+	{"Right Capture Select", "Headphone Mixer", "Right HP Mixer"},
+	{"Right Capture Select", "Phone Mixer", "Phone Mixer"},
+	{"Right Capture Select", "Phone", "PHONE"},
+
+	/* ALC Sidetone */
+	{"ALC Sidetone Mux", "Stereo", "Left Capture Select"},
+	{"ALC Sidetone Mux", "Stereo", "Right Capture Select"},
+	{"ALC Sidetone Mux", "Left", "Left Capture Select"},
+	{"ALC Sidetone Mux", "Right", "Right Capture Select"},
+
+	/* ADC's */
+	{"Left ADC", NULL, "Left Capture Select"},
+	{"Right ADC", NULL, "Right Capture Select"},
+
+	/* outputs */
+	{"MONOOUT", NULL, "Phone Mixer"},
+	{"HPOUTL", NULL, "Headphone PGA"},
+	{"Headphone PGA", NULL, "Left HP Mixer"},
+	{"HPOUTR", NULL, "Headphone PGA"},
+	{"Headphone PGA", NULL, "Right HP Mixer"},
+
+	/* mono hp mixer */
+	{"Mono HP Mixer", NULL, "Left HP Mixer"},
+	{"Mono HP Mixer", NULL, "Right HP Mixer"},
+
+	/* Out3 Mux */
+	{"Out3 Mux", "Left", "Left HP Mixer"},
+	{"Out3 Mux", "Mono", "Phone Mixer"},
+	{"Out3 Mux", "Left + Right", "Mono HP Mixer"},
+	{"Out 3 PGA", NULL, "Out3 Mux"},
+	{"OUT3", NULL, "Out 3 PGA"},
+
+	/* speaker Mux */
+	{"Speaker Mux", "Speaker Mix", "Speaker Mixer"},
+	{"Speaker Mux", "Headphone Mix", "Mono HP Mixer"},
+	{"Speaker PGA", NULL, "Speaker Mux"},
+	{"LOUT2", NULL, "Speaker PGA"},
+	{"ROUT2", NULL, "Speaker PGA"},
+
+	{NULL, NULL, NULL},
+};
+
+static int wm9712_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm9712_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm9712_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg == AC97_RESET || reg == AC97_GPIO_STATUS ||
+		reg == AC97_VENDOR_ID1 || reg == AC97_VENDOR_ID2 ||
+		reg == AC97_REC_GAIN)
+		return soc_ac97_ops.read(codec->ac97, reg);
+	else {
+		reg = reg >> 1;
+
+		if (reg > (ARRAY_SIZE(wm9712_reg)))
+			return -EIO;
+
+		return cache[reg];
+	}
+}
+
+static int ac97_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int val)
+{
+	u16 *cache = codec->reg_cache;
+
+	soc_ac97_ops.write(codec->ac97, reg, val);
+	reg = reg >> 1;
+	if (reg <= (ARRAY_SIZE(wm9712_reg)))
+		cache[reg] = val;
+
+	return 0;
+}
+
+static int ac97_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg;
+	u16 vra;
+
+	vra = ac97_read(codec, AC97_EXTENDED_STATUS);
+	ac97_write(codec, AC97_EXTENDED_STATUS, vra | 0x1);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg = AC97_PCM_FRONT_DAC_RATE;
+	else
+		reg = AC97_PCM_LR_ADC_RATE;
+
+	return ac97_write(codec, reg, runtime->rate);
+}
+
+static int ac97_aux_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 vra, xsle;
+
+	vra = ac97_read(codec, AC97_EXTENDED_STATUS);
+	ac97_write(codec, AC97_EXTENDED_STATUS, vra | 0x1);
+	xsle = ac97_read(codec, AC97_PCI_SID);
+	ac97_write(codec, AC97_PCI_SID, xsle | 0x8000);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -ENODEV;
+
+	return ac97_write(codec, AC97_PCM_SURR_DAC_RATE, runtime->rate);
+}
+
+struct snd_soc_codec_dai wm9712_dai[] = {
+{
+	.name = "AC97 HiFi",
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.ops = {
+		.prepare = ac97_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(ac97_modes),
+		.mode = ac97_modes,},
+	},
+	{
+	.name = "AC97 Aux",
+	.playback = {
+		.stream_name = "Aux Playback",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.ops = {
+		.prepare = ac97_aux_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(ac97_modes),
+		.mode = ac97_modes,},
+	},
+};
+EXPORT_SYMBOL_GPL(wm9712_dai);
+
+static int wm9712_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 reg;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* liam - maybe enable thermal shutdown */
+		reg = ac97_read(codec, AC97_EXTENDED_MID) & 0xdfff;
+		ac97_write(codec, AC97_EXTENDED_MID, reg);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* enable master bias and vmid */
+		reg = ac97_read(codec, AC97_EXTENDED_MID) & 0xbbff;
+		ac97_write(codec, AC97_EXTENDED_MID, reg);
+		ac97_write(codec, AC97_POWERDOWN, 0x0000);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* disable everything including AC link */
+		ac97_write(codec, AC97_EXTENDED_MID, 0xffff);
+		ac97_write(codec, AC97_EXTENDED_MSTATUS, 0xffff);
+		ac97_write(codec, AC97_POWERDOWN, 0xffff);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+static int wm9712_reset(struct snd_soc_codec *codec, int try_warm)
+{
+	if (try_warm && soc_ac97_ops.warm_reset) {
+		soc_ac97_ops.warm_reset(codec->ac97);
+		if (!(ac97_read(codec, 0) & 0x8000))
+			return 1;
+	}
+
+	soc_ac97_ops.reset(codec->ac97);
+	if (ac97_read(codec, 0) & 0x8000)
+		goto err;
+	return 0;
+
+err:
+	printk(KERN_ERR "WM9712 AC97 reset failed\n");
+	return -EIO;
+}
+
+static int wm9712_soc_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm9712_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm9712_soc_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i, ret;
+	u16 *cache = codec->reg_cache;
+
+	ret = wm9712_reset(codec, 1);
+	if (ret < 0){
+		printk(KERN_ERR "could not reset AC97 codec\n");
+		return ret;
+	}
+
+	wm9712_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	if (ret == 0) {
+		/* Sync reg_cache with the hardware after cold reset */
+		for (i = 2; i < ARRAY_SIZE(wm9712_reg) << 1; i+=2) {
+			if (i == AC97_INT_PAGING || i == AC97_POWERDOWN ||
+				(i > 0x58 && i != 0x5c))
+				continue;
+			soc_ac97_ops.write(codec->ac97, i, cache[i>>1]);
+		}
+	}
+
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0)
+		wm9712_dapm_event(codec, SNDRV_CTL_POWER_D0);
+
+	return ret;
+}
+
+static int wm9712_soc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	printk(KERN_INFO "WM9711/WM9712 SoC Audio Codec %s\n", WM9712_VERSION);
+
+	socdev->codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (socdev->codec == NULL)
+		return -ENOMEM;
+	codec = socdev->codec;
+	mutex_init(&codec->mutex);
+
+	codec->reg_cache =
+		kzalloc(sizeof(u16) * ARRAY_SIZE(wm9712_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL) {
+		kfree(codec->ac97);
+		kfree(socdev->codec);
+		socdev->codec = NULL;
+		return -ENOMEM;
+	}
+	memcpy(codec->reg_cache, wm9712_reg, sizeof(u16) * ARRAY_SIZE(wm9712_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm9712_reg);
+	codec->reg_cache_step = 2;
+
+	codec->name = "WM9712";
+	codec->owner = THIS_MODULE;
+	codec->dai = wm9712_dai;
+	codec->num_dai = ARRAY_SIZE(wm9712_dai);
+	codec->write = ac97_write;
+	codec->read = ac97_read;
+	codec->dapm_event = wm9712_dapm_event;
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	ret = snd_soc_new_ac97_codec(codec, &soc_ac97_ops, 0);
+	if (ret < 0)
+		goto err;
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0)
+		goto pcm_err;
+
+	ret = wm9712_reset(codec, 0);
+	if (ret < 0) {
+		printk(KERN_ERR "AC97 link error\n");
+		goto reset_err;
+	}
+
+	/* set alc mux to none */
+	ac97_write(codec, AC97_VIDEO, ac97_read(codec, AC97_VIDEO) | 0x3000);
+
+	wm9712_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm9712_add_controls(codec);
+	wm9712_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0)
+		goto reset_err;
+
+	return 0;
+
+reset_err:
+	snd_soc_free_pcms(socdev);
+
+pcm_err:
+	snd_soc_free_ac97_codec(codec);
+
+err:
+	kfree(socdev->codec->reg_cache);
+	kfree(socdev->codec);
+	socdev->codec = NULL;
+	return ret;
+}
+
+static int wm9712_soc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec == NULL)
+		return 0;
+
+	snd_soc_dapm_free(socdev);
+	snd_soc_free_pcms(socdev);
+	snd_soc_free_ac97_codec(codec);
+	kfree(codec->reg_cache);
+	kfree(codec);
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm9712 = {
+	.probe = 	wm9712_soc_probe,
+	.remove = 	wm9712_soc_remove,
+	.suspend =	wm9712_soc_suspend,
+	.resume =	wm9712_soc_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm9712);
+
+MODULE_DESCRIPTION("ASoC WM9711/WM9712 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm9712.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm9712.h
@@ -0,0 +1,14 @@
+/*
+ * wm9712.h  --  WM9712 Soc Audio driver
+ */
+
+#ifndef _WM9712_H
+#define _WM9712_H
+
+#define WM9712_DAI_AC97_HIFI	0
+#define WM9712_DAI_AC97_AUX		1
+
+extern struct snd_soc_codec_dai wm9712_dai[2];
+extern struct snd_soc_codec_device soc_codec_dev_wm9712;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm9713.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm9713.c
@@ -0,0 +1,1313 @@
+/*
+ * wm9713.c  --  ALSA Soc WM9713 codec support
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    4th Feb 2006   Initial version.
+ *
+ *  Features:-
+ *
+ *   o Support for AC97 Codec, Voice DAC and Aux DAC
+ *   o Support for DAPM
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#define WM9713_VERSION "0.12"
+
+struct wm9713 {
+	u32 pll; /* current PLL frequency */
+	u32 pll_resume; /* PLL resume frequency */
+};
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg);
+static int ac97_write(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int val);
+
+#define AC97_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define AC97_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+/* may need to expand this */
+static struct snd_soc_dai_mode ac97_modes[] = {
+	{
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE,
+		.pcmrate = AC97_RATES,
+	},
+};
+
+#define WM9713_VOICE_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | \
+	SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_DSP_A | \
+	SND_SOC_DAIFMT_DSP_B |  SND_SOC_DAIFMT_NB_NF | \
+	SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF)
+
+#define WM9713_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM9713_VOICE_FSB \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | \
+	SND_SOC_FSBD(8) | SND_SOC_FSBD(16))
+
+#define WM9713_VOICE_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000 | \
+	SNDRV_PCM_RATE_96000)
+
+#define WM9713_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+/*
+ * Voice modes
+ */
+static struct snd_soc_dai_mode wm9713_voice_modes[] = {
+	/* master modes */
+	{
+		.fmt = WM9713_VOICE_DAIFMT | SND_SOC_DAIFMT_CBM_CFM | \
+			SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt =  WM9713_HIFI_BITS,
+		.pcmrate = WM9713_VOICE_RATES,
+		.pcmdir = WM9713_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = WM9713_VOICE_FSB,
+	},
+
+	/* slave modes */
+	{
+		.fmt = WM9713_VOICE_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM9713_HIFI_BITS,
+		.pcmrate = WM9713_VOICE_RATES,
+		.pcmdir = WM9713_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * WM9713 register cache
+ * Reg 0x3c bit 15 is used by touch driver.
+ */
+static const u16 wm9713_reg[] = {
+	0x6174, 0x8080, 0x8080, 0x8080, // 6
+	0xc880, 0xe808, 0xe808, 0x0808, // e
+	0x00da, 0x8000, 0xd600, 0xaaa0, // 16
+	0xaaa0, 0xaaa0, 0x0000, 0x0000, // 1e
+	0x0f0f, 0x0040, 0x0000, 0x7f00, // 26
+	0x0405, 0x0410, 0xbb80, 0xbb80, // 2e
+	0x0000, 0xbb80, 0x0000, 0x4523, // 36
+	0x0000, 0x2000, 0x7eff, 0xffff, // 3e
+	0x0000, 0x0000, 0x0080, 0x0000, // 46
+	0x0000, 0x0000, 0xfffe, 0xffff, // 4e
+	0x0000, 0x0000, 0x0000, 0xfffe, // 56
+	0x4000, 0x0000, 0x0000, 0x0000, // 5e
+	0xb032, 0x3e00, 0x0000, 0x0000, // 66
+	0x0000, 0x0000, 0x0000, 0x0000, // 6e
+	0x0000, 0x0000, 0x0000, 0x0006, // 76
+	0x0001, 0x0000, 0x574d, 0x4c13, // 7e
+	0x0000, 0x0000, 0x0000 // virtual hp & mic mixers
+};
+
+/* virtual HP mixers regs */
+#define HPL_MIXER	0x80
+#define HPR_MIXER	0x82
+#define MICB_MUX	0x82
+
+static const char *wm9713_mic_mixer[] = {"Stereo", "Mic 1", "Mic 2", "Mute"};
+static const char *wm9713_rec_mux[] = {"Stereo", "Left", "Right", "Mute"};
+static const char *wm9713_rec_src[] =
+	{"Mic 1", "Mic 2", "Line", "Mono In", "Headphone", "Speaker",
+	"Mono Out", "Zh"};
+static const char *wm9713_rec_gain[] = {"+1.5dB Steps", "+0.75dB Steps"};
+static const char *wm9713_alc_select[] = {"None", "Left", "Right", "Stereo"};
+static const char *wm9713_mono_pga[] = {"Vmid", "Zh", "Mono", "Inv",
+	"Mono Vmid", "Inv Vmid"};
+static const char *wm9713_spk_pga[] =
+	{"Vmid", "Zh", "Headphone", "Speaker", "Inv", "Headphone Vmid",
+	"Speaker Vmid", "Inv Vmid"};
+static const char *wm9713_hp_pga[] = {"Vmid", "Zh", "Headphone",
+	"Headphone Vmid"};
+static const char *wm9713_out3_pga[] = {"Vmid", "Zh", "Inv 1", "Inv 1 Vmid"};
+static const char *wm9713_out4_pga[] = {"Vmid", "Zh", "Inv 2", "Inv 2 Vmid"};
+static const char *wm9713_dac_inv[] =
+	{"Off", "Mono", "Speaker", "Left Headphone", "Right Headphone",
+	"Headphone Mono", "NC", "Vmid"};
+static const char *wm9713_bass[] = {"Linear Control", "Adaptive Boost"};
+static const char *wm9713_ng_type[] = {"Constant Gain", "Mute"};
+static const char *wm9713_mic_select[] = {"Mic 1", "Mic 2 A", "Mic 2 B"};
+static const char *wm9713_micb_select[] = {"MPB", "MPA"};
+
+static const struct soc_enum wm9713_enum[] = {
+SOC_ENUM_SINGLE(AC97_LINE, 3, 4, wm9713_mic_mixer), /* record mic mixer 0 */
+SOC_ENUM_SINGLE(AC97_VIDEO, 14, 4, wm9713_rec_mux), /* record mux hp 1 */
+SOC_ENUM_SINGLE(AC97_VIDEO, 9, 4, wm9713_rec_mux),  /* record mux mono 2 */
+SOC_ENUM_SINGLE(AC97_VIDEO, 3, 8, wm9713_rec_src),  /* record mux left 3 */
+SOC_ENUM_SINGLE(AC97_VIDEO, 0, 8, wm9713_rec_src),  /* record mux right 4*/
+SOC_ENUM_DOUBLE(AC97_CD, 14, 6, 2, wm9713_rec_gain), /* record step size 5 */
+SOC_ENUM_SINGLE(AC97_PCI_SVID, 14, 4, wm9713_alc_select), /* alc source select 6*/
+SOC_ENUM_SINGLE(AC97_REC_GAIN, 14, 4, wm9713_mono_pga), /* mono input select 7 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN, 11, 8, wm9713_spk_pga), /* speaker left input select 8 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN, 8, 8, wm9713_spk_pga), /* speaker right input select 9 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN, 6, 3, wm9713_hp_pga), /* headphone left input 10 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN, 4, 3, wm9713_hp_pga), /* headphone right input 11 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN, 2, 4, wm9713_out3_pga), /* out 3 source 12 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN, 0, 4, wm9713_out4_pga), /* out 4 source 13 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN_MIC, 13, 8, wm9713_dac_inv), /* dac invert 1 14 */
+SOC_ENUM_SINGLE(AC97_REC_GAIN_MIC, 10, 8, wm9713_dac_inv), /* dac invert 2 15 */
+SOC_ENUM_SINGLE(AC97_GENERAL_PURPOSE, 15, 2, wm9713_bass), /* bass control 16 */
+SOC_ENUM_SINGLE(AC97_PCI_SVID, 5, 2, wm9713_ng_type), /* noise gate type 17 */
+SOC_ENUM_SINGLE(AC97_3D_CONTROL, 12, 3, wm9713_mic_select), /* mic selection 18 */
+SOC_ENUM_SINGLE(MICB_MUX, 0, 2, wm9713_micb_select), /* mic selection 19 */
+};
+
+static const struct snd_kcontrol_new wm9713_snd_ac97_controls[] = {
+SOC_DOUBLE("Speaker Playback Volume", AC97_MASTER, 8, 0, 31, 1),
+SOC_DOUBLE("Speaker Playback Switch", AC97_MASTER, 15, 7, 1, 1),
+SOC_DOUBLE("Headphone Playback Volume", AC97_HEADPHONE, 8, 0, 31, 1),
+SOC_DOUBLE("Headphone Playback Switch", AC97_HEADPHONE,15, 7, 1, 1),
+SOC_DOUBLE("Line In Volume", AC97_PC_BEEP, 8, 0, 31, 1),
+SOC_DOUBLE("PCM Playback Volume", AC97_PHONE, 8, 0, 31, 1),
+SOC_SINGLE("Mic 1 Volume", AC97_MIC, 8, 31, 1),
+SOC_SINGLE("Mic 2 Volume", AC97_MIC, 0, 31, 1),
+
+SOC_SINGLE("Mic Boost (+20dB) Switch", AC97_LINE, 5, 1, 0),
+SOC_SINGLE("Mic Headphone Mixer Volume", AC97_LINE, 0, 7, 1),
+
+SOC_SINGLE("Capture Switch", AC97_CD, 15, 1, 1),
+SOC_ENUM("Capture Volume Steps", wm9713_enum[5]),
+SOC_DOUBLE("Capture Volume", AC97_CD, 8, 0, 63, 0),
+SOC_SINGLE("Capture ZC Switch", AC97_CD, 7, 1, 0),
+
+SOC_SINGLE("Capture to Headphone Volume", AC97_VIDEO, 11, 7, 1),
+SOC_SINGLE("Capture to Mono Boost (+20dB) Switch", AC97_VIDEO, 8, 1, 0),
+SOC_SINGLE("Capture ADC Boost (+20dB) Switch", AC97_VIDEO, 6, 1, 0),
+
+SOC_SINGLE("ALC Target Volume", AC97_CODEC_CLASS_REV, 12, 15, 0),
+SOC_SINGLE("ALC Hold Time", AC97_CODEC_CLASS_REV, 8, 15, 0),
+SOC_SINGLE("ALC Decay Time ", AC97_CODEC_CLASS_REV, 4, 15, 0),
+SOC_SINGLE("ALC Attack Time", AC97_CODEC_CLASS_REV, 0, 15, 0),
+SOC_ENUM("ALC Function", wm9713_enum[6]),
+SOC_SINGLE("ALC Max Volume", AC97_PCI_SVID, 11, 7, 0),
+SOC_SINGLE("ALC ZC Timeout", AC97_PCI_SVID, 9, 3, 0),
+SOC_SINGLE("ALC ZC Switch", AC97_PCI_SVID, 8, 1, 0),
+SOC_SINGLE("ALC NG Switch", AC97_PCI_SVID, 7, 1, 0),
+SOC_ENUM("ALC NG Type", wm9713_enum[17]),
+SOC_SINGLE("ALC NG Threshold", AC97_PCI_SVID, 0, 31, 0),
+
+SOC_DOUBLE("Speaker Playback ZC Switch", AC97_MASTER, 14, 6, 1, 0),
+SOC_DOUBLE("Headphone Playback ZC Switch", AC97_HEADPHONE, 14, 6, 1, 0),
+
+SOC_SINGLE("Out4 Playback Switch", AC97_MASTER_MONO, 15, 1, 1),
+SOC_SINGLE("Out4 Playback ZC Switch", AC97_MASTER_MONO, 14, 1, 0),
+SOC_SINGLE("Out4 Playback Volume", AC97_MASTER_MONO, 8, 63, 1),
+
+SOC_SINGLE("Out3 Playback Switch", AC97_MASTER_MONO, 7, 1, 1),
+SOC_SINGLE("Out3 Playback ZC Switch", AC97_MASTER_MONO, 6, 1, 0),
+SOC_SINGLE("Out3 Playback Volume", AC97_MASTER_MONO, 0, 63, 1),
+
+SOC_SINGLE("Mono Capture Volume", AC97_MASTER_TONE, 8, 31, 1),
+SOC_SINGLE("Mono Playback Switch", AC97_MASTER_TONE, 7, 1, 1),
+SOC_SINGLE("Mono Playback ZC Switch", AC97_MASTER_TONE, 6, 1, 0),
+SOC_SINGLE("Mono Playback Volume", AC97_MASTER_TONE, 0, 31, 1),
+
+SOC_SINGLE("PC Beep Playback Headphone Volume", AC97_AUX, 12, 7, 1),
+SOC_SINGLE("PC Beep Playback Speaker Volume", AC97_AUX, 8, 7, 1),
+SOC_SINGLE("PC Beep Playback Mono Volume", AC97_AUX, 4, 7, 1),
+
+SOC_SINGLE("Voice Playback Headphone Volume", AC97_PCM, 12, 7, 1),
+SOC_SINGLE("Voice Playback Master Volume", AC97_PCM, 8, 7, 1),
+SOC_SINGLE("Voice Playback Mono Volume", AC97_PCM, 4, 7, 1),
+
+SOC_SINGLE("Aux Playback Headphone Volume", AC97_REC_SEL, 12, 7, 1),
+SOC_SINGLE("Aux Playback Master Volume", AC97_REC_SEL, 8, 7, 1),
+SOC_SINGLE("Aux Playback Mono Volume", AC97_REC_SEL, 4, 7, 1),
+
+SOC_ENUM("Bass Control", wm9713_enum[16]),
+SOC_SINGLE("Bass Cut-off Switch", AC97_GENERAL_PURPOSE, 12, 1, 1),
+SOC_SINGLE("Tone Cut-off Switch", AC97_GENERAL_PURPOSE, 4, 1, 1),
+SOC_SINGLE("Playback Attenuate (-6dB) Switch", AC97_GENERAL_PURPOSE, 6, 1, 0),
+SOC_SINGLE("Bass Volume", AC97_GENERAL_PURPOSE, 8, 15, 1),
+SOC_SINGLE("Tone Volume", AC97_GENERAL_PURPOSE, 0, 15, 1),
+
+SOC_SINGLE("3D Upper Cut-off Switch", AC97_REC_GAIN_MIC, 5, 1, 0),
+SOC_SINGLE("3D Lower Cut-off Switch", AC97_REC_GAIN_MIC, 4, 1, 0),
+SOC_SINGLE("3D Depth", AC97_REC_GAIN_MIC, 0, 15, 1),
+};
+
+/* add non dapm controls */
+static int wm9713_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm9713_snd_ac97_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm9713_snd_ac97_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/* We have to create a fake left and right HP mixers because
+ * the codec only has a single control that is shared by both channels.
+ * This makes it impossible to determine the audio path using the current
+ * register map, thus we add a new (virtual) register to help determine the
+ * audio route within the device.
+ */
+static int mixer_event (struct snd_soc_dapm_widget *w, int event)
+{
+	u16 l, r, beep, tone, phone, rec, pcm, aux;
+
+	l = ac97_read(w->codec, HPL_MIXER);
+	r = ac97_read(w->codec, HPR_MIXER);
+	beep = ac97_read(w->codec, AC97_PC_BEEP);
+	tone = ac97_read(w->codec, AC97_MASTER_TONE);
+	phone = ac97_read(w->codec, AC97_PHONE);
+	rec = ac97_read(w->codec, AC97_REC_SEL);
+	pcm = ac97_read(w->codec, AC97_PCM);
+	aux = ac97_read(w->codec, AC97_AUX);
+
+	if (event & SND_SOC_DAPM_PRE_REG)
+		return 0;
+	if (l & 0x1 || r & 0x1)
+		ac97_write(w->codec, AC97_PC_BEEP, beep & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PC_BEEP, beep | 0x8000);
+
+	if (l & 0x2 || r & 0x2)
+		ac97_write(w->codec, AC97_MASTER_TONE, tone & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_MASTER_TONE, tone | 0x8000);
+
+	if (l & 0x4 || r & 0x4)
+		ac97_write(w->codec, AC97_PHONE, phone & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PHONE, phone | 0x8000);
+
+	if (l & 0x8 || r & 0x8)
+		ac97_write(w->codec, AC97_REC_SEL, rec & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_REC_SEL, rec | 0x8000);
+
+	if (l & 0x10 || r & 0x10)
+		ac97_write(w->codec, AC97_PCM, pcm & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PCM, pcm | 0x8000);
+
+	if (l & 0x20 || r & 0x20)
+		ac97_write(w->codec, AC97_AUX, aux & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_AUX, aux | 0x8000);
+
+	return 0;
+}
+
+/* Left Headphone Mixers */
+static const struct snd_kcontrol_new wm9713_hpl_mixer_controls[] = {
+SOC_DAPM_SINGLE("PC Beep Playback Switch", HPL_MIXER, 5, 1, 0),
+SOC_DAPM_SINGLE("Voice Playback Switch", HPL_MIXER, 4, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", HPL_MIXER, 3, 1, 0),
+SOC_DAPM_SINGLE("PCM Playback Switch", HPL_MIXER, 2, 1, 0),
+SOC_DAPM_SINGLE("MonoIn Playback Switch", HPL_MIXER, 1, 1, 0),
+SOC_DAPM_SINGLE("Bypass Playback Switch", HPL_MIXER, 0, 1, 0),
+};
+
+/* Right Headphone Mixers */
+static const struct snd_kcontrol_new wm9713_hpr_mixer_controls[] = {
+SOC_DAPM_SINGLE("PC Beep Playback Switch", HPR_MIXER, 5, 1, 0),
+SOC_DAPM_SINGLE("Voice Playback Switch", HPR_MIXER, 4, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", HPR_MIXER, 3, 1, 0),
+SOC_DAPM_SINGLE("PCM Playback Switch", HPR_MIXER, 2, 1, 0),
+SOC_DAPM_SINGLE("MonoIn Playback Switch", HPR_MIXER, 1, 1, 0),
+SOC_DAPM_SINGLE("Bypass Playback Switch", HPR_MIXER, 0, 1, 0),
+};
+
+/* headphone capture mux */
+static const struct snd_kcontrol_new wm9713_hp_rec_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[1]);
+
+/* headphone mic mux */
+static const struct snd_kcontrol_new wm9713_hp_mic_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[0]);
+
+/* Speaker Mixer */
+static const struct snd_kcontrol_new wm9713_speaker_mixer_controls[] = {
+SOC_DAPM_SINGLE("PC Beep Playback Switch", AC97_AUX, 11, 1, 1),
+SOC_DAPM_SINGLE("Voice Playback Switch", AC97_PCM, 11, 1, 1),
+SOC_DAPM_SINGLE("Aux Playback Switch", AC97_REC_SEL, 11, 1, 1),
+SOC_DAPM_SINGLE("PCM Playback Switch", AC97_PHONE, 14, 1, 1),
+SOC_DAPM_SINGLE("MonoIn Playback Switch", AC97_MASTER_TONE, 14, 1, 1),
+SOC_DAPM_SINGLE("Bypass Playback Switch", AC97_PC_BEEP, 14, 1, 1),
+};
+
+/* Mono Mixer */
+static const struct snd_kcontrol_new wm9713_mono_mixer_controls[] = {
+SOC_DAPM_SINGLE("PC Beep Playback Switch", AC97_AUX, 7, 1, 1),
+SOC_DAPM_SINGLE("Voice Playback Switch", AC97_PCM, 7, 1, 1),
+SOC_DAPM_SINGLE("Aux Playback Switch", AC97_REC_SEL, 7, 1, 1),
+SOC_DAPM_SINGLE("PCM Playback Switch", AC97_PHONE, 13, 1, 1),
+SOC_DAPM_SINGLE("MonoIn Playback Switch", AC97_MASTER_TONE, 13, 1, 1),
+SOC_DAPM_SINGLE("Bypass Playback Switch", AC97_PC_BEEP, 13, 1, 1),
+SOC_DAPM_SINGLE("Mic 1 Sidetone Switch", AC97_LINE, 7, 1, 1),
+SOC_DAPM_SINGLE("Mic 2 Sidetone Switch", AC97_LINE, 6, 1, 1),
+};
+
+/* mono mic mux */
+static const struct snd_kcontrol_new wm9713_mono_mic_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[2]);
+
+/* mono output mux */
+static const struct snd_kcontrol_new wm9713_mono_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[7]);
+
+/* speaker left output mux */
+static const struct snd_kcontrol_new wm9713_hp_spkl_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[8]);
+
+/* speaker right output mux */
+static const struct snd_kcontrol_new wm9713_hp_spkr_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[9]);
+
+/* headphone left output mux */
+static const struct snd_kcontrol_new wm9713_hpl_out_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[10]);
+
+/* headphone right output mux */
+static const struct snd_kcontrol_new wm9713_hpr_out_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[11]);
+
+/* Out3 mux */
+static const struct snd_kcontrol_new wm9713_out3_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[12]);
+
+/* Out4 mux */
+static const struct snd_kcontrol_new wm9713_out4_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[13]);
+
+/* DAC inv mux 1 */
+static const struct snd_kcontrol_new wm9713_dac_inv1_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[14]);
+
+/* DAC inv mux 2 */
+static const struct snd_kcontrol_new wm9713_dac_inv2_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[15]);
+
+/* Capture source left */
+static const struct snd_kcontrol_new wm9713_rec_srcl_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[3]);
+
+/* Capture source right */
+static const struct snd_kcontrol_new wm9713_rec_srcr_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[4]);
+
+/* mic source */
+static const struct snd_kcontrol_new wm9713_mic_sel_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[18]);
+
+/* mic source B virtual control */
+static const struct snd_kcontrol_new wm9713_micb_sel_mux_controls =
+SOC_DAPM_ENUM("Route", wm9713_enum[19]);
+
+static const struct snd_soc_dapm_widget wm9713_dapm_widgets[] = {
+SND_SOC_DAPM_MUX("Capture Headphone Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_hp_rec_mux_controls),
+SND_SOC_DAPM_MUX("Sidetone Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_hp_mic_mux_controls),
+SND_SOC_DAPM_MUX("Capture Mono Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_mono_mic_mux_controls),
+SND_SOC_DAPM_MUX("Mono Out Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_mono_mux_controls),
+SND_SOC_DAPM_MUX("Left Speaker Out Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_hp_spkl_mux_controls),
+SND_SOC_DAPM_MUX("Right Speaker Out Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_hp_spkr_mux_controls),
+SND_SOC_DAPM_MUX("Left Headphone Out Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_hpl_out_mux_controls),
+SND_SOC_DAPM_MUX("Right Headphone Out Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_hpr_out_mux_controls),
+SND_SOC_DAPM_MUX("Out 3 Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_out3_mux_controls),
+SND_SOC_DAPM_MUX("Out 4 Mux", SND_SOC_NOPM, 0, 0,
+	&wm9713_out4_mux_controls),
+SND_SOC_DAPM_MUX("DAC Inv Mux 1", SND_SOC_NOPM, 0, 0,
+	&wm9713_dac_inv1_mux_controls),
+SND_SOC_DAPM_MUX("DAC Inv Mux 2", SND_SOC_NOPM, 0, 0,
+	&wm9713_dac_inv2_mux_controls),
+SND_SOC_DAPM_MUX("Left Capture Source", SND_SOC_NOPM, 0, 0,
+	&wm9713_rec_srcl_mux_controls),
+SND_SOC_DAPM_MUX("Right Capture Source", SND_SOC_NOPM, 0, 0,
+	&wm9713_rec_srcr_mux_controls),
+SND_SOC_DAPM_MUX("Mic A Source", SND_SOC_NOPM, 0, 0,
+	&wm9713_mic_sel_mux_controls ),
+SND_SOC_DAPM_MUX("Mic B Source", SND_SOC_NOPM, 0, 0,
+	&wm9713_micb_sel_mux_controls ),
+SND_SOC_DAPM_MIXER_E("Left HP Mixer", AC97_EXTENDED_MID, 3, 1,
+	&wm9713_hpl_mixer_controls[0], ARRAY_SIZE(wm9713_hpl_mixer_controls),
+	mixer_event, SND_SOC_DAPM_POST_REG),
+SND_SOC_DAPM_MIXER_E("Right HP Mixer", AC97_EXTENDED_MID, 2, 1,
+	&wm9713_hpr_mixer_controls[0], ARRAY_SIZE(wm9713_hpr_mixer_controls),
+	mixer_event, SND_SOC_DAPM_POST_REG),
+SND_SOC_DAPM_MIXER("Mono Mixer", AC97_EXTENDED_MID, 0, 1,
+	&wm9713_mono_mixer_controls[0], ARRAY_SIZE(wm9713_mono_mixer_controls)),
+SND_SOC_DAPM_MIXER("Speaker Mixer", AC97_EXTENDED_MID, 1, 1,
+	&wm9713_speaker_mixer_controls[0],
+	ARRAY_SIZE(wm9713_speaker_mixer_controls)),
+SND_SOC_DAPM_DAC("Left DAC", "Left HiFi Playback", AC97_EXTENDED_MID, 7, 1),
+SND_SOC_DAPM_DAC("Right DAC", "Right HiFi Playback", AC97_EXTENDED_MID, 6, 1),
+SND_SOC_DAPM_MIXER("AC97 Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+SND_SOC_DAPM_MIXER("HP Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+SND_SOC_DAPM_MIXER("Capture Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+SND_SOC_DAPM_DAC("Voice DAC", "Voice Playback", AC97_EXTENDED_MID, 12, 1),
+SND_SOC_DAPM_DAC("Aux DAC", "Aux Playback", AC97_EXTENDED_MID, 11, 1),
+SND_SOC_DAPM_ADC("Left ADC", "Left HiFi Capture", AC97_EXTENDED_MID, 5, 1),
+SND_SOC_DAPM_ADC("Right ADC", "Right HiFi Capture", AC97_EXTENDED_MID, 4, 1),
+SND_SOC_DAPM_PGA("Left Headphone", AC97_EXTENDED_MSTATUS, 10, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Right Headphone", AC97_EXTENDED_MSTATUS, 9, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Left Speaker", AC97_EXTENDED_MSTATUS, 8, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Right Speaker", AC97_EXTENDED_MSTATUS, 7, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Out 3", AC97_EXTENDED_MSTATUS, 11, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Out 4", AC97_EXTENDED_MSTATUS, 12, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mono Out", AC97_EXTENDED_MSTATUS, 13, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Left Line In", AC97_EXTENDED_MSTATUS, 6, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Right Line In", AC97_EXTENDED_MSTATUS, 5, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mono In", AC97_EXTENDED_MSTATUS, 4, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mic A PGA", AC97_EXTENDED_MSTATUS, 3, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mic B PGA", AC97_EXTENDED_MSTATUS, 2, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mic A Pre Amp", AC97_EXTENDED_MSTATUS, 1, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mic B Pre Amp", AC97_EXTENDED_MSTATUS, 0, 1, NULL, 0),
+SND_SOC_DAPM_MICBIAS("Mic Bias", AC97_EXTENDED_MSTATUS, 14, 1),
+SND_SOC_DAPM_OUTPUT("MONO"),
+SND_SOC_DAPM_OUTPUT("HPL"),
+SND_SOC_DAPM_OUTPUT("HPR"),
+SND_SOC_DAPM_OUTPUT("SPKL"),
+SND_SOC_DAPM_OUTPUT("SPKR"),
+SND_SOC_DAPM_OUTPUT("OUT3"),
+SND_SOC_DAPM_OUTPUT("OUT4"),
+SND_SOC_DAPM_INPUT("LINEL"),
+SND_SOC_DAPM_INPUT("LINER"),
+SND_SOC_DAPM_INPUT("MONOIN"),
+SND_SOC_DAPM_INPUT("PCBEEP"),
+SND_SOC_DAPM_INPUT("MIC1"),
+SND_SOC_DAPM_INPUT("MIC2A"),
+SND_SOC_DAPM_INPUT("MIC2B"),
+SND_SOC_DAPM_VMID("VMID"),
+};
+
+static const char *audio_map[][3] = {
+	/* left HP mixer */
+	{"Left HP Mixer", "PC Beep Playback Switch", "PCBEEP"},
+	{"Left HP Mixer", "Voice Playback Switch",   "Voice DAC"},
+	{"Left HP Mixer", "Aux Playback Switch",     "Aux DAC"},
+	{"Left HP Mixer", "Bypass Playback Switch",  "Left Line In"},
+	{"Left HP Mixer", "PCM Playback Switch",     "Left DAC"},
+	{"Left HP Mixer", "MonoIn Playback Switch",  "Mono In"},
+	{"Left HP Mixer", NULL,  "Capture Headphone Mux"},
+
+	/* right HP mixer */
+	{"Right HP Mixer", "PC Beep Playback Switch", "PCBEEP"},
+	{"Right HP Mixer", "Voice Playback Switch",   "Voice DAC"},
+	{"Right HP Mixer", "Aux Playback Switch",     "Aux DAC"},
+	{"Right HP Mixer", "Bypass Playback Switch",  "Right Line In"},
+	{"Right HP Mixer", "PCM Playback Switch",     "Right DAC"},
+	{"Right HP Mixer", "MonoIn Playback Switch",  "Mono In"},
+	{"Right HP Mixer", NULL,  "Capture Headphone Mux"},
+
+	/* virtual mixer - mixes left & right channels for spk and mono */
+	{"AC97 Mixer", NULL, "Left DAC"},
+	{"AC97 Mixer", NULL, "Right DAC"},
+	{"Line Mixer", NULL, "Right Line In"},
+	{"Line Mixer", NULL, "Left Line In"},
+	{"HP Mixer", NULL, "Left HP Mixer"},
+	{"HP Mixer", NULL, "Right HP Mixer"},
+	{"Capture Mixer", NULL, "Left Capture Source"},
+	{"Capture Mixer", NULL, "Right Capture Source"},
+
+	/* speaker mixer */
+	{"Speaker Mixer", "PC Beep Playback Switch", "PCBEEP"},
+	{"Speaker Mixer", "Voice Playback Switch",   "Voice DAC"},
+	{"Speaker Mixer", "Aux Playback Switch",     "Aux DAC"},
+	{"Speaker Mixer", "Bypass Playback Switch",  "Line Mixer"},
+	{"Speaker Mixer", "PCM Playback Switch",     "AC97 Mixer"},
+	{"Speaker Mixer", "MonoIn Playback Switch",  "Mono In"},
+
+	/* mono mixer */
+	{"Mono Mixer", "PC Beep Playback Switch", "PCBEEP"},
+	{"Mono Mixer", "Voice Playback Switch",   "Voice DAC"},
+	{"Mono Mixer", "Aux Playback Switch",     "Aux DAC"},
+	{"Mono Mixer", "Bypass Playback Switch",  "Line Mixer"},
+	{"Mono Mixer", "PCM Playback Switch",     "AC97 Mixer"},
+	{"Mono Mixer", NULL,  "Capture Mono Mux"},
+
+	/* DAC inv mux 1 */
+	{"DAC Inv Mux 1", "Mono", "Mono Mixer"},
+	{"DAC Inv Mux 1", "Speaker", "Speaker Mixer"},
+	{"DAC Inv Mux 1", "Left Headphone", "Left HP Mixer"},
+	{"DAC Inv Mux 1", "Right Headphone", "Right HP Mixer"},
+	{"DAC Inv Mux 1", "Headphone Mono", "HP Mixer"},
+
+	/* DAC inv mux 2 */
+	{"DAC Inv Mux 2", "Mono", "Mono Mixer"},
+	{"DAC Inv Mux 2", "Speaker", "Speaker Mixer"},
+	{"DAC Inv Mux 2", "Left Headphone", "Left HP Mixer"},
+	{"DAC Inv Mux 2", "Right Headphone", "Right HP Mixer"},
+	{"DAC Inv Mux 2", "Headphone Mono", "HP Mixer"},
+
+	/* headphone left mux */
+	{"Left Headphone Out Mux", "Headphone", "Left HP Mixer"},
+
+	/* headphone right mux */
+	{"Right Headphone Out Mux", "Headphone", "Right HP Mixer"},
+
+	/* speaker left mux */
+	{"Left Speaker Out Mux", "Headphone", "Left HP Mixer"},
+	{"Left Speaker Out Mux", "Speaker", "Speaker Mixer"},
+	{"Left Speaker Out Mux", "Inv", "DAC Inv Mux 1"},
+
+	/* speaker right mux */
+	{"Right Speaker Out Mux", "Headphone", "Right HP Mixer"},
+	{"Right Speaker Out Mux", "Speaker", "Speaker Mixer"},
+	{"Right Speaker Out Mux", "Inv", "DAC Inv Mux 2"},
+
+	/* mono mux */
+	{"Mono Out Mux", "Mono", "Mono Mixer"},
+	{"Mono Out Mux", "Inv", "DAC Inv Mux 1"},
+
+	/* out 3 mux */
+	{"Out 3 Mux", "Inv 1", "DAC Inv Mux 1"},
+
+	/* out 4 mux */
+	{"Out 4 Mux", "Inv 2", "DAC Inv Mux 2"},
+
+	/* output pga */
+	{"HPL", NULL, "Left Headphone"},
+	{"Left Headphone", NULL, "Left Headphone Out Mux"},
+	{"HPR", NULL, "Right Headphone"},
+	{"Right Headphone", NULL, "Right Headphone Out Mux"},
+	{"OUT3", NULL, "Out 3"},
+	{"Out 3", NULL, "Out 3 Mux"},
+	{"OUT4", NULL, "Out 4"},
+	{"Out 4", NULL, "Out 4 Mux"},
+	{"SPKL", NULL, "Left Speaker"},
+	{"Left Speaker", NULL, "Left Speaker Out Mux"},
+	{"SPKR", NULL, "Right Speaker"},
+	{"Right Speaker", NULL, "Right Speaker Out Mux"},
+	{"MONO", NULL, "Mono Out"},
+	{"Mono Out", NULL, "Mono Out Mux"},
+
+	/* input pga */
+	{"Left Line In", NULL, "LINEL"},
+	{"Right Line In", NULL, "LINER"},
+	{"Mono In", NULL, "MONOIN"},
+	{"Mic A PGA", NULL, "Mic A Pre Amp"},
+	{"Mic B PGA", NULL, "Mic B Pre Amp"},
+
+	/* left capture select */
+	{"Left Capture Source", "Mic 1", "Mic A Pre Amp"},
+	{"Left Capture Source", "Mic 2", "Mic B Pre Amp"},
+	{"Left Capture Source", "Line", "LINEL"},
+	{"Left Capture Source", "Mono In", "MONOIN"},
+	{"Left Capture Source", "Headphone", "Left HP Mixer"},
+	{"Left Capture Source", "Speaker", "Speaker Mixer"},
+	{"Left Capture Source", "Mono Out", "Mono Mixer"},
+
+	/* right capture select */
+	{"Right Capture Source", "Mic 1", "Mic A Pre Amp"},
+	{"Right Capture Source", "Mic 2", "Mic B Pre Amp"},
+	{"Right Capture Source", "Line", "LINER"},
+	{"Right Capture Source", "Mono In", "MONOIN"},
+	{"Right Capture Source", "Headphone", "Right HP Mixer"},
+	{"Right Capture Source", "Speaker", "Speaker Mixer"},
+	{"Right Capture Source", "Mono Out", "Mono Mixer"},
+
+	/* left ADC */
+	{"Left ADC", NULL, "Left Capture Source"},
+
+	/* right ADC */
+	{"Right ADC", NULL, "Right Capture Source"},
+
+	/* mic */
+	{"Mic A Pre Amp", NULL, "Mic A Source"},
+	{"Mic A Source", "Mic 1", "MIC1"},
+	{"Mic A Source", "Mic 2 A", "MIC2A"},
+	{"Mic A Source", "Mic 2 B", "Mic B Source"},
+	{"Mic B Pre Amp", "MPB", "Mic B Source"},
+	{"Mic B Source", NULL, "MIC2B"},
+
+	/* headphone capture */
+	{"Capture Headphone Mux", "Stereo", "Capture Mixer"},
+	{"Capture Headphone Mux", "Left", "Left Capture Source"},
+	{"Capture Headphone Mux", "Right", "Right Capture Source"},
+
+	/* mono capture */
+	{"Capture Mono Mux", "Stereo", "Capture Mixer"},
+	{"Capture Mono Mux", "Left", "Left Capture Source"},
+	{"Capture Mono Mux", "Right", "Right Capture Source"},
+
+	{NULL, NULL, NULL},
+};
+
+static int wm9713_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm9713_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm9713_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg == AC97_RESET || reg == AC97_GPIO_STATUS ||
+		reg == AC97_VENDOR_ID1 || reg == AC97_VENDOR_ID2 ||
+		reg == AC97_CD)
+		return soc_ac97_ops.read(codec->ac97, reg);
+	else {
+		reg = reg >> 1;
+
+		if (reg > (ARRAY_SIZE(wm9713_reg)))
+			return -EIO;
+
+		return cache[reg];
+	}
+}
+
+static int ac97_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int val)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg < 0x7c)
+		soc_ac97_ops.write(codec->ac97, reg, val);
+	reg = reg >> 1;
+	if (reg <= (ARRAY_SIZE(wm9713_reg)))
+		cache[reg] = val;
+
+	return 0;
+}
+
+struct pll_ {
+	unsigned int in_hz;
+	unsigned int lf:1; /* allows low frequency use */
+	unsigned int sdm:1; /* allows fraction n div */
+	unsigned int divsel:1; /* enables input clock div */
+	unsigned int divctl:1; /* input clock divider */
+	unsigned int n:4;
+	unsigned int k;
+};
+
+struct pll_ pll[] = {
+	{13000000, 0, 1, 0, 0, 7, 0x23f488},
+	{2048000,  1, 0, 0, 0, 12, 0x0},
+	{4096000,  1, 0, 0, 0, 6, 0x0},
+	{12288000, 0, 0, 0, 0, 8, 0x0},
+	/* liam - add more entries */
+};
+
+/* we must have either 24.576MHz or a PLL freq */
+static unsigned int wm9713_config_ac97sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	int i;
+	dai->mclk = 0;
+
+	/* first check if we can get away witout burning any PLL power */
+	if (24576000 == clk) {
+		/* standard AC97 clock */
+		dai->mclk = clk;
+		goto out;
+	}
+
+	/* ok no standard clock, so we must now try the PLL */
+	for(i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (clk == pll[i].in_hz) {
+			dai->mclk = clk; /* clock out */
+			goto out;
+		}
+	}
+
+out:
+	return dai->mclk;
+}
+
+/* The WM9713 voice DAC can only run at 256FS. This interface and DAC are
+ * clocked by the main AC97 clock divided down to 256 FS.
+ */
+static unsigned int wm9713_config_vsysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+
+	int i, j, best_clk = info->fs * info->rate;
+
+	/* can we run at this clk without the PLL ? */
+	for (i = 1; i <= 16; i++) {
+		if (best_clk * i == clk) {
+			dai->pll_in = 0;
+			dai->clk_div = i << 1;
+			dai->mclk = best_clk;
+			return dai->mclk;
+		}
+	}
+
+	/* now check for PLL support */
+	for (i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (pll[i].in_hz == clk) {
+			for (j = 1; j <= 16; j++) {
+				if (24576000 == j * best_clk) {
+					dai->pll_in = clk;
+					dai->pll_out = 24576000;
+					dai->clk_div = j << 1;
+					dai->mclk = best_clk;
+					return dai->mclk;
+				}
+			}
+		}
+	}
+
+	/* this clk is not supported */
+	return 0;
+}
+
+u32 wm9713_set_pll(struct snd_soc_codec *codec, u32 in)
+{
+	struct wm9713 *wm = (struct wm9713*)codec->private_data;
+	int i;
+	u16 reg, reg2;
+
+	/* turn PLL off ? */
+	if (in == 0) {
+		/* disable PLL power and select ext source */
+		reg = ac97_read(codec, AC97_HANDSET_RATE);
+		ac97_write(codec, AC97_HANDSET_RATE, reg | 0x0080);
+		reg = ac97_read(codec, AC97_EXTENDED_MID);
+		ac97_write(codec, AC97_EXTENDED_MID, reg | 0x0200);
+		wm->pll = 0;
+		return 0;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (pll[i].in_hz == in)
+			goto found;
+	}
+	return -EINVAL;
+
+found:
+	if (pll[i].sdm == 0) {
+		reg = (pll[i].n << 12) | (pll[i].lf << 11) |
+			(pll[i].divsel << 9) | (pll[i].divctl << 8);
+		ac97_write(codec, AC97_LINE1_LEVEL, reg);
+	} else {
+		/* write the fractional k to the reg 0x46 pages */
+		reg2 = (pll[i].n << 12) | (pll[i].lf << 11) | (pll[i].sdm << 10) |
+			(pll[i].divsel << 9) | (pll[i].divctl << 8);
+
+		reg = reg2 | (0x5 << 4) | (pll[i].k >> 20); /* K [21:20] */
+		ac97_write(codec, AC97_LINE1_LEVEL, reg);
+
+		reg = reg2 | (0x4 << 4) | ((pll[i].k >> 16) & 0xf); /* K [19:16] */
+		ac97_write(codec, AC97_LINE1_LEVEL, reg);
+
+		reg = reg2 | (0x3 << 4) | ((pll[i].k >> 12) & 0xf); /* K [15:12] */
+		ac97_write(codec, AC97_LINE1_LEVEL, reg);
+
+		reg = reg2 | (0x2 << 4) | ((pll[i].k >> 8) & 0xf); /* K [11:8] */
+		ac97_write(codec, AC97_LINE1_LEVEL, reg);
+
+		reg = reg2 | (0x1 << 4) | ((pll[i].k >> 4) & 0xf); /* K [7:4] */
+		ac97_write(codec, AC97_LINE1_LEVEL, reg);
+
+		reg = reg2 | (0x0 << 4) | (pll[i].k & 0xf); /* K [3:0] */
+		ac97_write(codec, AC97_LINE1_LEVEL, reg);
+	}
+
+	/* turn PLL on and select as source */
+	reg = ac97_read(codec, AC97_EXTENDED_MID);
+	ac97_write(codec, AC97_EXTENDED_MID, reg & 0xfdff);
+	reg = ac97_read(codec, AC97_HANDSET_RATE);
+	ac97_write(codec, AC97_HANDSET_RATE, reg & 0xff7f);
+	/* wait 10ms AC97 link frames for the link to stabilise */
+	schedule_timeout_interruptible(msecs_to_jiffies(10));
+	wm->pll = in;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wm9713_set_pll);
+
+static int wm9713_voice_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 reg = 0x8000, bfs, div, gpio;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+	gpio = ac97_read(codec, AC97_GPIO_CFG) & 0xffe2;
+
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:
+		reg |= 0x4000;
+		gpio |= 0x0008;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		reg |= 0x6000;
+		gpio |= 0x000c;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		reg |= 0x0200;
+		gpio |= 0x000d;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		gpio |= 0x0009;
+		break;
+	}
+	ac97_write(codec, AC97_GPIO_CFG, gpio);
+
+	/* enable PLL if needed */
+	if (rtd->codec_dai->pll_in)
+		wm9713_set_pll(codec, rtd->codec_dai->pll_in);
+
+	/* set the PCM divider */
+	div = ac97_read(codec, AC97_HANDSET_RATE) & 0xf0ff;
+	ac97_write(codec, AC97_HANDSET_RATE, div |
+		((rtd->codec_dai->clk_div >> 1) -1) << 8);
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		reg |= 0x00c0;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		reg |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		reg |= 0x0040;
+		break;
+	}
+
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		reg |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		reg |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		reg |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		reg |= 0x0043;
+		break;
+	}
+
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		reg |= 0x0004;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		reg |= 0x0008;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		reg |= 0x000c;
+		break;
+	}
+
+	switch (bfs) {
+	case 2:
+		reg |= (0x1 << 9);
+		break;
+	case 4:
+		reg |= (0x2 << 9);
+		break;
+	case 8:
+		reg |= (0x3 << 9);
+		break;
+	case 16:
+		reg |= (0x4 << 9);
+		break;
+	}
+
+	/* enable PCM interface in master mode */
+	ac97_write(codec, AC97_CENTER_LFE_MASTER, reg);
+	return 0;
+}
+
+static void wm9713_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (!codec->active)
+		wm9713_set_pll(codec, 0);
+}
+
+static void wm9713_voiceshutdown(snd_pcm_substream_t *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_device *socdev = rtd->socdev;
+    struct snd_soc_codec *codec = socdev->codec;
+    u16 status;
+
+    wm9713_shutdown(substream);
+
+    /* Gracefully shut down the voice interface. */
+    status = ac97_read(codec, AC97_EXTENDED_STATUS) | 0x1000;
+    ac97_write(codec,AC97_HANDSET_RATE,0x0280);
+    schedule_timeout_interruptible(msecs_to_jiffies(1));
+    ac97_write(codec,AC97_HANDSET_RATE,0x0F80);
+    ac97_write(codec,AC97_EXTENDED_MID,status);
+}
+
+static int ac97_hifi_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg;
+	u16 vra;
+
+	/* we need a 24576000Hz clock to run at the correct speed */
+	if (rtd->codec_dai->mclk != 24576000)
+		wm9713_set_pll(codec, rtd->codec_dai->mclk);
+
+	vra = ac97_read(codec, AC97_EXTENDED_STATUS);
+	ac97_write(codec, AC97_EXTENDED_STATUS, vra | 0x1);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg = AC97_PCM_FRONT_DAC_RATE;
+	else
+		reg = AC97_PCM_LR_ADC_RATE;
+
+	return ac97_write(codec, reg, runtime->rate);
+}
+
+static int ac97_aux_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 vra, xsle;
+
+	/* we need a 24576000Hz clock to run at the correct speed */
+	if (rtd->codec_dai->mclk != 24576000)
+		wm9713_set_pll(codec, rtd->codec_dai->mclk);
+
+	vra = ac97_read(codec, AC97_EXTENDED_STATUS);
+	ac97_write(codec, AC97_EXTENDED_STATUS, vra | 0x1);
+	xsle = ac97_read(codec, AC97_PCI_SID);
+	ac97_write(codec, AC97_PCI_SID, xsle | 0x8000);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -ENODEV;
+
+	return ac97_write(codec, AC97_PCM_SURR_DAC_RATE, runtime->rate);
+}
+
+struct snd_soc_codec_dai wm9713_dai[] = {
+{
+	.name = "AC97 HiFi",
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.config_sysclk = wm9713_config_ac97sysclk,
+	.ops = {
+		.shutdown = wm9713_shutdown,
+		.prepare = ac97_hifi_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(ac97_modes),
+		.mode = ac97_modes,},},
+	{
+	.name = "AC97 Aux",
+	.playback = {
+		.stream_name = "Aux Playback",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.config_sysclk = wm9713_config_ac97sysclk,
+	.ops = {
+		.shutdown = wm9713_shutdown,
+		.prepare = ac97_aux_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(ac97_modes),
+		.mode = ac97_modes,}
+	},
+	{
+	.name = "WM9713 Voice",
+	.playback = {
+		.stream_name = "Voice Playback",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.capture = {
+		.stream_name = "Voice Capture",
+		.channels_min = 1,
+		.channels_max = 2,},
+	.config_sysclk = wm9713_config_vsysclk,
+	.ops = {
+		.prepare = wm9713_voice_prepare,
+		.shutdown = wm9713_voiceshutdown,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm9713_voice_modes),
+		.mode = wm9713_voice_modes,},
+	},
+};
+EXPORT_SYMBOL_GPL(wm9713_dai);
+
+int wm9713_reset(struct snd_soc_codec *codec, int try_warm)
+{
+	if (try_warm && soc_ac97_ops.warm_reset) {
+		soc_ac97_ops.warm_reset(codec->ac97);
+		if (!(ac97_read(codec, 0) & 0x8000))
+			return 1;
+	}
+
+	soc_ac97_ops.reset(codec->ac97);
+	if (ac97_read(codec, 0) & 0x8000)
+		return -EIO;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wm9713_reset);
+
+static int wm9713_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 reg;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* enable thermal shutdown */
+		reg = ac97_read(codec, AC97_EXTENDED_MID) & 0x1bff;
+		ac97_write(codec, AC97_EXTENDED_MID, reg);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* enable master bias and vmid */
+		reg = ac97_read(codec, AC97_EXTENDED_MID) & 0x3bff;
+		ac97_write(codec, AC97_EXTENDED_MID, reg);
+		ac97_write(codec, AC97_POWERDOWN, 0x0000);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* disable everything including AC link */
+		ac97_write(codec, AC97_EXTENDED_MID, 0xffff);
+		ac97_write(codec, AC97_EXTENDED_MSTATUS, 0xffff);
+		ac97_write(codec, AC97_POWERDOWN, 0xffff);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+static int wm9713_soc_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	struct wm9713 *wm = (struct wm9713*)codec->private_data;
+
+	if (wm->pll) {
+		wm->pll_resume = wm->pll;
+		wm9713_set_pll(codec, 0);
+	}
+	wm9713_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm9713_soc_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	struct wm9713 *wm = (struct wm9713*)codec->private_data;
+	int i, ret;
+	u16 *cache = codec->reg_cache;
+
+	if ((ret = wm9713_reset(codec, 1)) < 0){
+		printk(KERN_ERR "could not reset AC97 codec\n");
+		return ret;
+	}
+
+	wm9713_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* only synchronise the codec if warm reset failed */
+	if (ret == 0) {
+		for (i = 2; i < ARRAY_SIZE(wm9713_reg) << 1; i+=2) {
+			if (i == AC97_POWERDOWN || i == AC97_EXTENDED_MID ||
+				i == AC97_EXTENDED_MSTATUS || i > 0x66)
+				continue;
+			soc_ac97_ops.write(codec->ac97, i, cache[i>>1]);
+		}
+	}
+
+	if (wm->pll_resume) {
+		wm9713_set_pll(codec, wm->pll_resume);
+		wm->pll_resume = 0;
+	}
+
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0)
+		wm9713_dapm_event(codec, SNDRV_CTL_POWER_D0);
+
+	return ret;
+}
+
+static int wm9713_soc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	int ret = 0, reg;
+
+	printk(KERN_INFO "WM9713/WM9714 SoC Audio Codec %s\n", WM9713_VERSION);
+
+	socdev->codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (socdev->codec == NULL)
+		return -ENOMEM;
+	codec = socdev->codec;
+	mutex_init(&codec->mutex);
+
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm9713_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL){
+		kfree(socdev->codec);
+		socdev->codec = NULL;
+		return -ENOMEM;
+	}
+	memcpy(codec->reg_cache, wm9713_reg,
+		sizeof(u16) * ARRAY_SIZE(wm9713_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm9713_reg);
+	codec->reg_cache_step = 2;
+
+	codec->private_data = kzalloc(sizeof(struct wm9713), GFP_KERNEL);
+	if (codec->private_data == NULL) {
+		kfree(codec->reg_cache);
+		kfree(socdev->codec);
+		socdev->codec = NULL;
+		return -ENOMEM;
+	}
+
+	codec->name = "WM9713";
+	codec->owner = THIS_MODULE;
+	codec->dai = wm9713_dai;
+	codec->num_dai = ARRAY_SIZE(wm9713_dai);
+	codec->write = ac97_write;
+	codec->read = ac97_read;
+	codec->dapm_event = wm9713_dapm_event;
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	ret = snd_soc_new_ac97_codec(codec, &soc_ac97_ops, 0);
+	if (ret < 0)
+		goto err;
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0)
+		goto pcm_err;
+
+	/* do a cold reset for the controller and then try
+	 * a warm reset followed by an optional cold reset for codec */
+	wm9713_reset(codec, 0);
+	ret = wm9713_reset(codec, 1);
+	if (ret < 0)	{
+		printk(KERN_ERR "AC97 link error\n");
+		goto reset_err;
+	}
+
+	wm9713_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* unmute the adc - move to kcontrol */
+	reg = ac97_read(codec, AC97_CD) & 0x7fff;
+	ac97_write(codec, AC97_CD, reg);
+
+	wm9713_add_controls(codec);
+	wm9713_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0)
+		goto reset_err;
+	return 0;
+
+reset_err:
+	snd_soc_free_pcms(socdev);
+
+pcm_err:
+	snd_soc_free_ac97_codec(codec);
+
+err:
+	kfree(socdev->codec->private_data);
+	kfree(socdev->codec->reg_cache);
+	kfree(socdev->codec);
+	socdev->codec = NULL;
+	return ret;
+}
+
+static int wm9713_soc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec == NULL)
+		return 0;
+
+	snd_soc_dapm_free(socdev);
+	snd_soc_free_pcms(socdev);
+	snd_soc_free_ac97_codec(codec);
+	kfree(codec->private_data);
+	kfree(codec->reg_cache);
+	kfree(codec);
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm9713= {
+	.probe = 	wm9713_soc_probe,
+	.remove = 	wm9713_soc_remove,
+	.suspend =	wm9713_soc_suspend,
+	.resume = 	wm9713_soc_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm9713);
+
+MODULE_DESCRIPTION("ASoC WM9713/WM9714 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm9713.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm9713.h
@@ -0,0 +1,18 @@
+/*
+ * wm9713.h  --  WM9713 Soc Audio driver
+ */
+
+#ifndef _WM9713_H
+#define _WM9713_H
+
+#define WM9713_DAI_AC97_HIFI	0
+#define WM9713_DAI_AC97_AUX		1
+#define WM9713_DAI_PCM_VOICE	2
+
+extern struct snd_soc_codec_device soc_codec_dev_wm9713;
+extern struct snd_soc_codec_dai wm9713_dai[3];
+
+u32 wm9713_set_pll(struct snd_soc_codec *codec, u32 in);
+int wm9713_reset(struct snd_soc_codec *codec,  int try_warm);
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/pxa/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/Kconfig
@@ -0,0 +1,125 @@
+menu "SoC Audio for the Intel PXA2xx"
+
+config SND_PXA2xx_SOC
+	tristate "SoC Audio for the Intel PXA2xx chip"
+	depends on ARCH_PXA && SND
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the PXA2xx AC97, I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_PXA2xx_AC97
+	tristate
+	select SND_AC97_CODEC
+
+config SND_PXA2xx_SOC_AC97
+	tristate
+	select SND_AC97_BUS
+	select SND_SOC_AC97_BUS
+
+config SND_PXA2xx_SOC_I2S
+	tristate
+
+config SND_PXA2xx_SOC_SSP
+	tristate
+	select PXA_SSP
+
+config SND_PXA2xx_SOC_MAINSTONE
+	tristate "SoC AC97 Audio support for Intel Mainstone"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_AC97
+	help
+	  Say Y if you want to add support for generic AC97 SoC audio on Mainstone.
+
+config SND_PXA2xx_SOC_MAINSTONE_WM8731
+	tristate "SoC I2S Audio support for Intel Mainstone - WM8731"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_SOC_I2S
+	help
+	  Say Y if you want to add support for SoC audio on Mainstone
+	  with the WM8731.
+
+config SND_PXA2xx_SOC_MAINSTONE_WM8753
+	tristate "SoC I2S/SSP Audio support for Intel Mainstone - WM8753"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_SOC_I2S
+	select SND_PXA2xx_SOC_SSP
+	help
+	  Say Y if you want to add support for SoC audio on Mainstone
+	  with the WM8753.
+
+config SND_PXA2xx_SOC_MAINSTONE_WM8974
+	tristate "SoC I2S Audio support for Intel Mainstone - WM8974"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_SOC_I2S
+	help
+	  Say Y if you want to add support for SoC audio on Mainstone
+	  with the WM8974.
+
+config SND_PXA2xx_SOC_MAINSTONE_WM9713
+	tristate "SoC I2S/SSP Audio support for Intel Mainstone - WM9713"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_SOC_AC97
+	select SND_PXA2xx_SOC_SSP
+	help
+	  Say Y if you want to add support for SoC voice audio on Mainstone
+	  with the WM9713.
+
+config SND_MAINSTONE_BASEBAND
+	tristate "Example SoC Baseband Audio support for Intel Mainstone"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_SOC_AC97
+	help
+	  Say Y if you want to add support for SoC baseband on Mainstone
+	  with the WM9713 and example Baseband modem.
+
+config SND_MAINSTONE_BLUETOOTH
+	tristate "Example SoC Bluetooth Audio support for Intel Mainstone"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_SOC_I2S
+	help
+	  Say Y if you want to add support for SoC bluetooth on Mainstone
+	  with the WM8753 and example Bluetooth codec.
+
+config SND_PXA2xx_SOC_MAINSTONE_WM9712
+	tristate "SoC I2S/SSP Audio support for Intel Mainstone - WM9712"
+	depends on SND_PXA2xx_SOC && MACH_MAINSTONE
+	select SND_PXA2xx_SOC_AC97
+	help
+	  Say Y if you want to add support for SoC voice audio on Mainstone
+	  with the WM9712.
+
+config SND_PXA2xx_SOC_CORGI
+	tristate "SoC Audio support for Sharp Zaurus SL-C7x0"
+	depends on SND_PXA2xx_SOC && PXA_SHARP_C7xx
+	select SND_PXA2xx_SOC_I2S
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-C7x0 models (Corgi, Shepherd, Husky).
+
+config SND_PXA2xx_SOC_SPITZ
+	tristate "SoC Audio support for Sharp Zaurus SL-Cxx00"
+	depends on SND_PXA2xx_SOC && PXA_SHARP_Cxx00
+	select SND_PXA2xx_SOC_I2S
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-Cxx00 models (Spitz, Borzoi and Akita).
+
+config SND_PXA2xx_SOC_POODLE
+	tristate "SoC Audio support for Poodle"
+	depends on SND_PXA2xx_SOC && MACH_POODLE
+	select SND_PXA2xx_SOC_I2S
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-5600 model (Poodle).
+
+config SND_PXA2xx_SOC_TOSA
+	tristate "SoC AC97 Audio support for Tosa"
+	depends on SND_PXA2xx_SOC && MACH_TOSA
+	select SND_PXA2xx_SOC_AC97
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-C6000x models (Tosa).
+
+endmenu
Index: linux-2.6-pxa-new/sound/soc/pxa/Makefile
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/Makefile
@@ -0,0 +1,36 @@
+# PXA Platform Support
+snd-soc-pxa2xx-objs := pxa2xx-pcm.o
+snd-soc-pxa2xx-ac97-objs := pxa2xx-ac97.o
+snd-soc-pxa2xx-i2s-objs := pxa2xx-i2s.o
+snd-soc-pxa2xx-ssp-objs := pxa2xx-ssp.o
+
+obj-$(CONFIG_SND_PXA2xx_SOC) += snd-soc-pxa2xx.o
+obj-$(CONFIG_SND_PXA2xx_SOC_AC97) += snd-soc-pxa2xx-ac97.o
+obj-$(CONFIG_SND_PXA2xx_SOC_I2S) += snd-soc-pxa2xx-i2s.o
+obj-$(CONFIG_SND_PXA2xx_SOC_SSP) += snd-soc-pxa2xx-ssp.o
+
+# PXA Machine Support
+snd-soc-corgi-objs := corgi.o
+snd-soc-mainstone-wm8731-objs := mainstone_wm8731.o
+snd-soc-mainstone-wm8753-objs := mainstone_wm8753.o
+snd-soc-mainstone-wm8974-objs := mainstone_wm8974.o
+snd-soc-mainstone-wm9713-objs := mainstone_wm9713.o
+snd-soc-mainstone-wm9712-objs := mainstone_wm9712.o
+snd-soc-mainstone-baseband-objs := mainstone_baseband.o
+snd-soc-mainstone-bluetooth-objs := mainstone_bluetooth.o
+snd-soc-poodle-objs := poodle.o
+snd-soc-tosa-objs := tosa.o
+snd-soc-spitz-objs := spitz.o
+
+obj-$(CONFIG_SND_PXA2xx_SOC_CORGI) += snd-soc-corgi.o
+obj-$(CONFIG_SND_PXA2xx_SOC_MAINSTONE_WM8731) += snd-soc-mainstone-wm8731.o
+obj-$(CONFIG_SND_PXA2xx_SOC_MAINSTONE_WM8753) += snd-soc-mainstone-wm8753.o
+obj-$(CONFIG_SND_PXA2xx_SOC_MAINSTONE_WM8974) += snd-soc-mainstone-wm8974.o
+obj-$(CONFIG_SND_PXA2xx_SOC_MAINSTONE_WM9713) += snd-soc-mainstone-wm9713.o
+obj-$(CONFIG_SND_PXA2xx_SOC_MAINSTONE_WM9712) += snd-soc-mainstone-wm9712.o
+obj-$(CONFIG_SND_MAINSTONE_BASEBAND) += snd-soc-mainstone-baseband.o
+obj-$(CONFIG_SND_MAINSTONE_BLUETOOTH) += snd-soc-mainstone-bluetooth.o
+obj-$(CONFIG_SND_PXA2xx_SOC_POODLE) += snd-soc-poodle.o
+obj-$(CONFIG_SND_PXA2xx_SOC_TOSA) += snd-soc-tosa.o
+obj-$(CONFIG_SND_PXA2xx_SOC_SPITZ) += snd-soc-spitz.o
+
Index: linux-2.6-pxa-new/sound/soc/pxa/corgi.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/corgi.c
@@ -0,0 +1,361 @@
+/*
+ * corgi.c  --  SoC audio for Corgi
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Nov 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/corgi.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm8731.h"
+#include "pxa2xx-pcm.h"
+
+#define CORGI_HP        0
+#define CORGI_MIC       1
+#define CORGI_LINE      2
+#define CORGI_HEADSET   3
+#define CORGI_HP_OFF    4
+#define CORGI_SPK_ON    0
+#define CORGI_SPK_OFF   1
+
+ /* audio clock in Hz - rounded from 12.235MHz */
+#define CORGI_AUDIO_CLOCK 12288000
+
+static int corgi_jack_func;
+static int corgi_spk_func;
+
+static void corgi_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0, mic = 0, line = 0, hp = 0, hs = 0;
+
+	/* set up jack connection */
+	switch (corgi_jack_func) {
+	case CORGI_HP:
+		hp = 1;
+		/* set = unmute headphone */
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case CORGI_MIC:
+		mic = 1;
+		/* reset = mute headphone */
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case CORGI_LINE:
+		line = 1;
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case CORGI_HEADSET:
+		hs = 1;
+		mic = 1;
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	}
+
+	if (corgi_spk_func == CORGI_SPK_ON)
+		spk = 1;
+
+	/* set the enpoints to their new connetion states */
+	snd_soc_dapm_set_endpoint(codec, "Ext Spk", spk);
+	snd_soc_dapm_set_endpoint(codec, "Mic Jack", mic);
+	snd_soc_dapm_set_endpoint(codec, "Line Jack", line);
+	snd_soc_dapm_set_endpoint(codec, "Headphone Jack", hp);
+	snd_soc_dapm_set_endpoint(codec, "Headset Jack", hs);
+
+	/* signal a DAPM event */
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int corgi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	corgi_ext_control(codec);
+	return 0;
+}
+
+/* we need to unmute the HP at shutdown as the mute burns power on corgi */
+static int corgi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* set = unmute headphone */
+	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+	return 0;
+}
+
+static struct snd_soc_ops corgi_ops = {
+	.startup = corgi_startup,
+	.shutdown = corgi_shutdown,
+};
+
+static int corgi_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = corgi_jack_func;
+	return 0;
+}
+
+static int corgi_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (corgi_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	corgi_jack_func = ucontrol->value.integer.value[0];
+	corgi_ext_control(codec);
+	return 1;
+}
+
+static int corgi_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = corgi_spk_func;
+	return 0;
+}
+
+static int corgi_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (corgi_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	corgi_spk_func = ucontrol->value.integer.value[0];
+	corgi_ext_control(codec);
+	return 1;
+}
+
+static int corgi_amp_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+	else
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+
+	return 0;
+}
+
+static int corgi_mic_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+	else
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+
+	return 0;
+}
+
+/* corgi machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_MIC("Mic Jack", corgi_mic_event),
+SND_SOC_DAPM_SPK("Ext Spk", corgi_amp_event),
+SND_SOC_DAPM_LINE("Line Jack", NULL),
+SND_SOC_DAPM_HP("Headset Jack", NULL),
+};
+
+/* Corgi machine audio map (connections to the codec pins) */
+static const char *audio_map[][3] = {
+
+	/* headset Jack  - in = micin, out = LHPOUT*/
+	{"Headset Jack", NULL, "LHPOUT"},
+
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+
+	/* speaker connected to LOUT, ROUT */
+	{"Ext Spk", NULL, "ROUT"},
+	{"Ext Spk", NULL, "LOUT"},
+
+	/* mic is connected to MICIN (via right channel of headphone jack) */
+	{"MICIN", NULL, "Mic Jack"},
+
+	/* Same as the above but no mic bias for line signals */
+	{"MICIN", NULL, "Line Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum corgi_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new wm8731_corgi_controls[] = {
+	SOC_ENUM_EXT("Jack Function", corgi_enum[0], corgi_get_jack,
+		corgi_set_jack),
+	SOC_ENUM_EXT("Speaker Function", corgi_enum[1], corgi_get_spk,
+		corgi_set_spk),
+};
+
+/*
+ * Logic for a wm8731 as connected on a Sharp SL-C7x0 Device
+ */
+static int corgi_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	snd_soc_dapm_set_endpoint(codec, "LLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "RLINEIN", 0);
+
+	/* Add corgi specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8731_corgi_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8731_corgi_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add corgi specific widgets */
+	for(i = 0; i < ARRAY_SIZE(wm8731_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8731_dapm_widgets[i]);
+	}
+
+	/* Set up corgi specific audio path audio_map */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static unsigned int corgi_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	if (info->bclk_master & SND_SOC_DAIFMT_CBS_CFS) {
+		/* pxa2xx is i2s master  */
+		switch (info->rate) {
+		case 44100:
+		case 88200:
+			/* configure codec digital filters for 44.1, 88.2 */
+			rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+				11289600);
+		break;
+		default:
+			/* configure codec digital filters for all other rates */
+			rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+				CORGI_AUDIO_CLOCK);
+		break;
+		}
+		/* config pxa i2s as master */
+		return rtd->cpu_dai->config_sysclk(rtd->cpu_dai, info,
+			CORGI_AUDIO_CLOCK);
+	} else {
+		/* codec is i2s master -
+		 * only configure codec DAI clock and filters */
+		return rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+			CORGI_AUDIO_CLOCK);
+	}
+}
+
+/* corgi digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link corgi_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8731_dai,
+	.init = corgi_wm8731_init,
+	.config_sysclk = corgi_config_sysclk,
+};
+
+/* corgi audio machine driver */
+static struct snd_soc_machine snd_soc_machine_corgi = {
+	.name = "Corgi",
+	.dai_link = &corgi_dai,
+	.num_links = 1,
+	.ops = &corgi_ops,
+};
+
+/* corgi audio private data */
+static struct wm8731_setup_data corgi_wm8731_setup = {
+	.i2c_address = 0x1b,
+};
+
+/* corgi audio subsystem */
+static struct snd_soc_device corgi_snd_devdata = {
+	.machine = &snd_soc_machine_corgi,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &corgi_wm8731_setup,
+};
+
+static struct platform_device *corgi_snd_device;
+
+static int __init corgi_init(void)
+{
+	int ret;
+
+	if (!(machine_is_corgi() || machine_is_shepherd() || machine_is_husky()))
+		return -ENODEV;
+
+	corgi_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!corgi_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(corgi_snd_device, &corgi_snd_devdata);
+	corgi_snd_devdata.dev = &corgi_snd_device->dev;
+	ret = platform_device_add(corgi_snd_device);
+
+	if (ret)
+		platform_device_put(corgi_snd_device);
+
+	return ret;
+}
+
+static void __exit corgi_exit(void)
+{
+	platform_device_unregister(corgi_snd_device);
+}
+
+module_init(corgi_init);
+module_exit(corgi_exit);
+
+/* Module information */
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Corgi");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone.c
@@ -0,0 +1,126 @@
+/*
+ * mainstone.c  --  SoC audio for Mainstone
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Mainstone audio amplifier code taken from arch/arm/mach-pxa/mainstone.c
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Oct 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/mainstone.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/ac97.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+static long mst_audio_suspend_mask;
+
+static int mainstone_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mst_audio_suspend_mask = MST_MSCWR2;
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_resume(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= mst_audio_suspend_mask | ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_probe(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_remove(struct platform_device *pdev)
+{
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static struct snd_soc_machine_config codecs[] = {
+{
+	.name = "AC97",
+	.sname = "AC97 HiFi",
+	.iface = &pxa_ac97_interface[0],
+},
+{
+	.name = "AC97 Aux",
+	.sname = "AC97 Aux",
+	.iface = &pxa_ac97_interface[1],
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.probe = mainstone_probe,
+	.remove = mainstone_remove,
+	.suspend_pre = mainstone_suspend,
+	.resume_post = mainstone_resume,
+	.config = codecs,
+	.nconfigs = ARRAY_SIZE(codecs),
+};
+
+static struct snd_soc_device mainstone_snd_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_ac97,
+};
+
+static struct platform_device *mainstone_snd_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_device, &mainstone_snd_devdata);
+	mainstone_snd_devdata.dev = &mainstone_snd_device->dev;
+	ret = platform_device_add(mainstone_snd_device);
+
+	if (ret)
+		platform_device_put(mainstone_snd_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC Mainstone");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone_baseband.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone_baseband.c
@@ -0,0 +1,249 @@
+/*
+ * mainstone_baseband.c
+ * Mainstone Example Baseband modem  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    15th Apr 2006   Initial version.
+ *
+ * This is example code to demonstrate connecting a baseband modem to the PCM
+ * DAI on the WM9713 codec on the Intel Mainstone platform. It is by no means
+ * complete as it requires code to control the modem.
+ *
+ * The architecture consists of the WM9713 AC97 DAI connected to the PXA27x
+ * AC97 controller and the WM9713 PCM DAI connected to the basebands DAI. The
+ * baseband is controlled via a serial port. Audio is routed between the PXA27x
+ * and the baseband via internal WM9713 analog paths.
+ *
+ * This driver is not the baseband modem driver. This driver only calls
+ * functions from the Baseband driver to set up it's PCM DAI.
+ *
+ * It's intended to use this driver as follows:-
+ *
+ *  1. open() WM9713 PCM audio device.
+ *  2. open() serial device (for AT commands).
+ *  3. configure PCM audio device (rate etc) - sets up WM9713 PCM DAI,
+ *      this will also set up the baseband PCM DAI (via calling baseband driver).
+ *  4. send any further AT commands to set up baseband.
+ *  5. configure codec audio mixer paths.
+ *  6. open(), configure and read/write AC97 audio device - to Tx/Rx voice
+ *
+ * The PCM audio device is opened but IO is never performed on it as the IO is
+ * directly between the codec and the baseband (and not the CPU).
+ *
+ * TODO:
+ *  o Implement callbacks
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+#include <asm/arch/ssp.h>
+
+#include "../codecs/wm9713.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+
+#define BASEBAND_XXX_DAIFMT \
+	(SND_SOC_DAIFMT_DSP_B  | SND_SOC_DAIFMT_CBS_CFS |\
+	 SND_SOC_DAIFMT_NB_NF)
+
+#define BASEBAND_XXX_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+/*
+ * PCM modes - 8k 16bit mono baseband modem is master
+ */
+static struct snd_soc_dai_mode mainstone_example_modes[] = {
+	/* port master clk & frame modes */
+	{BASEBAND_XXX_DAIFMT, SND_SOC_DAITDM_LRDW(0,0), SNDRV_PCM_FORMAT_S16_LE,
+		SNDRV_PCM_RATE_8000, BASEBAND_XXX_DIR, SND_SOC_DAI_BFS_RATE, 256, 64},
+};
+
+/* Do specific baseband PCM voice startup here */
+static int mainstone_baseband_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+/* Do specific baseband PCM voice shutdown here */
+static void mainstone_baseband_shutdown (struct snd_pcm_substream *substream)
+{
+}
+
+/* Do specific baseband modem PCM voice hw params init here */
+static int mainstone_baseband_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+/* Do specific baseband modem PCM voice hw params free here */
+static int mainstone_baseband_hw_free(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static struct snd_soc_cpu_dai mainstone_example_dai[] = {
+	{	.name = "Baseband",
+		.id = 0,
+		.type = SND_SOC_DAI_PCM,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 1,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 1,},
+		.ops = {
+			.startup = mainstone_baseband_startup,
+			.shutdown = mainstone_baseband_shutdown,
+			.hw_params = mainstone_baseband_hw_params,
+			.hw_free = mainstone_baseband_hw_free,
+			},
+		.caps = {
+			.mode = mainstone_example_modes,
+			.num_modes = ARRAY_SIZE(mainstone_example_modes),},
+	},
+};
+
+/* do we need to do any thing on the mainstone when the stream is
+ * started and stopped
+ */
+static int mainstone_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static void mainstone_shutdown(struct snd_pcm_substream *substream)
+{
+}
+
+static struct snd_soc_ops mainstone_ops = {
+	.startup = mainstone_startup,
+	.shutdown = mainstone_shutdown,
+};
+
+/* PM */
+static int mainstone_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int mainstone_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int mainstone_probe(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int mainstone_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int mainstone_wm9713_init(struct snd_soc_codec *codec)
+{
+	return 0;
+}
+
+unsigned int mainstone_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	/* wm8753 has pll that generates mclk from 13MHz xtal */
+	return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 13000000);
+}
+
+/* the physical audio connections between the WM9713, Baseband and pxa2xx */
+static struct snd_soc_dai_link mainstone_dai[] = {
+{
+	.name = "AC97",
+	.stream_name = "AC97 HiFi",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_HIFI],
+	.codec_dai = &wm9713_dai[WM9713_DAI_AC97_HIFI],
+	.init = mainstone_wm9713_init,
+},
+{
+	.name = "AC97 Aux",
+	.stream_name = "AC97 Aux",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_AUX],
+	.codec_dai = &wm9713_dai[WM9713_DAI_AC97_AUX],
+},
+{
+	.name = "Baseband",
+	.stream_name = "Voice",
+	.cpu_dai = mainstone_example_dai,
+	.codec_dai = &wm9713_dai[WM9713_DAI_PCM_VOICE],
+	.config_sysclk = mainstone_config_sysclk,
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.probe = mainstone_probe,
+	.remove = mainstone_remove,
+	.suspend_pre = mainstone_suspend,
+	.resume_post = mainstone_resume,
+	.ops = &mainstone_ops,
+	.dai_link = mainstone_dai,
+	.num_links = ARRAY_SIZE(mainstone_dai),
+};
+
+static struct snd_soc_device mainstone_snd_ac97_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm9713,
+};
+
+static struct platform_device *mainstone_snd_ac97_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_ac97_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_ac97_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_ac97_device, &mainstone_snd_ac97_devdata);
+	mainstone_snd_ac97_devdata.dev = &mainstone_snd_ac97_device->dev;
+
+	if((ret = platform_device_add(mainstone_snd_ac97_device)) != 0)
+		platform_device_put(mainstone_snd_ac97_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_ac97_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("Mainstone Example Baseband PCM Interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone_bluetooth.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone_bluetooth.c
@@ -0,0 +1,399 @@
+/*
+ * mainstone_bluetooth.c
+ * Mainstone Example Bluetooth  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    15th May 2006   Initial version.
+ *
+ * This is example code to demonstrate connecting a bluetooth codec to the PCM
+ * DAI on the WM8753 codec on the Intel Mainstone platform. It is by no means
+ * complete as it requires code to control the BT codec.
+ *
+ * The architecture consists of the WM8753 HIFI DAI connected to the PXA27x
+ * I2S controller and the WM8753 PCM DAI connected to the bluetooth DAI. The
+ * bluetooth codec and wm8753 are controlled via I2C. Audio is routed between
+ * the PXA27x and the bluetooth via internal WM8753 analog paths.
+ *
+ * This example supports the following audio input/outputs.
+ *
+ *  o Board mounted Mic and Speaker (spk has amplifier)
+ *  o Headphones via jack socket
+ *  o BT source and sink
+ *
+ * This driver is not the bluetooth codec driver. This driver only calls
+ * functions from the Bluetooth driver to set up it's PCM DAI.
+ *
+ * It's intended to use the driver as follows:-
+ *
+ *  1. open() WM8753 PCM audio device.
+ *  2. configure PCM audio device (rate etc) - sets up WM8753 PCM DAI,
+ *      this should also set up the BT codec DAI (via calling bt driver).
+ *  3. configure codec audio mixer paths.
+ *  4. open(), configure and read/write HIFI audio device - to Tx/Rx voice
+ *
+ * The PCM audio device is opened but IO is never performed on it as the IO is
+ * directly between the codec and the BT codec (and not the CPU).
+ *
+ * TODO:
+ *  o Implement callbacks
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+#include <asm/arch/ssp.h>
+
+#include "../codecs/wm8753.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+
+#define BLUETOOTH_DAIFMT \
+	(SND_SOC_DAIFMT_DSP_B  | SND_SOC_DAIFMT_CBS_CFS |\
+	 SND_SOC_DAIFMT_NB_NF)
+
+#define BLUETOOTH_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+/*
+ * PCM modes - 8k 16bit mono BT codec is master
+ */
+static struct snd_soc_dai_mode mainstone_bt_modes[] = {
+	/* port master clk & frame modes */
+	{BLUETOOTH_DAIFMT, SND_SOC_DAITDM_LRDW(0,0), SNDRV_PCM_FORMAT_S16_LE,
+		SNDRV_PCM_RATE_8000, BLUETOOTH_DIR, SND_SOC_DAI_BFS_RATE, 256, 64},
+};
+
+/* Do specific bluetooth PCM startup here */
+static int mainstone_bt_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+/* Do specific bluetooth PCM shutdown here */
+static void mainstone_bt_shutdown (struct snd_pcm_substream *substream)
+{
+}
+
+/* Do pecific bluetooth PCM hw params init here */
+static int mainstone_bt_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+/* Do specific bluetooth PCM hw params free here */
+static int mainstone_bt_hw_free(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static struct snd_soc_cpu_dai mainstone_bt_dai[] = {
+	{	.name = "Bluetooth",
+		.id = 0,
+		.type = SND_SOC_DAI_PCM,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 1,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 1,},
+		.ops = {
+			.startup = mainstone_bt_startup,
+			.shutdown = mainstone_bt_shutdown,
+			.hw_params = mainstone_bt_hw_params,
+			.hw_free = mainstone_bt_hw_free,
+			},
+		.caps = {
+			.mode = mainstone_bt_modes,
+			.num_modes = ARRAY_SIZE(mainstone_bt_modes),},
+	},
+};
+
+/* do we need to do any thing on the mainstone when the stream is
+ * started and stopped
+ */
+static int mainstone_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static void mainstone_shutdown(struct snd_pcm_substream *substream)
+{
+}
+
+static struct snd_soc_ops mainstone_ops = {
+	.startup = mainstone_startup,
+	.shutdown = mainstone_shutdown,
+};
+
+/* PM */
+static int mainstone_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int mainstone_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int mainstone_probe(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int mainstone_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+/*
+ * Machine audio functions.
+ *
+ * The machine now has 3 extra audio controls.
+ *
+ * Jack function: Sets function (device plugged into Jack) to nothing (Off)
+ *                or Headphones.
+ *
+ * Mic function: Set the on board Mic to On or Off
+ * Spk function: Set the on board Spk to On or Off
+ *
+ * example: BT playback (of far end) and capture (of near end)
+ *  Set Mic and Speaker to On, open BT alsa interface as above and set up
+ *  internal audio paths.
+ */
+
+static int machine_jack_func = 0;
+static int machine_spk_func = 0;
+static int machine_mic_func = 0;
+
+static int machine_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = machine_jack_func;
+	return 0;
+}
+
+static int machine_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	machine_jack_func = ucontrol->value.integer.value[0];
+	snd_soc_dapm_set_endpoint(codec, "Headphone Jack", machine_jack_func);
+	return 0;
+}
+
+static int machine_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = machine_spk_func;
+	return 0;
+}
+
+static int machine_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	machine_spk_func = ucontrol->value.integer.value[0];
+	snd_soc_dapm_set_endpoint(codec, "Spk", machine_spk_func);
+	return 0;
+}
+
+static int machine_get_mic(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = machine_spk_func;
+	return 0;
+}
+
+static int machine_set_mic(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	machine_spk_func = ucontrol->value.integer.value[0];
+	snd_soc_dapm_set_endpoint(codec, "Mic", machine_mic_func);
+	return 0;
+}
+
+/* turns on board speaker amp on/off */
+static int machine_amp_event(struct snd_soc_dapm_widget *w, int event)
+{
+#if 0
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		/* on */
+	else
+		/* off */
+#endif
+	return 0;
+}
+
+/* machine dapm widgets */
+static const struct snd_soc_dapm_widget machine_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_SPK("Spk", machine_amp_event),
+SND_SOC_DAPM_MIC("Mic", NULL),
+};
+
+/* machine connections to the codec pins */
+static const char* audio_map[][3] = {
+
+	/* headphone connected to LOUT1, ROUT1 */
+	{"Headphone Jack", NULL, "LOUT"},
+	{"Headphone Jack", NULL, "ROUT"},
+
+	/* speaker connected to LOUT2, ROUT2 */
+	{"Spk", NULL, "ROUT2"},
+	{"Spk", NULL, "LOUT2"},
+
+	/* mic is connected to MIC1 (via Mic Bias) */
+	{"MIC1", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char* jack_function[] = {"Off", "Headphone"};
+static const char* spk_function[] = {"Off", "On"};
+static const char* mic_function[] = {"Off", "On"};
+static const struct soc_enum machine_ctl_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+	SOC_ENUM_SINGLE_EXT(2, mic_function),
+};
+
+static const struct snd_kcontrol_new wm8753_machine_controls[] = {
+	SOC_ENUM_EXT("Jack Function", machine_ctl_enum[0], machine_get_jack, machine_set_jack),
+	SOC_ENUM_EXT("Speaker Function", machine_ctl_enum[1], machine_get_spk, machine_set_spk),
+	SOC_ENUM_EXT("Mic Function", machine_ctl_enum[2], machine_get_mic, machine_set_mic),
+};
+
+static int mainstone_wm8753_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* not used on this machine - e.g. will never be powered up */
+	snd_soc_dapm_set_endpoint(codec, "OUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "OUT4", 0);
+	snd_soc_dapm_set_endpoint(codec, "MONO2", 0);
+	snd_soc_dapm_set_endpoint(codec, "MONO1", 0);
+	snd_soc_dapm_set_endpoint(codec, "LINE1", 0);
+	snd_soc_dapm_set_endpoint(codec, "LINE2", 0);
+	snd_soc_dapm_set_endpoint(codec, "RXP", 0);
+	snd_soc_dapm_set_endpoint(codec, "RXN", 0);
+	snd_soc_dapm_set_endpoint(codec, "MIC2", 0);
+
+	/* Add machine specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8753_machine_controls); i++) {
+		if ((err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8753_machine_controls[i],codec, NULL))) < 0)
+			return err;
+	}
+
+	/* Add machine specific widgets */
+	for(i = 0; i < ARRAY_SIZE(machine_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &machine_dapm_widgets[i]);
+	}
+
+	/* Set up machine specific audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0], audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+/* this configures the clocking between the WM8753 and the BT codec */
+unsigned int mainstone_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	/* wm8753 has pll that generates mclk from 13MHz xtal */
+	return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 13000000);
+}
+
+static struct snd_soc_dai_link mainstone_dai[] = {
+{ /* Hifi Playback - for similatious use with voice below */
+	.name = "WM8753",
+	.stream_name = "WM8753 HiFi",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8753_dai[WM8753_DAI_HIFI],
+	.init = mainstone_wm8753_init,
+	.config_sysclk = mainstone_config_sysclk,
+},
+{ /* Voice via BT */
+	.name = "Bluetooth",
+	.stream_name = "Voice",
+	.cpu_dai = mainstone_bt_dai,
+	.codec_dai = &wm8753_dai[WM8753_DAI_VOICE],
+	.config_sysclk = mainstone_config_sysclk,
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.probe = mainstone_probe,
+	.remove = mainstone_remove,
+	.suspend_pre = mainstone_suspend,
+	.resume_post = mainstone_resume,
+	.ops = &mainstone_ops,
+	.dai_link = mainstone_dai,
+	.num_links = ARRAY_SIZE(mainstone_dai),
+};
+
+static struct snd_soc_device mainstone_snd_wm8753_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8753,
+};
+
+static struct platform_device *mainstone_snd_wm8753_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_wm8753_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_wm8753_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_wm8753_device, &mainstone_snd_wm8753_devdata);
+	mainstone_snd_wm8753_devdata.dev = &mainstone_snd_wm8753_device->dev;
+
+	if((ret = platform_device_add(mainstone_snd_wm8753_device)) != 0)
+		platform_device_put(mainstone_snd_wm8753_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_wm8753_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("Mainstone Example Bluetooth PCM Interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm8731.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm8731.c
@@ -0,0 +1,156 @@
+/*
+ * mainstone.c  --  SoC audio for Mainstone
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Mainstone audio amplifier code taken from arch/arm/mach-pxa/mainstone.c
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    5th June 2006   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/mainstone.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm8731.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+
+
+static const struct snd_soc_dapm_widget dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+};
+
+static const char* intercon[][3] = {
+
+	/* speaker connected to LHPOUT */
+	{"Ext Spk", NULL, "LHPOUT"},
+
+	/* mic is connected to Mic Jack, with WM8731 Mic Bias */
+	{"MICIN", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Int Mic"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+/*
+ * Logic for a wm8731 as connected on a Endrelia ETI-B1 board.
+ */
+static int mainstone_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+
+	/* Add specific widgets */
+	for(i = 0; i < ARRAY_SIZE(dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &dapm_widgets[i]);
+	}
+
+	/* Set up specific audio path interconnects */
+	for(i = 0; intercon[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, intercon[i][0], intercon[i][1], intercon[i][2]);
+	}
+
+	/* not connected */
+	snd_soc_dapm_set_endpoint(codec, "RLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "LLINEIN", 0);
+
+	/* always connected */
+	snd_soc_dapm_set_endpoint(codec, "Int Mic", 1);
+	snd_soc_dapm_set_endpoint(codec, "Ext Spk", 1);
+
+	snd_soc_dapm_sync_endpoints(codec);
+
+	return 0;
+}
+
+unsigned int mainstone_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	/* we have a 12.288MHz crystal */
+	return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 12288000);
+}
+
+static struct snd_soc_dai_link mainstone_dai[] = {
+{
+	.name = "WM8731",
+	.stream_name = "WM8731 HiFi",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8731_dai,
+	.init = mainstone_wm8731_init,
+	.config_sysclk = mainstone_config_sysclk,
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.dai_link = mainstone_dai,
+	.num_links = ARRAY_SIZE(mainstone_dai),
+};
+
+static struct wm8731_setup_data corgi_wm8731_setup = {
+	.i2c_address = 0x1b,
+};
+
+static struct snd_soc_device mainstone_snd_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &corgi_wm8731_setup,
+};
+
+static struct platform_device *mainstone_snd_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_device, &mainstone_snd_devdata);
+	mainstone_snd_devdata.dev = &mainstone_snd_device->dev;
+	ret = platform_device_add(mainstone_snd_device);
+
+	if (ret)
+		platform_device_put(mainstone_snd_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC WM8731 Mainstone");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm8753.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm8753.c
@@ -0,0 +1,226 @@
+/*
+ * mainstone.c  --  SoC audio for Mainstone
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Mainstone audio amplifier code taken from arch/arm/mach-pxa/mainstone.c
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Oct 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/mainstone.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm8753.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+
+static int mainstone_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if(rtd->cpu_dai->type == SND_SOC_DAI_PCM && rtd->cpu_dai->id == 1) {
+		/* enable USB on the go MUX so we can use SSPFRM2 */
+		MST_MSCWR2 |= MST_MSCWR2_USB_OTG_SEL;
+		MST_MSCWR2 &= ~MST_MSCWR2_USB_OTG_RST;
+	}
+	return 0;
+}
+
+static void mainstone_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if(rtd->cpu_dai->type == SND_SOC_DAI_PCM && rtd->cpu_dai->id == 1) {
+		/* disable USB on the go MUX so we can use ttyS0 */
+		MST_MSCWR2 &= ~MST_MSCWR2_USB_OTG_SEL;
+		MST_MSCWR2 |= MST_MSCWR2_USB_OTG_RST;
+	}
+}
+
+static struct snd_soc_ops mainstone_ops = {
+	.startup = mainstone_startup,
+	.shutdown = mainstone_shutdown,
+};
+
+static long mst_audio_suspend_mask;
+
+static int mainstone_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mst_audio_suspend_mask = MST_MSCWR2;
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_resume(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= mst_audio_suspend_mask | ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_probe(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_remove(struct platform_device *pdev)
+{
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+/* example machine audio_mapnections */
+static const char* audio_map[][3] = {
+
+	/* mic is connected to mic1 - with bias */
+	{"MIC1", NULL, "Mic Bias"},
+	{"MIC1N", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic1 Jack"},
+	{"Mic Bias", NULL, "Mic1 Jack"},
+
+	{"ACIN", NULL, "ACOP"},
+	{NULL, NULL, NULL},
+};
+
+/* headphone detect support on my board */
+static const char * hp_pol[] = {"Headphone", "Speaker"};
+static const struct soc_enum wm8753_enum =
+	SOC_ENUM_SINGLE(WM8753_OUTCTL, 1, 2, hp_pol);
+
+static const struct snd_kcontrol_new wm8753_mainstone_controls[] = {
+	SOC_SINGLE("Headphone Detect Switch", WM8753_OUTCTL, 6, 1, 0),
+	SOC_ENUM("Headphone Detect Polarity", wm8753_enum),
+};
+
+/*
+ * This is an example machine initialisation for a wm8753 connected to a
+ * Mainstone II. It is missing logic to detect hp/mic insertions and logic
+ * to re-route the audio in such an event.
+ */
+static int mainstone_wm8753_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* set up mainstone codec pins */
+	snd_soc_dapm_set_endpoint(codec, "RXP", 0);
+	snd_soc_dapm_set_endpoint(codec, "RXN", 0);
+	snd_soc_dapm_set_endpoint(codec, "MIC2", 0);
+
+	/* add mainstone specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8753_mainstone_controls); i++) {
+		if ((err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8753_mainstone_controls[i],codec, NULL))) < 0)
+			return err;
+	}
+
+	/* set up mainstone specific audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0], audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+unsigned int mainstone_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	/* wm8753 has pll that generates mclk from 13MHz xtal */
+	return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 13000000);
+}
+
+static struct snd_soc_dai_link mainstone_dai[] = {
+{ /* Hifi Playback - for similatious use with voice below */
+	.name = "WM8753",
+	.stream_name = "WM8753 HiFi",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8753_dai[WM8753_DAI_HIFI],
+	.init = mainstone_wm8753_init,
+	.config_sysclk = mainstone_config_sysclk,
+},
+{ /* Voice via BT */
+	.name = "Bluetooth",
+	.stream_name = "Voice",
+	.cpu_dai = &pxa_ssp_dai[1],
+	.codec_dai = &wm8753_dai[WM8753_DAI_VOICE],
+	.config_sysclk = mainstone_config_sysclk,
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.probe = mainstone_probe,
+	.remove = mainstone_remove,
+	.suspend_pre = mainstone_suspend,
+	.resume_post = mainstone_resume,
+	.ops = &mainstone_ops,
+	.dai_link = mainstone_dai,
+	.num_links = ARRAY_SIZE(mainstone_dai),
+};
+
+static struct wm8753_setup_data mainstone_wm8753_setup = {
+	.i2c_address = 0x1a,
+};
+
+static struct snd_soc_device mainstone_snd_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8753,
+	.codec_data = &mainstone_wm8753_setup,
+};
+
+static struct platform_device *mainstone_snd_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_device, &mainstone_snd_devdata);
+	mainstone_snd_devdata.dev = &mainstone_snd_device->dev;
+	ret = platform_device_add(mainstone_snd_device);
+
+	if (ret)
+		platform_device_put(mainstone_snd_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC WM8753 Mainstone");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm8974.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm8974.c
@@ -0,0 +1,112 @@
+/*
+ * mainstone.c  --  SoC audio for Mainstone
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Mainstone audio amplifier code taken from arch/arm/mach-pxa/mainstone.c
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Oct 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/mainstone.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm8974.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+
+static int mainstone_wm8974_init(struct snd_soc_codec *codec)
+{
+	return 0;
+}
+
+unsigned int mainstone_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	/* we have a PLL */
+	return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 12288000);
+
+}
+
+static struct snd_soc_dai_link mainstone_dai[] = {
+{
+	.name = "WM8974",
+	.stream_name = "WM8974 HiFi",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8974_dai,
+	.init = mainstone_wm8974_init,
+	.config_sysclk = mainstone_config_sysclk,
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.dai_link = mainstone_dai,
+	.num_links = ARRAY_SIZE(mainstone_dai),
+};
+
+static struct wm8974_setup_data mainstone_wm8974_setup = {
+	.i2c_address = 0x1a,
+};
+
+static struct snd_soc_device mainstone_snd_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8974,
+	.codec_data = &mainstone_wm8974_setup,
+};
+
+static struct platform_device *mainstone_snd_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_device, &mainstone_snd_devdata);
+	mainstone_snd_devdata.dev = &mainstone_snd_device->dev;
+	ret = platform_device_add(mainstone_snd_device);
+
+	if (ret)
+		platform_device_put(mainstone_snd_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC Mainstone");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm9712.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm9712.c
@@ -0,0 +1,171 @@
+/*
+ * mainstone.c  --  SoC audio for Mainstone
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Mainstone audio amplifier code taken from arch/arm/mach-pxa/mainstone.c
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    29th Jan 2006   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/mainstone.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm9712.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+static long mst_audio_suspend_mask;
+
+static int mainstone_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mst_audio_suspend_mask = MST_MSCWR2;
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_resume(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= mst_audio_suspend_mask | ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_probe(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_remove(struct platform_device *pdev)
+{
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+/* mainstone machine dapm widgets */
+static const struct snd_soc_dapm_widget mainstone_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic (Internal)", NULL),
+};
+
+/* example machine interconnections */
+static const char* intercon[][3] = {
+
+	/* mic is connected to mic1 - with bias */
+	{"MIC1", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic (Internal)"},
+
+	{NULL, NULL, NULL},
+};
+
+/*
+ * This is an example machine initialisation for a wm8753 connected to a
+ * Mainstone II. It is missing logic to detect hp/mic insertions and logic
+ * to re-route the audio in such an event.
+ */
+static int mainstone_wm9712_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	/* set up mainstone codec pins */
+	snd_soc_dapm_set_endpoint(codec, "RXP", 0);
+	snd_soc_dapm_set_endpoint(codec, "RXN", 0);
+	//snd_soc_dapm_set_endpoint(codec, "MIC2", 0);
+
+	/* Add mainstone specific widgets */
+	for(i = 0; i < ARRAY_SIZE(mainstone_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &mainstone_dapm_widgets[i]);
+	}
+
+	/* set up mainstone specific audio path interconnects */
+	for(i = 0; intercon[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, intercon[i][0], intercon[i][1], intercon[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static struct snd_soc_dai_link mainstone_dai[] = {
+{
+	.name = "AC97",
+	.stream_name = "AC97 HiFi",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_HIFI],
+	.codec_dai = &wm9712_dai[WM9712_DAI_AC97_HIFI],
+	.init = mainstone_wm9712_init,
+},
+{
+	.name = "AC97 Aux",
+	.stream_name = "AC97 Aux",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_AUX],
+	.codec_dai = &wm9712_dai[WM9712_DAI_AC97_AUX],
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.probe = mainstone_probe,
+	.remove = mainstone_remove,
+	.suspend_pre = mainstone_suspend,
+	.resume_post = mainstone_resume,
+	.dai_link = mainstone_dai,
+	.num_links = ARRAY_SIZE(mainstone_dai),
+};
+
+static struct snd_soc_device mainstone_snd_ac97_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm9712,
+};
+
+static struct platform_device *mainstone_snd_ac97_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_ac97_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_ac97_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_ac97_device, &mainstone_snd_ac97_devdata);
+	mainstone_snd_ac97_devdata.dev = &mainstone_snd_ac97_device->dev;
+
+	if((ret = platform_device_add(mainstone_snd_ac97_device)) != 0)
+		platform_device_put(mainstone_snd_ac97_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_ac97_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC WM9712 Mainstone");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm9713.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/mainstone_wm9713.c
@@ -0,0 +1,263 @@
+/*
+ * mainstone.c  --  SoC audio for Mainstone
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Mainstone audio amplifier code taken from arch/arm/mach-pxa/mainstone.c
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    29th Jan 2006   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/mainstone.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm9713.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine mainstone;
+
+static int mainstone_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if(rtd->cpu_dai->type == SND_SOC_DAI_PCM && rtd->cpu_dai->id == 1) {
+		/* enable USB on the go MUX so we can use SSPFRM2 */
+		MST_MSCWR2 |= MST_MSCWR2_USB_OTG_SEL;
+		MST_MSCWR2 &= ~MST_MSCWR2_USB_OTG_RST;
+	}
+	return 0;
+}
+
+static void mainstone_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if(rtd->cpu_dai->type == SND_SOC_DAI_PCM && rtd->cpu_dai->id == 1) {
+		/* disable USB on the go MUX so we can use ttyS0 */
+		MST_MSCWR2 &= ~MST_MSCWR2_USB_OTG_SEL;
+		MST_MSCWR2 |= MST_MSCWR2_USB_OTG_RST;
+	}
+}
+
+static struct snd_soc_ops mainstone_ops = {
+	.startup = mainstone_startup,
+	.shutdown = mainstone_shutdown,
+};
+
+static int test = 0;
+static int get_test(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = test;
+	return 0;
+}
+
+static int set_test(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	test = ucontrol->value.integer.value[0];
+	if(test) {
+
+	} else {
+
+	}
+	return 0;
+}
+
+static long mst_audio_suspend_mask;
+
+static int mainstone_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	mst_audio_suspend_mask = MST_MSCWR2;
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_resume(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= mst_audio_suspend_mask | ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_probe(struct platform_device *pdev)
+{
+	MST_MSCWR2 &= ~MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static int mainstone_remove(struct platform_device *pdev)
+{
+	MST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;
+	return 0;
+}
+
+static const char* test_function[] = {"Off", "On"};
+static const struct soc_enum mainstone_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, test_function),
+};
+
+static const struct snd_kcontrol_new mainstone_controls[] = {
+	SOC_ENUM_EXT("ATest Function", mainstone_enum[0], get_test, set_test),
+};
+
+/* mainstone machine dapm widgets */
+static const struct snd_soc_dapm_widget mainstone_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic 1", NULL),
+	SND_SOC_DAPM_MIC("Mic 2", NULL),
+	SND_SOC_DAPM_MIC("Mic 3", NULL),
+};
+
+/* example machine audio_mapnections */
+static const char* audio_map[][3] = {
+
+	/* mic is connected to mic1 - with bias */
+	{"MIC1", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic 1"},
+	/* mic is connected to mic2A - with bias */
+	{"MIC2A", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic 2"},
+	/* mic is connected to mic2B - with bias */
+	{"MIC2B", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic 3"},
+
+	{NULL, NULL, NULL},
+};
+
+/*
+ * This is an example machine initialisation for a wm9713 connected to a
+ * Mainstone II. It is missing logic to detect hp/mic insertions and logic
+ * to re-route the audio in such an event.
+ */
+static int mainstone_wm9713_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* set up mainstone codec pins */
+	snd_soc_dapm_set_endpoint(codec, "RXP", 0);
+	snd_soc_dapm_set_endpoint(codec, "RXN", 0);
+	//snd_soc_dapm_set_endpoint(codec, "MIC2", 0);
+
+	/* Add test specific controls */
+	for (i = 0; i < ARRAY_SIZE(mainstone_controls); i++) {
+		if ((err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&mainstone_controls[i],codec, NULL))) < 0)
+			return err;
+	}
+
+	/* Add mainstone specific widgets */
+	for(i = 0; i < ARRAY_SIZE(mainstone_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &mainstone_dapm_widgets[i]);
+	}
+
+	/* set up mainstone specific audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0], audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+/* configure the system audio clock */
+unsigned int mainstone_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 24576000);
+}
+
+static struct snd_soc_dai_link mainstone_dai[] = {
+{
+	.name = "AC97",
+	.stream_name = "AC97 HiFi",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_HIFI],
+	.codec_dai = &wm9713_dai[WM9713_DAI_AC97_HIFI],
+	.init = mainstone_wm9713_init,
+	.config_sysclk = mainstone_config_sysclk,
+},
+{
+	.name = "AC97 Aux",
+	.stream_name = "AC97 Aux",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_AUX],
+	.codec_dai = &wm9713_dai[WM9713_DAI_AC97_AUX],
+	.config_sysclk = mainstone_config_sysclk,
+},
+{
+	.name = "WM9713",
+	.stream_name = "WM9713 Voice",
+	.cpu_dai = &pxa_ssp_dai[PXA2XX_DAI_SSP2],
+	.codec_dai = &wm9713_dai[WM9713_DAI_PCM_VOICE],
+	.config_sysclk = mainstone_config_sysclk,
+},
+};
+
+static struct snd_soc_machine mainstone = {
+	.name = "Mainstone",
+	.probe = mainstone_probe,
+	.remove = mainstone_remove,
+	.suspend_pre = mainstone_suspend,
+	.resume_post = mainstone_resume,
+	.ops = &mainstone_ops,
+	.dai_link = mainstone_dai,
+	.num_links = ARRAY_SIZE(mainstone_dai),
+};
+
+static struct snd_soc_device mainstone_snd_ac97_devdata = {
+	.machine = &mainstone,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm9713,
+};
+
+static struct platform_device *mainstone_snd_ac97_device;
+
+static int __init mainstone_init(void)
+{
+	int ret;
+
+	mainstone_snd_ac97_device = platform_device_alloc("soc-audio", -1);
+	if (!mainstone_snd_ac97_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(mainstone_snd_ac97_device, &mainstone_snd_ac97_devdata);
+	mainstone_snd_ac97_devdata.dev = &mainstone_snd_ac97_device->dev;
+
+	if((ret = platform_device_add(mainstone_snd_ac97_device)) != 0)
+		platform_device_put(mainstone_snd_ac97_device);
+
+	return ret;
+}
+
+static void __exit mainstone_exit(void)
+{
+	platform_device_unregister(mainstone_snd_ac97_device);
+}
+
+module_init(mainstone_init);
+module_exit(mainstone_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC WM9713 Mainstone");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/poodle.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/poodle.c
@@ -0,0 +1,329 @@
+/*
+ * poodle.c  --  SoC audio for Poodle
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/locomo.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/poodle.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm8731.h"
+#include "pxa2xx-pcm.h"
+
+#define POODLE_HP        1
+#define POODLE_HP_OFF    0
+#define POODLE_SPK_ON    1
+#define POODLE_SPK_OFF   0
+
+ /* audio clock in Hz - rounded from 12.235MHz */
+#define POODLE_AUDIO_CLOCK 12288000
+
+static int poodle_jack_func;
+static int poodle_spk_func;
+
+static void poodle_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0;
+
+	/* set up jack connection */
+	if (poodle_jack_func == POODLE_HP) {
+		/* set = unmute headphone */
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_L, 1);
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_R, 1);
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 1);
+	} else {
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_L, 0);
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_R, 0);
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+	}
+
+	if (poodle_spk_func == POODLE_SPK_ON)
+		spk = 1;
+
+	/* set the enpoints to their new connetion states */
+	snd_soc_dapm_set_endpoint(codec, "Ext Spk", spk);
+
+	/* signal a DAPM event */
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int poodle_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	poodle_ext_control(codec);
+	return 0;
+}
+
+/* we need to unmute the HP at shutdown as the mute burns power on poodle */
+static int poodle_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* set = unmute headphone */
+	locomo_gpio_write(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_L, 1);
+	locomo_gpio_write(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_R, 1);
+	return 0;
+}
+
+static struct snd_soc_ops poodle_ops = {
+	.startup = poodle_startup,
+	.shutdown = poodle_shutdown,
+};
+
+static int poodle_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = poodle_jack_func;
+	return 0;
+}
+
+static int poodle_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (poodle_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	poodle_jack_func = ucontrol->value.integer.value[0];
+	poodle_ext_control(codec);
+	return 1;
+}
+
+static int poodle_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = poodle_spk_func;
+	return 0;
+}
+
+static int poodle_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (poodle_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	poodle_spk_func = ucontrol->value.integer.value[0];
+	poodle_ext_control(codec);
+	return 1;
+}
+
+static int poodle_amp_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_AMP_ON, 0);
+	else
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_AMP_ON, 1);
+
+	return 0;
+}
+
+/* poodle machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_SPK("Ext Spk", poodle_amp_event),
+};
+
+/* Corgi machine audio_mapnections to the codec pins */
+static const char *audio_map[][3] = {
+
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+
+	/* speaker connected to LOUT, ROUT */
+	{"Ext Spk", NULL, "ROUT"},
+	{"Ext Spk", NULL, "LOUT"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Off", "Headphone"};
+static const char *spk_function[] = {"Off", "On"};
+static const struct soc_enum poodle_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const snd_kcontrol_new_t wm8731_poodle_controls[] = {
+	SOC_ENUM_EXT("Jack Function", poodle_enum[0], poodle_get_jack,
+		poodle_set_jack),
+	SOC_ENUM_EXT("Speaker Function", poodle_enum[1], poodle_get_spk,
+		poodle_set_spk),
+};
+
+/*
+ * Logic for a wm8731 as connected on a Sharp SL-C7x0 Device
+ */
+static int poodle_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	snd_soc_dapm_set_endpoint(codec, "LLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "RLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "MICIN", 1);
+
+	/* Add poodle specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8731_poodle_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8731_poodle_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add poodle specific widgets */
+	for (i = 0; i < ARRAY_SIZE(wm8731_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8731_dapm_widgets[i]);
+	}
+
+	/* Set up poodle specific audio path audio_map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static unsigned int poodle_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	if (info->bclk_master & SND_SOC_DAIFMT_CBS_CFS) {
+		/* pxa2xx is i2s master  */
+		switch (info->rate) {
+		case 44100:
+		case 88200:
+			/* configure codec digital filters for 44.1, 88.2 */
+			rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+				11289600);
+		break;
+		default:
+			/* configure codec digital filters for all other rates */
+			rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+				POODLE_AUDIO_CLOCK);
+		break;
+		}
+		return rtd->cpu_dai->config_sysclk(rtd->cpu_dai, info,
+			POODLE_AUDIO_CLOCK);
+	} else {
+		/* codec is i2s master -
+		 * only configure codec DAI clock and filters */
+		return rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+			POODLE_AUDIO_CLOCK);
+	}
+}
+
+/* poodle digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link poodle_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8731_dai,
+	.init = poodle_wm8731_init,
+	.config_sysclk = poodle_config_sysclk,
+};
+
+/* poodle audio machine driver */
+static struct snd_soc_machine snd_soc_machine_poodle = {
+	.name = "Poodle",
+	.dai_link = &poodle_dai,
+	.num_links = 1,
+	.ops = &poodle_ops,
+};
+
+/* poodle audio private data */
+static struct wm8731_setup_data poodle_wm8731_setup = {
+	.i2c_address = 0x1b,
+};
+
+/* poodle audio subsystem */
+static struct snd_soc_device poodle_snd_devdata = {
+	.machine = &snd_soc_machine_poodle,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &poodle_wm8731_setup,
+};
+
+static struct platform_device *poodle_snd_device;
+
+static int __init poodle_init(void)
+{
+	int ret;
+
+	if (!machine_is_poodle())
+		return -ENODEV;
+
+	locomo_gpio_set_dir(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_AMP_ON, 0);
+	/* should we mute HP at startup - burning power ?*/
+	locomo_gpio_set_dir(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_L, 0);
+	locomo_gpio_set_dir(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_R, 0);
+
+	poodle_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!poodle_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(poodle_snd_device, &poodle_snd_devdata);
+	poodle_snd_devdata.dev = &poodle_snd_device->dev;
+	ret = platform_device_add(poodle_snd_device);
+
+	if (ret)
+		platform_device_put(poodle_snd_device);
+
+	return ret;
+}
+
+static void __exit poodle_exit(void)
+{
+	platform_device_unregister(poodle_snd_device);
+}
+
+module_init(poodle_init);
+module_exit(poodle_exit);
+
+/* Module information */
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Poodle");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-ac97.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-ac97.c
@@ -0,0 +1,437 @@
+/*
+ * linux/sound/pxa2xx-ac97.c -- AC97 support for the Intel PXA2xx chip.
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Dec 02, 2004
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/irq.h>
+#include <linux/mutex.h>
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+
+#include "pxa2xx-pcm.h"
+
+static DEFINE_MUTEX(car_mutex);
+static DECLARE_WAIT_QUEUE_HEAD(gsr_wq);
+static volatile long gsr_bits;
+
+#define AC97_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define AC97_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+/* may need to expand this */
+static struct snd_soc_dai_mode pxa2xx_ac97_modes[] = {
+	{
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = AC97_RATES,
+		.pcmdir = AC97_DIR,
+	},
+};
+
+/*
+ * Beware PXA27x bugs:
+ *
+ *   o Slot 12 read from modem space will hang controller.
+ *   o CDONE, SDONE interrupt fails after any slot 12 IO.
+ *
+ * We therefore have an hybrid approach for waiting on SDONE (interrupt or
+ * 1 jiffy timeout if interrupt never comes).
+ */
+
+static unsigned short pxa2xx_ac97_read(struct snd_ac97 *ac97,
+	unsigned short reg)
+{
+	unsigned short val = -1;
+	volatile u32 *reg_addr;
+
+	mutex_lock(&car_mutex);
+
+	/* set up primary or secondary codec/modem space */
+#ifdef CONFIG_PXA27x
+	reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#else
+	if (reg == AC97_GPIO_STATUS)
+		reg_addr = ac97->num ? &SMC_REG_BASE : &PMC_REG_BASE;
+	else
+		reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#endif
+	reg_addr += (reg >> 1);
+
+#ifndef CONFIG_PXA27x
+	if (reg == AC97_GPIO_STATUS) {
+		/* read from controller cache */
+		val = *reg_addr;
+		goto out;
+	}
+#endif
+
+	/* start read access across the ac97 link */
+	GSR = GSR_CDONE | GSR_SDONE;
+	gsr_bits = 0;
+	val = *reg_addr;
+
+	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1);
+	if (!((GSR | gsr_bits) & GSR_SDONE)) {
+		printk(KERN_ERR "%s: read error (ac97_reg=%x GSR=%#lx)\n",
+				__FUNCTION__, reg, GSR | gsr_bits);
+		val = -1;
+		goto out;
+	}
+
+	/* valid data now */
+	GSR = GSR_CDONE | GSR_SDONE;
+	gsr_bits = 0;
+	val = *reg_addr;
+	/* but we've just started another cycle... */
+	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1);
+
+out:	mutex_unlock(&car_mutex);
+	return val;
+}
+
+static void pxa2xx_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+	unsigned short val)
+{
+	volatile u32 *reg_addr;
+
+	mutex_lock(&car_mutex);
+
+	/* set up primary or secondary codec/modem space */
+#ifdef CONFIG_PXA27x
+	reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#else
+	if (reg == AC97_GPIO_STATUS)
+		reg_addr = ac97->num ? &SMC_REG_BASE : &PMC_REG_BASE;
+	else
+		reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#endif
+	reg_addr += (reg >> 1);
+
+	GSR = GSR_CDONE | GSR_SDONE;
+	gsr_bits = 0;
+	*reg_addr = val;
+	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_CDONE, 1);
+	if (!((GSR | gsr_bits) & GSR_CDONE))
+		printk(KERN_ERR "%s: write error (ac97_reg=%x GSR=%#lx)\n",
+				__FUNCTION__, reg, GSR | gsr_bits);
+
+	mutex_unlock(&car_mutex);
+}
+
+static void pxa2xx_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	gsr_bits = 0;
+
+#ifdef CONFIG_PXA27x
+	/* warm reset broken on Bulverde,
+	   so manually keep AC97 reset high */
+	pxa_gpio_mode(113 | GPIO_OUT | GPIO_DFLT_HIGH);
+	udelay(10);
+	GCR |= GCR_WARM_RST;
+	pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
+	udelay(500);
+#else
+	GCR |= GCR_WARM_RST | GCR_PRIRDY_IEN | GCR_SECRDY_IEN;
+	wait_event_timeout(gsr_wq, gsr_bits & (GSR_PCR | GSR_SCR), 1);
+#endif
+
+	if (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)))
+		printk(KERN_INFO "%s: warm reset timeout (GSR=%#lx)\n",
+				 __FUNCTION__, gsr_bits);
+
+	GCR &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
+	GCR |= GCR_SDONE_IE|GCR_CDONE_IE;
+}
+
+static void pxa2xx_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+	GCR &=  GCR_COLD_RST;  /* clear everything but nCRST */
+	GCR &= ~GCR_COLD_RST;  /* then assert nCRST */
+
+	gsr_bits = 0;
+#ifdef CONFIG_PXA27x
+	/* PXA27x Developers Manual section 13.5.2.2.1 */
+	pxa_set_cken(1 << 31, 1);
+	udelay(5);
+	pxa_set_cken(1 << 31, 0);
+	GCR = GCR_COLD_RST;
+	udelay(50);
+#else
+	GCR = GCR_COLD_RST;
+	GCR |= GCR_CDONE_IE|GCR_SDONE_IE;
+	wait_event_timeout(gsr_wq, gsr_bits & (GSR_PCR | GSR_SCR), 1);
+#endif
+
+	if (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)))
+		printk(KERN_INFO "%s: cold reset timeout (GSR=%#lx)\n",
+				 __FUNCTION__, gsr_bits);
+
+	GCR &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
+	GCR |= GCR_SDONE_IE|GCR_CDONE_IE;
+}
+
+static irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id)
+{
+	long status;
+
+	status = GSR;
+	if (status) {
+		GSR = status;
+		gsr_bits |= status;
+		wake_up(&gsr_wq);
+
+#ifdef CONFIG_PXA27x
+		/* Although we don't use those we still need to clear them
+		   since they tend to spuriously trigger when MMC is used
+		   (hardware bug? go figure)... */
+		MISR = MISR_EOC;
+		PISR = PISR_EOC;
+		MCSR = MCSR_EOC;
+#endif
+
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+struct snd_ac97_bus_ops soc_ac97_ops = {
+	.read	= pxa2xx_ac97_read,
+	.write	= pxa2xx_ac97_write,
+	.warm_reset	= pxa2xx_ac97_warm_reset,
+	.reset	= pxa2xx_ac97_cold_reset,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_stereo_out = {
+	.name			= "AC97 PCM Stereo out",
+	.dev_addr		= __PREG(PCDR),
+	.drcmr			= &DRCMRTXPCDR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_stereo_in = {
+	.name			= "AC97 PCM Stereo in",
+	.dev_addr		= __PREG(PCDR),
+	.drcmr			= &DRCMRRXPCDR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_aux_mono_out = {
+	.name			= "AC97 Aux PCM (Slot 5) Mono out",
+	.dev_addr		= __PREG(MODR),
+	.drcmr			= &DRCMRTXMODR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_aux_mono_in = {
+	.name			= "AC97 Aux PCM (Slot 5) Mono in",
+	.dev_addr		= __PREG(MODR),
+	.drcmr			= &DRCMRRXMODR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_mic_mono_in = {
+	.name			= "AC97 Mic PCM (Slot 6) Mono in",
+	.dev_addr		= __PREG(MCDR),
+	.drcmr			= &DRCMRRXMCDR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+#ifdef CONFIG_PM
+static int pxa2xx_ac97_suspend(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	GCR |= GCR_ACLINK_OFF;
+	pxa_set_cken(CKEN2_AC97, 0);
+	return 0;
+}
+
+static int pxa2xx_ac97_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	pxa_gpio_mode(GPIO31_SYNC_AC97_MD);
+	pxa_gpio_mode(GPIO30_SDATA_OUT_AC97_MD);
+	pxa_gpio_mode(GPIO28_BITCLK_AC97_MD);
+	pxa_gpio_mode(GPIO29_SDATA_IN_AC97_MD);
+#ifdef CONFIG_PXA27x
+	/* Use GPIO 113 as AC97 Reset on Bulverde */
+	pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
+#endif
+	pxa_set_cken(CKEN2_AC97, 1);
+	return 0;
+}
+
+#else
+#define pxa2xx_ac97_suspend	NULL
+#define pxa2xx_ac97_resume	NULL
+#endif
+
+static int pxa2xx_ac97_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = request_irq(IRQ_AC97, pxa2xx_ac97_irq, IRQF_DISABLED, "AC97", NULL);
+	if (ret < 0)
+		goto err;
+
+	pxa_gpio_mode(GPIO31_SYNC_AC97_MD);
+	pxa_gpio_mode(GPIO30_SDATA_OUT_AC97_MD);
+	pxa_gpio_mode(GPIO28_BITCLK_AC97_MD);
+	pxa_gpio_mode(GPIO29_SDATA_IN_AC97_MD);
+#ifdef CONFIG_PXA27x
+	/* Use GPIO 113 as AC97 Reset on Bulverde */
+	pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
+#endif
+	pxa_set_cken(CKEN2_AC97, 1);
+	return 0;
+
+ err:
+	if (CKEN & CKEN2_AC97) {
+		GCR |= GCR_ACLINK_OFF;
+		free_irq(IRQ_AC97, NULL);
+		pxa_set_cken(CKEN2_AC97, 0);
+	}
+	return ret;
+}
+
+static void pxa2xx_ac97_remove(struct platform_device *pdev)
+{
+	GCR |= GCR_ACLINK_OFF;
+	free_irq(IRQ_AC97, NULL);
+	pxa_set_cken(CKEN2_AC97, 0);
+}
+
+static int pxa2xx_ac97_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->cpu_dai->dma_data = &pxa2xx_ac97_pcm_stereo_out;
+	else
+		rtd->cpu_dai->dma_data = &pxa2xx_ac97_pcm_stereo_in;
+
+	return 0;
+}
+
+static int pxa2xx_ac97_hw_aux_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->cpu_dai->dma_data = &pxa2xx_ac97_pcm_aux_mono_out;
+	else
+		rtd->cpu_dai->dma_data = &pxa2xx_ac97_pcm_aux_mono_in;
+
+	return 0;
+}
+
+static int pxa2xx_ac97_hw_mic_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return -ENODEV;
+	else
+		rtd->cpu_dai->dma_data = &pxa2xx_ac97_pcm_mic_mono_in;
+
+	return 0;
+}
+
+/*
+ * There is only 1 physical AC97 interface for pxa2xx, but it
+ * has extra fifo's that can be used for aux DACs and ADCs.
+ */
+struct snd_soc_cpu_dai pxa_ac97_dai[] = {
+{
+	.name = "pxa2xx-ac97",
+	.id = 0,
+	.type = SND_SOC_DAI_AC97,
+	.probe = pxa2xx_ac97_probe,
+	.remove = pxa2xx_ac97_remove,
+	.suspend = pxa2xx_ac97_suspend,
+	.resume = pxa2xx_ac97_resume,
+	.playback = {
+		.stream_name = "AC97 Playback",
+		.channels_min = 2,
+		.channels_max = 2,},
+	.capture = {
+		.stream_name = "AC97 Capture",
+		.channels_min = 2,
+		.channels_max = 2,},
+	.ops = {
+		.hw_params = pxa2xx_ac97_hw_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(pxa2xx_ac97_modes),
+		.mode = pxa2xx_ac97_modes,},
+},
+{
+	.name = "pxa2xx-ac97-aux",
+	.id = 1,
+	.type = SND_SOC_DAI_AC97,
+	.playback = {
+		.stream_name = "AC97 Aux Playback",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.capture = {
+		.stream_name = "AC97 Aux Capture",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.ops = {
+		.hw_params = pxa2xx_ac97_hw_aux_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(pxa2xx_ac97_modes),
+		.mode = pxa2xx_ac97_modes,},
+},
+{
+	.name = "pxa2xx-ac97-mic",
+	.id = 2,
+	.type = SND_SOC_DAI_AC97,
+	.capture = {
+		.stream_name = "AC97 Mic Capture",
+		.channels_min = 1,
+		.channels_max = 1,},
+	.ops = {
+		.hw_params = pxa2xx_ac97_hw_mic_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(pxa2xx_ac97_modes),
+		.mode = pxa2xx_ac97_modes,},},
+};
+
+EXPORT_SYMBOL_GPL(pxa_ac97_dai);
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
+
+MODULE_AUTHOR("Nicolas Pitre");
+MODULE_DESCRIPTION("AC97 driver for the Intel PXA2xx chip");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-i2s.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-i2s.c
@@ -0,0 +1,354 @@
+/*
+ * pxa2xx-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+
+#include "pxa2xx-pcm.h"
+
+/* used to disable sysclk if external crystal is used */
+static int extclk;
+module_param(extclk, int, 0);
+MODULE_PARM_DESC(extclk, "set to 1 to disable pxa2xx i2s sysclk");
+
+struct pxa_i2s_port {
+	u32 sadiv;
+	u32 sacr0;
+	u32 sacr1;
+	u32 saimr;
+	int master;
+};
+static struct pxa_i2s_port pxa_i2s;
+
+#define PXA_I2S_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF)
+
+#define PXA_I2S_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define PXA_I2S_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+/* priv is divider */
+static struct snd_soc_dai_mode pxa2xx_i2s_modes[] = {
+	/* pxa2xx I2S frame and clock master modes */
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x48,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x34,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x24,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0x1a,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0xd,
+	},
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = PXA_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = SND_SOC_FSBD(4),
+		.priv = 0xc,
+	},
+
+	/* pxa2xx I2S frame master and clock slave mode */
+	{
+		.fmt = PXA_I2S_DAIFMT | SND_SOC_DAIFMT_CBM_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = PXA_I2S_RATES,
+		.pcmdir = PXA_I2S_DIR,
+		.fs = SND_SOC_FS_ALL,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.bfs = 64,
+		.priv = 0x48,
+	},
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_i2s_pcm_stereo_out = {
+	.name			= "I2S PCM Stereo out",
+	.dev_addr		= __PREG(SADR),
+	.drcmr			= &DRCMRTXSADR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_i2s_pcm_stereo_in = {
+	.name			= "I2S PCM Stereo in",
+	.dev_addr		= __PREG(SADR),
+	.drcmr			= &DRCMRRXSADR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_gpio gpio_bus[] = {
+	{ /* I2S SoC Slave */
+		.rx = GPIO29_SDATA_IN_I2S_MD,
+		.tx = GPIO30_SDATA_OUT_I2S_MD,
+		.clk = GPIO28_BITCLK_IN_I2S_MD,
+		.frm = GPIO31_SYNC_I2S_MD,
+	},
+	{ /* I2S SoC Master */
+#ifdef CONFIG_PXA27x
+		.sys = GPIO113_I2S_SYSCLK_MD,
+#else
+		.sys = GPIO32_SYSCLK_I2S_MD,
+#endif
+		.rx = GPIO29_SDATA_IN_I2S_MD,
+		.tx = GPIO30_SDATA_OUT_I2S_MD,
+		.clk = GPIO28_BITCLK_OUT_I2S_MD,
+		.frm = GPIO31_SYNC_I2S_MD,
+	},
+};
+
+static int pxa2xx_i2s_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (!rtd->cpu_dai->active) {
+		SACR0 |= SACR0_RST;
+		SACR0 = 0;
+	}
+
+	return 0;
+}
+
+/* wait for I2S controller to be ready */
+static int pxa_i2s_wait(void)
+{
+	int i;
+
+	/* flush the Rx FIFO */
+	for(i = 0; i < 16; i++)
+		SADR;
+	return 0;
+}
+
+static int pxa2xx_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	pxa_i2s.master = 0;
+	if (rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CBS_CFS)
+		pxa_i2s.master = 1;
+
+	if (pxa_i2s.master && !extclk)
+		pxa_gpio_mode(gpio_bus[pxa_i2s.master].sys);
+
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].rx);
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].tx);
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].frm);
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].clk);
+	pxa_set_cken(CKEN8_I2S, 1);
+	pxa_i2s_wait();
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->cpu_dai->dma_data = &pxa2xx_i2s_pcm_stereo_out;
+	else
+		rtd->cpu_dai->dma_data = &pxa2xx_i2s_pcm_stereo_in;
+
+	/* is port used by another stream */
+	if (!(SACR0 & SACR0_ENB)) {
+
+		SACR0 = 0;
+		SACR1 = 0;
+		if (pxa_i2s.master)
+			SACR0 |= SACR0_BCKD;
+
+		SACR0 |= SACR0_RFTH(14) | SACR0_TFTH(1);
+
+		if (rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_LEFT_J)
+			SACR1 |= SACR1_AMSL;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		SAIMR |= SAIMR_TFS;
+	else
+		SAIMR |= SAIMR_RFS;
+
+	SADIV = rtd->cpu_dai->dai_runtime.priv;
+	return 0;
+}
+
+static int pxa2xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		SACR0 |= SACR0_ENB;
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void pxa2xx_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		SACR1 |= SACR1_DRPL;
+		SAIMR &= ~SAIMR_TFS;
+	} else {
+		SACR1 |= SACR1_DREC;
+		SAIMR &= ~SAIMR_RFS;
+	}
+
+	if (SACR1 & (SACR1_DREC | SACR1_DRPL)) {
+		SACR0 &= ~SACR0_ENB;
+		pxa_i2s_wait();
+		pxa_set_cken(CKEN8_I2S, 0);
+	}
+}
+
+#ifdef CONFIG_PM
+static int pxa2xx_i2s_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	/* store registers */
+	pxa_i2s.sacr0 = SACR0;
+	pxa_i2s.sacr1 = SACR1;
+	pxa_i2s.saimr = SAIMR;
+	pxa_i2s.sadiv = SADIV;
+
+	/* deactivate link */
+	SACR0 &= ~SACR0_ENB;
+	pxa_i2s_wait();
+	return 0;
+}
+
+static int pxa2xx_i2s_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	pxa_i2s_wait();
+
+	SACR0 = pxa_i2s.sacr0 &= ~SACR0_ENB;
+	SACR1 = pxa_i2s.sacr1;
+	SAIMR = pxa_i2s.saimr;
+	SADIV = pxa_i2s.sadiv;
+	SACR0 |= SACR0_ENB;
+
+	return 0;
+}
+
+#else
+#define pxa2xx_i2s_suspend	NULL
+#define pxa2xx_i2s_resume	NULL
+#endif
+
+/* pxa2xx I2S sysclock is always 256 FS */
+static unsigned int pxa_i2s_config_sysclk(struct snd_soc_cpu_dai *iface,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	return info->rate << 8;
+}
+
+struct snd_soc_cpu_dai pxa_i2s_dai = {
+	.name = "pxa2xx-i2s",
+	.id = 0,
+	.type = SND_SOC_DAI_I2S,
+	.suspend = pxa2xx_i2s_suspend,
+	.resume = pxa2xx_i2s_resume,
+	.config_sysclk = pxa_i2s_config_sysclk,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.ops = {
+		.startup = pxa2xx_i2s_startup,
+		.shutdown = pxa2xx_i2s_shutdown,
+		.trigger = pxa2xx_i2s_trigger,
+		.hw_params = pxa2xx_i2s_hw_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(pxa2xx_i2s_modes),
+		.mode = pxa2xx_i2s_modes,},
+};
+
+EXPORT_SYMBOL_GPL(pxa_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("pxa2xx I2S SoC Interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-pcm.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-pcm.c
@@ -0,0 +1,363 @@
+/*
+ * linux/sound/arm/pxa2xx-pcm.c -- ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+
+#include "pxa2xx-pcm.h"
+
+static const struct snd_pcm_hardware pxa2xx_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+					SNDRV_PCM_FMTBIT_S24_LE |
+					SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192 - 32,
+	.periods_min		= 1,
+	.periods_max		= PAGE_SIZE/sizeof(pxa_dma_desc),
+	.buffer_bytes_max	= 128 * 1024,
+	.fifo_size		= 32,
+};
+
+struct pxa2xx_runtime_data {
+	int dma_ch;
+	struct pxa2xx_pcm_dma_params *params;
+	pxa_dma_desc *dma_desc_array;
+	dma_addr_t dma_desc_array_phys;
+};
+
+static void pxa2xx_pcm_dma_irq(int dma_ch, void *dev_id)
+{
+	struct snd_pcm_substream *substream = dev_id;
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+	int dcsr;
+
+	dcsr = DCSR(dma_ch);
+	DCSR(dma_ch) = dcsr & ~DCSR_STOPIRQEN;
+
+	if (dcsr & DCSR_ENDINTR) {
+		snd_pcm_period_elapsed(substream);
+	} else {
+		printk( KERN_ERR "%s: DMA error on channel %d (DCSR=%#x)\n",
+			prtd->params->name, dma_ch, dcsr );
+	}
+}
+
+static int pxa2xx_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct pxa2xx_pcm_dma_params *dma = rtd->cpu_dai->dma_data;
+	size_t totsize = params_buffer_bytes(params);
+	size_t period = params_period_bytes(params);
+	pxa_dma_desc *dma_desc;
+	dma_addr_t dma_buff_phys, next_desc_phys;
+	int ret;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		ret = pxa_request_dma(prtd->params->name, DMA_PRIO_LOW,
+			      pxa2xx_pcm_dma_irq, substream);
+		if (ret < 0)
+			return ret;
+		prtd->dma_ch = ret;
+	} else if (prtd->params != dma) {
+		pxa_free_dma(prtd->dma_ch);
+		prtd->params = dma;
+		ret = pxa_request_dma(prtd->params->name, DMA_PRIO_LOW,
+			      pxa2xx_pcm_dma_irq, substream);
+		if (ret < 0)
+			return ret;
+		prtd->dma_ch = ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = totsize;
+
+	dma_desc = prtd->dma_desc_array;
+	next_desc_phys = prtd->dma_desc_array_phys;
+	dma_buff_phys = runtime->dma_addr;
+	do {
+		next_desc_phys += sizeof(pxa_dma_desc);
+		dma_desc->ddadr = next_desc_phys;
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dma_desc->dsadr = dma_buff_phys;
+			dma_desc->dtadr = prtd->params->dev_addr;
+		} else {
+			dma_desc->dsadr = prtd->params->dev_addr;
+			dma_desc->dtadr = dma_buff_phys;
+		}
+		if (period > totsize)
+			period = totsize;
+		dma_desc->dcmd = prtd->params->dcmd | period | DCMD_ENDIRQEN;
+		dma_desc++;
+		dma_buff_phys += period;
+	} while (totsize -= period);
+	dma_desc[-1].ddadr = prtd->dma_desc_array_phys;
+
+	return 0;
+}
+
+static int pxa2xx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+
+	if (prtd && prtd->params)
+		*prtd->params->drcmr = 0;
+
+	if (prtd->dma_ch) {
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		pxa_free_dma(prtd->dma_ch);
+		prtd->dma_ch = 0;
+	}
+
+	return 0;
+}
+
+static int pxa2xx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+
+	DCSR(prtd->dma_ch) &= ~DCSR_RUN;
+	DCSR(prtd->dma_ch) = 0;
+	DCMD(prtd->dma_ch) = 0;
+	*prtd->params->drcmr = prtd->dma_ch | DRCMR_MAPVLD;
+
+	return 0;
+}
+
+static int pxa2xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		DDADR(prtd->dma_ch) = prtd->dma_desc_array_phys;
+		DCSR(prtd->dma_ch) = DCSR_RUN;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		DCSR(prtd->dma_ch) &= ~DCSR_RUN;
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+		DCSR(prtd->dma_ch) |= DCSR_RUN;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		DDADR(prtd->dma_ch) = prtd->dma_desc_array_phys;
+		DCSR(prtd->dma_ch) |= DCSR_RUN;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t
+pxa2xx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd = runtime->private_data;
+
+	dma_addr_t ptr = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+			 DSADR(prtd->dma_ch) : DTADR(prtd->dma_ch);
+	snd_pcm_uframes_t x = bytes_to_frames(runtime, ptr - runtime->dma_addr);
+
+	if (x == runtime->buffer_size)
+		x = 0;
+	return x;
+}
+
+static int pxa2xx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &pxa2xx_pcm_hardware);
+
+	/*
+	 * For mysterious reasons (and despite what the manual says)
+	 * playback samples are lost if the DMA count is not a multiple
+	 * of the DMA burst size.  Let's add a rule to enforce that.
+	 */
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+		SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);
+	if (ret)
+		goto out;
+
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+		SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);
+	if (ret)
+		goto out;
+
+	prtd = kzalloc(sizeof(struct pxa2xx_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	prtd->dma_desc_array =
+		dma_alloc_writecombine(substream->pcm->card->dev, PAGE_SIZE,
+				       &prtd->dma_desc_array_phys, GFP_KERNEL);
+	if (!prtd->dma_desc_array) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	runtime->private_data = prtd;
+	return 0;
+
+ err1:
+	kfree(prtd);
+ out:
+	return ret;
+}
+
+static int pxa2xx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd = runtime->private_data;
+
+	dma_free_writecombine(substream->pcm->card->dev, PAGE_SIZE,
+			      prtd->dma_desc_array, prtd->dma_desc_array_phys);
+	kfree(prtd);
+	return 0;
+}
+
+static int pxa2xx_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops pxa2xx_pcm_ops = {
+	.open		= pxa2xx_pcm_open,
+	.close		= pxa2xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= pxa2xx_pcm_hw_params,
+	.hw_free	= pxa2xx_pcm_hw_free,
+	.prepare	= pxa2xx_pcm_prepare,
+	.trigger	= pxa2xx_pcm_trigger,
+	.pointer	= pxa2xx_pcm_pointer,
+	.mmap		= pxa2xx_pcm_mmap,
+};
+
+static int pxa2xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = pxa2xx_pcm_hardware.buffer_bytes_max;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void pxa2xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 pxa2xx_pcm_dmamask = DMA_32BIT_MASK;
+
+int pxa2xx_pcm_new(struct snd_card *card, struct snd_soc_codec_dai *dai,
+	struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &pxa2xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_32BIT_MASK;
+
+	if (dai->playback.channels_min) {
+		ret = pxa2xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = pxa2xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+struct snd_soc_platform pxa2xx_soc_platform = {
+	.name		= "pxa2xx-audio",
+	.pcm_ops 	= &pxa2xx_pcm_ops,
+	.pcm_new	= pxa2xx_pcm_new,
+	.pcm_free	= pxa2xx_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(pxa2xx_soc_platform);
+
+MODULE_AUTHOR("Nicolas Pitre");
+MODULE_DESCRIPTION("Intel PXA2xx PCM DMA module");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-pcm.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-pcm.h
@@ -0,0 +1,48 @@
+/*
+ * linux/sound/arm/pxa2xx-pcm.h -- ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _PXA2XX_PCM_H
+#define _PXA2XX_PCM_H
+
+struct pxa2xx_pcm_dma_params {
+	char *name;			/* stream identifier */
+	u32 dcmd;			/* DMA descriptor dcmd field */
+	volatile u32 *drcmr;		/* the DMA request channel to use */
+	u32 dev_addr;			/* device physical address for DMA */
+};
+
+struct pxa2xx_gpio {
+	u32 sys;
+	u32	rx;
+	u32 tx;
+	u32 clk;
+	u32 frm;
+};
+
+/* pxa2xx DAI ID's */
+#define PXA2XX_DAI_AC97_HIFI	0
+#define PXA2XX_DAI_AC97_AUX		1
+#define PXA2XX_DAI_AC97_MIC		2
+#define PXA2XX_DAI_I2S			0
+#define PXA2XX_DAI_SSP1			0
+#define PXA2XX_DAI_SSP2			1
+#define PXA2XX_DAI_SSP3			2
+
+extern struct snd_soc_cpu_dai pxa_ac97_dai[3];
+extern struct snd_soc_cpu_dai pxa_i2s_dai;
+extern struct snd_soc_cpu_dai pxa_ssp_dai[3];
+
+/* platform data */
+extern struct snd_soc_platform pxa2xx_soc_platform;
+extern struct snd_ac97_bus_ops pxa2xx_ac97_ops;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-ssp.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/pxa2xx-ssp.c
@@ -0,0 +1,767 @@
+/*
+ * pxa2xx-ssp.c  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *
+ * TODO:
+ *  o Fix master mode (bug)
+ *  o Fix resume (bug)
+ *  o Add support for other clocks
+ *  o Test network mode for > 16bit sample size
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+#include <asm/arch/ssp.h>
+
+#include "pxa2xx-pcm.h"
+
+/*
+ * SSP sysclock frequency in Hz
+ * Neither default pxa2xx PLL clocks are good for audio, hence pxa27x
+ * has audio clock. I would recommend using the pxa27x audio clock or an
+ * external clock or making the codec master to gurantee better sample rates.
+ */
+#ifdef CONFIG_PXA27x
+static int sysclk[3] = {13000000, 13000000, 13000000};
+#else
+static int sysclk[3] = {1843200, 1843200, 1843200};
+#endif
+module_param_array(sysclk, int, NULL, 0);
+MODULE_PARM_DESC(sysclk, "sysclk frequency in Hz");
+
+/*
+ * SSP sysclock source.
+ * sysclk is ignored if audio clock is used
+ */
+#ifdef CONFIG_PXA27x
+static int clksrc[3] = {0, 0, 0};
+#else
+static int clksrc[3] = {0, 0, 0};
+#endif
+module_param_array(clksrc, int, NULL, 0);
+MODULE_PARM_DESC(clksrc,
+	"sysclk source, 0 = internal PLL, 1 = ext, 2 = network, 3 = audio clock");
+
+/*
+ * SSP GPIO's
+ */
+#define GPIO26_SSP1RX_MD	(26 | GPIO_ALT_FN_1_IN)
+#define GPIO25_SSP1TX_MD	(25 | GPIO_ALT_FN_2_OUT)
+#define GPIO23_SSP1CLKS_MD	(23 | GPIO_ALT_FN_2_IN)
+#define GPIO24_SSP1FRMS_MD	(24 | GPIO_ALT_FN_2_IN)
+#define GPIO23_SSP1CLKM_MD	(23 | GPIO_ALT_FN_2_OUT)
+#define GPIO24_SSP1FRMM_MD	(24 | GPIO_ALT_FN_2_OUT)
+
+#define GPIO11_SSP2RX_MD	(11 | GPIO_ALT_FN_2_IN)
+#define GPIO13_SSP2TX_MD	(13 | GPIO_ALT_FN_1_OUT)
+#define GPIO22_SSP2CLKS_MD	(22 | GPIO_ALT_FN_3_IN)
+#define GPIO88_SSP2FRMS_MD	(88 | GPIO_ALT_FN_3_IN)
+#define GPIO22_SSP2CLKM_MD	(22 | GPIO_ALT_FN_3_OUT)
+#define GPIO88_SSP2FRMM_MD	(88 | GPIO_ALT_FN_3_OUT)
+
+#define GPIO82_SSP3RX_MD	(82 | GPIO_ALT_FN_1_IN)
+#define GPIO81_SSP3TX_MD	(81 | GPIO_ALT_FN_1_OUT)
+#define GPIO84_SSP3CLKS_MD	(84 | GPIO_ALT_FN_1_IN)
+#define GPIO83_SSP3FRMS_MD	(83 | GPIO_ALT_FN_1_IN)
+#define GPIO84_SSP3CLKM_MD	(84 | GPIO_ALT_FN_1_OUT)
+#define GPIO83_SSP3FRMM_MD	(83 | GPIO_ALT_FN_1_OUT)
+
+#define PXA_SSP_MDAIFMT \
+	(SND_SOC_DAIFMT_DSP_B  |SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_CBM_CFS | \
+	SND_SOC_DAIFMT_CBS_CFM | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF)
+
+#define PXA_SSP_SDAIFMT \
+	(SND_SOC_DAIFMT_DSP_B  |SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_CBM_CFS | \
+	SND_SOC_DAIFMT_CBS_CFM | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF)
+
+#define PXA_SSP_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define PXA_SSP_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | \
+	SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
+
+#define PXA_SSP_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+/*
+ * SSP modes
+ */
+static struct snd_soc_dai_mode pxa2xx_ssp_modes[] = {
+	/* port slave clk & frame modes */
+	{
+		.fmt = PXA_SSP_SDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = PXA_SSP_RATES,
+		.pcmdir = PXA_SSP_DIR,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+
+	/* port master clk & frame modes */
+#ifdef CONFIG_PXA27x
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_11025,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_22050,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 256,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 128,
+		.bfs = SND_SOC_FSBW(1),
+	},
+	{
+		.fmt = PXA_SSP_MDAIFMT,
+		.pcmfmt = PXA_SSP_BITS,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = PXA_SSP_DIR,
+		.flags = SND_SOC_DAI_BFS_RCW,
+		.fs = 128,
+		.bfs = SND_SOC_FSBW(1),
+	},
+#endif
+};
+
+static struct ssp_dev ssp[3];
+#ifdef CONFIG_PM
+static struct ssp_state ssp_state[3];
+#endif
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp1_pcm_mono_out = {
+	.name			= "SSP1 PCM Mono out",
+	.dev_addr		= __PREG(SSDR_P1),
+	.drcmr			= &DRCMRTXSSDR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp1_pcm_mono_in = {
+	.name			= "SSP1 PCM Mono in",
+	.dev_addr		= __PREG(SSDR_P1),
+	.drcmr			= &DRCMRRXSSDR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp1_pcm_stereo_out = {
+	.name			= "SSP1 PCM Stereo out",
+	.dev_addr		= __PREG(SSDR_P1),
+	.drcmr			= &DRCMRTXSSDR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp1_pcm_stereo_in = {
+	.name			= "SSP1 PCM Stereo in",
+	.dev_addr		= __PREG(SSDR_P1),
+	.drcmr			= &DRCMRRXSSDR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp2_pcm_mono_out = {
+	.name			= "SSP2 PCM Mono out",
+	.dev_addr		= __PREG(SSDR_P2),
+	.drcmr			= &DRCMRTXSS2DR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp2_pcm_mono_in = {
+	.name			= "SSP2 PCM Mono in",
+	.dev_addr		= __PREG(SSDR_P2),
+	.drcmr			= &DRCMRRXSS2DR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp2_pcm_stereo_out = {
+	.name			= "SSP2 PCM Stereo out",
+	.dev_addr		= __PREG(SSDR_P2),
+	.drcmr			= &DRCMRTXSS2DR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp2_pcm_stereo_in = {
+	.name			= "SSP2 PCM Stereo in",
+	.dev_addr		= __PREG(SSDR_P2),
+	.drcmr			= &DRCMRRXSS2DR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp3_pcm_mono_out = {
+	.name			= "SSP3 PCM Mono out",
+	.dev_addr		= __PREG(SSDR_P3),
+	.drcmr			= &DRCMRTXSS3DR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp3_pcm_mono_in = {
+	.name			= "SSP3 PCM Mono in",
+	.dev_addr		= __PREG(SSDR_P3),
+	.drcmr			= &DRCMRRXSS3DR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp3_pcm_stereo_out = {
+	.name			= "SSP3 PCM Stereo out",
+	.dev_addr		= __PREG(SSDR_P3),
+	.drcmr			= &DRCMRTXSS3DR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ssp3_pcm_stereo_in = {
+	.name			= "SSP3 PCM Stereo in",
+	.dev_addr		= __PREG(SSDR_P3),
+	.drcmr			= &DRCMRRXSS3DR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params *ssp_dma_params[3][4] = {
+	{&pxa2xx_ssp1_pcm_mono_out, &pxa2xx_ssp1_pcm_mono_in,
+	&pxa2xx_ssp1_pcm_stereo_out,&pxa2xx_ssp1_pcm_stereo_in,},
+	{&pxa2xx_ssp2_pcm_mono_out, &pxa2xx_ssp2_pcm_mono_in,
+	&pxa2xx_ssp2_pcm_stereo_out, &pxa2xx_ssp2_pcm_stereo_in,},
+	{&pxa2xx_ssp3_pcm_mono_out, &pxa2xx_ssp3_pcm_mono_in,
+	&pxa2xx_ssp3_pcm_stereo_out,&pxa2xx_ssp3_pcm_stereo_in,},
+};
+
+static struct pxa2xx_gpio ssp_gpios[3][4] = {
+	{{ /* SSP1 SND_SOC_DAIFMT_CBM_CFM */
+		.rx = GPIO26_SSP1RX_MD,
+		.tx = GPIO25_SSP1TX_MD,
+		.clk = (23 | GPIO_ALT_FN_2_IN),
+		.frm = (24 | GPIO_ALT_FN_2_IN),
+	},
+	{ /* SSP1 SND_SOC_DAIFMT_CBS_CFS */
+		.rx = GPIO26_SSP1RX_MD,
+		.tx = GPIO25_SSP1TX_MD,
+		.clk = (23 | GPIO_ALT_FN_2_OUT),
+		.frm = (24 | GPIO_ALT_FN_2_OUT),
+	},
+	{ /* SSP1 SND_SOC_DAIFMT_CBS_CFM */
+		.rx = GPIO26_SSP1RX_MD,
+		.tx = GPIO25_SSP1TX_MD,
+		.clk = (23 | GPIO_ALT_FN_2_OUT),
+		.frm = (24 | GPIO_ALT_FN_2_IN),
+	},
+	{ /* SSP1 SND_SOC_DAIFMT_CBM_CFS */
+		.rx = GPIO26_SSP1RX_MD,
+		.tx = GPIO25_SSP1TX_MD,
+		.clk = (23 | GPIO_ALT_FN_2_IN),
+		.frm = (24 | GPIO_ALT_FN_2_OUT),
+	}},
+	{{ /* SSP2 SND_SOC_DAIFMT_CBM_CFM */
+		.rx = GPIO11_SSP2RX_MD,
+		.tx = GPIO13_SSP2TX_MD,
+		.clk = (22 | GPIO_ALT_FN_3_IN),
+		.frm = (88 | GPIO_ALT_FN_3_IN),
+	},
+	{ /* SSP2 SND_SOC_DAIFMT_CBS_CFS */
+		.rx = GPIO11_SSP2RX_MD,
+		.tx = GPIO13_SSP2TX_MD,
+		.clk = (22 | GPIO_ALT_FN_3_OUT),
+		.frm = (88 | GPIO_ALT_FN_3_OUT),
+	},
+	{ /* SSP2 SND_SOC_DAIFMT_CBS_CFM */
+		.rx = GPIO11_SSP2RX_MD,
+		.tx = GPIO13_SSP2TX_MD,
+		.clk = (22 | GPIO_ALT_FN_3_OUT),
+		.frm = (88 | GPIO_ALT_FN_3_IN),
+	},
+	{ /* SSP2 SND_SOC_DAIFMT_CBM_CFS */
+		.rx = GPIO11_SSP2RX_MD,
+		.tx = GPIO13_SSP2TX_MD,
+		.clk = (22 | GPIO_ALT_FN_3_IN),
+		.frm = (88 | GPIO_ALT_FN_3_OUT),
+	}},
+	{{ /* SSP3 SND_SOC_DAIFMT_CBM_CFM */
+		.rx = GPIO82_SSP3RX_MD,
+		.tx = GPIO81_SSP3TX_MD,
+		.clk = (84 | GPIO_ALT_FN_3_IN),
+		.frm = (83 | GPIO_ALT_FN_3_IN),
+	},
+	{ /* SSP3 SND_SOC_DAIFMT_CBS_CFS */
+		.rx = GPIO82_SSP3RX_MD,
+		.tx = GPIO81_SSP3TX_MD,
+		.clk = (84 | GPIO_ALT_FN_3_OUT),
+		.frm = (83 | GPIO_ALT_FN_3_OUT),
+	},
+	{ /* SSP3 SND_SOC_DAIFMT_CBS_CFM */
+		.rx = GPIO82_SSP3RX_MD,
+		.tx = GPIO81_SSP3TX_MD,
+		.clk = (84 | GPIO_ALT_FN_3_OUT),
+		.frm = (83 | GPIO_ALT_FN_3_IN),
+	},
+	{ /* SSP3 SND_SOC_DAIFMT_CBM_CFS */
+		.rx = GPIO82_SSP3RX_MD,
+		.tx = GPIO81_SSP3TX_MD,
+		.clk = (84 | GPIO_ALT_FN_3_IN),
+		.frm = (83 | GPIO_ALT_FN_3_OUT),
+	}},
+};
+
+static int pxa2xx_ssp_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int ret = 0;
+
+	if (!rtd->cpu_dai->active) {
+		ret = ssp_init (&ssp[rtd->cpu_dai->id], rtd->cpu_dai->id + 1,
+			SSP_NO_IRQ);
+		if (ret < 0)
+			return ret;
+		ssp_disable(&ssp[rtd->cpu_dai->id]);
+	}
+	return ret;
+}
+
+static void pxa2xx_ssp_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (!rtd->cpu_dai->active) {
+		ssp_disable(&ssp[rtd->cpu_dai->id]);
+		ssp_exit(&ssp[rtd->cpu_dai->id]);
+	}
+}
+
+#ifdef CONFIG_PM
+
+#if defined (CONFIG_PXA27x)
+static int cken[3] = {CKEN23_SSP1, CKEN3_SSP2, CKEN4_SSP3};
+#else
+static int cken[3] = {CKEN3_SSP, CKEN9_NSSP, CKEN10_ASSP};
+#endif
+
+static int pxa2xx_ssp_suspend(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	ssp_save_state(&ssp[dai->id], &ssp_state[dai->id]);
+	pxa_set_cken(cken[dai->id], 0);
+	return 0;
+}
+
+static int pxa2xx_ssp_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	pxa_set_cken(cken[dai->id], 1);
+	ssp_restore_state(&ssp[dai->id], &ssp_state[dai->id]);
+	ssp_enable(&ssp[dai->id]);
+
+	return 0;
+}
+
+#else
+#define pxa2xx_ssp_suspend	NULL
+#define pxa2xx_ssp_resume	NULL
+#endif
+
+/* todo - check clk source and PLL before returning clock rate */
+static unsigned int pxa_ssp_config_sysclk(struct snd_soc_cpu_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	/* audio clock ? (divide by 1) */
+	if (clksrc[dai->id] == 3) {
+		switch(info->rate){
+		case 8000:
+		case 16000:
+		case 32000:
+		case 48000:
+		case 96000:
+			return 12288000;
+			break;
+		case 11025:
+		case 22050:
+		case 44100:
+		case 88200:
+			return 11289600;
+		break;
+		}
+	}
+
+	/* pll */
+	return sysclk[dai->id];
+}
+
+#ifdef CONFIG_PXA27x
+static u32 pxa27x_set_audio_clk(unsigned int rate, unsigned int fs)
+{
+	u32 aclk = 0, div = 0;
+
+	if (rate == 0 || fs == 0)
+		return 0;
+
+	switch(rate){
+	case 8000:
+	case 16000:
+	case 32000:
+	case 48000:
+	case 96000:
+		aclk = 0x2 << 4;
+		div = 12288000 / (rate * fs);
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		aclk = 0x1 << 4;
+		div = 11289600 / (rate * fs);
+		break;
+	}
+
+	aclk |= ffs(div) - 1;
+	return aclk;
+}
+#endif
+
+static inline int get_scr(int srate, int id)
+{
+	if (srate == 0)
+		return 0;
+	return (sysclk[id] / srate) - 1;
+}
+
+static int pxa2xx_ssp_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int fmt = 0, dma = 0, fs, chn = params_channels(params);
+	u32 ssp_mode = 0, ssp_setup = 0, psp_mode = 0, rate = 0;
+
+	fs = rtd->cpu_dai->dai_runtime.fs;
+
+	/* select correct DMA params */
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		dma = 1;
+	if (chn == 2 || rtd->cpu_dai->dai_runtime.pcmfmt != PXA_SSP_BITS)
+		dma += 2;
+	rtd->cpu_dai->dma_data = ssp_dma_params[rtd->cpu_dai->id][dma];
+
+	/* is port used by another stream */
+	if (SSCR0 & SSCR0_SSE)
+		return 0;
+
+	/* bit size */
+	switch(rtd->cpu_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		ssp_mode |=SSCR0_DataSize(16);
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		ssp_mode |=(SSCR0_EDSS | SSCR0_DataSize(8));
+		/* use network mode for stereo samples > 16 bits */
+		if (chn == 2) {
+			ssp_mode |= (SSCR0_MOD | SSCR0_SlotsPerFrm(2) << 24);
+			/* active slots 0,1 */
+			SSTSA_P(rtd->cpu_dai->id +1) = 0x3;
+			SSRSA_P(rtd->cpu_dai->id +1) = 0x3;
+		}
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		ssp_mode |= (SSCR0_EDSS | SSCR0_DataSize(16));
+		/* use network mode for stereo samples > 16 bits */
+		if (chn == 2) {
+			ssp_mode |= (SSCR0_MOD | SSCR0_SlotsPerFrm(2) << 24);
+			/* active slots 0,1 */
+			SSTSA_P(rtd->cpu_dai->id +1) = 0x3;
+			SSRSA_P(rtd->cpu_dai->id +1) = 0x3;
+		}
+		break;
+	}
+
+	ssp_mode |= SSCR0_PSP;
+	ssp_setup = SSCR1_RxTresh(14) | SSCR1_TxTresh(1) |
+		SSCR1_TRAIL | SSCR1_RWOT;
+
+	switch(rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		ssp_setup |= (SSCR1_SCLKDIR | SSCR1_SFRMDIR);
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		ssp_setup |= SSCR1_SCLKDIR;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		ssp_setup |= SSCR1_SFRMDIR;
+		break;
+	}
+
+	switch(rtd->cpu_dai->dai_runtime.fmt) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		fmt = 1;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		fmt = 2;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		fmt = 3;
+		break;
+	}
+
+	pxa_gpio_mode(ssp_gpios[rtd->cpu_dai->id][fmt].rx);
+	pxa_gpio_mode(ssp_gpios[rtd->cpu_dai->id][fmt].tx);
+	pxa_gpio_mode(ssp_gpios[rtd->cpu_dai->id][fmt].frm);
+	pxa_gpio_mode(ssp_gpios[rtd->cpu_dai->id][fmt].clk);
+
+	switch (rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		psp_mode |= SSPSP_SFRMP | SSPSP_FSRT;
+		break;
+	}
+
+	if (rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_DSP_A)
+		psp_mode |= SSPSP_SCMODE(2);
+	if (rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_DSP_B)
+		psp_mode |= SSPSP_SCMODE(3);
+
+	switch(clksrc[rtd->cpu_dai->id]) {
+	case 2: /* network clock */
+		ssp_mode |= SSCR0_NCS | SSCR0_MOD;
+	case 1: /* external clock */
+		ssp_mode |= SSCR0_ECS;
+	case 0: /* internal clock */
+		rate = get_scr(snd_soc_get_rate(rtd->cpu_dai->dai_runtime.pcmrate),
+			rtd->cpu_dai->id);
+		break;
+#ifdef CONFIG_PXA27x
+	case 3: /* audio clock */
+		ssp_mode |= (1 << 30);
+		SSACD_P(rtd->cpu_dai->id) = (0x1 << 3) |
+			pxa27x_set_audio_clk(
+				snd_soc_get_rate(rtd->cpu_dai->dai_runtime.pcmrate), fs);
+	 	break;
+#endif
+	}
+
+	ssp_config(&ssp[rtd->cpu_dai->id], ssp_mode, ssp_setup, psp_mode,
+		SSCR0_SerClkDiv(rate));
+#if 0
+	printk("SSCR0 %x SSCR1 %x SSTO %x SSPSP %x SSSR %x\n",
+		SSCR0_P(rtd->cpu_dai->id+1), SSCR1_P(rtd->cpu_dai->id+1),
+		SSTO_P(rtd->cpu_dai->id+1), SSPSP_P(rtd->cpu_dai->id+1),
+		SSSR_P(rtd->cpu_dai->id+1));
+#endif
+	return 0;
+}
+
+static int pxa2xx_ssp_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_RESUME:
+		ssp_enable(&ssp[rtd->cpu_dai->id]);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSCR1_P(rtd->cpu_dai->id+1) |= SSCR1_TSRE;
+		else
+			SSCR1_P(rtd->cpu_dai->id+1) |= SSCR1_RSRE;
+		SSSR_P(rtd->cpu_dai->id+1) |= SSSR_P(rtd->cpu_dai->id+1);
+		break;
+	case SNDRV_PCM_TRIGGER_START:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSCR1_P(rtd->cpu_dai->id+1) |= SSCR1_TSRE;
+		else
+			SSCR1_P(rtd->cpu_dai->id+1) |= SSCR1_RSRE;
+		ssp_enable(&ssp[rtd->cpu_dai->id]);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSCR1_P(rtd->cpu_dai->id+1) &= ~SSCR1_TSRE;
+		else
+			SSCR1_P(rtd->cpu_dai->id+1) &= ~SSCR1_RSRE;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		ssp_disable(&ssp[rtd->cpu_dai->id]);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSCR1_P(rtd->cpu_dai->id+1) &= ~SSCR1_TSRE;
+		else
+			SSCR1_P(rtd->cpu_dai->id+1) &= ~SSCR1_RSRE;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+#if 0
+	printk("SSCR0 %x SSCR1 %x SSTO %x SSPSP %x SSSR %x\n",
+		SSCR0_P(rtd->cpu_dai->id+1), SSCR1_P(rtd->cpu_dai->id+1),
+		SSTO_P(rtd->cpu_dai->id+1), SSPSP_P(rtd->cpu_dai->id+1),
+		SSSR_P(rtd->cpu_dai->id+1));
+#endif
+	return ret;
+}
+
+struct snd_soc_cpu_dai pxa_ssp_dai[] = {
+	{	.name = "pxa2xx-ssp1",
+		.id = 0,
+		.type = SND_SOC_DAI_PCM,
+		.suspend = pxa2xx_ssp_suspend,
+		.resume = pxa2xx_ssp_resume,
+		.config_sysclk = pxa_ssp_config_sysclk,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.ops = {
+			.startup = pxa2xx_ssp_startup,
+			.shutdown = pxa2xx_ssp_shutdown,
+			.trigger = pxa2xx_ssp_trigger,
+			.hw_params = pxa2xx_ssp_hw_params,},
+		.caps = {
+			.mode = pxa2xx_ssp_modes,
+			.num_modes = ARRAY_SIZE(pxa2xx_ssp_modes),},
+	},
+	{	.name = "pxa2xx-ssp2",
+		.id = 1,
+		.type = SND_SOC_DAI_PCM,
+		.suspend = pxa2xx_ssp_suspend,
+		.resume = pxa2xx_ssp_resume,
+		.config_sysclk = pxa_ssp_config_sysclk,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.ops = {
+			.startup = pxa2xx_ssp_startup,
+			.shutdown = pxa2xx_ssp_shutdown,
+			.trigger = pxa2xx_ssp_trigger,
+			.hw_params = pxa2xx_ssp_hw_params,},
+		.caps = {
+			.mode = pxa2xx_ssp_modes,
+			.num_modes = ARRAY_SIZE(pxa2xx_ssp_modes),},
+	},
+	{	.name = "pxa2xx-ssp3",
+		.id = 2,
+		.type = SND_SOC_DAI_PCM,
+		.suspend = pxa2xx_ssp_suspend,
+		.resume = pxa2xx_ssp_resume,
+		.config_sysclk = pxa_ssp_config_sysclk,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.ops = {
+			.startup = pxa2xx_ssp_startup,
+			.shutdown = pxa2xx_ssp_shutdown,
+			.trigger = pxa2xx_ssp_trigger,
+			.hw_params = pxa2xx_ssp_hw_params,},
+		.caps = {
+			.mode = pxa2xx_ssp_modes,
+			.num_modes = ARRAY_SIZE(pxa2xx_ssp_modes),},
+	},
+};
+
+EXPORT_SYMBOL_GPL(pxa_ssp_dai);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("pxa2xx SSP/PCM SoC Interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/spitz.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/spitz.c
@@ -0,0 +1,374 @@
+/*
+ * spitz.c  --  SoC audio for Sharp SL-Cxx00 models Spitz, Borzoi and Akita
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Nov 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/akita.h>
+#include <asm/arch/spitz.h>
+#include <asm/mach-types.h>
+#include "../codecs/wm8750.h"
+#include "pxa2xx-pcm.h"
+
+#define SPITZ_HP        0
+#define SPITZ_MIC       1
+#define SPITZ_LINE      2
+#define SPITZ_HEADSET   3
+#define SPITZ_HP_OFF    4
+#define SPITZ_SPK_ON    0
+#define SPITZ_SPK_OFF   1
+
+ /* audio clock in Hz - rounded from 12.235MHz */
+#define SPITZ_AUDIO_CLOCK 12288000
+
+static int spitz_jack_func;
+static int spitz_spk_func;
+
+static void spitz_ext_control(struct snd_soc_codec *codec)
+{
+	if (spitz_spk_func == SPITZ_SPK_ON)
+		snd_soc_dapm_set_endpoint(codec, "Ext Spk", 1);
+	else
+		snd_soc_dapm_set_endpoint(codec, "Ext Spk", 0);
+
+	/* set up jack connection */
+	switch (spitz_jack_func) {
+	case SPITZ_HP:
+		/* enable and unmute hp jack, disable mic bias */
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 1);
+		set_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		set_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_MIC:
+		/* enable mic jack and bias, mute hp */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 1);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_LINE:
+		/* enable line jack, disable mic bias and mute hp */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 1);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_HEADSET:
+		/* enable and unmute headset jack enable mic bias, mute L hp */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 1);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 1);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		set_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_HP_OFF:
+
+		/* jack removed, everything off */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	}
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int spitz_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	spitz_ext_control(codec);
+	return 0;
+}
+
+static struct snd_soc_ops spitz_ops = {
+	.startup = spitz_startup,
+};
+
+static int spitz_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = spitz_jack_func;
+	return 0;
+}
+
+static int spitz_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (spitz_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	spitz_jack_func = ucontrol->value.integer.value[0];
+	spitz_ext_control(codec);
+	return 1;
+}
+
+static int spitz_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = spitz_spk_func;
+	return 0;
+}
+
+static int spitz_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (spitz_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	spitz_spk_func = ucontrol->value.integer.value[0];
+	spitz_ext_control(codec);
+	return 1;
+}
+
+static int spitz_mic_bias(struct snd_soc_dapm_widget *w, int event)
+{
+	if (machine_is_borzoi() || machine_is_spitz()) {
+		if (SND_SOC_DAPM_EVENT_ON(event))
+			set_scoop_gpio(&spitzscoop2_device.dev,
+				SPITZ_SCP2_MIC_BIAS);
+		else
+			reset_scoop_gpio(&spitzscoop2_device.dev,
+				SPITZ_SCP2_MIC_BIAS);
+	}
+
+	if (machine_is_akita()) {
+		if (SND_SOC_DAPM_EVENT_ON(event))
+			akita_set_ioexp(&akitaioexp_device.dev,
+				AKITA_IOEXP_MIC_BIAS);
+		else
+			akita_reset_ioexp(&akitaioexp_device.dev,
+				AKITA_IOEXP_MIC_BIAS);
+	}
+	return 0;
+}
+
+/* spitz machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8750_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", spitz_mic_bias),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_LINE("Line Jack", NULL),
+
+	/* headset is a mic and mono headphone */
+	SND_SOC_DAPM_HP("Headset Jack", NULL),
+};
+
+/* Spitz machine audio_map */
+static const char *audio_map[][3] = {
+
+	/* headphone connected to LOUT1, ROUT1 */
+	{"Headphone Jack", NULL, "LOUT1"},
+	{"Headphone Jack", NULL, "ROUT1"},
+
+	/* headset connected to ROUT1 and LINPUT1 with bias (def below) */
+	{"Headset Jack", NULL, "ROUT1"},
+
+	/* ext speaker connected to LOUT2, ROUT2  */
+	{"Ext Spk", NULL , "ROUT2"},
+	{"Ext Spk", NULL , "LOUT2"},
+
+	/* mic is connected to input 1 - with bias */
+	{"LINPUT1", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic Jack"},
+
+	/* line is connected to input 1 - no bias */
+	{"LINPUT1", NULL, "Line Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum spitz_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new wm8750_spitz_controls[] = {
+	SOC_ENUM_EXT("Jack Function", spitz_enum[0], spitz_get_jack,
+		spitz_set_jack),
+	SOC_ENUM_EXT("Speaker Function", spitz_enum[1], spitz_get_spk,
+		spitz_set_spk),
+};
+
+/*
+ * Logic for a wm8750 as connected on a Sharp SL-Cxx00 Device
+ */
+static int spitz_wm8750_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* NC codec pins */
+	snd_soc_dapm_set_endpoint(codec, "RINPUT1", 0);
+	snd_soc_dapm_set_endpoint(codec, "LINPUT2", 0);
+	snd_soc_dapm_set_endpoint(codec, "RINPUT2", 0);
+	snd_soc_dapm_set_endpoint(codec, "LINPUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "RINPUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "OUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "MONO", 0);
+
+	/* Add spitz specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8750_spitz_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8750_spitz_controls[i], codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add spitz specific widgets */
+	for (i = 0; i < ARRAY_SIZE(wm8750_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8750_dapm_widgets[i]);
+	}
+
+	/* Set up spitz specific audio path audio_map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static unsigned int spitz_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	if (info->bclk_master & SND_SOC_DAIFMT_CBS_CFS) {
+		/* pxa2xx is i2s master  */
+		switch (info->rate) {
+		case 11025:
+		case 22050:
+		case 44100:
+		case 88200:
+			/* configure codec digital filters
+			 * for 11.025, 22.05, 44.1, 88.2 */
+			rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+				11289600);
+		break;
+		default:
+			/* configure codec digital filters for all other rates */
+			rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+				SPITZ_AUDIO_CLOCK);
+		break;
+		}
+		/* configure pxa2xx i2s interface clocks as master */
+		return rtd->cpu_dai->config_sysclk(rtd->cpu_dai, info,
+			SPITZ_AUDIO_CLOCK);
+	} else {
+		/* codec is i2s master - only configure codec DAI clock */
+		return rtd->codec_dai->config_sysclk(rtd->codec_dai, info,
+			SPITZ_AUDIO_CLOCK);
+	}
+}
+
+/* spitz digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link spitz_dai = {
+	.name = "wm8750",
+	.stream_name = "WM8750",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8750_dai,
+	.init = spitz_wm8750_init,
+	.config_sysclk = spitz_config_sysclk,
+};
+
+/* spitz audio machine driver */
+static struct snd_soc_machine snd_soc_machine_spitz = {
+	.name = "Spitz",
+	.dai_link = &spitz_dai,
+	.num_links = 1,
+	.ops = &spitz_ops,
+};
+
+/* spitz audio private data */
+static struct wm8750_setup_data spitz_wm8750_setup = {
+	.i2c_address = 0x1b,
+};
+
+/* spitz audio subsystem */
+static struct snd_soc_device spitz_snd_devdata = {
+	.machine = &snd_soc_machine_spitz,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8750,
+	.codec_data = &spitz_wm8750_setup,
+};
+
+static struct platform_device *spitz_snd_device;
+
+static int __init spitz_init(void)
+{
+	int ret;
+
+	if (!(machine_is_spitz() || machine_is_borzoi() || machine_is_akita()))
+		return -ENODEV;
+
+	spitz_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!spitz_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(spitz_snd_device, &spitz_snd_devdata);
+	spitz_snd_devdata.dev = &spitz_snd_device->dev;
+	ret = platform_device_add(spitz_snd_device);
+
+	if (ret)
+		platform_device_put(spitz_snd_device);
+
+	return ret;
+}
+
+static void __exit spitz_exit(void)
+{
+	platform_device_unregister(spitz_snd_device);
+}
+
+module_init(spitz_init);
+module_exit(spitz_exit);
+
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Spitz");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/pxa/tosa.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/pxa/tosa.c
@@ -0,0 +1,287 @@
+/*
+ * tosa.c  --  SoC audio for Tosa
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Nov 2005   Initial version.
+ *
+ * GPIO's
+ *  1 - Jack Insertion
+ *  5 - Hookswitch (headset answer/hang up switch)
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/tmio.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/audio.h>
+#include <asm/arch/tosa.h>
+
+#include "../codecs/wm9712.h"
+#include "pxa2xx-pcm.h"
+
+static struct snd_soc_machine tosa;
+
+#define TOSA_HP        0
+#define TOSA_MIC_INT   1
+#define TOSA_HEADSET   2
+#define TOSA_HP_OFF    3
+#define TOSA_SPK_ON    0
+#define TOSA_SPK_OFF   1
+
+static int tosa_jack_func;
+static int tosa_spk_func;
+
+static void tosa_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0, mic_int = 0, hp = 0, hs = 0;
+
+	/* set up jack connection */
+	switch (tosa_jack_func) {
+	case TOSA_HP:
+		hp = 1;
+		break;
+	case TOSA_MIC_INT:
+		mic_int = 1;
+		break;
+	case TOSA_HEADSET:
+		hs = 1;
+		break;
+	}
+
+	if (tosa_spk_func == TOSA_SPK_ON)
+		spk = 1;
+
+	snd_soc_dapm_set_endpoint(codec, "Speaker", spk);
+	snd_soc_dapm_set_endpoint(codec, "Mic (Internal)", mic_int);
+	snd_soc_dapm_set_endpoint(codec, "Headphone Jack", hp);
+	snd_soc_dapm_set_endpoint(codec, "Headset Jack", hs);
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int tosa_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	tosa_ext_control(codec);
+	return 0;
+}
+
+static struct snd_soc_ops tosa_ops = {
+	.startup = tosa_startup,
+};
+
+static int tosa_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tosa_jack_func;
+	return 0;
+}
+
+static int tosa_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (tosa_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tosa_jack_func = ucontrol->value.integer.value[0];
+	tosa_ext_control(codec);
+	return 1;
+}
+
+static int tosa_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tosa_spk_func;
+	return 0;
+}
+
+static int tosa_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (tosa_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tosa_spk_func = ucontrol->value.integer.value[0];
+	tosa_ext_control(codec);
+	return 1;
+}
+
+/* tosa dapm event handlers */
+static int tosa_hp_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_tc6393_gpio(&tc6393_device.dev,TOSA_TC6393_L_MUTE);
+	else
+		reset_tc6393_gpio(&tc6393_device.dev,TOSA_TC6393_L_MUTE);
+	return 0;
+}
+
+/* tosa machine dapm widgets */
+static const struct snd_soc_dapm_widget tosa_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", tosa_hp_event),
+SND_SOC_DAPM_HP("Headset Jack", NULL),
+SND_SOC_DAPM_MIC("Mic (Internal)", NULL),
+SND_SOC_DAPM_SPK("Speaker", NULL),
+};
+
+/* tosa audio map */
+static const char *audio_map[][3] = {
+
+	/* headphone connected to HPOUTL, HPOUTR */
+	{"Headphone Jack", NULL, "HPOUTL"},
+	{"Headphone Jack", NULL, "HPOUTR"},
+
+	/* ext speaker connected to LOUT2, ROUT2 */
+	{"Speaker", NULL, "LOUT2"},
+	{"Speaker", NULL, "ROUT2"},
+
+	/* internal mic is connected to mic1, mic2 differential - with bias */
+	{"MIC1", NULL, "Mic Bias"},
+	{"MIC2", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic (Internal)"},
+
+	/* headset is connected to HPOUTR, and LINEINR with bias */
+	{"Headset Jack", NULL, "HPOUTR"},
+	{"LINEINR", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Headset Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum tosa_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new tosa_controls[] = {
+	SOC_ENUM_EXT("Jack Function", tosa_enum[0], tosa_get_jack,
+		tosa_set_jack),
+	SOC_ENUM_EXT("Speaker Function", tosa_enum[1], tosa_get_spk,
+		tosa_set_spk),
+};
+
+static int tosa_ac97_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	snd_soc_dapm_set_endpoint(codec, "OUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "MONOOUT", 0);
+
+	/* add tosa specific controls */
+	for (i = 0; i < ARRAY_SIZE(tosa_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&tosa_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* add tosa specific widgets */
+	for (i = 0; i < ARRAY_SIZE(tosa_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &tosa_dapm_widgets[i]);
+	}
+
+	/* set up tosa specific audio path audio_map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static struct snd_soc_dai_link tosa_dai[] = {
+{
+	.name = "AC97",
+	.stream_name = "AC97 HiFi",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_HIFI],
+	.codec_dai = &wm9712_dai[WM9712_DAI_AC97_HIFI],
+	.init = tosa_ac97_init,
+},
+{
+	.name = "AC97 Aux",
+	.stream_name = "AC97 Aux",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_AUX],
+	.codec_dai = &wm9712_dai[WM9712_DAI_AC97_AUX],
+},
+};
+
+static struct snd_soc_machine tosa = {
+	.name = "Tosa",
+	.dai_link = tosa_dai,
+	.num_links = ARRAY_SIZE(tosa_dai),
+	.ops = &tosa_ops,
+};
+
+static struct snd_soc_device tosa_snd_devdata = {
+	.machine = &tosa,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm9712,
+};
+
+static struct platform_device *tosa_snd_device;
+
+static int __init tosa_init(void)
+{
+	int ret;
+
+	if (!machine_is_tosa())
+		return -ENODEV;
+
+	tosa_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!tosa_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(tosa_snd_device, &tosa_snd_devdata);
+	tosa_snd_devdata.dev = &tosa_snd_device->dev;
+	ret = platform_device_add(tosa_snd_device);
+
+	if (ret)
+		platform_device_put(tosa_snd_device);
+
+	return ret;
+}
+
+static void __exit tosa_exit(void)
+{
+	platform_device_unregister(tosa_snd_device);
+}
+
+module_init(tosa_init);
+module_exit(tosa_exit);
+
+/* Module information */
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Tosa");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/soc-dapm.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/soc-dapm.c
@@ -0,0 +1,1327 @@
+/*
+ * soc-dapm.c  --  ALSA SoC Dynamic Audio Power Management
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *    25th Oct 2005   Implemented path power domain.
+ *    18th Dec 2005   Implemented machine and stream level power domain.
+ *
+ *  Features:
+ *    o Changes power status of internal codec blocks depending on the
+ *      dynamic configuration of codec internal audio paths and active
+ *      DAC's/ADC's.
+ *    o Platform power domain - can support external components i.e. amps and
+ *      mic/meadphone insertion events.
+ *    o Automatic Mic Bias support
+ *    o Jack insertion power event initiation - e.g. hp insertion will enable
+ *      sinks, dacs, etc
+ *    o Delayed powerdown of audio susbsytem to reduce pops between a quick
+ *      device reopen.
+ *
+ *  Todo:
+ *    o DAPM power change sequencing - allow for configurable per
+ *      codec sequences.
+ *    o Support for analogue bias optimisation.
+ *    o Support for reduced codec oversampling rates.
+ *    o Support for reduced codec bias currents.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/jiffies.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+/* debug */
+#define DAPM_DEBUG 0
+#if DAPM_DEBUG
+#define dump_dapm(codec, action) dbg_dump_dapm(codec, action)
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dump_dapm(codec, action)
+#define dbg(format, arg...)
+#endif
+
+#define POP_DEBUG 0
+#if POP_DEBUG
+#define POP_TIME 500 /* 500 msecs - change if pop debug is too fast */
+#define pop_wait(time) schedule_timeout_interruptible(msecs_to_jiffies(time))
+#define pop_dbg(format, arg...) printk(format, ## arg); pop_wait(POP_TIME)
+#else
+#define pop_dbg(format, arg...)
+#define pop_wait(time)
+#endif
+
+/* dapm power sequences - make this per codec in the future */
+static int dapm_up_seq[] = {
+	snd_soc_dapm_pre, snd_soc_dapm_micbias, snd_soc_dapm_mic,
+	snd_soc_dapm_mux, snd_soc_dapm_dac, snd_soc_dapm_mixer, snd_soc_dapm_pga,
+	snd_soc_dapm_adc, snd_soc_dapm_hp, snd_soc_dapm_spk, snd_soc_dapm_post
+};
+static int dapm_down_seq[] = {
+	snd_soc_dapm_pre, snd_soc_dapm_adc, snd_soc_dapm_hp, snd_soc_dapm_spk,
+	snd_soc_dapm_pga, snd_soc_dapm_mixer, snd_soc_dapm_dac, snd_soc_dapm_mic,
+	snd_soc_dapm_micbias, snd_soc_dapm_mux, snd_soc_dapm_post
+};
+
+static int dapm_status = 1;
+module_param(dapm_status, int, 0);
+MODULE_PARM_DESC(dapm_status, "enable DPM sysfs entries");
+
+/* create a new dapm widget */
+static struct snd_soc_dapm_widget *dapm_cnew_widget(
+	const struct snd_soc_dapm_widget *_widget)
+{
+	struct snd_soc_dapm_widget* widget;
+	widget = kmalloc(sizeof(struct snd_soc_dapm_widget), GFP_KERNEL);
+	if (!widget)
+		return NULL;
+
+	memcpy(widget, _widget, sizeof(struct snd_soc_dapm_widget));
+	return widget;
+}
+
+/* set up initial codec paths */
+static void dapm_set_path_status(struct snd_soc_dapm_widget *w,
+	struct snd_soc_dapm_path *p, int i)
+{
+	switch (w->id) {
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer: {
+		int val;
+		int reg = w->kcontrols[i].private_value & 0xff;
+		int shift = (w->kcontrols[i].private_value >> 8) & 0x0f;
+		int mask = (w->kcontrols[i].private_value >> 16) & 0xff;
+		int invert = (w->kcontrols[i].private_value >> 24) & 0x01;
+
+		val = snd_soc_read(w->codec, reg);
+		val = (val >> shift) & mask;
+
+		if ((invert && !val) || (!invert && val))
+			p->connect = 1;
+		else
+			p->connect = 0;
+	}
+	break;
+	case snd_soc_dapm_mux: {
+		struct soc_enum *e = (struct soc_enum *)w->kcontrols[i].private_value;
+		int val, item, bitmask;
+
+		for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+		val = snd_soc_read(w->codec, e->reg);
+		item = (val >> e->shift_l) & (bitmask - 1);
+
+		p->connect = 0;
+		for (i = 0; i < e->mask; i++) {
+			if (!(strcmp(p->name, e->texts[i])) && item == i)
+				p->connect = 1;
+		}
+	}
+	break;
+	/* does not effect routing - always connected */
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+		p->connect = 1;
+	break;
+	/* does effect routing - dynamically connected */
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_spk:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+		p->connect = 0;
+	break;
+	}
+}
+
+/* connect mux widget to it's interconnecting audio paths */
+static int dapm_connect_mux(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name,
+	const struct snd_kcontrol_new *kcontrol)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	int i;
+
+	for (i = 0; i < e->mask; i++) {
+		if (!(strcmp(control_name, e->texts[i]))) {
+			list_add(&path->list, &codec->dapm_paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = (char*)e->texts[i];
+			dapm_set_path_status(dest, path, 0);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+/* connect mixer widget to it's interconnecting audio paths */
+static int dapm_connect_mixer(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name)
+{
+	int i;
+
+	/* search for mixer kcontrol */
+	for (i = 0; i < dest->num_kcontrols; i++) {
+		if (!strcmp(control_name, dest->kcontrols[i].name)) {
+			list_add(&path->list, &codec->dapm_paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = dest->kcontrols[i].name;
+			dapm_set_path_status(dest, path, i);
+			return 0;
+		}
+	}
+	return -ENODEV;
+}
+
+/* update dapm codec register bits */
+static int dapm_update_bits(struct snd_soc_dapm_widget *widget)
+{
+	int change, power;
+	unsigned short old, new;
+	struct snd_soc_codec *codec = widget->codec;
+
+	/* check for valid widgets */
+	if (widget->reg < 0 || widget->id == snd_soc_dapm_input ||
+		widget->id == snd_soc_dapm_output ||
+		widget->id == snd_soc_dapm_hp ||
+		widget->id == snd_soc_dapm_mic ||
+		widget->id == snd_soc_dapm_line ||
+		widget->id == snd_soc_dapm_spk)
+		return 0;
+
+	power = widget->power;
+	if (widget->invert)
+		power = (power ? 0:1);
+
+	old = snd_soc_read(codec, widget->reg);
+	new = (old & ~(0x1 << widget->shift)) | (power << widget->shift);
+
+	change = old != new;
+	if (change) {
+		pop_dbg("pop test %s : %s in %d ms\n", widget->name,
+			widget->power ? "on" : "off", POP_TIME);
+		snd_soc_write(codec, widget->reg, new);
+		pop_wait(POP_TIME);
+	}
+	dbg("reg old %x new %x change %d\n", old, new, change);
+	return change;
+}
+
+/* ramps the volume up or down to minimise pops before or after a
+ * DAPM power event */
+static int dapm_set_pga(struct snd_soc_dapm_widget *widget, int power)
+{
+	const struct snd_kcontrol_new *k = widget->kcontrols;
+
+	if (widget->muted && !power)
+		return 0;
+	if (!widget->muted && power)
+		return 0;
+
+	if (widget->num_kcontrols && k) {
+		int reg = k->private_value & 0xff;
+		int shift = (k->private_value >> 8) & 0x0f;
+		int mask = (k->private_value >> 16) & 0xff;
+		int invert = (k->private_value >> 24) & 0x01;
+
+		if (power) {
+			int i;
+			/* power up has happended, increase volume to last level */
+			if (invert) {
+				for (i = mask; i > widget->saved_value; i--)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			} else {
+				for (i = 0; i < widget->saved_value; i++)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			}
+			widget->muted = 0;
+		} else {
+			/* power down is about to occur, decrease volume to mute */
+			int val = snd_soc_read(widget->codec, reg);
+			int i = widget->saved_value = (val >> shift) & mask;
+			if (invert) {
+				for (; i < mask; i++)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			} else {
+				for (; i > 0; i--)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			}
+			widget->muted = 1;
+		}
+	}
+	return 0;
+}
+
+/* create new dapm mixer control */
+static int dapm_new_mixer(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	int i, ret = 0;
+	char name[32];
+	struct snd_soc_dapm_path *path;
+
+	/* add kcontrol */
+	for (i = 0; i < w->num_kcontrols; i++) {
+
+		/* match name */
+		list_for_each_entry(path, &w->sources, list_sink) {
+
+			/* mixer/mux paths name must match control name */
+			if (path->name != (char*)w->kcontrols[i].name)
+				continue;
+
+			/* add dapm control with long name */
+			snprintf(name, 32, "%s %s", w->name, w->kcontrols[i].name);
+			path->long_name = kstrdup (name, GFP_KERNEL);
+			if (path->long_name == NULL)
+				return -ENOMEM;
+
+			path->kcontrol = snd_soc_cnew(&w->kcontrols[i], w,
+				path->long_name);
+			ret = snd_ctl_add(codec->card, path->kcontrol);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to add dapm kcontrol %s\n",
+						path->long_name);
+				kfree(path->long_name);
+				path->long_name = NULL;
+				return ret;
+			}
+		}
+	}
+	return ret;
+}
+
+/* create new dapm mux control */
+static int dapm_new_mux(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_path *path = NULL;
+	struct snd_kcontrol *kcontrol;
+	int ret = 0;
+
+	if (!w->num_kcontrols) {
+		printk(KERN_ERR "asoc: mux %s has no controls\n", w->name);
+		return -EINVAL;
+	}
+
+	kcontrol = snd_soc_cnew(&w->kcontrols[0], w, w->name);
+	ret = snd_ctl_add(codec->card, kcontrol);
+	if (ret < 0)
+		goto err;
+
+	list_for_each_entry(path, &w->sources, list_sink)
+		path->kcontrol = kcontrol;
+
+	return ret;
+
+err:
+	printk(KERN_ERR "asoc: failed to add kcontrol %s\n", w->name);
+	return ret;
+}
+
+/* create new dapm volume control */
+static int dapm_new_pga(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	struct snd_kcontrol *kcontrol;
+	int ret = 0;
+
+	if (!w->num_kcontrols)
+		return -EINVAL;
+
+	kcontrol = snd_soc_cnew(&w->kcontrols[0], w, w->name);
+	ret = snd_ctl_add(codec->card, kcontrol);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to add kcontrol %s\n", w->name);
+		return ret;
+	}
+
+	return ret;
+}
+
+/* reset 'walked' bit for each dapm path */
+static inline void dapm_clear_walk(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_path *p;
+
+	list_for_each_entry(p, &codec->dapm_paths, list)
+		p->walked = 0;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * output widget. Returns number of complete paths.
+ */
+static int is_connected_output_ep(struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	if (widget->id == snd_soc_dapm_adc && widget->active)
+		return 1;
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_output && !widget->ext)
+			return 1;
+
+		/* connected jack or spk ? */
+		if (widget->id == snd_soc_dapm_hp || widget->id == snd_soc_dapm_spk ||
+			widget->id == snd_soc_dapm_line)
+			return 1;
+	}
+
+	list_for_each_entry(path, &widget->sinks, list_source) {
+		if (path->walked)
+			continue;
+
+		if (path->sink && path->connect) {
+			path->walked = 1;
+			con += is_connected_output_ep(path->sink);
+		}
+	}
+
+	return con;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * input widget. Returns number of complete paths.
+ */
+static int is_connected_input_ep(struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	/* active stream ? */
+	if (widget->id == snd_soc_dapm_dac && widget->active)
+		return 1;
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_input && !widget->ext)
+			return 1;
+
+		/* connected VMID/Bias for lower pops */
+		if (widget->id == snd_soc_dapm_vmid)
+			return 1;
+
+		/* connected jack ? */
+		if (widget->id == snd_soc_dapm_mic || widget->id == snd_soc_dapm_line)
+			return 1;
+	}
+
+	list_for_each_entry(path, &widget->sources, list_sink) {
+		if (path->walked)
+			continue;
+
+		if (path->source && path->connect) {
+			path->walked = 1;
+			con += is_connected_input_ep(path->source);
+		}
+	}
+
+	return con;
+}
+
+/*
+ * Scan each dapm widget for complete audio path.
+ * A complete path is a route that has valid endpoints i.e.:-
+ *
+ *  o DAC to output pin.
+ *  o Input Pin to ADC.
+ *  o Input pin to Output pin (bypass, sidetone)
+ *  o DAC to ADC (loopback).
+ */
+int dapm_power_widgets(struct snd_soc_codec *codec, int event)
+{
+	struct snd_soc_dapm_widget *w;
+	int in, out, i, c = 1, *seq = NULL, ret = 0, power_change, power;
+
+	/* do we have a sequenced stream event */
+	if (event == SND_SOC_DAPM_STREAM_START) {
+		c = ARRAY_SIZE(dapm_up_seq);
+		seq = dapm_up_seq;
+	} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+		c = ARRAY_SIZE(dapm_down_seq);
+		seq = dapm_down_seq;
+	}
+
+	for(i = 0; i < c; i++) {
+		list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+			/* is widget in stream order */
+			if (seq && seq[i] && w->id != seq[i])
+				continue;
+
+			/* vmid - no action */
+			if (w->id == snd_soc_dapm_vmid)
+				continue;
+
+			/* active ADC */
+			if (w->id == snd_soc_dapm_adc && w->active) {
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = (in != 0) ? 1 : 0;
+				dapm_update_bits(w);
+				continue;
+			}
+
+			/* active DAC */
+			if (w->id == snd_soc_dapm_dac && w->active) {
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = (out != 0) ? 1 : 0;
+				dapm_update_bits(w);
+				continue;
+			}
+
+			/* programmable gain/attenuation */
+			if (w->id == snd_soc_dapm_pga) {
+				int on;
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = on = (out != 0 && in != 0) ? 1 : 0;
+
+				if (!on)
+					dapm_set_pga(w, on); /* lower volume to reduce pops */
+				dapm_update_bits(w);
+				if (on)
+					dapm_set_pga(w, on); /* restore volume from zero */
+
+				continue;
+			}
+
+			/* pre and post event widgets */
+			if (w->id == snd_soc_dapm_pre) {
+				if (!w->event)
+					continue;
+
+				if (event == SND_SOC_DAPM_STREAM_START) {
+					ret = w->event(w, SND_SOC_DAPM_PRE_PMU);
+					if (ret < 0)
+						return ret;
+				} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+					ret = w->event(w, SND_SOC_DAPM_PRE_PMD);
+					if (ret < 0)
+						return ret;
+				}
+				continue;
+			}
+			if (w->id == snd_soc_dapm_post) {
+				if (!w->event)
+					continue;
+
+				if (event == SND_SOC_DAPM_STREAM_START) {
+					ret = w->event(w, SND_SOC_DAPM_POST_PMU);
+					if (ret < 0)
+						return ret;
+				} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+					ret = w->event(w, SND_SOC_DAPM_POST_PMD);
+					if (ret < 0)
+						return ret;
+				}
+				continue;
+			}
+
+			/* all other widgets */
+			in = is_connected_input_ep(w);
+			dapm_clear_walk(w->codec);
+			out = is_connected_output_ep(w);
+			dapm_clear_walk(w->codec);
+			power = (out != 0 && in != 0) ? 1 : 0;
+			power_change = (w->power == power) ? 0: 1;
+			w->power = power;
+
+			/* call any power change event handlers */
+			if (power_change) {
+				if (w->event) {
+					dbg("power %s event for %s flags %x\n",
+						w->power ? "on" : "off", w->name, w->event_flags);
+					if (power) {
+						/* power up event */
+						if (w->event_flags & SND_SOC_DAPM_PRE_PMU) {
+							ret = w->event(w, SND_SOC_DAPM_PRE_PMU);
+							if (ret < 0)
+								return ret;
+						}
+						dapm_update_bits(w);
+						if (w->event_flags & SND_SOC_DAPM_POST_PMU){
+							ret = w->event(w, SND_SOC_DAPM_POST_PMU);
+							if (ret < 0)
+								return ret;
+						}
+					} else {
+						/* power down event */
+						if (w->event_flags & SND_SOC_DAPM_PRE_PMD) {
+							ret = w->event(w, SND_SOC_DAPM_PRE_PMD);
+							if (ret < 0)
+								return ret;
+						}
+						dapm_update_bits(w);
+						if (w->event_flags & SND_SOC_DAPM_POST_PMD) {
+							ret = w->event(w, SND_SOC_DAPM_POST_PMD);
+							if (ret < 0)
+								return ret;
+						}
+					}
+				} else
+					/* no event handler */
+					dapm_update_bits(w);
+			}
+		}
+	}
+
+	return ret;
+}
+
+#if DAPM_DEBUG
+static void dbg_dump_dapm(struct snd_soc_codec* codec, const char *action)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_path *p = NULL;
+	int in, out;
+
+	printk("DAPM %s %s\n", codec->name, action);
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		/* only display widgets that effect routing */
+		switch (w->id) {
+		case snd_soc_dapm_pre:
+		case snd_soc_dapm_post:
+		case snd_soc_dapm_vmid:
+			continue;
+		case snd_soc_dapm_mux:
+		case snd_soc_dapm_output:
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_mixer:
+			if (w->name) {
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				printk("%s: %s  in %d out %d\n", w->name,
+					w->power ? "On":"Off",in, out);
+
+				list_for_each_entry(p, &w->sources, list_sink) {
+					if (p->connect)
+						printk(" in  %s %s\n", p->name ? p->name : "static",
+							p->source->name);
+				}
+				list_for_each_entry(p, &w->sinks, list_source) {
+					p = list_entry(lp, struct snd_soc_dapm_path, list_source);
+					if (p->connect)
+						printk(" out %s %s\n", p->name ? p->name : "static",
+							p->sink->name);
+				}
+			}
+		break;
+		}
+	}
+}
+#endif
+
+/* test and update the power status of a mux widget */
+int dapm_mux_update_power(struct snd_soc_dapm_widget *widget,
+	struct snd_kcontrol *kcontrol, int mask, int val, struct soc_enum* e)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	if (widget->id != snd_soc_dapm_mux)
+		return -ENODEV;
+
+	if (!snd_soc_test_bits(widget->codec, e->reg, mask, val))
+		return 0;
+
+	/* find dapm widget path assoc with kcontrol */
+	list_for_each_entry(path, &widget->codec->dapm_paths, list) {
+		if (path->kcontrol != kcontrol)
+			continue;
+
+		if (!path->name || ! e->texts[val])
+			continue;
+
+		found = 1;
+		/* we now need to match the string in the enum to the path */
+		if (!(strcmp(path->name, e->texts[val])))
+			path->connect = 1; /* new connection */
+		else
+			path->connect = 0; /* old connection must be powered down */
+	}
+
+	if (found)
+		dapm_power_widgets(widget->codec, SND_SOC_DAPM_STREAM_NOP);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dapm_mux_update_power);
+
+/* test and update the power status of a mixer widget */
+int dapm_mixer_update_power(struct snd_soc_dapm_widget *widget,
+	struct snd_kcontrol *kcontrol, int reg, int val_mask, int val, int invert)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	if (widget->id != snd_soc_dapm_mixer)
+		return -ENODEV;
+
+	if (!snd_soc_test_bits(widget->codec, reg, val_mask, val))
+		return 0;
+
+	/* find dapm widget path assoc with kcontrol */
+	list_for_each_entry(path, &widget->codec->dapm_paths, list) {
+		if (path->kcontrol != kcontrol)
+			continue;
+
+		/* found, now check type */
+		found = 1;
+		if (val)
+			/* new connection */
+			path->connect = invert ? 0:1;
+		else
+			/* old connection must be powered down */
+			path->connect = invert ? 1:0;
+		break;
+	}
+
+	if (found)
+		dapm_power_widgets(widget->codec, SND_SOC_DAPM_STREAM_NOP);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dapm_mixer_update_power);
+
+/* show dapm widget status in sys fs */
+static ssize_t dapm_widget_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = devdata->codec;
+	struct snd_soc_dapm_widget *w;
+	int count = 0;
+	char *state = "not set";
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		/* only display widgets that burnm power */
+		switch (w->id) {
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_mixer:
+			if (w->name)
+				count += sprintf(buf + count, "%s: %s\n",
+					w->name, w->power ? "On":"Off");
+		break;
+		default:
+		break;
+		}
+	}
+
+	switch(codec->dapm_state){
+	case SNDRV_CTL_POWER_D0:
+		state = "D0";
+		break;
+	case SNDRV_CTL_POWER_D1:
+		state = "D1";
+		break;
+	case SNDRV_CTL_POWER_D2:
+		state = "D2";
+		break;
+	case SNDRV_CTL_POWER_D3hot:
+		state = "D3hot";
+		break;
+	case SNDRV_CTL_POWER_D3cold:
+		state = "D3cold";
+		break;
+	}
+	count += sprintf(buf + count, "PM State: %s\n", state);
+
+	return count;
+}
+
+static DEVICE_ATTR(dapm_widget, 0444, dapm_widget_show, NULL);
+
+int snd_soc_dapm_sys_add(struct device *dev)
+{
+	int ret = 0;
+
+	if (dapm_status)
+		ret = device_create_file(dev, &dev_attr_dapm_widget);
+
+	return ret;
+}
+
+static void snd_soc_dapm_sys_remove(struct device *dev)
+{
+	if (dapm_status)
+		device_remove_file(dev, &dev_attr_dapm_widget);
+}
+
+/* free all dapm widgets and resources */
+void dapm_free_widgets(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_widget *w, *next_w;
+	struct snd_soc_dapm_path *p, *next_p;
+
+	list_for_each_entry_safe(w, next_w, &codec->dapm_widgets, list) {
+		list_del(&w->list);
+		kfree(w);
+	}
+
+	list_for_each_entry_safe(p, next_p, &codec->dapm_paths, list) {
+		list_del(&p->list);
+		kfree(p->long_name);
+		kfree(p);
+	}
+}
+
+/**
+ * snd_soc_dapm_sync_endpoints - scan and power dapm paths
+ * @codec: audio codec
+ *
+ * Walks all dapm audio paths and powers widgets according to their
+ * stream or path usage.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec)
+{
+	return dapm_power_widgets(codec, SND_SOC_DAPM_STREAM_NOP);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_sync_endpoints);
+
+/**
+ * snd_soc_dapm_connect_input - connect dapm widgets
+ * @codec: audio codec
+ * @sink: name of target widget
+ * @control: mixer control name
+ * @source: name of source name
+ *
+ * Connects 2 dapm widgets together via a named audio path. The sink is
+ * the widget receiving the audio signal, whilst the source is the sender
+ * of the audio signal.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_connect_input(struct snd_soc_codec *codec, const char *sink,
+	const char * control, const char *source)
+{
+	struct snd_soc_dapm_path *path;
+	struct snd_soc_dapm_widget *wsource = NULL, *wsink = NULL, *w;
+	int ret = 0;
+
+	/* find src and dest widgets */
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		if (!wsink && !(strcmp(w->name, sink))) {
+			wsink = w;
+			continue;
+		}
+		if (!wsource && !(strcmp(w->name, source))) {
+			wsource = w;
+		}
+	}
+
+	if (wsource == NULL || wsink == NULL)
+		return -ENODEV;
+
+	path = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);
+	if (!path)
+		return -ENOMEM;
+
+	path->source = wsource;
+	path->sink = wsink;
+	INIT_LIST_HEAD(&path->list);
+	INIT_LIST_HEAD(&path->list_source);
+	INIT_LIST_HEAD(&path->list_sink);
+
+	/* check for external widgets */
+	if (wsink->id == snd_soc_dapm_input) {
+		if (wsource->id == snd_soc_dapm_micbias ||
+			wsource->id == snd_soc_dapm_mic ||
+			wsink->id == snd_soc_dapm_line)
+			wsink->ext = 1;
+	}
+	if (wsource->id == snd_soc_dapm_output) {
+		if (wsink->id == snd_soc_dapm_spk ||
+			wsink->id == snd_soc_dapm_hp ||
+			wsink->id == snd_soc_dapm_line)
+			wsource->ext = 1;
+	}
+
+	/* connect static paths */
+	if (control == NULL) {
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	}
+
+	/* connect dynamic paths */
+	switch(wsink->id) {
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	case snd_soc_dapm_mux:
+		ret = dapm_connect_mux(codec, wsource, wsink, path, control,
+			&wsink->kcontrols[0]);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+		ret = dapm_connect_mixer(codec, wsource, wsink, path, control);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_spk:
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 0;
+		return 0;
+	}
+	return 0;
+
+err:
+	printk(KERN_WARNING "asoc: no dapm match for %s --> %s --> %s\n", source,
+		control, sink);
+	kfree(path);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_connect_input);
+
+/**
+ * snd_soc_dapm_new_widgets - add new dapm widgets
+ * @codec: audio codec
+ *
+ * Checks the codec for any new dapm widgets and creates them if found.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_new_widgets(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_widget *w;
+
+	mutex_lock(&codec->mutex);
+	list_for_each_entry(w, &codec->dapm_widgets, list)
+	{
+		if (w->new)
+			continue;
+
+		switch(w->id) {
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_mixer:
+			dapm_new_mixer(codec, w);
+			break;
+		case snd_soc_dapm_mux:
+			dapm_new_mux(codec, w);
+			break;
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_pga:
+			dapm_new_pga(codec, w);
+			break;
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_output:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_vmid:
+		case snd_soc_dapm_pre:
+		case snd_soc_dapm_post:
+			break;
+		}
+		w->new = 1;
+	}
+
+	dapm_power_widgets(codec, SND_SOC_DAPM_STREAM_NOP);
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_widgets);
+
+/**
+ * snd_soc_dapm_get_volsw - dapm mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+
+	/* return the saved value if we are powered down */
+	if (widget->id == snd_soc_dapm_pga && !widget->power) {
+		ucontrol->value.integer.value[0] = widget->saved_value;
+		return 0;
+	}
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(widget->codec, reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(widget->codec, reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_volsw);
+
+/**
+ * snd_soc_dapm_put_volsw - dapm mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	unsigned short val, val2, val_mask;
+	int ret;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+
+	mutex_lock(&widget->codec->mutex);
+	widget->value = val;
+
+	/* save volume value if the widget is powered down */
+	if (widget->id == snd_soc_dapm_pga && !widget->power) {
+		widget->saved_value = val;
+		mutex_unlock(&widget->codec->mutex);
+		return 1;
+	}
+
+	dapm_mixer_update_power(widget, kcontrol, reg, val_mask, val, invert);
+	if (widget->event) {
+		if (widget->event_flags & SND_SOC_DAPM_PRE_REG) {
+			ret = widget->event(widget, SND_SOC_DAPM_PRE_REG);
+			if (ret < 0)
+				goto out;
+		}
+		ret = snd_soc_update_bits(widget->codec, reg, val_mask, val);
+		if (widget->event_flags & SND_SOC_DAPM_POST_REG)
+			ret = widget->event(widget, SND_SOC_DAPM_POST_REG);
+	} else
+		ret = snd_soc_update_bits(widget->codec, reg, val_mask, val);
+
+out:
+	mutex_unlock(&widget->codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_volsw);
+
+/**
+ * snd_soc_dapm_get_enum_double - dapm enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(widget->codec, e->reg);
+	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_enum_double);
+
+/**
+ * snd_soc_dapm_put_enum_double - dapm enumerated double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, mux;
+	unsigned short mask, bitmask;
+	int ret = 0;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	mux = ucontrol->value.enumerated.item[0];
+	val = mux << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	mutex_lock(&widget->codec->mutex);
+	widget->value = val;
+	dapm_mux_update_power(widget, kcontrol, mask, mux, e);
+	if (widget->event) {
+		if (widget->event_flags & SND_SOC_DAPM_PRE_REG) {
+			ret = widget->event(widget, SND_SOC_DAPM_PRE_REG);
+			if (ret < 0)
+				goto out;
+		}
+		ret = snd_soc_update_bits(widget->codec, e->reg, mask, val);
+		if (widget->event_flags & SND_SOC_DAPM_POST_REG)
+			ret = widget->event(widget, SND_SOC_DAPM_POST_REG);
+	} else
+		ret = snd_soc_update_bits(widget->codec, e->reg, mask, val);
+
+out:
+	mutex_unlock(&widget->codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_enum_double);
+
+/**
+ * snd_soc_dapm_new_control - create new dapm control
+ * @codec: audio codec
+ * @widget: widget template
+ *
+ * Creates a new dapm control based upon the template.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_new_control(struct snd_soc_codec *codec,
+	const struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_widget *w;
+
+	if ((w = dapm_cnew_widget(widget)) == NULL)
+		return -ENOMEM;
+
+	w->codec = codec;
+	INIT_LIST_HEAD(&w->sources);
+	INIT_LIST_HEAD(&w->sinks);
+	INIT_LIST_HEAD(&w->list);
+	list_add(&w->list, &codec->dapm_widgets);
+
+	/* machine layer set ups unconnected pins and insertions */
+	w->connected = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_control);
+
+/**
+ * snd_soc_dapm_stream_event - send a stream event to the dapm core
+ * @codec: audio codec
+ * @stream: stream name
+ * @event: stream event
+ *
+ * Sends a stream event to the dapm core. The core then makes any
+ * necessary widget power changes.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_stream_event(struct snd_soc_codec *codec,
+	char *stream, int event)
+{
+	struct snd_soc_dapm_widget *w;
+
+	mutex_lock(&codec->mutex);
+	list_for_each_entry(w, &codec->dapm_widgets, list)
+	{
+		if (!w->sname)
+			continue;
+		dbg("widget %s\n %s stream %s event %d\n", w->name, w->sname,
+			stream, event);
+		if (strstr(w->sname, stream)) {
+			switch(event) {
+			case SND_SOC_DAPM_STREAM_START:
+				w->active = 1;
+				break;
+			case SND_SOC_DAPM_STREAM_STOP:
+				w->active = 0;
+				break;
+			case SND_SOC_DAPM_STREAM_SUSPEND:
+				if (w->active)
+					w->suspend = 1;
+				w->active = 0;
+				break;
+			case SND_SOC_DAPM_STREAM_RESUME:
+				if (w->suspend) {
+					w->active = 1;
+					w->suspend = 0;
+				}
+				break;
+			case SND_SOC_DAPM_STREAM_PAUSE_PUSH:
+				break;
+			case SND_SOC_DAPM_STREAM_PAUSE_RELEASE:
+				break;
+			}
+		}
+	}
+	mutex_unlock(&codec->mutex);
+
+	dapm_power_widgets(codec, event);
+	dump_dapm(codec, __FUNCTION__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_stream_event);
+
+/**
+ * snd_soc_dapm_set_endpoint - set audio endpoint status
+ * @codec: audio codec
+ * @endpoint: audio signal endpoint (or start point)
+ * @status: point status
+ *
+ * Set audio endpoint status - connected or disconnected.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+	char *endpoint, int status)
+{
+	struct snd_soc_dapm_widget *w;
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+		if (!strcmp(w->name, endpoint)) {
+			w->connected = status;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_set_endpoint);
+
+/**
+ * snd_soc_dapm_free - free dapm resources
+ * @socdev: SoC device
+ *
+ * Free all dapm widgets and resources.
+ */
+void snd_soc_dapm_free(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+
+	snd_soc_dapm_sys_remove(socdev->dev);
+	dapm_free_widgets(codec);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_free);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("Dynamic Audio Power Management core for ALSA SoC");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/soc-core.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/soc-core.c
@@ -0,0 +1,2063 @@
+/*
+ * soc-core.c  --  ALSA SoC Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *    25th Oct 2005   Working Codec, Interface and Platform registration.
+ *
+ *  TODO:
+ *   o Add hw rules to enforce rates, etc.
+ *   o More testing with other codecs/machines.
+ *   o Add more codecs and platforms to ensure good API coverage.
+ *   o Support TDM on PCM and I2S
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+/* debug */
+#define SOC_DEBUG 1
+#if SOC_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+/* debug DAI capabilities matching */
+#define SOC_DEBUG_DAI 1
+#if SOC_DEBUG_DAI
+#define dbgc(format, arg...) printk(format, ## arg)
+#else
+#define dbgc(format, arg...)
+#endif
+
+#define CODEC_CPU(codec, cpu)	((codec << 4) | cpu)
+
+static DEFINE_MUTEX(pcm_mutex);
+static DEFINE_MUTEX(io_mutex);
+static struct workqueue_struct *soc_workq;
+static struct work_struct soc_stream_work;
+static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
+
+/* supported sample rates */
+/* ATTENTION: these values depend on the definition in pcm.h! */
+static const unsigned int rates[] = {
+	5512, 8000, 11025, 16000, 22050, 32000, 44100,
+	48000, 64000, 88200, 96000, 176400, 192000
+};
+
+/*
+ * This is a timeout to do a DAPM powerdown after a stream is closed().
+ * It can be used to eliminate pops between different playback streams, e.g.
+ * between two audio tracks.
+ */
+static int pmdown_time = 5000;
+module_param(pmdown_time, int, 0);
+MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+/* unregister ac97 codec */
+static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
+{
+	if (codec->ac97->dev.bus)
+		device_unregister(&codec->ac97->dev);
+	return 0;
+}
+
+/* stop no dev release warning */
+static void soc_ac97_device_release(struct device *dev){}
+
+/* register ac97 codec to bus */
+static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+{
+	int err;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = NULL;
+	codec->ac97->dev.release = soc_ac97_device_release;
+
+	snprintf(codec->ac97->dev.bus_id, BUS_ID_SIZE, "%d-%d:%s",
+		 codec->card->number, 0, codec->name);
+	err = device_register(&codec->ac97->dev);
+	if (err < 0) {
+		snd_printk(KERN_ERR "Can't register ac97 bus\n");
+		codec->ac97->dev.bus = NULL;
+		return err;
+	}
+	return 0;
+}
+#endif
+
+static inline const char* get_dai_name(int type)
+{
+	switch(type) {
+	case SND_SOC_DAI_AC97:
+		return "AC97";
+	case SND_SOC_DAI_I2S:
+		return "I2S";
+	case SND_SOC_DAI_PCM:
+		return "PCM";
+	}
+	return NULL;
+}
+
+/* get rate format from rate */
+static inline int soc_get_rate_format(int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rates); i++) {
+		if (rates[i] == rate)
+			return 1 << i;
+	}
+	return 0;
+}
+
+/* gets the audio system mclk/sysclk for the given parameters */
+static unsigned inline int soc_get_mclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_machine *machine = socdev->machine;
+	int i;
+
+	/* find the matching machine config and get it's mclk for the given
+	 * sample rate and hardware format */
+	for(i = 0; i < machine->num_links; i++) {
+		if (machine->dai_link[i].cpu_dai == rtd->cpu_dai &&
+			machine->dai_link[i].config_sysclk)
+			return machine->dai_link[i].config_sysclk(rtd, info);
+	}
+	return 0;
+}
+
+/* changes a bitclk multiplier mask to a divider mask */
+static u64 soc_bfs_rcw_to_div(u64 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	int i, j;
+	u64 bfs_ = 0;
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("rcw --> div min bclk %d with mclk %d\n", min, mclk);
+
+	for (i = 0; i < 64; i++) {
+		if ((bfs >> i) & 0x1) {
+			j = min * (i + 1);
+			bfs_ |= SND_SOC_FSBD(mclk/j);
+			dbgc("rcw --> div support mult %d\n",
+				SND_SOC_FSBD_REAL(1<<i));
+		}
+	}
+
+	return bfs_;
+}
+
+/* changes a bitclk divider mask to a multiplier mask */
+static u64 soc_bfs_div_to_rcw(u64 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	int i, j;
+	u64 bfs_ = 0;
+
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("div to rcw min bclk %d with mclk %d\n", min, mclk);
+
+	for (i = 0; i < 64; i++) {
+		if ((bfs >> i) & 0x1) {
+			j = mclk / (i + 1);
+			if (j >= min) {
+				bfs_ |= SND_SOC_FSBW(j/min);
+				dbgc("div --> rcw support div %d\n",
+					SND_SOC_FSBW_REAL(1<<i));
+			}
+		}
+	}
+
+	return bfs_;
+}
+
+/* changes a constant bitclk to a multiplier mask */
+static u64 soc_bfs_rate_to_rcw(u64 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	unsigned int bfs_ = rate * bfs;
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("rate --> rcw min bclk %d with mclk %d\n", min, mclk);
+
+	if (bfs_ < min)
+		return 0;
+	else {
+		bfs_ = SND_SOC_FSBW(bfs_/min);
+		dbgc("rate --> rcw support div %d\n", SND_SOC_FSBW_REAL(bfs_));
+		return bfs_;
+	}
+}
+
+/* changes a bitclk multiplier mask to a divider mask */
+static u64 soc_bfs_rate_to_div(u64 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	unsigned int bfs_ = rate * bfs;
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("rate --> div min bclk %d with mclk %d\n", min, mclk);
+
+	if (bfs_ < min)
+		return 0;
+	else {
+		bfs_ = SND_SOC_FSBW(mclk/bfs_);
+		dbgc("rate --> div support div %d\n", SND_SOC_FSBD_REAL(bfs_));
+		return bfs_;
+	}
+}
+
+/* Matches codec DAI and SoC CPU DAI hardware parameters */
+static int soc_hw_match_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_mode *codec_dai_mode = NULL;
+	struct snd_soc_dai_mode *cpu_dai_mode = NULL;
+	struct snd_soc_clock_info clk_info;
+	unsigned int fs, mclk, rate = params_rate(params),
+		chn, j, k, cpu_bclk, codec_bclk, pcmrate;
+	u16 fmt = 0;
+	u64 codec_bfs, cpu_bfs;
+
+	dbg("asoc: match version %s\n", SND_SOC_VERSION);
+	clk_info.rate = rate;
+	pcmrate = soc_get_rate_format(rate);
+
+	/* try and find a match from the codec and cpu DAI capabilities */
+	for (j = 0; j < rtd->codec_dai->caps.num_modes; j++) {
+		for (k = 0; k < rtd->cpu_dai->caps.num_modes; k++) {
+			codec_dai_mode = &rtd->codec_dai->caps.mode[j];
+			cpu_dai_mode = &rtd->cpu_dai->caps.mode[k];
+
+			if (!(codec_dai_mode->pcmrate & cpu_dai_mode->pcmrate &
+					pcmrate)) {
+				dbgc("asoc: DAI[%d:%d] failed to match rate\n", j, k);
+				continue;
+			}
+
+			fmt = codec_dai_mode->fmt & cpu_dai_mode->fmt;
+			if (!(fmt & SND_SOC_DAIFMT_FORMAT_MASK)) {
+				dbgc("asoc: DAI[%d:%d] failed to match format\n", j, k);
+				continue;
+			}
+
+			if (!(fmt & SND_SOC_DAIFMT_CLOCK_MASK)) {
+				dbgc("asoc: DAI[%d:%d] failed to match clock masters\n",
+					 j, k);
+				continue;
+			}
+
+			if (!(fmt & SND_SOC_DAIFMT_INV_MASK)) {
+				dbgc("asoc: DAI[%d:%d] failed to match invert\n", j, k);
+				continue;
+			}
+
+			if (!(codec_dai_mode->pcmfmt & cpu_dai_mode->pcmfmt)) {
+				dbgc("asoc: DAI[%d:%d] failed to match pcm format\n", j, k);
+				continue;
+			}
+
+			if (!(codec_dai_mode->pcmdir & cpu_dai_mode->pcmdir)) {
+				dbgc("asoc: DAI[%d:%d] failed to match direction\n", j, k);
+				continue;
+			}
+
+			/* todo - still need to add tdm selection */
+			rtd->cpu_dai->dai_runtime.fmt =
+			rtd->codec_dai->dai_runtime.fmt =
+				1 << (ffs(fmt & SND_SOC_DAIFMT_FORMAT_MASK) -1) |
+				1 << (ffs(fmt & SND_SOC_DAIFMT_CLOCK_MASK) - 1) |
+				1 << (ffs(fmt & SND_SOC_DAIFMT_INV_MASK) - 1);
+			clk_info.bclk_master =
+				rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK;
+
+			/* make sure the ratio between rate and master
+			 * clock is acceptable*/
+			fs = (cpu_dai_mode->fs & codec_dai_mode->fs);
+			if (fs == 0) {
+				dbgc("asoc: DAI[%d:%d] failed to match FS\n", j, k);
+				continue;
+			}
+			clk_info.fs = rtd->cpu_dai->dai_runtime.fs =
+				rtd->codec_dai->dai_runtime.fs = fs;
+
+			/* calculate audio system clocking using slowest clocks possible*/
+			mclk = soc_get_mclk(rtd, &clk_info);
+			if (mclk == 0) {
+				dbgc("asoc: DAI[%d:%d] configuration not clockable\n", j, k);
+				dbgc("asoc: rate %d fs %d master %x\n", rate, fs,
+					clk_info.bclk_master);
+				continue;
+			}
+
+			/* calculate word size (per channel) and frame size */
+			rtd->codec_dai->dai_runtime.pcmfmt =
+				rtd->cpu_dai->dai_runtime.pcmfmt =
+				1 << params_format(params);
+
+			chn = params_channels(params);
+			/* i2s always has left and right */
+			if (params_channels(params) == 1 &&
+				rtd->cpu_dai->dai_runtime.fmt & (SND_SOC_DAIFMT_I2S |
+					SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_LEFT_J))
+				chn <<= 1;
+
+			/* Calculate bfs - the ratio between bitclock and the sample rate
+			 * We must take into consideration the dividers and multipliers
+			 * used in the codec and cpu DAI modes. We always choose the
+			 * lowest possible clocks to reduce power.
+			 */
+			switch (CODEC_CPU(codec_dai_mode->flags, cpu_dai_mode->flags)) {
+			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_DIV):
+				/* cpu & codec bfs dividers */
+				rtd->cpu_dai->dai_runtime.bfs =
+					rtd->codec_dai->dai_runtime.bfs =
+					1 << (fls(codec_dai_mode->bfs & cpu_dai_mode->bfs) - 1);
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_RCW):
+				/* normalise bfs codec divider & cpu rcw mult */
+				codec_bfs = soc_bfs_div_to_rcw(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->cpu_dai->dai_runtime.bfs =
+					1 << (ffs(codec_bfs & cpu_dai_mode->bfs) - 1);
+				cpu_bfs = soc_bfs_rcw_to_div(cpu_dai_mode->bfs, rate, mclk,
+						rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->codec_dai->dai_runtime.bfs =
+					1 << (fls(codec_dai_mode->bfs & cpu_bfs) - 1);
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_DIV):
+				/* normalise bfs codec rcw mult & cpu divider */
+				codec_bfs = soc_bfs_rcw_to_div(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->cpu_dai->dai_runtime.bfs =
+					1 << (fls(codec_bfs & cpu_dai_mode->bfs) -1);
+				cpu_bfs = soc_bfs_div_to_rcw(cpu_dai_mode->bfs, rate, mclk,
+						rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->codec_dai->dai_runtime.bfs =
+					1 << (ffs(codec_dai_mode->bfs & cpu_bfs) -1);
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_RCW):
+				/* codec & cpu bfs rate rcw multipliers */
+				rtd->cpu_dai->dai_runtime.bfs =
+					rtd->codec_dai->dai_runtime.bfs =
+					1 << (ffs(codec_dai_mode->bfs & cpu_dai_mode->bfs) -1);
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_RATE):
+				/* normalise cpu bfs rate const multiplier & codec div */
+				cpu_bfs = soc_bfs_rate_to_div(cpu_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(codec_dai_mode->bfs & cpu_bfs) {
+					rtd->codec_dai->dai_runtime.bfs = cpu_bfs;
+					rtd->cpu_dai->dai_runtime.bfs = cpu_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_RATE):
+				/* normalise cpu bfs rate const multiplier & codec rcw mult */
+				cpu_bfs = soc_bfs_rate_to_rcw(cpu_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(codec_dai_mode->bfs & cpu_bfs) {
+					rtd->codec_dai->dai_runtime.bfs = cpu_bfs;
+					rtd->cpu_dai->dai_runtime.bfs = cpu_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_RCW):
+				/* normalise cpu bfs rate rcw multiplier & codec const mult */
+				codec_bfs = soc_bfs_rate_to_rcw(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(cpu_dai_mode->bfs & codec_bfs) {
+					rtd->cpu_dai->dai_runtime.bfs = codec_bfs;
+					rtd->codec_dai->dai_runtime.bfs = codec_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_DIV):
+				/* normalise cpu bfs div & codec const mult */
+				codec_bfs = soc_bfs_rate_to_div(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(codec_dai_mode->bfs & codec_bfs) {
+					rtd->cpu_dai->dai_runtime.bfs = codec_bfs;
+					rtd->codec_dai->dai_runtime.bfs = codec_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_RATE):
+				/* cpu & codec constant mult */
+				if(codec_dai_mode->bfs == cpu_dai_mode->bfs)
+					rtd->cpu_dai->dai_runtime.bfs =
+						rtd->codec_dai->dai_runtime.bfs =
+						codec_dai_mode->bfs;
+				else
+					rtd->cpu_dai->dai_runtime.bfs =
+						rtd->codec_dai->dai_runtime.bfs = 0;
+				break;
+			default:
+				if(codec_dai_mode->flags == 0)
+					printk(KERN_ERR "asoc: error missing codec DAI flags\n");
+				else
+					printk(KERN_ERR "asoc: error missing CPU DAI flags\n");
+				break;
+			}
+
+			/* make sure the bit clock speed is acceptable */
+			if (!rtd->cpu_dai->dai_runtime.bfs ||
+				!rtd->codec_dai->dai_runtime.bfs) {
+				dbgc("asoc: DAI[%d:%d] failed to match BFS\n", j, k);
+				dbgc("asoc: cpu_dai %llu codec %llu\n",
+					rtd->cpu_dai->dai_runtime.bfs,
+					rtd->codec_dai->dai_runtime.bfs);
+				dbgc("asoc: mclk %d hwfmt %x\n", mclk, fmt);
+				continue;
+			}
+
+			goto found;
+		}
+	}
+	printk(KERN_ERR "asoc: no matching DAI found between codec and CPU\n");
+	return -EINVAL;
+
+found:
+	/* we have matching DAI's, so complete the runtime info */
+	rtd->codec_dai->dai_runtime.pcmrate =
+		rtd->cpu_dai->dai_runtime.pcmrate =
+		soc_get_rate_format(rate);
+
+	rtd->codec_dai->dai_runtime.priv = codec_dai_mode->priv;
+	rtd->cpu_dai->dai_runtime.priv = cpu_dai_mode->priv;
+	rtd->codec_dai->dai_runtime.flags = codec_dai_mode->flags;
+	rtd->cpu_dai->dai_runtime.flags = cpu_dai_mode->flags;
+
+	/* for debug atm */
+	dbg("asoc: DAI[%d:%d] Match OK\n", j, k);
+	if (rtd->codec_dai->dai_runtime.flags == SND_SOC_DAI_BFS_DIV) {
+		codec_bclk = (rtd->codec_dai->dai_runtime.fs * params_rate(params)) /
+			SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+		dbg("asoc: codec fs %d mclk %d bfs div %d bclk %d\n",
+			rtd->codec_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs),	codec_bclk);
+	} else if(rtd->codec_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RATE) {
+		codec_bclk = params_rate(params) * rtd->codec_dai->dai_runtime.bfs;
+		dbg("asoc: codec fs %d mclk %d bfs rate mult %llu bclk %d\n",
+			rtd->codec_dai->dai_runtime.fs, mclk,
+			rtd->codec_dai->dai_runtime.bfs, codec_bclk);
+	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RCW) {
+		codec_bclk = params_rate(params) * params_channels(params) *
+			snd_pcm_format_physical_width(rtd->codec_dai->dai_runtime.pcmfmt) *
+			SND_SOC_FSBW_REAL(rtd->codec_dai->dai_runtime.bfs);
+		dbg("asoc: codec fs %d mclk %d bfs rcw mult %d bclk %d\n",
+			rtd->codec_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBW_REAL(rtd->codec_dai->dai_runtime.bfs), codec_bclk);
+	} else
+		codec_bclk = 0;
+
+	if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_DIV) {
+		cpu_bclk = (rtd->cpu_dai->dai_runtime.fs * params_rate(params)) /
+			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
+		dbg("asoc: cpu fs %d mclk %d bfs div %d bclk %d\n",
+			rtd->cpu_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
+	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RATE) {
+		cpu_bclk = params_rate(params) * rtd->cpu_dai->dai_runtime.bfs;
+		dbg("asoc: cpu fs %d mclk %d bfs rate mult %llu bclk %d\n",
+			rtd->cpu_dai->dai_runtime.fs, mclk,
+			rtd->cpu_dai->dai_runtime.bfs, cpu_bclk);
+	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RCW) {
+		cpu_bclk = params_rate(params) * params_channels(params) *
+			snd_pcm_format_physical_width(rtd->cpu_dai->dai_runtime.pcmfmt) *
+			SND_SOC_FSBW_REAL(rtd->cpu_dai->dai_runtime.bfs);
+		dbg("asoc: cpu fs %d mclk %d bfs mult rcw %d bclk %d\n",
+			rtd->cpu_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBW_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
+	} else
+		cpu_bclk = 0;
+
+	/*
+	 * Check we have matching bitclocks. If we don't then it means the
+	 * sysclock returned by either the codec or cpu DAI (selected by the
+	 * machine sysclock function) is wrong compared with the supported DAI
+	 * modes for the codec or cpu DAI.
+	 */
+	if (cpu_bclk != codec_bclk && cpu_bclk){
+		printk(KERN_ERR
+			"asoc: codec and cpu bitclocks differ, audio may be wrong speed\n"
+			);
+		printk(KERN_ERR "asoc: codec %d != cpu %d\n", codec_bclk, cpu_bclk);
+	}
+
+	switch(rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dbg("asoc: DAI codec BCLK master, LRC master\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		dbg("asoc: DAI codec BCLK slave, LRC master\n");
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		dbg("asoc: DAI codec BCLK master, LRC slave\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dbg("asoc: DAI codec BCLK slave, LRC slave\n");
+		break;
+	}
+	dbg("asoc: mode %x, invert %x\n",
+		rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK,
+		rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK);
+	dbg("asoc: audio rate %d chn %d fmt %x\n", params_rate(params),
+		params_channels(params), params_format(params));
+
+	return 0;
+}
+
+static inline u32 get_rates(struct snd_soc_dai_mode *modes, int nmodes)
+{
+	int i;
+	u32 rates = 0;
+
+	for(i = 0; i < nmodes; i++)
+		rates |= modes[i].pcmrate;
+
+	return rates;
+}
+
+static inline u64 get_formats(struct snd_soc_dai_mode *modes, int nmodes)
+{
+	int i;
+	u64 formats = 0;
+
+	for(i = 0; i < nmodes; i++)
+		formats |= modes[i].pcmfmt;
+
+	return formats;
+}
+
+/*
+ * Called by ALSA when a PCM substream is opened, the runtime->hw record is
+ * then initialized and any private data can be allocated. This also calls
+ * startup for the cpu DAI, platform, machine and codec DAI.
+ */
+static int soc_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	/* startup the audio subsystem */
+	if (rtd->cpu_dai->ops.startup) {
+		ret = rtd->cpu_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open interface %s\n",
+				rtd->cpu_dai->name);
+			goto out;
+		}
+	}
+
+	if (platform->pcm_ops->open) {
+		ret = platform->pcm_ops->open(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);
+			goto platform_err;
+		}
+	}
+
+	if (machine->ops && machine->ops->startup) {
+		ret = machine->ops->startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: %s startup failed\n", machine->name);
+			goto machine_err;
+		}
+	}
+
+	if (rtd->codec_dai->ops.startup) {
+		ret = rtd->codec_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open codec %s\n",
+				rtd->codec_dai->name);
+			goto codec_dai_err;
+		}
+	}
+
+	/* create runtime params from DMA, codec and cpu DAI */
+	if (runtime->hw.rates)
+		runtime->hw.rates &=
+			get_rates(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_rates(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+	else
+		runtime->hw.rates =
+			get_rates(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_rates(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+	if (runtime->hw.formats)
+		runtime->hw.formats &=
+			get_formats(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_formats(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+	else
+		runtime->hw.formats =
+			get_formats(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_formats(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+
+	/* Check that the codec and cpu DAI's are compatible */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		runtime->hw.rate_min =
+			max(rtd->codec_dai->playback.rate_min,
+				rtd->cpu_dai->playback.rate_min);
+		runtime->hw.rate_max =
+			min(rtd->codec_dai->playback.rate_max,
+				rtd->cpu_dai->playback.rate_max);
+		runtime->hw.channels_min =
+			max(rtd->codec_dai->playback.channels_min,
+				rtd->cpu_dai->playback.channels_min);
+		runtime->hw.channels_max =
+			min(rtd->codec_dai->playback.channels_max,
+				rtd->cpu_dai->playback.channels_max);
+	} else {
+		runtime->hw.rate_min =
+			max(rtd->codec_dai->capture.rate_min,
+				rtd->cpu_dai->capture.rate_min);
+		runtime->hw.rate_max =
+			min(rtd->codec_dai->capture.rate_max,
+				rtd->cpu_dai->capture.rate_max);
+		runtime->hw.channels_min =
+			max(rtd->codec_dai->capture.channels_min,
+				rtd->cpu_dai->capture.channels_min);
+		runtime->hw.channels_max =
+			min(rtd->codec_dai->capture.channels_max,
+				rtd->cpu_dai->capture.channels_max);
+	}
+
+	snd_pcm_limit_hw_rates(runtime);
+	if (!runtime->hw.rates) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",
+			rtd->codec_dai->name, rtd->cpu_dai->name);
+		goto codec_dai_err;
+	}
+	if (!runtime->hw.formats) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",
+			rtd->codec_dai->name, rtd->cpu_dai->name);
+		goto codec_dai_err;
+	}
+	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
+			rtd->codec_dai->name, rtd->cpu_dai->name);
+		goto codec_dai_err;
+	}
+
+	dbg("asoc: %s <-> %s info:\n", rtd->codec_dai->name, rtd->cpu_dai->name);
+	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
+	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
+		runtime->hw.channels_max);
+	dbg("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
+		runtime->hw.rate_max);
+
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->cpu_dai->playback.active = rtd->codec_dai->playback.active = 1;
+	else
+		rtd->cpu_dai->capture.active = rtd->codec_dai->capture.active = 1;
+	rtd->cpu_dai->active = rtd->codec_dai->active = 1;
+	rtd->cpu_dai->runtime = runtime;
+	socdev->codec->active++;
+	mutex_unlock(&pcm_mutex);
+	return 0;
+
+codec_dai_err:
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+machine_err:
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+
+platform_err:
+	if (rtd->cpu_dai->ops.shutdown)
+		rtd->cpu_dai->ops.shutdown(substream);
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Power down the audio subsytem pmdown_time msecs after close is called.
+ * This is to ensure there are no pops or clicks in between any music tracks
+ * due to DAPM power cycling.
+ */
+static void close_delayed_work(void *data)
+{
+	struct snd_soc_device *socdev = data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai;
+	int i;
+
+	mutex_lock(&pcm_mutex);
+	for(i = 0; i < codec->num_dai; i++) {
+		codec_dai = &codec->dai[i];
+
+		dbg("pop wq checking: %s status: %s waiting: %s\n",
+			codec_dai->playback.stream_name,
+			codec_dai->playback.active ? "active" : "inactive",
+			codec_dai->pop_wait ? "yes" : "no");
+
+		/* are we waiting on this codec DAI stream */
+		if (codec_dai->pop_wait == 1) {
+
+			codec_dai->pop_wait = 0;
+			snd_soc_dapm_stream_event(codec, codec_dai->playback.stream_name,
+				SND_SOC_DAPM_STREAM_STOP);
+
+			/* power down the codec power domain if no longer active */
+			if (codec->active == 0) {
+				dbg("pop wq D3 %s %s\n", codec->name,
+					codec_dai->playback.stream_name);
+		 		if (codec->dapm_event)
+					codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+			}
+		}
+	}
+	mutex_unlock(&pcm_mutex);
+}
+
+/*
+ * Called by ALSA when a PCM substream is closed. Private data can be
+ * freed here. The cpu DAI, codec DAI, machine and platform are also
+ * shutdown.
+ */
+static int soc_codec_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&pcm_mutex);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->cpu_dai->playback.active = rtd->codec_dai->playback.active = 0;
+	else
+		rtd->cpu_dai->capture.active = rtd->codec_dai->capture.active = 0;
+
+	if (rtd->codec_dai->playback.active == 0 &&
+		rtd->codec_dai->capture.active == 0) {
+		rtd->cpu_dai->active = rtd->codec_dai->active = 0;
+	}
+	codec->active--;
+
+	if (rtd->cpu_dai->ops.shutdown)
+		rtd->cpu_dai->ops.shutdown(substream);
+
+	if (rtd->codec_dai->ops.shutdown)
+		rtd->codec_dai->ops.shutdown(substream);
+
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+	rtd->cpu_dai->runtime = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* start delayed pop wq here for playback streams */
+		rtd->codec_dai->pop_wait = 1;
+		queue_delayed_work(soc_workq, &soc_stream_work,
+			msecs_to_jiffies(pmdown_time));
+	} else {
+		/* capture streams can be powered down now */
+		snd_soc_dapm_stream_event(codec, rtd->codec_dai->capture.stream_name,
+			SND_SOC_DAPM_STREAM_STOP);
+
+		if (codec->active == 0 && rtd->codec_dai->pop_wait == 0){
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+		}
+	}
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+/*
+ * Called by ALSA when the PCM substream is prepared, can set format, sample
+ * rate, etc.  This function is non atomic and can be called multiple times,
+ * it can refer to the runtime info.
+ */
+static int soc_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+	if (platform->pcm_ops->prepare) {
+		ret = platform->pcm_ops->prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: platform prepare error\n");
+			goto out;
+		}
+	}
+
+	if (rtd->codec_dai->ops.prepare) {
+		ret = rtd->codec_dai->ops.prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: codec DAI prepare error\n");
+			goto out;
+		}
+	}
+
+	if (rtd->cpu_dai->ops.prepare)
+		ret = rtd->cpu_dai->ops.prepare(substream);
+
+	/* we only want to start a DAPM playback stream if we are not waiting
+	 * on an existing one stopping */
+	if (rtd->codec_dai->pop_wait) {
+		/* we are waiting for the delayed work to start */
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+		else {
+			rtd->codec_dai->pop_wait = 0;
+			cancel_delayed_work(&soc_stream_work);
+			if (rtd->codec_dai->digital_mute)
+				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+		}
+	} else {
+		/* no delayed work - do we need to power up codec */
+		if (codec->dapm_state != SNDRV_CTL_POWER_D0) {
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D1);
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D0);
+			if (rtd->codec_dai->digital_mute)
+				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+
+		} else {
+			/* codec already powered - power on widgets */
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			if (rtd->codec_dai->digital_mute)
+				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Called by ALSA when the hardware params are set by application. This
+ * function can also be called multiple times and can allocate buffers
+ * (using snd_pcm_lib_* ). It's non-atomic.
+ */
+static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	/* we don't need to match any AC97 params */
+	if (rtd->cpu_dai->type != SND_SOC_DAI_AC97) {
+		ret = soc_hw_match_params(substream, params);
+		if (ret < 0)
+			goto out;
+	} else {
+		struct snd_soc_clock_info clk_info;
+		clk_info.rate = params_rate(params);
+		ret = soc_get_mclk(rtd, &clk_info);
+		if (ret < 0)
+			goto out;
+	}
+
+	if (rtd->codec_dai->ops.hw_params) {
+		ret = rtd->codec_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
+				rtd->codec_dai->name);
+			goto out;
+		}
+	}
+
+	if (rtd->cpu_dai->ops.hw_params) {
+		ret = rtd->cpu_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set interface %s hw params\n",
+				rtd->cpu_dai->name);
+			goto interface_err;
+		}
+	}
+
+	if (platform->pcm_ops->hw_params) {
+		ret = platform->pcm_ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set platform %s hw params\n",
+				platform->name);
+			goto platform_err;
+		}
+	}
+
+	if (machine->ops && machine->ops->hw_params) {
+		ret = machine->ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine hw_params failed\n");
+			goto machine_err;
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+
+machine_err:
+	if (platform->pcm_ops->hw_free)
+		platform->pcm_ops->hw_free(substream);
+
+platform_err:
+	if (rtd->cpu_dai->ops.hw_free)
+		rtd->cpu_dai->ops.hw_free(substream);
+
+interface_err:
+	if (rtd->codec_dai->ops.hw_free)
+		rtd->codec_dai->ops.hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Free's resources allocated by hw_params, can be called multiple times
+ */
+static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+
+	mutex_lock(&pcm_mutex);
+
+	/* apply codec digital mute */
+	if (!codec->active && rtd->codec_dai->digital_mute)
+		rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 1);
+
+	/* free any machine hw params */
+	if (machine->ops && machine->ops->hw_free)
+		machine->ops->hw_free(substream);
+
+	/* free any DMA resources */
+	if (platform->pcm_ops->hw_free)
+		platform->pcm_ops->hw_free(substream);
+
+	/* now free hw params for the DAI's  */
+	if (rtd->codec_dai->ops.hw_free)
+		rtd->codec_dai->ops.hw_free(substream);
+
+	if (rtd->cpu_dai->ops.hw_free)
+		rtd->cpu_dai->ops.hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	int ret;
+
+	if (rtd->codec_dai->ops.trigger) {
+		ret = rtd->codec_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (platform->pcm_ops->trigger) {
+		ret = platform->pcm_ops->trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->cpu_dai->ops.trigger) {
+		ret = rtd->cpu_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+/* ASoC PCM operations */
+static struct snd_pcm_ops soc_pcm_ops = {
+	.open		= soc_pcm_open,
+	.close		= soc_codec_close,
+	.hw_params	= soc_pcm_hw_params,
+	.hw_free	= soc_pcm_hw_free,
+	.prepare	= soc_pcm_prepare,
+	.trigger	= soc_pcm_trigger,
+};
+
+#ifdef CONFIG_PM
+/* powers down audio subsystem for suspend */
+static int soc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	/* mute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->digital_mute && dai->playback.active)
+			dai->digital_mute(codec, dai, 1);
+	}
+
+	if (machine->suspend_pre)
+		machine->suspend_pre(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+		if (platform->suspend)
+			platform->suspend(pdev, cpu_dai);
+	}
+
+	/* close any waiting streams and save state */
+	flush_workqueue(soc_workq);
+	codec->suspend_dapm_state = codec->dapm_state;
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char *stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+	}
+
+	if (codec_dev->suspend)
+		codec_dev->suspend(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+	}
+
+	if (machine->suspend_post)
+		machine->suspend_post(pdev, state);
+
+	return 0;
+}
+
+/* powers up audio subsystem after a suspend */
+static int soc_resume(struct platform_device *pdev)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	if (machine->resume_pre)
+		machine->resume_pre(pdev);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+	}
+
+	if (codec_dev->resume)
+		codec_dev->resume(pdev);
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char* stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+	}
+
+	/* unmute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->digital_mute && dai->playback.active)
+			dai->digital_mute(codec, dai, 0);
+	}
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+		if (platform->resume)
+			platform->resume(pdev, cpu_dai);
+	}
+
+	if (machine->resume_post)
+		machine->resume_post(pdev);
+
+	return 0;
+}
+
+#else
+#define soc_suspend	NULL
+#define soc_resume	NULL
+#endif
+
+/* probes a new socdev */
+static int soc_probe(struct platform_device *pdev)
+{
+	int ret = 0, i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	if (machine->probe) {
+		ret = machine->probe(pdev);
+		if(ret < 0)
+			return ret;
+	}
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->probe) {
+			ret = cpu_dai->probe(pdev);
+			if(ret < 0)
+				goto cpu_dai_err;
+		}
+	}
+
+	if (codec_dev->probe) {
+		ret = codec_dev->probe(pdev);
+		if(ret < 0)
+			goto cpu_dai_err;
+	}
+
+	if (platform->probe) {
+		ret = platform->probe(pdev);
+		if(ret < 0)
+			goto platform_err;
+	}
+
+	/* DAPM stream work */
+	soc_workq = create_workqueue("kdapm");
+	if (soc_workq == NULL)
+		goto work_err;
+	INIT_WORK(&soc_stream_work, close_delayed_work, socdev);
+	return 0;
+
+work_err:
+	if (platform->remove)
+		platform->remove(pdev);
+
+platform_err:
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+cpu_dai_err:
+	for (i--; i > 0; i--) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return ret;
+}
+
+/* removes a socdev */
+static int soc_remove(struct platform_device *pdev)
+{
+	int i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	if (soc_workq)
+		destroy_workqueue(soc_workq);
+
+	if (platform->remove)
+		platform->remove(pdev);
+
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return 0;
+}
+
+/* ASoC platform driver */
+static struct platform_driver soc_driver = {
+	.driver		= {
+		.name		= "soc-audio",
+	},
+	.probe		= soc_probe,
+	.remove		= soc_remove,
+	.suspend	= soc_suspend,
+	.resume		= soc_resume,
+};
+
+/* create a new pcm */
+static int soc_new_pcm(struct snd_soc_device *socdev,
+	struct snd_soc_dai_link *dai_link, int num)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai = dai_link->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = dai_link->cpu_dai;
+	struct snd_soc_pcm_runtime *rtd;
+	struct snd_pcm *pcm;
+	char new_name[64];
+	int ret = 0, playback = 0, capture = 0;
+
+	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
+	if (rtd == NULL)
+		return -ENOMEM;
+	rtd->cpu_dai = cpu_dai;
+	rtd->codec_dai = codec_dai;
+	rtd->socdev = socdev;
+
+	/* check client and interface hw capabilities */
+	sprintf(new_name, "%s %s-%s-%d",dai_link->stream_name, codec_dai->name,
+		get_dai_name(cpu_dai->type), num);
+
+	if (codec_dai->playback.channels_min)
+		playback = 1;
+	if (codec_dai->capture.channels_min)
+		capture = 1;
+
+	ret = snd_pcm_new(codec->card, new_name, codec->pcm_devs++, playback,
+		capture, &pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_data = rtd;
+	soc_pcm_ops.mmap = socdev->platform->pcm_ops->mmap;
+	soc_pcm_ops.pointer = socdev->platform->pcm_ops->pointer;
+	soc_pcm_ops.ioctl = socdev->platform->pcm_ops->ioctl;
+	soc_pcm_ops.copy = socdev->platform->pcm_ops->copy;
+	soc_pcm_ops.silence = socdev->platform->pcm_ops->silence;
+	soc_pcm_ops.ack = socdev->platform->pcm_ops->ack;
+	soc_pcm_ops.page = socdev->platform->pcm_ops->page;
+
+	if (playback)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
+
+	if (capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
+
+	ret = socdev->platform->pcm_new(codec->card, codec_dai, pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: platform pcm constructor failed\n");
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_free = socdev->platform->pcm_free;
+	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,
+		cpu_dai->name);
+	return ret;
+}
+
+/* codec register dump */
+static ssize_t codec_reg_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = devdata->codec;
+	int i, step = 1, count = 0;
+
+	if (!codec->reg_cache_size)
+		return 0;
+
+	if (codec->reg_cache_step)
+		step = codec->reg_cache_step;
+
+	count += sprintf(buf, "%s registers\n", codec->name);
+	for(i = 0; i < codec->reg_cache_size; i += step)
+		count += sprintf(buf + count, "%2x: %4x\n", i, codec->read(codec, i));
+
+	return count;
+}
+static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
+
+/**
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ * @ops: AC97 bus operations
+ * @num: AC97 codec number
+ *
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
+ */
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num)
+{
+	mutex_lock(&codec->mutex);
+
+	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (codec->ac97 == NULL) {
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
+	if (codec->ac97->bus == NULL) {
+		kfree(codec->ac97);
+		codec->ac97 = NULL;
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus->ops = ops;
+	codec->ac97->num = num;
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+
+/**
+ * snd_soc_free_ac97_codec - free AC97 codec device
+ * @codec: audio codec
+ *
+ * Frees AC97 codec device resources.
+ */
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+{
+	mutex_lock(&codec->mutex);
+	kfree(codec->ac97->bus);
+	kfree(codec->ac97);
+	codec->ac97 = NULL;
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+
+/**
+ * snd_soc_update_bits - update codec register bits
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	if (change)
+		snd_soc_write(codec, reg, new);
+
+	mutex_unlock(&io_mutex);
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_update_bits);
+
+/**
+ * snd_soc_test_bits - test register for change
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Tests a register with a new value and checks if the new value is
+ * different from the old value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	mutex_unlock(&io_mutex);
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_test_bits);
+
+/**
+ * snd_soc_get_rate - get int sample rate
+ * @hwpcmrate: the hardware pcm rate
+ *
+ * Returns the audio rate integaer value, else 0.
+ */
+int snd_soc_get_rate(int hwpcmrate)
+{
+	int rate = ffs(hwpcmrate) - 1;
+
+	if (rate > ARRAY_SIZE(rates))
+		return 0;
+	return rates[rate];
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_rate);
+
+/**
+ * snd_soc_new_pcms - create new sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Create a new sound card based upon the codec and interface pcms.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char * xid)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i;
+
+	mutex_lock(&codec->mutex);
+
+	/* register a sound card */
+	codec->card = snd_card_new(idx, xid, codec->owner, 0);
+	if (!codec->card) {
+		printk(KERN_ERR "asoc: can't create sound card for codec %s\n",
+			codec->name);
+		mutex_unlock(&codec->mutex);
+		return -ENODEV;
+	}
+
+	codec->card->dev = socdev->dev;
+	codec->card->private_data = codec;
+	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
+
+	/* create the pcms */
+	for(i = 0; i < machine->num_links; i++) {
+		ret = soc_new_pcm(socdev, &machine->dai_link[i], i);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't create pcm %s\n",
+				machine->dai_link[i].stream_name);
+			mutex_unlock(&codec->mutex);
+			return ret;
+		}
+	}
+
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
+
+/**
+ * snd_soc_register_card - register sound card
+ * @socdev: the SoC audio device
+ *
+ * Register a SoC sound card. Also registers an AC97 device if the
+ * codec is AC97 for ad hoc devices.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_register_card(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i, ac97 = 0, err = 0;
+
+	mutex_lock(&codec->mutex);
+	for(i = 0; i < machine->num_links; i++) {
+		if (socdev->machine->dai_link[i].init) {
+			err = socdev->machine->dai_link[i].init(codec);
+			if (err < 0) {
+				printk(KERN_ERR "asoc: failed to init %s\n",
+					socdev->machine->dai_link[i].stream_name);
+				continue;
+			}
+		}
+		if (socdev->machine->dai_link[i].cpu_dai->type == SND_SOC_DAI_AC97)
+			ac97 = 1;
+	}
+	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
+		 "%s", machine->name);
+	snprintf(codec->card->longname, sizeof(codec->card->longname),
+		 "%s (%s)", machine->name, codec->name);
+
+	ret = snd_card_register(codec->card);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to register soundcard for codec %s\n",
+				codec->name);
+		goto out;
+	}
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (ac97) {
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: AC97 device register failed\n");
+			snd_card_free(codec->card);
+			goto out;
+		}
+	}
+#endif
+
+	err = snd_soc_dapm_sys_add(socdev->dev);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
+
+	err = device_create_file(socdev->dev, &dev_attr_codec_reg);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add codec sysfs entries\n");
+out:
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_card);
+
+/**
+ * snd_soc_free_pcms - free sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Frees sound card and pcms associated with the socdev.
+ * Also unregister the codec if it is an AC97 device.
+ */
+void snd_soc_free_pcms(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (codec->ac97)
+		soc_ac97_dev_unregister(codec);
+#endif
+
+	if (codec->card)
+		snd_card_free(codec->card);
+	device_remove_file(socdev->dev, &dev_attr_codec_reg);
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_pcms);
+
+/**
+ * snd_soc_set_runtime_hwparams - set the runtime hardware parameters
+ * @substream: the pcm substream
+ * @hw: the hardware parameters
+ *
+ * Sets the substream runtime hardware parameters.
+ */
+int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
+	const struct snd_pcm_hardware *hw)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	runtime->hw.info = hw->info;
+	runtime->hw.formats = hw->formats;
+	runtime->hw.period_bytes_min = hw->period_bytes_min;
+	runtime->hw.period_bytes_max = hw->period_bytes_max;
+	runtime->hw.periods_min = hw->periods_min;
+	runtime->hw.periods_max = hw->periods_max;
+	runtime->hw.buffer_bytes_max = hw->buffer_bytes_max;
+	runtime->hw.fifo_size = hw->fifo_size;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
+
+/**
+ * snd_soc_cnew - create new control
+ * @_template: control template
+ * @data: control private data
+ * @lnng_name: control long name
+ *
+ * Create a new mixer control from a template control.
+ *
+ * Returns 0 for success, else error.
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+	void *data, char *long_name)
+{
+	struct snd_kcontrol_new template;
+
+	memcpy(&template, _template, sizeof(template));
+	if (long_name)
+		template.name = long_name;
+	template.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+	template.index = 0;
+
+	return snd_ctl_new1(&template, data);
+}
+EXPORT_SYMBOL_GPL(snd_soc_cnew);
+
+/**
+ * snd_soc_info_enum_double - enumerated double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double enumerated
+ * mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
+
+/**
+ * snd_soc_get_enum_double - enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(codec, e->reg);
+	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
+
+/**
+ * snd_soc_put_enum_double - enumerated double mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val;
+	unsigned short mask, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	val = ucontrol->value.enumerated.item[0] << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	return snd_soc_update_bits(codec, e->reg, mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
+
+/**
+ * snd_soc_info_enum_ext - external enumerated single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about an external enumerated
+ * single mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);
+
+/**
+ * snd_soc_info_volsw_ext - external single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = kcontrol->private_value;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
+
+/**
+ * snd_soc_info_bool_ext - external single boolean mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single boolean external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_bool_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_bool_ext);
+
+/**
+ * snd_soc_info_volsw - single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = shift == rshift ? 1 : 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
+
+/**
+ * snd_soc_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(codec, reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
+
+/**
+ * snd_soc_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+	err = snd_soc_update_bits(codec, reg, val_mask, val);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
+
+/**
+ * snd_soc_info_volsw_2r - double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double mixer control that
+ * spans 2 codec registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
+
+/**
+ * snd_soc_get_volsw_2r - double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	ucontrol->value.integer.value[1] =
+		(snd_soc_read(codec, reg2) >> shift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		ucontrol->value.integer.value[1] =
+			mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
+
+/**
+ * snd_soc_put_volsw_2r - double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val_mask = mask << shift;
+	val = (ucontrol->value.integer.value[0] & mask);
+	val2 = (ucontrol->value.integer.value[1] & mask);
+
+	if (invert) {
+		val = mask - val;
+		val2 = mask - val2;
+	}
+
+	val = val << shift;
+	val2 = val2 << shift;
+
+	if ((err = snd_soc_update_bits(codec, reg, val_mask, val)) < 0)
+		return err;
+
+	err = snd_soc_update_bits(codec, reg2, val_mask, val2);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
+
+static int __devinit snd_soc_init(void)
+{
+	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);
+	return platform_driver_register(&soc_driver);
+}
+
+static void snd_soc_exit(void)
+{
+ 	platform_driver_unregister(&soc_driver);
+}
+
+module_init(snd_soc_init);
+module_exit(snd_soc_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC Core");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/at91/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/at91/Kconfig
@@ -0,0 +1,24 @@
+menu "SoC Audio for the Atmel AT91"
+
+config SND_AT91_SOC
+	tristate "SoC Audio for the Atmel AT91 System-on-Chip"
+	depends on ARCH_AT91 && SND
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the AT91 SSC interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_AT91_SOC_I2S
+	tristate
+
+config SND_AT91_SOC_ETI_B1_WM8731
+	tristate "SoC I2S Audio support for Endrelia ETI-B1 board"
+	depends on SND_AT91_SOC && MACH_ETI_B1
+	select SND_AT91_SOC_I2S
+	select SND_SOC_WM8731
+	help
+	  Say Y if you want to add support for SoC audio on Endrelia
+          ETI-B1 board.
+
+endmenu
Index: linux-2.6-pxa-new/sound/soc/at91/Makefile
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/at91/Makefile
@@ -0,0 +1,11 @@
+# AT91 Platform Support
+snd-soc-at91-objs := at91rm9200-pcm.o
+snd-soc-at91-i2s-objs := at91rm9200-i2s.o
+
+obj-$(CONFIG_SND_AT91_SOC) += snd-soc-at91.o
+obj-$(CONFIG_SND_AT91_SOC_I2S) += snd-soc-at91-i2s.o
+
+# AT91 Machine Support
+snd-soc-eti-b1-wm8731-objs := eti_b1_wm8731.o
+
+obj-$(CONFIG_SND_AT91_SOC_ETI_B1_WM8731) += snd-soc-eti-b1-wm8731.o
Index: linux-2.6-pxa-new/sound/soc/at91/at91rm9200-i2s.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/at91/at91rm9200-i2s.c
@@ -0,0 +1,715 @@
+/*
+ * at91rm9200-i2s.c  --  ALSA Soc Audio Layer Platform driver and DMA engine
+ *
+ * Author: Frank Mandarino <fmandarino@endrelia.com>
+ *         Endrelia Technologies Inc.
+ *
+ * Based on pxa2xx Platform drivers by
+ * Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *     3rd Mar 2006   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/arch/at91rm9200.h>
+#include <asm/arch/at91rm9200_ssc.h>
+#include <asm/arch/at91rm9200_pdc.h>
+#include <asm/arch/hardware.h>
+
+#include "at91rm9200-pcm.h"
+
+#if 0
+#define	DBG(x...)	printk(KERN_DEBUG "at91rm9200-i2s:" x)
+#else
+#define	DBG(x...)
+#endif
+
+#define AT91RM9200_I2S_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_NB_NF)
+
+#define AT91RM9200_I2S_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+/* priv is (SSC_CMR.DIV << 16 | SSC_TCMR.PERIOD ) */
+static struct snd_soc_dai_mode at91rm9200_i2s[] = {
+
+	/* 8k: BCLK = (MCLK/10) = (60MHz/50) = 1.2MHz */
+	{
+		.fmt = AT91RM9200_I2S_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = AT91RM9200_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1500,
+		.bfs = SND_SOC_FSBD(10),
+		.priv = (25 << 16 | 74),
+	},
+
+	/* 16k: BCLK = (MCLK/3) ~= (60MHz/14) = 4.285714MHz */
+	{
+		.fmt = AT91RM9200_I2S_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_16000,
+		.pcmdir = AT91RM9200_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 750,
+		.bfs = SND_SOC_FSBD(3),
+		.priv = (7 << 16 | 133),
+	},
+
+	/* 32k: BCLK = (MCLK/3) ~= (60MHz/14) = 4.285714MHz */
+	{
+		.fmt = AT91RM9200_I2S_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = AT91RM9200_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 375,
+		.bfs = SND_SOC_FSBD(3),
+		.priv = (7 << 16 | 66),
+	},
+
+	/* 48k: BCLK = (MCLK/5) ~= (60MHz/26) = 2.3076923MHz */
+	{
+		.fmt = AT91RM9200_I2S_DAIFMT,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = AT91RM9200_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 250,
+		.bfs SND_SOC_FSBD(5),
+		.priv = (13 << 16 | 23),
+	},
+};
+
+
+/*
+ * SSC registers required by the PCM DMA engine.
+ */
+static struct at91rm9200_ssc_regs ssc_reg[3] = {
+	{
+	.cr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_SSC_CR),
+	.ier	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_SSC_IER),
+	.idr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_SSC_IDR),
+	},
+	{
+	.cr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_SSC_CR),
+	.ier	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_SSC_IER),
+	.idr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_SSC_IDR),
+	},
+	{
+	.cr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_SSC_CR),
+	.ier	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_SSC_IER),
+	.idr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_SSC_IDR),
+	},
+};
+
+static struct at91rm9200_pdc_regs pdc_tx_reg[3] = {
+	{
+	.xpr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_TPR),
+	.xcr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_TCR),
+	.xnpr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_TNPR),
+	.xncr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_TNCR),
+	.ptcr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_PTCR),
+	},
+	{
+	.xpr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_TPR),
+	.xcr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_TCR),
+	.xnpr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_TNPR),
+	.xncr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_TNCR),
+	.ptcr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_PTCR),
+	},
+	{
+	.xpr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_TPR),
+	.xcr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_TCR),
+	.xnpr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_TNPR),
+	.xncr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_TNCR),
+	.ptcr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_PTCR),
+	},
+};
+
+static struct at91rm9200_pdc_regs pdc_rx_reg[3] = {
+	{
+	.xpr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_RPR),
+	.xcr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_RCR),
+	.xnpr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_RNPR),
+	.xncr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_RNCR),
+	.ptcr	= (void __iomem *) (AT91_VA_BASE_SSC0 + AT91_PDC_PTCR),
+	},
+	{
+	.xpr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_RPR),
+	.xcr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_RCR),
+	.xnpr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_RNPR),
+	.xncr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_RNCR),
+	.ptcr	= (void __iomem *) (AT91_VA_BASE_SSC1 + AT91_PDC_PTCR),
+	},
+	{
+	.xpr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_RPR),
+	.xcr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_RCR),
+	.xnpr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_RNPR),
+	.xncr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_RNCR),
+	.ptcr	= (void __iomem *) (AT91_VA_BASE_SSC2 + AT91_PDC_PTCR),
+	},
+};
+
+/*
+ * SSC & PDC status bits for transmit and receive.
+ */
+static struct at91rm9200_ssc_mask ssc_tx_mask = {
+	.ssc_enable	= AT91_SSC_TXEN,
+	.ssc_disable	= AT91_SSC_TXDIS,
+	.ssc_endx	= AT91_SSC_ENDTX,
+	.ssc_endbuf	= AT91_SSC_TXBUFE,
+	.pdc_enable	= AT91_PDC_TXTEN,
+	.pdc_disable	= AT91_PDC_TXTDIS,
+};
+
+static struct at91rm9200_ssc_mask ssc_rx_mask = {
+	.ssc_enable	= AT91_SSC_RXEN,
+	.ssc_disable	= AT91_SSC_RXDIS,
+	.ssc_endx	= AT91_SSC_ENDRX,
+	.ssc_endbuf	= AT91_SSC_RXBUFF,
+	.pdc_enable	= AT91_PDC_RXTEN,
+	.pdc_disable	= AT91_PDC_RXTDIS,
+};
+
+/*
+ * A MUTEX is used to protect an SSC initialzed flag which allows
+ * the substream hw_params() call to initialize the SSC only if
+ * there are no other substreams open.  If there are other
+ * substreams open, the hw_param() call can only check that
+ * it is using the same format and rate.
+ */
+static DECLARE_MUTEX(ssc0_mutex);
+static DECLARE_MUTEX(ssc1_mutex);
+static DECLARE_MUTEX(ssc2_mutex);
+
+/*
+ * DMA parameters.
+ */
+static at91rm9200_pcm_dma_params_t ssc_dma_params[3][2] = {
+	{{
+	.name		= "SSC0/I2S PCM Stereo out",
+	.ssc		= &ssc_reg[0],
+	.pdc		= &pdc_tx_reg[0],
+	.mask		= &ssc_tx_mask,
+	},
+	{
+	.name		= "SSC0/I2S PCM Stereo in",
+	.ssc		= &ssc_reg[0],
+	.pdc		= &pdc_rx_reg[0],
+	.mask		= &ssc_rx_mask,
+	}},
+	{{
+	.name		= "SSC1/I2S PCM Stereo out",
+	.ssc		= &ssc_reg[1],
+	.pdc		= &pdc_tx_reg[1],
+	.mask		= &ssc_tx_mask,
+	},
+	{
+	.name		= "SSC1/I2S PCM Stereo in",
+	.ssc		= &ssc_reg[1],
+	.pdc		= &pdc_rx_reg[1],
+	.mask		= &ssc_rx_mask,
+	}},
+	{{
+	.name		= "SSC2/I2S PCM Stereo out",
+	.ssc		= &ssc_reg[2],
+	.pdc		= &pdc_tx_reg[2],
+	.mask		= &ssc_tx_mask,
+	},
+	{
+	.name		= "SSC1/I2S PCM Stereo in",
+	.ssc		= &ssc_reg[2],
+	.pdc		= &pdc_rx_reg[2],
+	.mask		= &ssc_rx_mask,
+	}},
+};
+
+
+struct at91rm9200_ssc_state {
+	u32	ssc_cmr;
+	u32	ssc_rcmr;
+	u32	ssc_rfmr;
+	u32	ssc_tcmr;
+	u32	ssc_tfmr;
+	u32	ssc_sr;
+	u32	ssc_imr;
+};
+
+static struct at91rm9200_ssc_info {
+	char		*name;
+	void __iomem    *ssc_base;
+	u32		pid;
+	spinlock_t 	lock;		/* lock for dir_mask */
+	int		dir_mask;	/* 0=unused, 1=playback, 2=capture */
+	struct semaphore *mutex;
+	int		initialized;
+	int		pcmfmt;
+	int		rate;
+	at91rm9200_pcm_dma_params_t *dma_params[2];
+	struct at91rm9200_ssc_state ssc_state;
+
+} ssc_info[3] = {
+	{
+	.name		= "ssc0",
+	.ssc_base	= (void __iomem *) AT91_VA_BASE_SSC0,
+	.pid		= AT91_ID_SSC0,
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.dir_mask	= 0,
+	.mutex		= &ssc0_mutex,
+	.initialized	= 0,
+	},
+	{
+	.name		= "ssc1",
+	.ssc_base	= (void __iomem *) AT91_VA_BASE_SSC1,
+	.pid		= AT91_ID_SSC1,
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.dir_mask	= 0,
+	.mutex		= &ssc1_mutex,
+	.initialized	= 0,
+	},
+	{
+	.name		= "ssc2",
+	.ssc_base	= (void __iomem *) AT91_VA_BASE_SSC2,
+	.pid		= AT91_ID_SSC2,
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.dir_mask	= 0,
+	.mutex		= &ssc2_mutex,
+	.initialized	= 0,
+	},
+};
+
+
+static irqreturn_t at91rm9200_i2s_interrupt(int irq, void *dev_id)
+{
+	struct at91rm9200_ssc_info *ssc_p = dev_id;
+	at91rm9200_pcm_dma_params_t *dma_params;
+	u32 ssc_sr;
+	int i;
+
+	ssc_sr = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_SR)
+			& at91_ssc_read(ssc_p->ssc_base + AT91_SSC_IMR);
+
+	/*
+	 * Loop through the substreams attached to this SSC.  If
+	 * a DMA-related interrupt occurred on that substream, call
+	 * the DMA interrupt handler function, if one has been
+	 * registered in the dma_params structure by the PCM driver.
+	 */
+	for (i = 0; i < ARRAY_SIZE(ssc_p->dma_params); i++) {
+		dma_params = ssc_p->dma_params[i];
+
+		if (dma_params != NULL && dma_params->dma_intr_handler != NULL &&
+			(ssc_sr &
+			(dma_params->mask->ssc_endx | dma_params->mask->ssc_endbuf)))
+
+			dma_params->dma_intr_handler(ssc_sr, dma_params->substream);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int at91rm9200_i2s_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct at91rm9200_ssc_info *ssc_p = &ssc_info[rtd->cpu_dai->id];
+	int dir_mask;
+
+	DBG("i2s_startup: SSC_SR=0x%08lx\n",
+			at91_ssc_read(ssc_p->ssc_base + AT91_SSC_SR));
+	dir_mask = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0x1 : 0x2;
+
+	spin_lock_irq(&ssc_p->lock);
+	if (ssc_p->dir_mask & dir_mask) {
+		spin_unlock_irq(&ssc_p->lock);
+		return -EBUSY;
+	}
+	ssc_p->dir_mask |= dir_mask;
+	spin_unlock_irq(&ssc_p->lock);
+
+	return 0;
+}
+
+static void at91rm9200_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct at91rm9200_ssc_info *ssc_p = &ssc_info[rtd->cpu_dai->id];
+	at91rm9200_pcm_dma_params_t *dma_params = rtd->cpu_dai->dma_data;
+	int dir, dir_mask;
+
+	dir = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1;
+
+	if (dma_params != NULL) {
+		at91_ssc_write(dma_params->ssc->cr, dma_params->mask->ssc_disable);
+		DBG("%s disabled SSC_SR=0x%08lx\n", (dir ? "receive" : "transmit"),
+			at91_ssc_read(ssc_p->ssc_base + AT91_SSC_SR));
+
+		dma_params->substream = NULL;
+		ssc_p->dma_params[dir] = NULL;
+	}
+
+	dir_mask = 1 << dir;
+
+	spin_lock_irq(&ssc_p->lock);
+	ssc_p->dir_mask &= ~dir_mask;
+	if (!ssc_p->dir_mask) {
+		/* Shutdown the SSC clock. */
+		DBG("Stopping pid %d clock\n", ssc_p->pid);
+		at91_sys_write(AT91_PMC_PCDR, 1<<ssc_p->pid);
+
+		if (ssc_p->initialized)
+			free_irq(ssc_p->pid, ssc_p);
+
+		/* Reset the SSC */
+		at91_ssc_write(ssc_p->ssc_base + AT91_SSC_CR, AT91_SSC_SWRST);
+
+		/* Force a re-init on the next hw_params() call. */
+		ssc_p->initialized = 0;
+	}
+	spin_unlock_irq(&ssc_p->lock);
+}
+
+#ifdef CONFIG_PM
+static int at91rm9200_i2s_suspend(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	struct at91rm9200_ssc_info *ssc_p;
+
+	if(!dai->active)
+		return 0;
+
+	ssc_p = &ssc_info[dai->id];
+
+	/* Save the status register before disabling transmit and receive. */
+	ssc_p->state->ssc_sr = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_SR);
+	at91_ssc_write(ssc_p->ssc_base +
+		AT91_SSC_CR, AT91_SSC_TXDIS | AT91_SSC_RXDIS);
+
+	/* Save the current interrupt mask, then disable unmasked interrupts. */
+	ssc_p->state->ssc_imr = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_IMR);
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_IDR, ssc_p->state->ssc_imr);
+
+	ssc_p->state->ssc_cmr  = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_CMR);
+	ssc_p->state->ssc_rcmr = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_RCMR);
+	ssc_p->state->ssc_rfmr = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_RCMR);
+	ssc_p->state->ssc_tcmr = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_RCMR);
+	ssc_p->state->ssc_tfmr = at91_ssc_read(ssc_p->ssc_base + AT91_SSC_RCMR);
+
+	return 0;
+}
+
+static int at91rm9200_i2s_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	struct at91rm9200_ssc_info *ssc_p;
+	u32 cr_mask;
+
+	if(!dai->active)
+		return 0;
+
+	ssc_p = &ssc_info[dai->id];
+
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_RCMR, ssc_p->state->ssc_tfmr);
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_RCMR, ssc_p->state->ssc_tcmr);
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_RCMR, ssc_p->state->ssc_rfmr);
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_RCMR, ssc_p->state->ssc_rcmr);
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_CMR,  ssc_p->state->ssc_cmr);
+
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_IER,  ssc_p->state->ssc_imr);
+
+	at91_ssc_write(ssc_p->ssc_base + AT91_SSC_CR,
+		((ssc_p->state->ssc_sr & AT91_SSC_RXENA) ? AT91_SSC_RXEN : 0) |
+		((ssc_p->state->ssc_sr & AT91_SSC_TXENA) ? AT91_SSC_TXEN : 0));
+
+	return 0;
+}
+
+#else
+#define at91rm9200_i2s_suspend	NULL
+#define at91rm9200_i2s_resume	NULL
+#endif
+
+static unsigned int at91rm9200_i2s_config_sysclk(
+	struct snd_soc_cpu_dai *iface, struct snd_soc_clock_info *info,
+	unsigned int clk)
+{
+	/* Currently, there is only support for USB (12Mhz) mode */
+	if (clk != 12000000)
+		return 0;
+	return 12000000;
+}
+
+static int at91rm9200_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int id = rtd->cpu_dai->id;
+	struct at91rm9200_ssc_info *ssc_p = &ssc_info[id];
+	at91rm9200_pcm_dma_params_t *dma_params;
+	unsigned int pcmfmt, rate;
+	int dir, channels, bits;
+	struct clk *mck_clk;
+	unsigned long bclk;
+	u32 div, period, tfmr, rfmr, tcmr, rcmr;
+	int ret;
+
+	/*
+	 * Currently, there is only one set of dma params for
+	 * each direction.  If more are added, this code will
+	 * have to be changed to select the proper set.
+	 */
+	dir = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1;
+
+	dma_params = &ssc_dma_params[id][dir];
+	dma_params->substream = substream;
+
+	ssc_p->dma_params[dir] = dma_params;
+	rtd->cpu_dai->dma_data = dma_params;
+
+	rate = params_rate(params);
+	channels = params_channels(params);
+
+	pcmfmt = rtd->cpu_dai->dai_runtime.pcmfmt;
+	switch (pcmfmt) {
+		case SNDRV_PCM_FMTBIT_S16_LE:
+			/* likely this is all we'll ever support, but ... */
+			bits = 16;
+			dma_params->pdc_xfer_size = 2;
+			break;
+		default:
+			printk(KERN_WARNING "at91rm9200-i2s: unsupported format %x\n",
+				pcmfmt);
+			return -EINVAL;
+	}
+
+	/* Don't allow both SSC substreams to initialize at the same time. */
+	down(ssc_p->mutex);
+
+	/*
+	 * If this SSC is alreadly initialized, then this substream must use
+	 * the same format and rate.
+	 */
+	if (ssc_p->initialized) {
+		if (pcmfmt != ssc_p->pcmfmt || rate != ssc_p->rate) {
+			printk(KERN_WARNING "at91rm9200-i2s: "
+				"incompatible substream in other direction\n");
+			up(ssc_p->mutex);
+			return -EINVAL;
+		}
+	} else {
+		/* Enable PMC peripheral clock for this SSC */
+		DBG("Starting pid %d clock\n", ssc_p->pid);
+		at91_sys_write(AT91_PMC_PCER, 1<<ssc_p->pid);
+
+		/* Reset the SSC */
+		at91_ssc_write(ssc_p->ssc_base + AT91_SSC_CR, AT91_SSC_SWRST);
+
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_RPR, 0);
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_RCR, 0);
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_RNPR, 0);
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_RNCR, 0);
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_TPR, 0);
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_TCR, 0);
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_TNPR, 0);
+		at91_ssc_write(ssc_p->ssc_base + AT91_PDC_TNCR, 0);
+
+		mck_clk = clk_get(NULL, "mck");
+
+		div = rtd->cpu_dai->dai_runtime.priv >> 16;
+		period = rtd->cpu_dai->dai_runtime.priv & 0xffff;
+		bclk = 60000000 / (2 * div);
+
+		DBG("mck %ld fsbd %d bfs %d bfs_real %d bclk %ld div %d period %d\n",
+			clk_get_rate(mck_clk),
+			SND_SOC_FSBD(6),
+			rtd->cpu_dai->dai_runtime.bfs,
+			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs),
+			bclk,
+			div,
+			period);
+
+		clk_put(mck_clk);
+
+		at91_ssc_write(ssc_p->ssc_base + AT91_SSC_CMR, div);
+
+		/*
+		 * Setup the TFMR and RFMR for the proper data format.
+		 */
+		tfmr =
+		  (( AT91_SSC_FSEDGE_POSITIVE	     ) & AT91_SSC_FSEDGE)
+		| (( 0				<< 23) & AT91_SSC_FSDEN)
+		| (( AT91_SSC_FSOS_NEGATIVE	     ) & AT91_SSC_FSOS)
+		| (((bits - 1)			<< 16) & AT91_SSC_FSLEN)
+		| (((channels - 1)		<<  8) & AT91_SSC_DATNB)
+		| (( 1				<<  7) & AT91_SSC_MSBF)
+		| (( 0				<<  5) & AT91_SSC_DATDEF)
+		| (((bits - 1)			<<  0) & AT91_SSC_DATALEN);
+		DBG("SSC_TFMR=0x%08x\n", tfmr);
+		at91_ssc_write(ssc_p->ssc_base + AT91_SSC_TFMR, tfmr);
+
+		rfmr =
+		  (( AT91_SSC_FSEDGE_POSITIVE	     ) & AT91_SSC_FSEDGE)
+		| (( AT91_SSC_FSOS_NONE		     ) & AT91_SSC_FSOS)
+		| (( 0				<< 16) & AT91_SSC_FSLEN)
+		| (((channels - 1)		<<  8) & AT91_SSC_DATNB)
+		| (( 1				<<  7) & AT91_SSC_MSBF)
+		| (( 0				<<  5) & AT91_SSC_LOOP)
+		| (((bits - 1)			<<  0) & AT91_SSC_DATALEN);
+
+		DBG("SSC_RFMR=0x%08x\n", rfmr);
+		at91_ssc_write(ssc_p->ssc_base + AT91_SSC_RFMR, rfmr);
+
+		/*
+		 * Setup the TCMR and RCMR to generate the proper BCLK
+		 * and LRC signals.
+		 */
+		tcmr =
+		  (( period			<< 24) & AT91_SSC_PERIOD)
+		| (( 1				<< 16) & AT91_SSC_STTDLY)
+		| (( AT91_SSC_START_FALLING_RF       ) & AT91_SSC_START)
+		| (( AT91_SSC_CKI_FALLING	     ) & AT91_SSC_CKI)
+		| (( AT91_SSC_CKO_CONTINUOUS	     ) & AT91_SSC_CKO)
+		| (( AT91_SSC_CKS_DIV		     ) & AT91_SSC_CKS);
+
+		DBG("SSC_TCMR=0x%08x\n", tcmr);
+		at91_ssc_write(ssc_p->ssc_base + AT91_SSC_TCMR, tcmr);
+
+		rcmr =
+		  (( 0				<< 24) & AT91_SSC_PERIOD)
+		| (( 1				<< 16) & AT91_SSC_STTDLY)
+		| (( AT91_SSC_START_TX_RX	     ) & AT91_SSC_START)
+		| (( AT91_SSC_CK_RISING		     ) & AT91_SSC_CKI)
+		| (( AT91_SSC_CKO_NONE		     ) & AT91_SSC_CKO)
+		| (( AT91_SSC_CKS_CLOCK		     ) & AT91_SSC_CKS);
+
+		DBG("SSC_RCMR=0x%08x\n", rcmr);
+		at91_ssc_write(ssc_p->ssc_base + AT91_SSC_RCMR, rcmr);
+
+		if ((ret = request_irq(ssc_p->pid, at91rm9200_i2s_interrupt,
+					0, ssc_p->name, ssc_p)) < 0) {
+			printk(KERN_WARNING "at91rm9200-i2s: request_irq failure\n");
+			return ret;
+		}
+
+		/*
+		 * Save the current substream parameters in order to check
+		 * that the substream in the opposite direction uses the
+		 * same parameters.
+		 */
+		ssc_p->pcmfmt = pcmfmt;
+		ssc_p->rate = rate;
+		ssc_p->initialized = 1;
+
+		DBG("hw_params: SSC initialized\n");
+	}
+
+	up(ssc_p->mutex);
+
+	return 0;
+}
+
+
+static int at91rm9200_i2s_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	at91rm9200_pcm_dma_params_t *dma_params = rtd->cpu_dai->dma_data;
+
+	at91_ssc_write(dma_params->ssc->cr, dma_params->mask->ssc_enable);
+
+	DBG("%s enabled SSC_SR=0x%08lx\n",
+	substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "transmit" : "receive",
+	at91_ssc_read(ssc_info[rtd->cpu_dai->id].ssc_base + AT91_SSC_SR));
+	return 0;
+}
+
+
+struct snd_soc_cpu_dai at91rm9200_i2s_dai[] = {
+	{	.name = "at91rm9200-ssc0/i2s",
+		.id = 0,
+		.type = SND_SOC_DAI_I2S,
+		.suspend = at91rm9200_i2s_suspend,
+		.resume = at91rm9200_i2s_resume,
+		.config_sysclk = at91rm9200_i2s_config_sysclk,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.ops = {
+			.startup = at91rm9200_i2s_startup,
+			.shutdown = at91rm9200_i2s_shutdown,
+			.prepare = at91rm9200_i2s_prepare,
+			.hw_params = at91rm9200_i2s_hw_params,},
+		.caps = {
+			.mode = &at91rm9200_i2s[0],
+			.num_modes = ARRAY_SIZE(at91rm9200_i2s),},
+	},
+	{	.name = "at91rm9200-ssc1/i2s",
+		.id = 1,
+		.type = SND_SOC_DAI_I2S,
+		.suspend = at91rm9200_i2s_suspend,
+		.resume = at91rm9200_i2s_resume,
+		.config_sysclk = at91rm9200_i2s_config_sysclk,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.ops = {
+			.startup = at91rm9200_i2s_startup,
+			.shutdown = at91rm9200_i2s_shutdown,
+			.prepare = at91rm9200_i2s_prepare,
+			.hw_params = at91rm9200_i2s_hw_params,},
+		.caps = {
+			.mode = &at91rm9200_i2s[0],
+			.num_modes = ARRAY_SIZE(at91rm9200_i2s),},
+	},
+	{	.name = "at91rm9200-ssc2/i2s",
+		.id = 2,
+		.type = SND_SOC_DAI_I2S,
+		.suspend = at91rm9200_i2s_suspend,
+		.resume = at91rm9200_i2s_resume,
+		.config_sysclk = at91rm9200_i2s_config_sysclk,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,},
+		.ops = {
+			.startup = at91rm9200_i2s_startup,
+			.shutdown = at91rm9200_i2s_shutdown,
+			.prepare = at91rm9200_i2s_prepare,
+			.hw_params = at91rm9200_i2s_hw_params,},
+		.caps = {
+			.mode = &at91rm9200_i2s[0],
+			.num_modes = ARRAY_SIZE(at91rm9200_i2s),},
+	},
+};
+
+EXPORT_SYMBOL_GPL(at91rm9200_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Frank Mandarino, fmandarino@endrelia.com, www.endrelia.com");
+MODULE_DESCRIPTION("AT91RM9200 I2S ASoC Interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/at91/at91rm9200-pcm.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/at91/at91rm9200-pcm.c
@@ -0,0 +1,428 @@
+/*
+ * at91rm9200-pcm.c -- ALSA PCM interface for the Atmel AT91RM9200 chip.
+ *
+ * Author:	Frank Mandarino <fmandarino@endrelia.com>
+ *		Endrelia Technologies Inc.
+ * Created:	Mar 3, 2006
+ *
+ * Based on pxa2xx-pcm.c by:
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/arch/at91rm9200.h>
+#include <asm/arch/at91rm9200_ssc.h>
+#include <asm/arch/at91rm9200_pdc.h>
+#include <asm/arch/hardware.h>
+
+#include "at91rm9200-pcm.h"
+
+#if 0
+#define	DBG(x...)	printk(KERN_INFO "at91rm9200-pcm: " x)
+#else
+#define	DBG(x...)
+#endif
+
+static const snd_pcm_hardware_t at91rm9200_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 32 * 1024,
+};
+
+struct at91rm9200_runtime_data {
+	at91rm9200_pcm_dma_params_t *params;
+	dma_addr_t dma_buffer;			/* physical address of dma buffer */
+	dma_addr_t dma_buffer_end;		/* first address beyond DMA buffer */
+	size_t period_size;
+	dma_addr_t period_ptr;			/* physical address of next period */
+	u32 pdc_xpr_save;			/* PDC register save */
+	u32 pdc_xcr_save;
+	u32 pdc_xnpr_save;
+	u32 pdc_xncr_save;
+};
+
+static void at91rm9200_pcm_dma_irq(u32 ssc_sr,
+	struct snd_pcm_substream *substream)
+{
+	struct at91rm9200_runtime_data *prtd = substream->runtime->private_data;
+	at91rm9200_pcm_dma_params_t *params = prtd->params;
+	static int count = 0;
+
+	count++;
+
+	if (ssc_sr & params->mask->ssc_endbuf) {
+
+		printk(KERN_WARNING
+			"at91rm9200-pcm: buffer %s on %s (SSC_SR=%#x, count=%d)\n",
+			substream->stream == SNDRV_PCM_STREAM_PLAYBACK
+				? "underrun" : "overrun",
+			params->name, ssc_sr, count);
+
+		/* re-start the PDC */
+		at91_ssc_write(params->pdc->ptcr, params->mask->pdc_disable);
+
+		prtd->period_ptr += prtd->period_size;
+		if (prtd->period_ptr >= prtd->dma_buffer_end) {
+			prtd->period_ptr = prtd->dma_buffer;
+		}
+
+		at91_ssc_write(params->pdc->xpr, prtd->period_ptr);
+		at91_ssc_write(params->pdc->xcr,
+				prtd->period_size / params->pdc_xfer_size);
+
+		at91_ssc_write(params->pdc->ptcr, params->mask->pdc_enable);
+	}
+
+	if (ssc_sr & params->mask->ssc_endx) {
+
+		/* Load the PDC next pointer and counter registers */
+		prtd->period_ptr += prtd->period_size;
+		if (prtd->period_ptr >= prtd->dma_buffer_end) {
+			prtd->period_ptr = prtd->dma_buffer;
+		}
+		at91_ssc_write(params->pdc->xnpr, prtd->period_ptr);
+		at91_ssc_write(params->pdc->xncr,
+				prtd->period_size / params->pdc_xfer_size);
+	}
+
+	snd_pcm_period_elapsed(substream);
+}
+
+static int at91rm9200_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct at91rm9200_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	prtd->params = rtd->cpu_dai->dma_data;
+	prtd->params->dma_intr_handler = at91rm9200_pcm_dma_irq;
+
+	prtd->dma_buffer = runtime->dma_addr;
+	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
+	prtd->period_size = params_period_bytes(params);
+
+	DBG("hw_params: DMA for %s initialized (dma_bytes=%d, period_size=%d)\n",
+		prtd->params->name, runtime->dma_bytes, prtd->period_size);
+	return 0;
+}
+
+static int at91rm9200_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct at91rm9200_runtime_data *prtd = substream->runtime->private_data;
+	at91rm9200_pcm_dma_params_t *params = prtd->params;
+
+	if (params != NULL) {
+		at91_ssc_write(params->pdc->ptcr, params->mask->pdc_disable);
+		prtd->params->dma_intr_handler = NULL;
+	}
+
+	return 0;
+}
+
+static int at91rm9200_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct at91rm9200_runtime_data *prtd = substream->runtime->private_data;
+	at91rm9200_pcm_dma_params_t *params = prtd->params;
+
+	at91_ssc_write(params->ssc->idr,
+			params->mask->ssc_endx | params->mask->ssc_endbuf);
+
+	at91_ssc_write(params->pdc->ptcr, params->mask->pdc_disable);
+	return 0;
+}
+
+static int at91rm9200_pcm_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	struct at91rm9200_runtime_data *prtd = substream->runtime->private_data;
+	at91rm9200_pcm_dma_params_t *params = prtd->params;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->period_ptr = prtd->dma_buffer;
+
+		at91_ssc_write(params->pdc->xpr, prtd->period_ptr);
+		at91_ssc_write(params->pdc->xcr,
+				prtd->period_size / params->pdc_xfer_size);
+
+		prtd->period_ptr += prtd->period_size;
+		at91_ssc_write(params->pdc->xnpr, prtd->period_ptr);
+		at91_ssc_write(params->pdc->xncr,
+				prtd->period_size / params->pdc_xfer_size);
+
+		DBG("trigger: period_ptr=%lx, xpr=%lx, xcr=%ld, xnpr=%lx, xncr=%ld\n",
+			(unsigned long) prtd->period_ptr,
+			at91_ssc_read(params->pdc->xpr),
+			at91_ssc_read(params->pdc->xcr),
+			at91_ssc_read(params->pdc->xnpr),
+			at91_ssc_read(params->pdc->xncr));
+
+		at91_ssc_write(params->ssc->ier,
+			params->mask->ssc_endx | params->mask->ssc_endbuf);
+
+		at91_ssc_write(params->pdc->ptcr, params->mask->pdc_enable);
+
+		DBG("sr=%lx imr=%lx\n", at91_ssc_read(params->ssc->ier - 4),
+					at91_ssc_read(params->ssc->ier + 8));
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		at91_ssc_write(params->pdc->ptcr, params->mask->pdc_disable);
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		at91_ssc_write(params->pdc->ptcr, params->mask->pdc_enable);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t at91rm9200_pcm_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct at91rm9200_runtime_data *prtd = runtime->private_data;
+	at91rm9200_pcm_dma_params_t *params = prtd->params;
+	dma_addr_t ptr;
+	snd_pcm_uframes_t x;
+
+	ptr = (dma_addr_t) at91_ssc_read(params->pdc->xpr);
+	x = bytes_to_frames(runtime, ptr - prtd->dma_buffer);
+
+	if (x == runtime->buffer_size)
+		x = 0;
+	return x;
+}
+
+static int at91rm9200_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct at91rm9200_runtime_data *prtd;
+	int ret = 0;
+
+	snd_soc_set_runtime_hwparams(substream, &at91rm9200_pcm_hardware);
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(struct at91rm9200_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	runtime->private_data = prtd;
+
+ out:
+	return ret;
+}
+
+static int at91rm9200_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct at91rm9200_runtime_data *prtd = substream->runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int at91rm9200_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops at91rm9200_pcm_ops = {
+	.open		= at91rm9200_pcm_open,
+	.close		= at91rm9200_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= at91rm9200_pcm_hw_params,
+	.hw_free	= at91rm9200_pcm_hw_free,
+	.prepare	= at91rm9200_pcm_prepare,
+	.trigger	= at91rm9200_pcm_trigger,
+	.pointer	= at91rm9200_pcm_pointer,
+	.mmap		= at91rm9200_pcm_mmap,
+};
+
+static int at91rm9200_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = at91rm9200_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+
+	DBG("preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
+		(void *) buf->area,
+		(void *) buf->addr,
+		size);
+
+	if (!buf->area)
+		return -ENOMEM;
+
+	buf->bytes = size;
+	return 0;
+}
+
+static u64 at91rm9200_pcm_dmamask = 0xffffffff;
+
+static int at91rm9200_pcm_new(struct snd_card *card,
+	struct snd_soc_codec_dai *dai, struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &at91rm9200_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = at91rm9200_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = at91rm9200_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+static void at91rm9200_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static int at91rm9200_pcm_suspend(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct at91rm9200_runtime_data *prtd;
+	at91rm9200_pcm_dma_params_t *params;
+
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* disable the PDC and save the PDC registers */
+
+	at91_ssc_write(params->pdc->ptcr, params->mask->pdc_disable);
+
+	prtd->pdc_xpr_save  = at91_ssc_read(params->pdc->xpr);
+	prtd->pdc_xcr_save  = at91_ssc_read(params->pdc->xcr);
+	prtd->pdc_xnpr_save = at91_ssc_read(params->pdc->xnpr);
+	prtd->pdc_xncr_save = at91_ssc_read(params->pdc->xncr);
+
+	return 0;
+}
+
+static int at91rm9200_pcm_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct at91rm9200_runtime_data *prtd;
+	at91rm9200_pcm_dma_params_t *params;
+
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* restore the PDC registers and enable the PDC */
+	at91_ssc_write(params->pdc->xpr,  prtd->pdc_xpr_save);
+	at91_ssc_write(params->pdc->xcr,  prtd->pdc_xcr_save);
+	at91_ssc_write(params->pdc->xnpr, prtd->pdc_xnpr_save);
+	at91_ssc_write(params->pdc->xncr, prtd->pdc_xncr_save);
+
+	at91_ssc_write(params->pdc->ptcr, params->mask->pdc_enable);
+	return 0;
+}
+
+struct snd_soc_platform at91rm9200_soc_platform = {
+	.name		= "at91rm9200-audio",
+	.pcm_ops 	= &at91rm9200_pcm_ops,
+	.pcm_new	= at91rm9200_pcm_new,
+	.pcm_free	= at91rm9200_pcm_free_dma_buffers,
+	.suspend	= at91rm9200_pcm_suspend,
+	.resume		= at91rm9200_pcm_resume,
+};
+
+EXPORT_SYMBOL_GPL(at91rm9200_soc_platform);
+
+MODULE_AUTHOR("Frank Mandarino <fmandarino@endrelia.com>");
+MODULE_DESCRIPTION("Atmel AT91RM9200 PCM module");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/at91/at91rm9200-pcm.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/at91/at91rm9200-pcm.h
@@ -0,0 +1,75 @@
+/*
+ * at91rm9200-pcm.h - ALSA PCM interface for the Atmel AT91RM9200 chip
+ *
+ * Author:	Frank Mandarino <fmandarino@endrelia.com>
+ *		Endrelia Technologies Inc.
+ * Created:	Mar 3, 2006
+ *
+ * Based on pxa2xx-pcm.h by:
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Registers and status bits that are required by the PCM driver.
+ */
+struct at91rm9200_ssc_regs {
+	void __iomem 	*cr;		/* SSC control */
+	void __iomem	*ier;		/* SSC interrupt enable */
+	void __iomem	*idr;		/* SSC interrupt disable */
+};
+
+struct at91rm9200_pdc_regs {
+	void __iomem	*xpr;		/* PDC recv/trans pointer */
+	void __iomem	*xcr;		/* PDC recv/trans counter */
+	void __iomem	*xnpr;		/* PDC next recv/trans pointer */
+	void __iomem	*xncr;		/* PDC next recv/trans counter */
+	void __iomem	*ptcr;		/* PDC transfer control */
+};
+
+struct at91rm9200_ssc_mask {
+	u32	ssc_enable;		/* SSC recv/trans enable */
+	u32	ssc_disable;		/* SSC recv/trans disable */
+	u32	ssc_endx;		/* SSC ENDTX or ENDRX */
+	u32	ssc_endbuf;		/* SSC TXBUFE or RXBUFF */
+	u32	pdc_enable;		/* PDC recv/trans enable */
+	u32	pdc_disable;		/* PDC recv/trans disable */
+};
+
+
+/*
+ * This structure, shared between the PCM driver and the interface,
+ * contains all information required by the PCM driver to perform the
+ * PDC DMA operation.  All fields except dma_intr_handler() are initialized
+ * by the interface.  The dms_intr_handler() pointer is set by the PCM
+ * driver and called by the interface SSC interrupt handler if it is
+ * non-NULL.
+ */
+typedef struct {
+	char *name;			/* stream identifier */
+	int pdc_xfer_size;		/* PDC counter increment in bytes */
+	struct at91rm9200_ssc_regs *ssc; /* SSC register addresses */
+	struct at91rm9200_pdc_regs *pdc; /* PDC receive/transmit registers */
+	struct at91rm9200_ssc_mask *mask;/* SSC & PDC status bits */
+	snd_pcm_substream_t *substream;
+	void (*dma_intr_handler)(u32, snd_pcm_substream_t *);
+} at91rm9200_pcm_dma_params_t;
+
+extern struct snd_soc_cpu_dai at91rm9200_i2s_dai[3];
+extern struct snd_soc_platform at91rm9200_soc_platform;
+
+
+/*
+ * SSC I/O helpers.
+ * E.g., at91_ssc_write(AT91_SSC(1) + AT91_SSC_CR, AT91_SSC_RXEN);
+ */
+#define AT91_SSC(x) (((x)==0) ? AT91_VA_BASE_SSC0 :\
+	 ((x)==1) ? AT91_VA_BASE_SSC1 : ((x)==2) ? AT91_VA_BASE_SSC2 : NULL)
+#define at91_ssc_read(a)	((unsigned long) __raw_readl(a))
+#define at91_ssc_write(a,v)	__raw_writel((v),(a))
Index: linux-2.6-pxa-new/sound/soc/imx/imx-ssi.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/imx-ssi.c
@@ -0,0 +1,452 @@
+/*
+ * imx-ssi.c  --  SSI driver for Freescale IMX
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Based on mxc-alsa-mc13783 (C) 2006 Freescale.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    29th Aug 2006   Initial version.
+ *
+ */
+
+#define IMX_DSP_DAIFMT \
+	( SND_SOC_DAIFMT_DSP__A |SND_SOC_DAIFMT_DSP_B  | \
+	SND_SOC_DAIFMT_CBS_CFS |SND_SOC_DAIFMT_CBM_CFS | \
+	SND_SOC_DAIFMT_CBS_CFM |SND_SOC_DAIFMT_NB_NF |\
+	SND_SOC_DAIFMT_NB_IF)
+
+#define IMX_DSP_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define IMX_DSP_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
+	SNDRV_PCM_RATE_96000)
+
+#define IMX_DSP_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_mode imx_dsp_pcm_modes[] = {
+
+	/* frame master and clock slave mode */
+	{IMX_DSP_DAIFMT | SND_SOC_DAIFMT_CBM_CFS,
+		SND_SOC_DAITDM_LRDW(0,0), IMX_DSP_BITS, IMX_DSP_RATES,
+		 IMX_DSP_DIR, 0, SND_SOC_FS_ALL,
+		 SND_SOC_FSB(32) | SND_SOC_FSB(32) | SND_SOC_FSB(16)},
+
+};
+
+static imx_pcm_dma_params_t imx_ssi1_pcm_stereo_out = {
+	.name			= "SSI1 PCM Stereo out",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = emi_2_per,
+		.watermark_level = SDMA_TXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI1_STX0,
+		.event_id = DMA_REQ_SSI1_TX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi1_pcm_stereo_in = {
+	.name			= "SSI1 PCM Stereo in",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_RXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI1_SRX0,
+		.event_id = DMA_REQ_SSI1_RX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi2_pcm_stereo_out = {
+	.name			= "SSI2 PCM Stereo out",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_TXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI2_STX0,
+		.event_id = DMA_REQ_SSI2_TX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi2_pcm_stereo_in = {
+	.name			= "SSI2 PCM Stereo in",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_RXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI2_SRX0,
+		.event_id = DMA_REQ_SSI2_RX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static int imx_dsp_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (!rtd->cpu_dai->active) {
+
+	}
+
+	return 0;
+}
+
+static int imx_ssi1_hw_tx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 bfs, div;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
+
+	SSI1_STCR = 0;
+	SSI1_STCCR = 0;
+
+	/* DAI mode */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_B:
+		SSI1_STCR |= SSI_STCR_TEFS; // data 1 bit after sync
+	case SND_SOC_DAIFMT_DSP_A:
+		SSI1_STCR |= SSI_STCR_TFSL; // frame is 1 bclk long
+		break;
+	}
+
+	/* DAI clock inversion */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		SSI1_STCR |= SSI_STCR_TFSI | SSI_STCR_TSCKP;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		SSI1_STCR |= SSI_STCR_TSCKP;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		SSI1_STCR |= SSI_STCR_TFSI;
+		break;
+	}
+
+	/* DAI data (word) size */
+	switch(rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		SSI1_STCCR |= SSI_STCCR_WL(16);
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		SSI1_STCCR |= SSI_STCCR_WL(20);
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		SSI1_STCCR |= SSI_STCCR_WL(24);
+		break;
+	}
+
+	/* DAI clock master masks */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:
+		SSI1_STCR |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		SSI1_STCR |= SSI_STCR_TFDIR;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		SSI1_STCR |= SSI_STCR_TXDIR;
+		break;
+	}
+
+	/* DAI BCLK ratio to SYSCLK / MCLK */
+	/* prescaler modulus - todo */
+	switch (bfs) {
+	case 2:
+		break;
+	case 4:
+		break;
+	case 8:
+		break;
+	case 16:
+		break;
+	}
+
+	/* TDM - todo, only fifo 0 atm */
+	SSI1_STCR |= SSI_STCR_TFEN0;
+	SSI1_STCCR |= SSI_STCCR_DC(params_channels(params));
+
+	return 0;
+}
+
+static int imx_ssi1_hw_rx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 bfs, div;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
+
+	SSI1_SRCR = 0;
+	SSI1_SRCCR = 0;
+
+	/* DAI mode */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_B:
+		SSI1_SRCR |= SSI_SRCR_REFS; // data 1 bit after sync
+	case SND_SOC_DAIFMT_DSP_A:
+		SSI1_SRCR |= SSI_SRCR_RFSL; // frame is 1 bclk long
+		break;
+	}
+
+	/* DAI clock inversion */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		SSI1_SRCR |= SSI_SRCR_TFSI | SSI_SRCR_TSCKP;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		SSI1_SRCR |= SSI_SRCR_RSCKP;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		SSI1_SRCR |= SSI_SRCR_RFSI;
+		break;
+	}
+
+	/* DAI data (word) size */
+	switch(rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		SSI1_SRCCR |= SSI_SRCCR_WL(16);
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		SSI1_SRCCR |= SSI_SRCCR_WL(20);
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		SSI1_SRCCR |= SSI_SRCCR_WL(24);
+		break;
+	}
+
+	/* DAI clock master masks */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:
+		SSI1_SRCR |= SSI_SRCR_RFDIR | SSI_SRCR_RXDIR;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		SSI1_SRCR |= SSI_SRCR_RFDIR;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		SSI1_SRCR |= SSI_SRCR_RXDIR;
+		break;
+	}
+
+	/* DAI BCLK ratio to SYSCLK / MCLK */
+	/* prescaler modulus - todo */
+	switch (bfs) {
+	case 2:
+		break;
+	case 4:
+		break;
+	case 8:
+		break;
+	case 16:
+		break;
+	}
+
+	/* TDM - todo, only fifo 0 atm */
+	SSI1_SRCR |= SSI_SRCR_RFEN0;
+	SSI1_SRCCR |= SSI_SRCCR_DC(params_channels(params));
+
+	return 0;
+}
+
+static int imx_ssi_dsp_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	/* clear register if not enabled */
+	if(!(SSI1_SCR & SSI_SCR_SSIEN))
+		SSI1_SCR = 0;
+
+	/* async */
+	if (rtd->cpu_dai->flags & SND_SOC_DAI_ASYNC)
+		SSI1_SCR |= SSI_SCR_SYN;
+
+	/* DAI mode */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_LEFT_J:
+		SSI1_SCR |= SSI_SCR_NET;
+		break;
+	}
+
+	/* TDM  - to complete */
+
+	/* Tx/Rx config */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		return imx_ssi1_dsp_hw_tx_params(substream, params);
+	} else {
+		return imx_ssi1_dsp_hw_rx_params(substream, params);
+	}
+}
+
+
+
+static int imx_ssi_dsp_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			SSI1_SCR |= SSI_SCR_TE;
+			SSI1_SIER |= SSI_SIER_TDMAE;
+		} else {
+			SSI1_SCR |= SSI_SCR_RE;
+			SSI1_SIER |= SSI_SIER_RDMAE;
+		}
+		SSI1_SCR |= SSI_SCR_SSIEN;
+
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSI1_SCR |= SSI_SCR_TE;
+		else
+			SSI1_SCR |= SSI_SCR_RE;
+	break
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSI1_SCR &= ~SSI_SCR_TE;
+		else
+			SSI1_SCR &= ~SSI_SCR_RE;
+	break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void imx_ssi_dsp_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	/* shutdown SSI */
+	if (!rtd->cpu_dai->active) {
+		if(rtd->cpu_dai->id == 0)
+			SSI1_SCR &= ~SSI_SCR_SSIEN;
+		else
+			SSI2_SCR &= ~SSI_SCR_SSIEN;
+	}
+}
+
+#ifdef CONFIG_PM
+static int imx_ssi_dsp_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if(!dai->active)
+		return 0;
+
+	if(rtd->cpu_dai->id == 0)
+		SSI1_SCR &= ~SSI_SCR_SSIEN;
+	else
+		SSI2_SCR &= ~SSI_SCR_SSIEN;
+
+	return 0;
+}
+
+static int imx_ssi_dsp_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if(!dai->active)
+		return 0;
+
+	if(rtd->cpu_dai->id == 0)
+		SSI1_SCR |= SSI_SCR_SSIEN;
+	else
+		SSI2_SCR |= SSI_SCR_SSIEN;
+
+	return 0;
+}
+
+#else
+#define imx_ssi_dsp_suspend	NULL
+#define imx_ssi_dsp_resume	NULL
+#endif
+
+static unsigned int imx_ssi_config_dsp_sysclk(struct snd_soc_cpu_dai *iface,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	return clk;
+}
+
+struct snd_soc_cpu_dai imx_ssi_dsp_dai = {
+	.name = "imx-dsp-1",
+	.id = 0,
+	.type = SND_SOC_DAI_PCM,
+	.suspend = imx_ssi_dsp_suspend,
+	.resume = imx_ssi_dsp_resume,
+	.config_sysclk = imx_ssi_config_dsp_sysclk,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.ops = {
+		.startup = imx_ssi_dsp_startup,
+		.shutdown = imx_ssi_dsp_shutdown,
+		.trigger = imx_ssi_trigger,
+		.hw_params = imx_ssi_dsp_hw_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(imx_dsp_modes),
+		.mode = imx_dsp_modes,},
+},
+{
+	.name = "imx-dsp-2",
+	.id = 1,
+	.type = SND_SOC_DAI_PCM,
+	.suspend = imx_ssi_dsp_suspend,
+	.resume = imx_ssi_dsp_resume,
+	.config_sysclk = imx_ssi_config_dsp_sysclk,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.ops = {
+		.startup = imx_dsp_startup,
+		.shutdown = imx_dsp_shutdown,
+		.trigger = imx_ssi1_trigger,
+		.hw_params = imx_ssi1_pcm_hw_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(imx_dsp_modes),
+		.mode = imx_dsp_modes,},
+};
+
+
+EXPORT_SYMBOL_GPL(imx_ssi_dsp_dai);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("i.MX ASoC SSI driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/imx/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/Kconfig
@@ -0,0 +1,31 @@
+menu "SoC Audio for the Freescale i.MX"
+
+config SND_MXC_SOC
+	tristate "SoC Audio for the Freescale i.MX CPU"
+	depends on ARCH_MXC && SND
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the MXC AC97, I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_MXC_AC97
+	tristate
+	select SND_AC97_CODEC
+
+config SND_MXC_SOC_AC97
+	tristate
+	select SND_AC97_BUS
+
+config SND_MXC_SOC_SSI
+	tristate
+
+config SND_MXC_SOC_MX3_WM8753
+	tristate "SoC Audio support for MX31 - WM8753"
+	depends on SND_MXC_SOC && ARCH_MX3
+	select SND_MXC_SOC_SSI
+	help
+	  Say Y if you want to add support for SoC audio on MX31ADS
+	  with the WM8753.
+
+endmenu
Index: linux-2.6-pxa-new/sound/soc/imx/Makefile
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/Makefile
@@ -0,0 +1,18 @@
+# i.MX Platform Support
+snd-soc-imx21-objs := imx21-pcm.o
+snd-soc-imx31-objs := imx31-pcm.o
+snd-soc-imx-ac97-objs := imx-ac97.o
+snd-soc-imx-i2s-objs := imx-i2s.o
+
+obj-$(CONFIG_SND_MXC_SOC) += snd-soc-imx.o
+obj-$(CONFIG_SND_MXC_SOC_AC97) += snd-soc-imx-ac97.o
+obj-$(CONFIG_SND_MXC_SOC_I2S) += snd-soc-imx-i2s.o
+
+# i.MX Machine Support
+snd-soc-mx31ads-wm8753-objs := mx31ads_wm8753.o
+obj-$(CONFIG_SND_SOC_MX31ADS_WM8753) += snd-soc-mx31ads-wm8753.o
+snd-soc-mx21ads-wm8753-objs := mx21ads_wm8753.o
+obj-$(CONFIG_SND_SOC_MX21ADS_WM8753) += snd-soc-mx21ads-wm8753.o
+snd-soc-mx21ads-wm8731-objs := mx21ads_wm8731.o
+obj-$(CONFIG_SND_SOC_MX21ADS_WM8731) += snd-soc-mx21ads-wm8731.o
+
Index: linux-2.6-pxa-new/sound/Makefile
===================================================================
--- linux-2.6-pxa-new.orig/sound/Makefile
+++ linux-2.6-pxa-new/sound/Makefile
@@ -5,7 +5,7 @@ obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_SOUND_PRIME) += sound_firmware.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/
+obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/ soc/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 ifeq ($(CONFIG_SND),y)
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8711.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8711.c
@@ -0,0 +1,843 @@
+/*
+ * wm8711.c  --  WM8711 ALSA SoC Audio driver
+ *
+ * Copyright 2006 Wolfson Microelectronics
+ *
+ * Author: Mike Arthur <linux@wolfsonmicro.com>
+ *
+ * Based on wm8711.c by Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8711.h"
+
+#define AUDIO_NAME "wm8711"
+#define WM8711_VERSION "0.2"
+
+/*
+ * Debug
+ */
+
+#define WM8711_DEBUG 0
+
+#ifdef WM8711_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+struct snd_soc_codec_device soc_codec_dev_wm8711;
+
+/*
+ * wm8711 register cache
+ * We can't read the WM8711 register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ * There is no point in caching the reset register
+ */
+static const u16 wm8711_reg[WM8711_CACHEREGNUM] = {
+    0x0079, 0x0079, 0x000a, 0x0008,
+    0x009f, 0x000a, 0x0000, 0x0000
+};
+
+#define WM8711_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF)
+
+#define WM8711_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK)
+
+#define WM8711_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define WM8711_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE | \
+	SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_mode wm8711_modes[] = {
+	/* codec frame and clock master modes */
+	/* 8k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 1536,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 2304,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 1408,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 2112,
+		.bfs = 64,
+	},
+
+	/* 32k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_32000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 576,
+		.bfs = 64,
+	},
+
+	/* 44.1k & 48k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 256,
+		.bfs = 64,
+	},
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 64,
+	},
+
+	/* 88.2 & 96k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 128,
+		.bfs = 64,
+
+	},
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 192,
+		.bfs = 64,
+	},
+
+	/* USB codec frame and clock master modes */
+	/* 8k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_8000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 1500,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 44.1k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 272,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 48k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_48000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 250,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 88.2k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_88200,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 136,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* 96k */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = SNDRV_PCM_RATE_96000,
+		.pcmdir = WM8711_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 125,
+		.bfs = SND_SOC_FSBD(1),
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8711_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8711_HIFI_BITS,
+		.pcmrate = WM8711_RATES,
+		.pcmdir = WM8711_DIR,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8711 register cache
+ */
+static inline unsigned int wm8711_read_reg_cache(struct snd_soc_codec * codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == WM8711_RESET)
+		return 0;
+	if (reg >= WM8711_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8711 register cache
+ */
+static inline void wm8711_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= WM8711_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8711 register space
+ */
+static int wm8711_write(struct snd_soc_codec * codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8753 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8711_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8711_reset(c)	wm8711_write(c, WM8711_RESET, 0)
+
+static const struct snd_kcontrol_new wm8711_snd_controls[] = {
+
+SOC_DOUBLE_R("Master Playback Volume", WM8711_LOUT1V, WM8711_ROUT1V,
+	0, 127, 0),
+SOC_DOUBLE_R("Master Playback ZC Switch", WM8711_LOUT1V, WM8711_ROUT1V,
+	7, 1, 0),
+
+};
+
+/* add non dapm controls */
+static int wm8711_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8711_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8711_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Output Mixer */
+static const snd_kcontrol_new_t wm8711_output_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8711_APANA, 3, 1, 0),
+SOC_DAPM_SINGLE("HiFi Playback Switch", WM8711_APANA, 4, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget wm8711_dapm_widgets[] = {
+SND_SOC_DAPM_MIXER("Output Mixer", WM8711_PWR, 4, 1,
+	&wm8711_output_mixer_controls[0],
+	ARRAY_SIZE(wm8711_output_mixer_controls)),
+SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8711_PWR, 3, 1),
+SND_SOC_DAPM_OUTPUT("LOUT"),
+SND_SOC_DAPM_OUTPUT("LHPOUT"),
+SND_SOC_DAPM_OUTPUT("ROUT"),
+SND_SOC_DAPM_OUTPUT("RHPOUT"),
+};
+
+static const char *intercon[][3] = {
+	/* output mixer */
+	{"Output Mixer", "Line Bypass Switch", "Line Input"},
+	{"Output Mixer", "HiFi Playback Switch", "DAC"},
+
+	/* outputs */
+	{"RHPOUT", NULL, "Output Mixer"},
+	{"ROUT", NULL, "Output Mixer"},
+	{"LHPOUT", NULL, "Output Mixer"},
+	{"LOUT", NULL, "Output Mixer"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8711_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8711_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8711_dapm_widgets[i]);
+	}
+
+	/* set up audio path interconnects */
+	for(i = 0; intercon[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, intercon[i][0], intercon[i][1],
+			intercon[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:4;
+	u8 bosr:1;
+	u8 usb:1;
+};
+
+/* codec mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 48k */
+	{12288000, 48000, 256, 0x0, 0x0, 0x0},
+	{18432000, 48000, 384, 0x0, 0x1, 0x0},
+	{12000000, 48000, 250, 0x0, 0x0, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0x6, 0x0, 0x0},
+	{18432000, 32000, 576, 0x6, 0x1, 0x0},
+
+	/* 8k */
+	{12288000, 8000, 1536, 0x3, 0x0, 0x0},
+	{18432000, 8000, 2304, 0x3, 0x1, 0x0},
+	{11289600, 8000, 1408, 0xb, 0x0, 0x0},
+	{16934400, 8000, 2112, 0xb, 0x1, 0x0},
+	{12000000, 8000, 1500, 0x3, 0x0, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0x7, 0x0, 0x0},
+	{18432000, 96000, 192, 0x7, 0x1, 0x0},
+	{12000000, 96000, 125, 0x7, 0x0, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x8, 0x0, 0x0},
+	{16934400, 44100, 384, 0x8, 0x1, 0x0},
+	{12000000, 44100, 272, 0x8, 0x1, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0xf, 0x0, 0x0},
+	{16934400, 88200, 192, 0xf, 0x1, 0x0},
+	{12000000, 88200, 136, 0xf, 0x1, 0x1},
+};
+
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+	return 0;
+}
+
+/* WM8711 supports numerous clocks per sample rate */
+static unsigned int wm8711_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	dai->mclk = 0;
+
+	/* check that the calculated FS and rate actually match a clock from
+	 * the machine driver */
+	if (info->fs * info->rate == clk)
+		dai->mclk = clk;
+
+	return dai->mclk;
+}
+
+static int wm8711_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 iface = 0, srate;
+	int i = get_coeff(rtd->codec_dai->mclk,
+		snd_soc_get_rate(rtd->codec_dai->dai_runtime.pcmrate));
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+	srate = (coeff_div[i].sr << 2) | (coeff_div[i].bosr << 1) |
+		coeff_div[i].usb;
+	wm8711_write(codec, WM8711_SRATE, srate);
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		iface |= 0x0004;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iface |= 0x0008;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		iface |= 0x000c;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	}
+
+	/* set iface */
+	wm8711_write(codec, WM8711_IFACE, iface);
+
+    /* set active */
+    wm8711_write(codec, WM8711_ACTIVE, 0x0001);
+    return 0;
+}
+
+static void wm8711_shutdown(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_device *socdev = rtd->socdev;
+    struct snd_soc_codec *codec = socdev->codec;
+
+    /* deactivate */
+    if (!codec->active) {
+        udelay(50);
+        wm8711_write(codec, WM8711_ACTIVE, 0x0);
+    }
+}
+
+static int wm8711_mute(struct snd_soc_codec *codec,
+    struct snd_soc_codec_dai *dai, int mute)
+{
+    u16 mute_reg = wm8711_read_reg_cache(codec, WM8711_APDIGI) & 0xfff7;
+    if (mute)
+        wm8711_write(codec, WM8711_APDIGI, mute_reg | 0x8);
+    else
+        wm8711_write(codec, WM8711_APDIGI, mute_reg);
+
+	return 0;
+}
+
+static int wm8711_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 reg = wm8711_read_reg_cache(codec, WM8711_PWR) & 0xff7f;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* vref/mid, osc on, dac unmute */
+		wm8711_write(codec, WM8711_PWR, reg);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, */
+		wm8711_write(codec, WM8711_PWR, reg | 0x0040);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, dac mute, inactive */
+		wm8711_write(codec, WM8711_ACTIVE, 0x0);
+		wm8711_write(codec, WM8711_PWR, 0xffff);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8711_dai = {
+	.name = "WM8711",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = wm8711_config_sysclk,
+	.digital_mute = wm8711_mute,
+	.ops = {
+		.prepare = wm8711_pcm_prepare,
+        .shutdown = wm8711_shutdown,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8711_modes),
+		.mode = wm8711_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8711_dai);
+
+static int wm8711_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8711_write(codec, WM8711_ACTIVE, 0x0);
+	wm8711_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8711_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8711_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8711_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8711_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8711 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8711_init(struct snd_soc_device* socdev)
+{
+	struct snd_soc_codec* codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8711";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8711_read_reg_cache;
+	codec->write = wm8711_write;
+	codec->dapm_event = wm8711_dapm_event;
+	codec->dai = &wm8711_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8711_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8711_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8711_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8711_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8711_reg);
+
+	wm8711_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	wm8711_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* set the update bits */
+	reg = wm8711_read_reg_cache(codec, WM8711_LOUT1V);
+	wm8711_write(codec, WM8711_LOUT1V, reg | 0x0100);
+	reg = wm8711_read_reg_cache(codec, WM8711_ROUT1V);
+	wm8711_write(codec, WM8711_ROUT1V, reg | 0x0100);
+
+	wm8711_add_controls(codec);
+	wm8711_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+    if (ret < 0) {
+        snd_soc_free_pcms(socdev);
+        snd_soc_dapm_free(socdev);
+    }
+
+	return ret;
+}
+
+static struct snd_soc_device *wm8711_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8711 2 wire address is determined by GPIO5
+ * state during powerup.
+ *    low  = 0x1a
+ *    high = 0x1b
+ */
+#define I2C_DRIVERID_WM8711 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8711_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int wm8711_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8711_socdev;
+	struct wm8711_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+
+	i2c_set_clientdata(i2c, codec);
+
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+        goto err;
+    }
+
+	ret = wm8711_init(socdev);
+    if (ret < 0) {
+        err("failed to initialise WM8711\n");
+        goto err;
+    }
+    return ret;
+
+err:
+    kfree(codec);
+    kfree(i2c);
+    return ret;
+
+}
+
+static int wm8711_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec* codec = i2c_get_clientdata(client);
+
+	i2c_detach_client(client);
+
+	kfree(codec->reg_cache);
+	kfree(client);
+
+	return 0;
+}
+
+static int wm8711_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8711_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8711_i2c_driver = {
+	.driver = {
+		.name = "WM8711 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8711,
+	.attach_adapter = wm8711_i2c_attach,
+	.detach_client =  wm8711_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8711",
+	.driver = &wm8711_i2c_driver,
+};
+#endif
+
+static int wm8711_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8711_setup_data *setup;
+	struct snd_soc_codec* codec;
+	int ret = 0;
+
+	info("WM8711 Audio Codec %s", WM8711_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8711_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8711_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8711_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8711_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8711_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8711 = {
+	.probe = 	wm8711_probe,
+	.remove = 	wm8711_remove,
+	.suspend = 	wm8711_suspend,
+	.resume =	wm8711_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8711);
+
+MODULE_DESCRIPTION("ASoC WM8711 driver");
+MODULE_AUTHOR("Mike Arthur");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8711.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8711.h
@@ -0,0 +1,39 @@
+/*
+ * wm8711.h  --  WM8711 Soc Audio driver
+ *
+ * Copyright 2006 Wolfson Microelectronics
+ *
+ * Author: Mike Arthur <linux@wolfsonmicro.com>
+ *
+ * Based on wm8731.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8711_H
+#define _WM8711_H
+
+/* WM8711 register space */
+
+#define WM8711_LOUT1V   0x02
+#define WM8711_ROUT1V   0x03
+#define WM8711_APANA    0x04
+#define WM8711_APDIGI   0x05
+#define WM8711_PWR      0x06
+#define WM8711_IFACE    0x07
+#define WM8711_SRATE    0x08
+#define WM8711_ACTIVE   0x09
+#define WM8711_RESET	0x0f
+
+#define WM8711_CACHEREGNUM 	8
+
+struct wm8711_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8711_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8711;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8980.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8980.c
@@ -0,0 +1,991 @@
+/*
+ * wm8980.c  --  WM8980 ALSA Soc Audio driver
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ *
+ * Authors:
+ * Mike Arthur      <linux@wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8980.h"
+
+#define AUDIO_NAME "wm8980"
+#define WM8980_VERSION "0.2"
+
+/*
+ * Debug
+ */
+
+#define WM8980_DEBUG 0
+
+#ifdef WM8980_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+struct snd_soc_codec_device soc_codec_dev_wm8980;
+
+/*
+ * wm8980 register cache
+ * We can't read the WM8980 register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8980_reg[WM8980_CACHEREGNUM] = {
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0050, 0x0000, 0x0140, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x00ff,
+    0x00ff, 0x0000, 0x0100, 0x00ff,
+    0x00ff, 0x0000, 0x012c, 0x002c,
+    0x002c, 0x002c, 0x002c, 0x0000,
+    0x0032, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0038, 0x000b, 0x0032, 0x0000,
+    0x0008, 0x000c, 0x0093, 0x00e9,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0033, 0x0010, 0x0010, 0x0100,
+    0x0100, 0x0002, 0x0001, 0x0001,
+    0x0039, 0x0039, 0x0039, 0x0039,
+    0x0001, 0x0001,
+};
+
+#define WM8980_DAIFMT \
+	(SND_SOC_DAIFMT_I2S  | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+    SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_DSP_B  | SND_SOC_DAIFMT_NB_NF   | \
+    SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF  | SND_SOC_DAIFMT_IB_IF)
+
+#define WM8980_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8980_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+#define WM8980_PCM_FORMATS \
+	(SNDRV_PCM_FORMAT_S16_LE | SNDRV_PCM_FORMAT_S20_3LE | \
+	SNDRV_PCM_FORMAT_S24_3LE | SNDRV_PCM_FORMAT_S24_LE  | \
+    SNDRV_PCM_FORMAT_S32_LE)
+
+#define WM8980_BCLK \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | SND_SOC_FSBD(8) |\
+    SND_SOC_FSBD(16) | SND_SOC_FSBD(32))
+
+static struct snd_soc_dai_mode wm8980_modes[] = {
+	/* codec frame and clock master modes */
+	{
+		.fmt = WM8980_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8980_PCM_FORMATS,
+		.pcmrate = WM8980_RATES,
+		.pcmdir = WM8980_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = WM8980_BCLK,
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8980_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+        .pcmfmt = WM8980_PCM_FORMATS,
+        .pcmrate = WM8980_RATES,
+        .pcmdir = WM8980_DIR,
+        .fs = SND_SOC_FS_ALL,
+        .bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8980 register cache
+ */
+static inline unsigned int wm8980_read_reg_cache(struct snd_soc_codec  *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == WM8980_RESET)
+		return 0;
+	if (reg >= WM8980_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8980 register cache
+ */
+static inline void wm8980_write_reg_cache(struct snd_soc_codec  *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= WM8980_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8980 register space
+ */
+static int wm8980_write(struct snd_soc_codec  *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8980 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8980_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -1;
+}
+
+#define wm8980_reset(c)	wm8980_write(c, WM8980_RESET, 0)
+
+static const char *wm8980_companding[] = {"Off", "NC", "u-law", "A-law" };
+static const char *wm8980_deemp[] = {"None", "32kHz", "44.1kHz", "48kHz" };
+static const char *wm8980_eqmode[] = {"Capture", "Playback" };
+static const char *wm8980_bw[] = {"Narrow", "Wide" };
+static const char *wm8980_eq1[] = {"80Hz", "105Hz", "135Hz", "175Hz" };
+static const char *wm8980_eq2[] = {"230Hz", "300Hz", "385Hz", "500Hz" };
+static const char *wm8980_eq3[] = {"650Hz", "850Hz", "1.1kHz", "1.4kHz" };
+static const char *wm8980_eq4[] = {"1.8kHz", "2.4kHz", "3.2kHz", "4.1kHz" };
+static const char *wm8980_eq5[] = {"5.3kHz", "6.9kHz", "9kHz", "11.7kHz" };
+static const char *wm8980_alc[] =
+    {"ALC both on", "ALC left only", "ALC right only", "Limiter" };
+
+static const struct soc_enum wm8980_enum[] = {
+	SOC_ENUM_SINGLE(WM8980_COMP, 1, 4, wm8980_companding), /* adc */
+	SOC_ENUM_SINGLE(WM8980_COMP, 3, 4, wm8980_companding), /* dac */
+	SOC_ENUM_SINGLE(WM8980_DAC,  4, 4, wm8980_deemp),
+	SOC_ENUM_SINGLE(WM8980_EQ1,  8, 2, wm8980_eqmode),
+
+	SOC_ENUM_SINGLE(WM8980_EQ1,  5, 4, wm8980_eq1),
+	SOC_ENUM_SINGLE(WM8980_EQ2,  8, 2, wm8980_bw),
+	SOC_ENUM_SINGLE(WM8980_EQ2,  5, 4, wm8980_eq2),
+	SOC_ENUM_SINGLE(WM8980_EQ3,  8, 2, wm8980_bw),
+
+	SOC_ENUM_SINGLE(WM8980_EQ3,  5, 4, wm8980_eq3),
+	SOC_ENUM_SINGLE(WM8980_EQ4,  8, 2, wm8980_bw),
+	SOC_ENUM_SINGLE(WM8980_EQ4,  5, 4, wm8980_eq4),
+	SOC_ENUM_SINGLE(WM8980_EQ5,  8, 2, wm8980_bw),
+
+	SOC_ENUM_SINGLE(WM8980_EQ5,  5, 4, wm8980_eq5),
+	SOC_ENUM_SINGLE(WM8980_ALC3,  8, 2, wm8980_alc),
+};
+
+static const struct snd_kcontrol_new wm8980_snd_controls[] = {
+SOC_SINGLE("Digital Loopback Switch", WM8980_COMP, 0, 1, 0),
+
+SOC_ENUM("ADC Companding", wm8980_enum[0]),
+SOC_ENUM("DAC Companding", wm8980_enum[1]),
+
+SOC_SINGLE("Jack Detection Enable", WM8980_JACK1, 6, 1, 0),
+
+SOC_SINGLE("DAC Right Inversion Switch", WM8980_DAC, 1, 1, 0),
+SOC_SINGLE("DAC Left Inversion Switch", WM8980_DAC, 0, 1, 0),
+
+SOC_SINGLE("Left Playback Volume", WM8980_DACVOLL, 0, 127, 0),
+SOC_SINGLE("Right Playback Volume", WM8980_DACVOLR, 0, 127, 0),
+
+SOC_SINGLE("High Pass Filter Switch", WM8980_ADC, 8, 1, 0),
+SOC_SINGLE("High Pass Filter Switch", WM8980_ADC, 8, 1, 0),
+SOC_SINGLE("High Pass Cut Off", WM8980_ADC, 4, 7, 0),
+SOC_SINGLE("Right ADC Inversion Switch", WM8980_ADC, 1, 1, 0),
+SOC_SINGLE("Left ADC Inversion Switch", WM8980_ADC, 0, 1, 0),
+
+SOC_SINGLE("Left Capture Volume", WM8980_ADCVOLL,  0, 127, 0),
+SOC_SINGLE("Right Capture Volume", WM8980_ADCVOLR,  0, 127, 0),
+
+SOC_ENUM("Equaliser Function", wm8980_enum[3]),
+SOC_ENUM("EQ1 Cut Off", wm8980_enum[4]),
+SOC_SINGLE("EQ1 Volume", WM8980_EQ1,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ2 Bandwith", wm8980_enum[5]),
+SOC_ENUM("EQ2 Cut Off", wm8980_enum[6]),
+SOC_SINGLE("EQ2 Volume", WM8980_EQ2,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ3 Bandwith", wm8980_enum[7]),
+SOC_ENUM("EQ3 Cut Off", wm8980_enum[8]),
+SOC_SINGLE("EQ3 Volume", WM8980_EQ3,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ4 Bandwith", wm8980_enum[9]),
+SOC_ENUM("EQ4 Cut Off", wm8980_enum[10]),
+SOC_SINGLE("EQ4 Volume", WM8980_EQ4,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ5 Bandwith", wm8980_enum[11]),
+SOC_ENUM("EQ5 Cut Off", wm8980_enum[12]),
+SOC_SINGLE("EQ5 Volume", WM8980_EQ5,  0, 31, 1),
+
+SOC_SINGLE("DAC Playback Limiter Switch", WM8980_DACLIM1,  8, 1, 0),
+SOC_SINGLE("DAC Playback Limiter Decay", WM8980_DACLIM1,  4, 15, 0),
+SOC_SINGLE("DAC Playback Limiter Attack", WM8980_DACLIM1,  0, 15, 0),
+
+SOC_SINGLE("DAC Playback Limiter Threshold", WM8980_DACLIM2,  4, 7, 0),
+SOC_SINGLE("DAC Playback Limiter Boost", WM8980_DACLIM2,  0, 15, 0),
+
+SOC_SINGLE("ALC Enable Switch", WM8980_ALC1,  8, 1, 0),
+SOC_SINGLE("ALC Capture Max Gain", WM8980_ALC1,  3, 7, 0),
+SOC_SINGLE("ALC Capture Min Gain", WM8980_ALC1,  0, 7, 0),
+
+SOC_SINGLE("ALC Capture ZC Switch", WM8980_ALC2,  8, 1, 0),
+SOC_SINGLE("ALC Capture Hold", WM8980_ALC2,  4, 7, 0),
+SOC_SINGLE("ALC Capture Target", WM8980_ALC2,  0, 15, 0),
+
+SOC_ENUM("ALC Capture Mode", wm8980_enum[13]),
+SOC_SINGLE("ALC Capture Decay", WM8980_ALC3,  4, 15, 0),
+SOC_SINGLE("ALC Capture Attack", WM8980_ALC3,  0, 15, 0),
+
+SOC_SINGLE("ALC Capture Noise Gate Switch", WM8980_NGATE,  3, 1, 0),
+SOC_SINGLE("ALC Capture Noise Gate Threshold", WM8980_NGATE,  0, 7, 0),
+
+SOC_SINGLE("Left Capture PGA ZC Switch", WM8980_INPPGAL,  7, 1, 0),
+SOC_SINGLE("Left Capture PGA Volume", WM8980_INPPGAL,  0, 63, 0),
+
+SOC_SINGLE("Right Capture PGA ZC Switch", WM8980_INPPGAR,  7, 1, 0),
+SOC_SINGLE("Right Capture PGA Volume", WM8980_INPPGAR,  0, 63, 0),
+
+SOC_SINGLE("Left Headphone Playback ZC Switch", WM8980_HPVOLL,  7, 1, 0),
+SOC_SINGLE("Left Headphone Playback Switch", WM8980_HPVOLL,  6, 1, 1),
+SOC_SINGLE("Left Headphone Playback Volume", WM8980_HPVOLL,  0, 63, 0),
+
+SOC_SINGLE("Right Headphone Playback ZC Switch", WM8980_HPVOLR,  7, 1, 0),
+SOC_SINGLE("Right Headphone Playback Switch", WM8980_HPVOLR,  6, 1, 1),
+SOC_SINGLE("Right Headphone Playback Volume", WM8980_HPVOLR,  0, 63, 0),
+
+SOC_SINGLE("Left Speaker Playback ZC Switch", WM8980_SPKVOLL,  7, 1, 0),
+SOC_SINGLE("Left Speaker Playback Switch", WM8980_SPKVOLL,  6, 1, 1),
+SOC_SINGLE("Left Speaker Playback Volume", WM8980_SPKVOLL,  0, 63, 0),
+
+SOC_SINGLE("Right Speaker Playback ZC Switch", WM8980_SPKVOLR,  7, 1, 0),
+SOC_SINGLE("Right Speaker Playback Switch", WM8980_SPKVOLR,  6, 1, 1),
+SOC_SINGLE("Right Speaker Playback Volume", WM8980_SPKVOLR,  0, 63, 0),
+
+SOC_DOUBLE_R("Capture Boost(+20dB)", WM8980_ADCBOOSTL, WM8980_ADCBOOSTR,
+	8, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm8980_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8980_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8980_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Left Output Mixer */
+static const snd_kcontrol_new_t wm8980_left_mixer_controls[] = {
+SOC_DAPM_SINGLE("Right PCM Playback Switch", WM8980_OUTPUT, 6, 1, 1),
+SOC_DAPM_SINGLE("Left PCM Playback Switch", WM8980_MIXL, 0, 1, 1),
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8980_MIXL, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8980_MIXL, 5, 1, 0),
+};
+
+/* Right Output Mixer */
+static const snd_kcontrol_new_t wm8980_right_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left PCM Playback Switch", WM8980_OUTPUT, 5, 1, 1),
+SOC_DAPM_SINGLE("Right PCM Playback Switch", WM8980_MIXR, 0, 1, 1),
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8980_MIXR, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8980_MIXR, 5, 1, 0),
+};
+
+/* Left AUX Input boost vol */
+static const snd_kcontrol_new_t wm8980_laux_boost_controls =
+SOC_DAPM_SINGLE("Left Aux Volume", WM8980_ADCBOOSTL, 0, 3, 0);
+
+/* Right AUX Input boost vol */
+static const snd_kcontrol_new_t wm8980_raux_boost_controls =
+SOC_DAPM_SINGLE("Right Aux Volume", WM8980_ADCBOOSTR, 0, 3, 0);
+
+/* Left Input boost vol */
+static const snd_kcontrol_new_t wm8980_lmic_boost_controls =
+SOC_DAPM_SINGLE("Left Input Volume", WM8980_ADCBOOSTL, 4, 3, 0);
+
+/* Right Input boost vol */
+static const snd_kcontrol_new_t wm8980_rmic_boost_controls =
+SOC_DAPM_SINGLE("Right Input Volume", WM8980_ADCBOOSTR, 4, 3, 0);
+
+/* Left Aux In to PGA */
+static const snd_kcontrol_new_t wm8980_laux_capture_boost_controls =
+SOC_DAPM_SINGLE("Left Capture Switch", WM8980_ADCBOOSTL,  8, 1, 0);
+
+/* Right  Aux In to PGA */
+static const snd_kcontrol_new_t wm8980_raux_capture_boost_controls =
+SOC_DAPM_SINGLE("Right Capture Switch", WM8980_ADCBOOSTR,  8, 1, 0);
+
+/* Left Input P In to PGA */
+static const snd_kcontrol_new_t wm8980_lmicp_capture_boost_controls =
+SOC_DAPM_SINGLE("Left Input P Capture Boost Switch", WM8980_INPUT,  0, 1, 0);
+
+/* Right Input P In to PGA */
+static const snd_kcontrol_new_t wm8980_rmicp_capture_boost_controls =
+SOC_DAPM_SINGLE("Right Input P Capture Boost Switch", WM8980_INPUT,  4, 1, 0);
+
+/* Left Input N In to PGA */
+static const snd_kcontrol_new_t wm8980_lmicn_capture_boost_controls =
+SOC_DAPM_SINGLE("Left Input N Capture Boost Switch", WM8980_INPUT,  1, 1, 0);
+
+/* Right Input N In to PGA */
+static const snd_kcontrol_new_t wm8980_rmicn_capture_boost_controls =
+SOC_DAPM_SINGLE("Right Input N Capture Boost Switch", WM8980_INPUT,  5, 1, 0);
+
+// TODO Widgets
+static const struct snd_soc_dapm_widget wm8980_dapm_widgets[] = {
+#if 0
+//SND_SOC_DAPM_MUTE("Mono Mute", WM8980_MONOMIX, 6, 0),
+//SND_SOC_DAPM_MUTE("Speaker Mute", WM8980_SPKMIX, 6, 0),
+
+SND_SOC_DAPM_MIXER("Speaker Mixer", WM8980_POWER3, 2, 0,
+	&wm8980_speaker_mixer_controls[0],
+	ARRAY_SIZE(wm8980_speaker_mixer_controls)),
+SND_SOC_DAPM_MIXER("Mono Mixer", WM8980_POWER3, 3, 0,
+	&wm8980_mono_mixer_controls[0],
+	ARRAY_SIZE(wm8980_mono_mixer_controls)),
+SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8980_POWER3, 0, 0),
+SND_SOC_DAPM_ADC("ADC", "HiFi Capture", WM8980_POWER3, 0, 0),
+SND_SOC_DAPM_PGA("Aux Input", WM8980_POWER1, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkN Out", WM8980_POWER3, 5, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkP Out", WM8980_POWER3, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mono Out", WM8980_POWER3, 7, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mic PGA", WM8980_POWER2, 2, 0, NULL, 0),
+
+SND_SOC_DAPM_PGA("Aux Boost", SND_SOC_NOPM, 0, 0,
+	&wm8980_aux_boost_controls, 1),
+SND_SOC_DAPM_PGA("Mic Boost", SND_SOC_NOPM, 0, 0,
+	&wm8980_mic_boost_controls, 1),
+SND_SOC_DAPM_SWITCH("Capture Boost", SND_SOC_NOPM, 0, 0,
+	&wm8980_capture_boost_controls),
+
+SND_SOC_DAPM_MIXER("Boost Mixer", WM8980_POWER2, 4, 0, NULL, 0),
+
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8980_POWER1, 4, 0),
+
+SND_SOC_DAPM_INPUT("MICN"),
+SND_SOC_DAPM_INPUT("MICP"),
+SND_SOC_DAPM_INPUT("AUX"),
+SND_SOC_DAPM_OUTPUT("MONOOUT"),
+SND_SOC_DAPM_OUTPUT("SPKOUTP"),
+SND_SOC_DAPM_OUTPUT("SPKOUTN"),
+#endif
+};
+
+static const char *audio_map[][3] = {
+	/* Mono output mixer */
+	{"Mono Mixer", "PCM Playback Switch", "DAC"},
+	{"Mono Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Mono Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Speaker output mixer */
+	{"Speaker Mixer", "PCM Playback Switch", "DAC"},
+	{"Speaker Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Speaker Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Outputs */
+	{"Mono Out", NULL, "Mono Mixer"},
+	{"MONOOUT", NULL, "Mono Out"},
+	{"SpkN Out", NULL, "Speaker Mixer"},
+	{"SpkP Out", NULL, "Speaker Mixer"},
+	{"SPKOUTN", NULL, "SpkN Out"},
+	{"SPKOUTP", NULL, "SpkP Out"},
+
+	/* Boost Mixer */
+	{"Boost Mixer", NULL, "ADC"},
+	{"Capture Boost Switch", "Aux Capture Boost Switch", "AUX"},
+	{"Aux Boost", "Aux Volume", "Boost Mixer"},
+	{"Capture Boost", "Capture Switch", "Boost Mixer"},
+	{"Mic Boost", "Mic Volume", "Boost Mixer"},
+
+	/* Inputs */
+	{"MICP", NULL, "Mic Boost"},
+	{"MICN", NULL, "Mic PGA"},
+	{"Mic PGA", NULL, "Capture Boost"},
+	{"AUX", NULL, "Aux Input"},
+
+    /*  */
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8980_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8980_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8980_dapm_widgets[i]);
+	}
+
+	/* set up audio path map */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0], audio_map[i][1],
+            audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct pll_ {
+	unsigned int in_hz, out_hz;
+	unsigned int pre:4; /* prescale - 1 */
+	unsigned int n:4;
+	unsigned int k;
+};
+
+struct pll_ pll[] = {
+	{12000000, 11289600, 0, 7, 0x86c220},
+	{12000000, 12288000, 0, 8, 0x3126e8},
+	{13000000, 11289600, 0, 6, 0xf28bd4},
+	{13000000, 12288000, 0, 7, 0x8fd525},
+	{12288000, 11289600, 0, 7, 0x59999a},
+	{11289600, 12288000, 0, 8, 0x80dee9},
+	/* TODO: liam - add more entries */
+};
+
+static int set_pll(struct snd_soc_codec *codec, unsigned int in,
+	unsigned int out)
+{
+	int i;
+	u16 reg;
+
+	if(out == 0) {
+		reg = wm8980_read_reg_cache(codec, WM8980_POWER1);
+		wm8980_write(codec, WM8980_POWER1, reg & 0x1df);
+		return 0;
+	}
+
+	for(i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (in == pll[i].in_hz && out == pll[i].out_hz) {
+			wm8980_write(codec, WM8980_PLLN, (pll[i].pre << 4) | pll[i].n);
+			wm8980_write(codec, WM8980_PLLK1, pll[i].k >> 18);
+			wm8980_write(codec, WM8980_PLLK1, (pll[i].k >> 9) && 0x1ff);
+			wm8980_write(codec, WM8980_PLLK1, pll[i].k && 0x1ff);
+			reg = wm8980_read_reg_cache(codec, WM8980_POWER1);
+			wm8980_write(codec, WM8980_POWER1, reg | 0x020);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/* mclk dividers * 2 */
+static unsigned char mclk_div[] = {2, 3, 4, 6, 8, 12, 16, 24};
+
+/* we need 256FS to drive the DAC's and ADC's */
+static unsigned int wm8980_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	int i, j, best_clk = info->fs * info->rate;
+
+	/* can we run at this clk without the PLL ? */
+	for (i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if ((best_clk >> 1) * mclk_div[i] == clk) {
+			dai->pll_in = 0;
+			dai->clk_div = mclk_div[i];
+			dai->mclk = best_clk;
+			return dai->mclk;
+		}
+	}
+
+	/* now check for PLL support */
+	for (i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (pll[i].in_hz == clk) {
+			for (j = 0; j < ARRAY_SIZE(mclk_div); j++) {
+				if (pll[i].out_hz == mclk_div[j] * (best_clk >> 1)) {
+					dai->pll_in = clk;
+					dai->pll_out = pll[i].out_hz;
+					dai->clk_div = mclk_div[j];
+					dai->mclk = best_clk;
+					return dai->mclk;
+				}
+			}
+		}
+	}
+
+	/* this clk is not supported */
+	return 0;
+}
+
+static int wm8980_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *dai = rtd->codec_dai;
+	u16 iface = 0, bfs, clk = 0, adn;
+	int fs = 48000 << 7, i;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+	switch (bfs) {
+	case 2:
+		clk |= 0x1 << 2;
+		break;
+	case 4:
+		clk |= 0x2 << 2;
+		break;
+	case 8:
+		clk |= 0x3 << 2;
+		break;
+	case 16:
+		clk |= 0x4 << 2;
+		break;
+	case 32:
+		clk |= 0x5 << 2;
+		break;
+	}
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clk |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0010;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0008;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x00018;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		iface |= 0x0020;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		iface |= 0x0040;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		iface |= 0x0060;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0180;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0100;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0080;
+		break;
+	}
+
+	/* filter coefficient */
+	adn = wm8980_read_reg_cache(codec, WM8980_ADD) & 0x1f1;
+	switch (rtd->codec_dai->dai_runtime.pcmrate) {
+	case SNDRV_PCM_RATE_8000:
+		adn |= 0x5 << 1;
+		fs = 8000 << 7;
+		break;
+	case SNDRV_PCM_RATE_11025:
+		adn |= 0x4 << 1;
+		fs = 11025 << 7;
+		break;
+	case SNDRV_PCM_RATE_16000:
+		adn |= 0x3 << 1;
+		fs = 16000 << 7;
+		break;
+	case SNDRV_PCM_RATE_22050:
+		adn |= 0x2 << 1;
+		fs = 22050 << 7;
+		break;
+	case SNDRV_PCM_RATE_32000:
+		adn |= 0x1 << 1;
+		fs = 32000 << 7;
+		break;
+	case SNDRV_PCM_RATE_44100:
+		fs = 44100 << 7;
+		break;
+	}
+
+	/* do we need to enable the PLL */
+	if(dai->pll_in)
+		set_pll(codec, dai->pll_in, dai->pll_out);
+
+	/* divide the clock to 256 fs */
+	for(i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if (dai->clk_div == mclk_div[i]) {
+			clk |= i << 5;
+			clk &= 0xff;
+			goto set;
+		}
+	}
+
+set:
+	/* set iface */
+	wm8980_write(codec, WM8980_IFACE, iface);
+	wm8980_write(codec, WM8980_CLOCK, clk);
+
+	return 0;
+}
+
+static int wm8980_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	set_pll(codec, 0, 0);
+	return 0;
+}
+
+static int wm8980_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8980_read_reg_cache(codec, WM8980_DAC) & 0xffbf;
+	if(mute)
+		wm8980_write(codec, WM8980_DAC, mute_reg | 0x40);
+	else
+		wm8980_write(codec, WM8980_DAC, mute_reg);
+
+	return 0;
+}
+
+/* TODO: liam need to make this lower power with dapm */
+static int wm8980_dapm_event(struct snd_soc_codec *codec, int event)
+{
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* vref/mid, clk and osc on, dac unmute, active */
+		wm8980_write(codec, WM8980_POWER1, 0x1ff);
+		wm8980_write(codec, WM8980_POWER2, 0x1ff);
+		wm8980_write(codec, WM8980_POWER3, 0x1ff);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, dac mute, inactive */
+
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, dac mute, inactive */
+		wm8980_write(codec, WM8980_POWER1, 0x0);
+		wm8980_write(codec, WM8980_POWER2, 0x0);
+		wm8980_write(codec, WM8980_POWER3, 0x0);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8980_dai = {
+	.name = "WM8980 HiFi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.config_sysclk = wm8980_config_sysclk,
+	.digital_mute = wm8980_mute,
+	.ops = {
+		.prepare = wm8980_pcm_prepare,
+		.hw_free = wm8980_hw_free,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8980_modes),
+		.mode = wm8980_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8980_dai);
+
+static int wm8980_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8980_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8980_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8980_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8980_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8980_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8980 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8980_init(struct snd_soc_device* socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "WM8980";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8980_read_reg_cache;
+	codec->write = wm8980_write;
+	codec->dapm_event = wm8980_dapm_event;
+	codec->dai = &wm8980_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8980_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8980_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8980_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8980_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8980_reg);
+
+	wm8980_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	wm8980_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8980_add_controls(codec);
+	wm8980_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if(ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *wm8980_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8980 2 wire address is 0x1a
+ */
+#define I2C_DRIVERID_WM8980 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8980_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int wm8980_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8980_socdev;
+	struct wm8980_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+
+	i2c_set_clientdata(i2c, codec);
+
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if(ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8980_init(socdev);
+	if(ret < 0) {
+		err("failed to initialise WM8980\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+
+}
+
+static int wm8980_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+
+	i2c_detach_client(client);
+
+	kfree(codec->reg_cache);
+	kfree(client);
+
+	return 0;
+}
+
+static int wm8980_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8980_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8980_i2c_driver = {
+	.driver = {
+		.name = "WM8980 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8980,
+	.attach_adapter = wm8980_i2c_attach,
+	.detach_client =  wm8980_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8980",
+	.driver = &wm8980_i2c_driver,
+};
+#endif
+
+static int wm8980_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8980_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8980 Audio Codec %s", WM8980_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8980_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8980_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8980_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8980_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8980_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8980 = {
+	.probe = 	wm8980_probe,
+	.remove = 	wm8980_remove,
+	.suspend = 	wm8980_suspend,
+	.resume =	wm8980_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8980);
+
+MODULE_DESCRIPTION("ASoC WM8980 driver");
+MODULE_AUTHOR("Mike Arthur");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8980.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8980.h
@@ -0,0 +1,77 @@
+/*
+ * wm8980.h  --  WM8980 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8980_H
+#define _WM8980_H
+
+/* WM8980 register space */
+
+#define WM8980_RESET		0x0
+#define WM8980_POWER1		0x1
+#define WM8980_POWER2		0x2
+#define WM8980_POWER3		0x3
+#define WM8980_IFACE		0x4
+#define WM8980_COMP			0x5
+#define WM8980_CLOCK		0x6
+#define WM8980_ADD			0x7
+#define WM8980_GPIO			0x8
+#define WM8980_JACK1        0x9
+#define WM8980_DAC			0xa
+#define WM8980_DACVOLL	    0xb
+#define WM8980_DACVOLR      0xc
+#define WM8980_JACK2        0xd
+#define WM8980_ADC			0xe
+#define WM8980_ADCVOLL		0xf
+#define WM8980_ADCVOLR      0x10
+#define WM8980_EQ1			0x12
+#define WM8980_EQ2			0x13
+#define WM8980_EQ3			0x14
+#define WM8980_EQ4			0x15
+#define WM8980_EQ5			0x16
+#define WM8980_DACLIM1		0x18
+#define WM8980_DACLIM2		0x19
+#define WM8980_NOTCH1		0x1b
+#define WM8980_NOTCH2		0x1c
+#define WM8980_NOTCH3		0x1d
+#define WM8980_NOTCH4		0x1e
+#define WM8980_ALC1			0x20
+#define WM8980_ALC2			0x21
+#define WM8980_ALC3			0x22
+#define WM8980_NGATE		0x23
+#define WM8980_PLLN			0x24
+#define WM8980_PLLK1		0x25
+#define WM8980_PLLK2		0x26
+#define WM8980_PLLK3		0x27
+#define WM8980_VIDEO		0x28
+#define WM8980_3D           0x29
+#define WM8980_BEEP         0x2b
+#define WM8980_INPUT		0x2c
+#define WM8980_INPPGAL  	0x2d
+#define WM8980_INPPGAR      0x2e
+#define WM8980_ADCBOOSTL	0x2f
+#define WM8980_ADCBOOSTR    0x30
+#define WM8980_OUTPUT		0x31
+#define WM8980_MIXL	        0x32
+#define WM8980_MIXR         0x33
+#define WM8980_HPVOLL		0x34
+#define WM8980_HPVOLR       0x35
+#define WM8980_SPKVOLL      0x36
+#define WM8980_SPKVOLR      0x37
+#define WM8980_OUT3MIX		0x38
+#define WM8980_MONOMIX      0x39
+
+#define WM8980_CACHEREGNUM 	58
+
+struct wm8980_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8980_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8980;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/at91/eti_b1_wm8731.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/at91/eti_b1_wm8731.c
@@ -0,0 +1,230 @@
+/*
+ * eti_b1_wm8731  --  SoC audio for Endrelia ETI_B1.
+ *
+ * Author:	Frank Mandarino <fmandarino@endrelia.com>
+ *		Endrelia Technologies Inc.
+ * Created:	Mar 29, 2006
+ *
+ * Based on corgi.c by:
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Nov 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/at91rm9200.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/hardware.h>
+
+#include "../codecs/wm8731.h"
+#include "at91rm9200-pcm.h"
+
+#if 0
+#define	DBG(x...)	printk(KERN_INFO "eti_b1_wm8731:" x)
+#else
+#define	DBG(x...)
+#endif
+
+static struct clk *pck1_clk;
+static struct clk *pllb_clk;
+
+static int eti_b1_startup(snd_pcm_substream_t *substream)
+{
+	/* Start PCK1 clock. */
+	clk_enable(pck1_clk);
+	DBG("pck1 started\n");
+
+	return 0;
+}
+
+static void eti_b1_shutdown(snd_pcm_substream_t *substream)
+{
+	/* Stop PCK1 clock. */
+	clk_disable(pck1_clk);
+	DBG("pck1 stopped\n");
+}
+
+static struct snd_soc_ops eti_b1_ops = {
+	.startup = eti_b1_startup,
+	.shutdown = eti_b1_shutdown,
+};
+
+
+static const struct snd_soc_dapm_widget eti_b1_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+};
+
+static const char *intercon[][3] = {
+
+	/* speaker connected to LHPOUT */
+	{"Ext Spk", NULL, "LHPOUT"},
+
+	/* mic is connected to Mic Jack, with WM8731 Mic Bias */
+	{"MICIN", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Int Mic"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+/*
+ * Logic for a wm8731 as connected on a Endrelia ETI-B1 board.
+ */
+static int eti_b1_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	DBG("eti_b1_wm8731_init() called\n");
+
+	/* Add specific widgets */
+	for(i = 0; i < ARRAY_SIZE(eti_b1_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &eti_b1_dapm_widgets[i]);
+	}
+
+	/* Set up specific audio path interconnects */
+	for(i = 0; intercon[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, intercon[i][0],
+			intercon[i][1], intercon[i][2]);
+	}
+
+	/* not connected */
+	snd_soc_dapm_set_endpoint(codec, "RLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "LLINEIN", 0);
+
+	/* always connected */
+	snd_soc_dapm_set_endpoint(codec, "Int Mic", 1);
+	snd_soc_dapm_set_endpoint(codec, "Ext Spk", 1);
+
+	snd_soc_dapm_sync_endpoints(codec);
+
+	return 0;
+}
+
+unsigned int eti_b1_config_sysclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	if(info->bclk_master & SND_SOC_DAIFMT_CBS_CFS) {
+		return rtd->codec_dai->config_sysclk(rtd->codec_dai, info, 12000000);
+	}
+	return 0;
+}
+
+static struct snd_soc_dai_link eti_b1_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731",
+	.cpu_dai = &at91rm9200_i2s_dai[1],
+	.codec_dai = &wm8731_dai,
+	.init = eti_b1_wm8731_init,
+	.config_sysclk = eti_b1_config_sysclk,
+};
+
+static struct snd_soc_machine snd_soc_machine_eti_b1 = {
+	.name = "ETI_B1",
+	.dai_link = &eti_b1_dai,
+	.num_links = 1,
+	.ops = &eti_b1_ops,
+};
+
+static struct wm8731_setup_data eti_b1_wm8731_setup = {
+	.i2c_address = 0x1a,
+};
+
+static struct snd_soc_device eti_b1_snd_devdata = {
+	.machine = &snd_soc_machine_eti_b1,
+	.platform = &at91rm9200_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &eti_b1_wm8731_setup,
+};
+
+static struct platform_device *eti_b1_snd_device;
+
+static int __init eti_b1_init(void)
+{
+	int ret;
+	u32 ssc_pio_lines;
+
+	eti_b1_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!eti_b1_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(eti_b1_snd_device, &eti_b1_snd_devdata);
+	eti_b1_snd_devdata.dev = &eti_b1_snd_device->dev;
+
+	ret = platform_device_add(eti_b1_snd_device);
+	if (ret) {
+		platform_device_put(eti_b1_snd_device);
+		return ret;
+	}
+
+ 	ssc_pio_lines = AT91_PB6_TF1 | AT91_PB7_TK1 | AT91_PB8_TD1
+			| AT91_PB9_RD1 /* | AT91_PB10_RK1 | AT91_PB11_RF1 */;
+
+	/* Reset all PIO registers and assign lines to peripheral A */
+ 	at91_sys_write(AT91_PIOB + PIO_PDR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_ODR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_IFDR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_CODR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_IDR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_MDDR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_PUDR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_ASR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_OWDR, ssc_pio_lines);
+
+	/*
+	 * Set PCK1 parent to PLLB and its rate to 12 Mhz.
+	 */
+	pllb_clk = clk_get(NULL, "pllb");
+	pck1_clk = clk_get(NULL, "pck1");
+
+	clk_set_parent(pck1_clk, pllb_clk);
+	clk_set_rate(pck1_clk, 12000000);
+
+	DBG("MCLK rate %luHz\n", clk_get_rate(pck1_clk));
+
+	/* assign the GPIO pin to PCK1 */
+	at91_set_B_periph(AT91_PIN_PA24, 0);
+
+	return ret;
+}
+
+static void __exit eti_b1_exit(void)
+{
+	clk_put(pck1_clk);
+	clk_put(pllb_clk);
+
+	platform_device_unregister(eti_b1_snd_device);
+}
+
+module_init(eti_b1_init);
+module_exit(eti_b1_exit);
+
+/* Module information */
+MODULE_AUTHOR("Frank Mandarino <fmandarino@endrelia.com>");
+MODULE_DESCRIPTION("ALSA SoC ETI-B1-WM8731");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8510.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8510.c
@@ -0,0 +1,895 @@
+/*
+ * wm8510.c  --  WM8510 ALSA Soc Audio driver
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8510.h"
+
+#define AUDIO_NAME "wm8510"
+#define WM8510_VERSION "0.5"
+
+/*
+ * Debug
+ */
+
+#define WM8510_DEBUG 0
+
+#ifdef WM8510_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+struct snd_soc_codec_device soc_codec_dev_wm8510;
+
+/*
+ * wm8510 register cache
+ * We can't read the WM8510 register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8510_reg[WM8510_CACHEREGNUM] = {
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0050, 0x0000, 0x0140, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x00ff,
+    0x0000, 0x0000, 0x0100, 0x00ff,
+    0x0000, 0x0000, 0x012c, 0x002c,
+    0x002c, 0x002c, 0x002c, 0x0000,
+    0x0032, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0038, 0x000b, 0x0032, 0x0000,
+    0x0008, 0x000c, 0x0093, 0x00e9,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0003, 0x0010, 0x0000, 0x0000,
+    0x0000, 0x0002, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0039, 0x0000,
+    0x0000,
+};
+
+#define WM8510_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF | \
+	SND_SOC_DAIFMT_IB_IF)
+
+#define WM8510_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8510_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+#define WM8794_BCLK \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | SND_SOC_FSBD(8) |\
+	 SND_SOC_FSBD(16) | SND_SOC_FSBD(32))
+
+#define WM8794_HIFI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_mode wm8510_modes[] = {
+	/* codec frame and clock master modes */
+	{
+		.fmt = WM8510_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8794_HIFI_BITS,
+		.pcmrate = WM8510_RATES,
+		.pcmdir = WM8510_DIR,
+		.fs = 256,
+		.bfs = WM8794_BCLK,
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8510_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = WM8794_HIFI_BITS,
+		.pcmrate = WM8510_RATES,
+		.pcmdir = WM8510_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8510 register cache
+ */
+static inline unsigned int wm8510_read_reg_cache(struct snd_soc_codec * codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == WM8510_RESET)
+		return 0;
+	if (reg >= WM8510_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8510 register cache
+ */
+static inline void wm8510_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= WM8510_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8510 register space
+ */
+static int wm8510_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8510 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8510_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8510_reset(c)	wm8510_write(c, WM8510_RESET, 0)
+
+static const char *wm8510_companding[] = {"Off", "NC", "u-law", "A-law" };
+static const char *wm8510_deemp[] = {"None", "32kHz", "44.1kHz", "48kHz" };
+static const char *wm8510_alc[] = {"ALC", "Limiter" };
+
+static const struct soc_enum wm8510_enum[] = {
+	SOC_ENUM_SINGLE(WM8510_COMP, 1, 4, wm8510_companding), /* adc */
+	SOC_ENUM_SINGLE(WM8510_COMP, 3, 4, wm8510_companding), /* dac */
+	SOC_ENUM_SINGLE(WM8510_DAC,  4, 4, wm8510_deemp),
+	SOC_ENUM_SINGLE(WM8510_ALC3,  8, 2, wm8510_alc),
+};
+
+static const struct snd_kcontrol_new wm8510_snd_controls[] = {
+
+SOC_SINGLE("Digital Loopback Switch", WM8510_COMP, 0, 1, 0),
+
+SOC_ENUM("DAC Companding", wm8510_enum[1]),
+SOC_ENUM("ADC Companding", wm8510_enum[0]),
+
+SOC_ENUM("Playback De-emphasis", wm8510_enum[2]),
+SOC_SINGLE("DAC Inversion Switch", WM8510_DAC, 0, 1, 0),
+
+SOC_SINGLE("Master Playback Volume", WM8510_DACVOL, 0, 127, 0),
+
+SOC_SINGLE("High Pass Filter Switch", WM8510_ADC, 8, 1, 0),
+SOC_SINGLE("High Pass Cut Off", WM8510_ADC, 4, 7, 0),
+SOC_SINGLE("ADC Inversion Switch", WM8510_COMP, 0, 1, 0),
+
+SOC_SINGLE("Capture Volume", WM8510_ADCVOL,  0, 127, 0),
+
+SOC_SINGLE("DAC Playback Limiter Switch", WM8510_DACLIM1,  8, 1, 0),
+SOC_SINGLE("DAC Playback Limiter Decay", WM8510_DACLIM1,  4, 15, 0),
+SOC_SINGLE("DAC Playback Limiter Attack", WM8510_DACLIM1,  0, 15, 0),
+
+SOC_SINGLE("DAC Playback Limiter Threshold", WM8510_DACLIM2,  4, 7, 0),
+SOC_SINGLE("DAC Playback Limiter Boost", WM8510_DACLIM2,  0, 15, 0),
+
+SOC_SINGLE("ALC Enable Switch", WM8510_ALC1,  8, 1, 0),
+SOC_SINGLE("ALC Capture Max Gain", WM8510_ALC1,  3, 7, 0),
+SOC_SINGLE("ALC Capture Min Gain", WM8510_ALC1,  0, 7, 0),
+
+SOC_SINGLE("ALC Capture ZC Switch", WM8510_ALC2,  8, 1, 0),
+SOC_SINGLE("ALC Capture Hold", WM8510_ALC2,  4, 7, 0),
+SOC_SINGLE("ALC Capture Target", WM8510_ALC2,  0, 15, 0),
+
+SOC_ENUM("ALC Capture Mode", wm8510_enum[3]),
+SOC_SINGLE("ALC Capture Decay", WM8510_ALC3,  4, 15, 0),
+SOC_SINGLE("ALC Capture Attack", WM8510_ALC3,  0, 15, 0),
+
+SOC_SINGLE("ALC Capture Noise Gate Switch", WM8510_NGATE,  3, 1, 0),
+SOC_SINGLE("ALC Capture Noise Gate Threshold", WM8510_NGATE,  0, 7, 0),
+
+SOC_SINGLE("Capture PGA ZC Switch", WM8510_INPPGA,  7, 1, 0),
+SOC_SINGLE("Capture PGA Volume", WM8510_INPPGA,  0, 63, 0),
+
+SOC_SINGLE("Speaker Playback ZC Switch", WM8510_SPKVOL,  7, 1, 0),
+SOC_SINGLE("Speaker Playback Switch", WM8510_SPKVOL,  6, 1, 1),
+SOC_SINGLE("Speaker Playback Volume", WM8510_SPKVOL,  0, 63, 0),
+
+SOC_SINGLE("Capture Boost(+20dB)", WM8510_ADCBOOST,  8, 1, 0),
+SOC_SINGLE("Mono Playback Switch", WM8510_MONOMIX, 6, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm8510_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8510_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8510_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Speaker Output Mixer */
+static const struct snd_kcontrol_new wm8510_speaker_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8510_SPKMIX, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8510_SPKMIX, 5, 1, 0),
+SOC_DAPM_SINGLE("PCM Playback Switch", WM8510_SPKMIX, 0, 1, 1),
+};
+
+/* Mono Output Mixer */
+static const struct snd_kcontrol_new wm8510_mono_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8510_MONOMIX, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8510_MONOMIX, 2, 1, 0),
+SOC_DAPM_SINGLE("PCM Playback Switch", WM8510_MONOMIX, 0, 1, 1),
+};
+
+/* AUX Input boost vol */
+static const struct snd_kcontrol_new wm8510_aux_boost_controls =
+SOC_DAPM_SINGLE("Aux Volume", WM8510_ADCBOOST, 0, 7, 0);
+
+/* Mic Input boost vol */
+static const struct snd_kcontrol_new wm8510_mic_boost_controls =
+SOC_DAPM_SINGLE("Mic Volume", WM8510_ADCBOOST, 4, 7, 0);
+
+/* Capture boost switch */
+static const struct snd_kcontrol_new wm8510_capture_boost_controls =
+SOC_DAPM_SINGLE("Capture Boost Switch", WM8510_INPPGA,  6, 1, 0);
+
+/* Aux In to PGA */
+static const struct snd_kcontrol_new wm8510_aux_capture_boost_controls =
+SOC_DAPM_SINGLE("Aux Capture Boost Switch", WM8510_INPPGA,  2, 1, 0);
+
+/* Mic P In to PGA */
+static const struct snd_kcontrol_new wm8510_micp_capture_boost_controls =
+SOC_DAPM_SINGLE("Mic P Capture Boost Switch", WM8510_INPPGA,  0, 1, 0);
+
+/* Mic N In to PGA */
+static const struct snd_kcontrol_new wm8510_micn_capture_boost_controls =
+SOC_DAPM_SINGLE("Mic N Capture Boost Switch", WM8510_INPPGA,  1, 1, 0);
+
+static const struct snd_soc_dapm_widget wm8510_dapm_widgets[] = {
+SND_SOC_DAPM_MIXER("Speaker Mixer", WM8510_POWER3, 2, 0,
+	&wm8510_speaker_mixer_controls[0],
+	ARRAY_SIZE(wm8510_speaker_mixer_controls)),
+SND_SOC_DAPM_MIXER("Mono Mixer", WM8510_POWER3, 3, 0,
+	&wm8510_mono_mixer_controls[0],
+	ARRAY_SIZE(wm8510_mono_mixer_controls)),
+SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8510_POWER3, 0, 0),
+SND_SOC_DAPM_ADC("ADC", "HiFi Capture", WM8510_POWER3, 0, 0),
+SND_SOC_DAPM_PGA("Aux Input", WM8510_POWER1, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkN Out", WM8510_POWER3, 5, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkP Out", WM8510_POWER3, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mono Out", WM8510_POWER3, 7, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mic PGA", WM8510_POWER2, 2, 0, NULL, 0),
+
+SND_SOC_DAPM_PGA("Aux Boost", SND_SOC_NOPM, 0, 0,
+	&wm8510_aux_boost_controls, 1),
+SND_SOC_DAPM_PGA("Mic Boost", SND_SOC_NOPM, 0, 0,
+	&wm8510_mic_boost_controls, 1),
+SND_SOC_DAPM_SWITCH("Capture Boost", SND_SOC_NOPM, 0, 0,
+	&wm8510_capture_boost_controls),
+
+SND_SOC_DAPM_MIXER("Boost Mixer", WM8510_POWER2, 4, 0, NULL, 0),
+
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8510_POWER1, 4, 0),
+
+SND_SOC_DAPM_INPUT("MICN"),
+SND_SOC_DAPM_INPUT("MICP"),
+SND_SOC_DAPM_INPUT("AUX"),
+SND_SOC_DAPM_OUTPUT("MONOOUT"),
+SND_SOC_DAPM_OUTPUT("SPKOUTP"),
+SND_SOC_DAPM_OUTPUT("SPKOUTN"),
+};
+
+static const char *audio_map[][3] = {
+	/* Mono output mixer */
+	{"Mono Mixer", "PCM Playback Switch", "DAC"},
+	{"Mono Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Mono Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Speaker output mixer */
+	{"Speaker Mixer", "PCM Playback Switch", "DAC"},
+	{"Speaker Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Speaker Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Outputs */
+	{"Mono Out", NULL, "Mono Mixer"},
+	{"MONOOUT", NULL, "Mono Out"},
+	{"SpkN Out", NULL, "Speaker Mixer"},
+	{"SpkP Out", NULL, "Speaker Mixer"},
+	{"SPKOUTN", NULL, "SpkN Out"},
+	{"SPKOUTP", NULL, "SpkP Out"},
+
+	/* Boost Mixer */
+	{"Boost Mixer", NULL, "ADC"},
+    {"Capture Boost Switch", "Aux Capture Boost Switch", "AUX"},
+	{"Aux Boost", "Aux Volume", "Boost Mixer"},
+    {"Capture Boost", "Capture Switch", "Boost Mixer"},
+	{"Mic Boost", "Mic Volume", "Boost Mixer"},
+
+	/* Inputs */
+	{"MICP", NULL, "Mic Boost"},
+	{"MICN", NULL, "Mic PGA"},
+	{"Mic PGA", NULL, "Capture Boost"},
+	{"AUX", NULL, "Aux Input"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8510_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8510_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8510_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct pll_ {
+	unsigned int in_hz, out_hz;
+	unsigned int pre:4; /* prescale - 1 */
+	unsigned int n:4;
+	unsigned int k;
+};
+
+struct pll_ pll[] = {
+	{12000000, 11289600, 0, 7, 0x86c220},
+	{12000000, 12288000, 0, 8, 0x3126e8},
+	{13000000, 11289600, 0, 6, 0xf28bd4},
+	{13000000, 12288000, 0, 7, 0x8fd525},
+	{12288000, 11289600, 0, 7, 0x59999a},
+	{11289600, 12288000, 0, 8, 0x80dee9},
+	/* liam - add more entries */
+};
+
+static int set_pll(struct snd_soc_codec *codec, unsigned int in,
+	unsigned int out)
+{
+	int i;
+	u16 reg;
+
+	if(out == 0) {
+		reg = wm8510_read_reg_cache(codec, WM8510_POWER1);
+		wm8510_write(codec, WM8510_POWER1, reg & 0x1df);
+		return 0;
+	}
+
+	for(i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (in == pll[i].in_hz && out == pll[i].out_hz) {
+			wm8510_write(codec, WM8510_PLLN, (pll[i].pre << 4) | pll[i].n);
+			wm8510_write(codec, WM8510_PLLK1, pll[i].k >> 18);
+			wm8510_write(codec, WM8510_PLLK1, (pll[i].k >> 9) && 0x1ff);
+			wm8510_write(codec, WM8510_PLLK1, pll[i].k && 0x1ff);
+			reg = wm8510_read_reg_cache(codec, WM8510_POWER1);
+			wm8510_write(codec, WM8510_POWER1, reg | 0x020);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/* mclk dividers * 2 */
+static unsigned char mclk_div[] = {2, 3, 4, 6, 8, 12, 16, 24};
+
+/* we need 256FS to drive the DAC's and ADC's */
+static unsigned int wm8510_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	int i, j, best_clk = info->fs * info->rate;
+
+	/* can we run at this clk without the PLL ? */
+	for (i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if ((best_clk >> 1) * mclk_div[i] == clk) {
+			dai->pll_in = 0;
+			dai->clk_div = mclk_div[i];
+			dai->mclk = best_clk;
+			return dai->mclk;
+		}
+	}
+
+	/* now check for PLL support */
+	for (i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (pll[i].in_hz == clk) {
+			for (j = 0; j < ARRAY_SIZE(mclk_div); j++) {
+				if (pll[i].out_hz == mclk_div[j] * (best_clk >> 1)) {
+					dai->pll_in = clk;
+					dai->pll_out = pll[i].out_hz;
+					dai->clk_div = mclk_div[j];
+					dai->mclk = best_clk;
+					return dai->mclk;
+				}
+			}
+		}
+	}
+
+	/* this clk is not supported */
+	return 0;
+}
+
+static int wm8510_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *dai = rtd->codec_dai;
+	u16 iface = 0, bfs, clk = 0, adn;
+	int fs = 48000 << 7, i;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+	switch (bfs) {
+	case 2:
+		clk |= 0x1 << 2;
+		break;
+	case 4:
+		clk |= 0x2 << 2;
+		break;
+	case 8:
+		clk |= 0x3 << 2;
+		break;
+	case 16:
+		clk |= 0x4 << 2;
+		break;
+	case 32:
+		clk |= 0x5 << 2;
+		break;
+	}
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clk |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0010;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0008;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x00018;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		iface |= 0x0020;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		iface |= 0x0040;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		iface |= 0x0060;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0180;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0100;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0080;
+		break;
+	}
+
+	/* filter coefficient */
+	adn = wm8510_read_reg_cache(codec, WM8510_ADD) & 0x1f1;
+	switch (rtd->codec_dai->dai_runtime.pcmrate) {
+	case SNDRV_PCM_RATE_8000:
+		adn |= 0x5 << 1;
+		fs = 8000 << 7;
+		break;
+	case SNDRV_PCM_RATE_11025:
+		adn |= 0x4 << 1;
+		fs = 11025 << 7;
+		break;
+	case SNDRV_PCM_RATE_16000:
+		adn |= 0x3 << 1;
+		fs = 16000 << 7;
+		break;
+	case SNDRV_PCM_RATE_22050:
+		adn |= 0x2 << 1;
+		fs = 22050 << 7;
+		break;
+	case SNDRV_PCM_RATE_32000:
+		adn |= 0x1 << 1;
+		fs = 32000 << 7;
+		break;
+	case SNDRV_PCM_RATE_44100:
+		fs = 44100 << 7;
+		break;
+	}
+
+	/* do we need to enable the PLL */
+	if(dai->pll_in)
+		set_pll(codec, dai->pll_in, dai->pll_out);
+
+	/* divide the clock to 256 fs */
+	for(i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if (dai->clk_div == mclk_div[i]) {
+			clk |= i << 5;
+			clk &= 0xff;
+			goto set;
+		}
+	}
+
+set:
+	/* set iface */
+	wm8510_write(codec, WM8510_IFACE, iface);
+	wm8510_write(codec, WM8510_CLOCK, clk);
+
+	return 0;
+}
+
+static int wm8510_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	set_pll(codec, 0, 0);
+	return 0;
+}
+
+static int wm8510_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8510_read_reg_cache(codec, WM8510_DAC) & 0xffbf;
+	if(mute)
+		wm8510_write(codec, WM8510_DAC, mute_reg | 0x40);
+	else
+		wm8510_write(codec, WM8510_DAC, mute_reg);
+	return 0;
+}
+
+/* liam need to make this lower power with dapm */
+static int wm8510_dapm_event(struct snd_soc_codec *codec, int event)
+{
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* vref/mid, clk and osc on, dac unmute, active */
+		wm8510_write(codec, WM8510_POWER1, 0x1ff);
+		wm8510_write(codec, WM8510_POWER2, 0x1ff);
+		wm8510_write(codec, WM8510_POWER3, 0x1ff);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, dac mute, inactive */
+
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, dac mute, inactive */
+		wm8510_write(codec, WM8510_POWER1, 0x0);
+		wm8510_write(codec, WM8510_POWER2, 0x0);
+		wm8510_write(codec, WM8510_POWER3, 0x0);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8510_dai = {
+	.name = "WM8510 HiFi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 1,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+	},
+	.config_sysclk = wm8510_config_sysclk,
+	.digital_mute = wm8510_mute,
+	.ops = {
+		.prepare = wm8510_pcm_prepare,
+		.hw_free = wm8510_hw_free,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8510_modes),
+		.mode = wm8510_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8510_dai);
+
+static int wm8510_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8510_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8510_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8510_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8510_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8510_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8510 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8510_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "WM8510";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8510_read_reg_cache;
+	codec->write = wm8510_write;
+	codec->dapm_event = wm8510_dapm_event;
+	codec->dai = &wm8510_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8510_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8510_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8510_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8510_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8510_reg);
+
+	wm8510_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	wm8510_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8510_add_controls(codec);
+	wm8510_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if(ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *wm8510_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8510 2 wire address is 0x1a
+ */
+#define I2C_DRIVERID_WM8510 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8510_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int wm8510_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8510_socdev;
+	struct wm8510_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if(ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8510_init(socdev);
+	if(ret < 0) {
+		err("failed to initialise WM8510\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8510_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8510_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8510_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8510_i2c_driver = {
+	.driver = {
+		.name = "WM8510 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8510,
+	.attach_adapter = wm8510_i2c_attach,
+	.detach_client =  wm8510_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8510",
+	.driver = &wm8510_i2c_driver,
+};
+#endif
+
+static int wm8510_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8510_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8510 Audio Codec %s", WM8510_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8510_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8510_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8510_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8510_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8510_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8510 = {
+	.probe = 	wm8510_probe,
+	.remove = 	wm8510_remove,
+	.suspend = 	wm8510_suspend,
+	.resume =	wm8510_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8510);
+
+MODULE_DESCRIPTION("ASoC WM8510 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8510.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8510.h
@@ -0,0 +1,64 @@
+/*
+ * wm8510.h  --  WM8510 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8510_H
+#define _WM8510_H
+
+/* WM8510 register space */
+
+#define WM8510_RESET		0x0
+#define WM8510_POWER1		0x1
+#define WM8510_POWER2		0x2
+#define WM8510_POWER3		0x3
+#define WM8510_IFACE		0x4
+#define WM8510_COMP			0x5
+#define WM8510_CLOCK		0x6
+#define WM8510_ADD			0x7
+#define WM8510_GPIO			0x8
+#define WM8510_DAC			0xa
+#define WM8510_DACVOL		0xb
+#define WM8510_ADC			0xe
+#define WM8510_ADCVOL		0xf
+#define WM8510_EQ1			0x12
+#define WM8510_EQ2			0x13
+#define WM8510_EQ3			0x14
+#define WM8510_EQ4			0x15
+#define WM8510_EQ5			0x16
+#define WM8510_DACLIM1		0x18
+#define WM8510_DACLIM2		0x19
+#define WM8510_NOTCH1		0x1b
+#define WM8510_NOTCH2		0x1c
+#define WM8510_NOTCH3		0x1d
+#define WM8510_NOTCH4		0x1e
+#define WM8510_ALC1			0x20
+#define WM8510_ALC2			0x21
+#define WM8510_ALC3			0x22
+#define WM8510_NGATE		0x23
+#define WM8510_PLLN			0x24
+#define WM8510_PLLK1		0x25
+#define WM8510_PLLK2		0x26
+#define WM8510_PLLK3		0x27
+#define WM8510_ATTEN		0x28
+#define WM8510_INPUT		0x2c
+#define WM8510_INPPGA		0x2d
+#define WM8510_ADCBOOST		0x2f
+#define WM8510_OUTPUT		0x31
+#define WM8510_SPKMIX		0x32
+#define WM8510_SPKVOL		0x36
+#define WM8510_MONOMIX		0x38
+
+#define WM8510_CACHEREGNUM 	57
+
+struct wm8510_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8510_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8510;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/imx/imx-ac97.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/imx-ac97.c
@@ -0,0 +1,281 @@
+/*
+ * imx-ssi.c  --  SSI driver for Freescale IMX
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Based on mxc-alsa-mc13783 (C) 2006 Freescale.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    29th Aug 2006   Initial version.
+ *
+ */
+
+#define IMX_AC97_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+/* may need to expand this */
+static struct snd_soc_dai_mode imx_ssi_ac97_modes[] = {
+	{0, 0,	SNDRV_PCM_FMTBIT_S16_LE,	IMX_AC97_RATES},
+	{0, 0,	SNDRV_PCM_FMTBIT_S18_3LE,	IMX_AC97_RATES},
+	{0, 0,	SNDRV_PCM_FMTBIT_S20_3LE,	IMX_AC97_RATES},
+};
+
+static imx_pcm_dma_params_t imx_ssi1_pcm_stereo_out = {
+	.name			= "SSI1 PCM Stereo out",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = emi_2_per,
+		.watermark_level = SDMA_TXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI1_STX0,
+		.event_id = DMA_REQ_SSI1_TX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi1_pcm_stereo_in = {
+	.name			= "SSI1 PCM Stereo in",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_RXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI1_SRX0,
+		.event_id = DMA_REQ_SSI1_RX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi2_pcm_stereo_out = {
+	.name			= "SSI2 PCM Stereo out",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_TXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI2_STX0,
+		.event_id = DMA_REQ_SSI2_TX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi2_pcm_stereo_in = {
+	.name			= "SSI2 PCM Stereo in",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_RXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI2_SRX0,
+		.event_id = DMA_REQ_SSI2_RX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static unsigned short imx_ssi_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
+{
+}
+
+static void imx_ssi_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
+{
+}
+
+static void imx_ssi_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+}
+
+static void imx_ssi_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+}
+
+struct snd_ac97_bus_ops soc_ac97_ops = {
+	.read	= imx_ssi_ac97_read,
+	.write	= imx_ssi_ac97_write,
+	.warm_reset	= imx_ssi_ac97_warm_reset,
+	.reset	= imx_ssi_ac97_cold_reset,
+};
+
+
+static intimx_ssi1_ac97_probe(struct platform_device *pdev)
+{
+	int ret;
+
+
+	return ret;
+}
+
+static void imx_ssi1_ac97_remove(struct platform_device *pdev)
+{
+	/* shutdown SSI */
+		if(rtd->cpu_dai->id == 0)
+			SSI1_SCR &= ~SSI_SCR_SSIEN;
+		else
+			SSI2_SCR &= ~SSI_SCR_SSIEN;
+	}
+
+}
+
+static int imx_ssi1_ac97_prepare(struct snd_pcm_substream *substream)
+{
+	// set vra
+}
+
+static int imx_ssi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (!rtd->cpu_dai->active) {
+
+	}
+
+	return 0;
+}
+
+static int imx_ssi1_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			SSI1_SCR |= SSI_SCR_TE;
+			SSI1_SIER |= SSI_SIER_TDMAE;
+		} else {
+			SSI1_SCR |= SSI_SCR_RE;
+			SSI1_SIER |= SSI_SIER_RDMAE;
+		}
+		SSI1_SCR |= SSI_SCR_SSIEN;
+
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSI1_SCR |= SSI_SCR_TE;
+		else
+			SSI1_SCR |= SSI_SCR_RE;
+	break
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSI1_SCR &= ~SSI_SCR_TE;
+		else
+			SSI1_SCR &= ~SSI_SCR_RE;
+	break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void imx_ssi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+
+}
+
+#ifdef CONFIG_PM
+static int imx_ssi_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if(!dai->active)
+		return 0;
+
+	if(rtd->cpu_dai->id == 0)
+		SSI1_SCR &= ~SSI_SCR_SSIEN;
+	else
+		SSI2_SCR &= ~SSI_SCR_SSIEN;
+
+	return 0;
+}
+
+static int imx_ssi_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if(!dai->active)
+		return 0;
+
+	if(rtd->cpu_dai->id == 0)
+		SSI1_SCR |= SSI_SCR_SSIEN;
+	else
+		SSI2_SCR |= SSI_SCR_SSIEN;
+
+	return 0;
+}
+
+#else
+#define imx_ssi_suspend	NULL
+#define imx_ssi_resume	NULL
+#endif
+
+static unsigned int imx_ssi_config_ac97_sysclk(struct snd_soc_cpu_dai *iface,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	return clk;
+}
+
+struct snd_soc_cpu_dai imx_ssi_ac97_dai = {
+	.name = "imx-ac97-1",
+	.id = 0,
+	.type = SND_SOC_DAI_AC97,
+	.suspend = imx_ssi_suspend,
+	.resume = imx_ssi_resume,
+	.config_sysclk = imx_ssi_ac97_config_sysclk,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.ops = {
+		.probe = imx_ac97_probe,
+		.remove = imx_ac97_shutdown,
+		.trigger = imx_ssi1_trigger,
+		.prepare = imx_ssi_ac97_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(imx_ssi_ac97_modes),
+		.mode = imx_ssi_ac97_modes,},
+},
+{
+	.name = "imx-ac97-2",
+	.id = 1,
+	.type = SND_SOC_DAI_AC97,
+	.suspend = imx_ssi_suspend,
+	.resume = imx_ssi_resume,
+	.config_sysclk = imx_ssi_ac97_config_sysclk,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.ops = {
+		.probe = imx_ac97_probe,
+		.remove = imx_ac97_shutdown,
+		.trigger = imx_ssi1_trigger,
+		.prepare = imx_ssi_ac97_prepare,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(imx_ssi_ac97_modes),
+		.mode = imx_ssi_ac97_modes,},
+};
+
+EXPORT_SYMBOL_GPL(imx_ssi_ac97_dai);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("i.MX ASoC AC97 driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/imx/imx-i2s.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/imx-i2s.c
@@ -0,0 +1,473 @@
+/*
+ * imx-ssi.c  --  SSI driver for Freescale IMX
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Based on mxc-alsa-mc13783 (C) 2006 Freescale.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    29th Aug 2006   Initial version.
+ *
+ */
+
+#define IMX_SSI_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J |\
+	SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_DSP__A |\
+	SND_SOC_DAIFMT_DSP_B  | SND_SOC_DAIFMT_CBS_CFS |\
+	SND_SOC_DAIFMT_CBM_CFS |  SND_SOC_DAIFMT_CBS_CFM |\
+	SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_NB_IF)
+
+#define IMX_SSI_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define IMX_SSI_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
+	SNDRV_PCM_RATE_96000)
+
+#define IMX_SSI_BITS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_mode imx_ssi_pcm_modes[] = {
+
+	/* frame master and clock slave mode */
+	{
+		.fmt = IMX_SSI_DAIFMT | SND_SOC_DAIFMT_CBM_CFS,
+		.tdm = SND_SOC_DAITDM_LRDW(0,0),
+		.pcmfmt = IMX_SSI_BITS,
+		.pcmrate = IMX_SSI_RATES,
+		.pcmdir = IMX_SSI_DIR,
+		.flags =  SND_SOC_DAI_BFS_RCW,
+		.fs = SND_SOC_FS_ALL,
+		.bfs = SND_SOC_FSBW(1) | SND_SOC_FSBW(2),
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi1_pcm_stereo_out = {
+	.name			= "SSI1 PCM Stereo out",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = emi_2_per,
+		.watermark_level = SDMA_TXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI1_STX0,
+		.event_id = DMA_REQ_SSI1_TX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi1_pcm_stereo_in = {
+	.name			= "SSI1 PCM Stereo in",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_RXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI1_SRX0,
+		.event_id = DMA_REQ_SSI1_RX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi2_pcm_stereo_out = {
+	.name			= "SSI2 PCM Stereo out",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_TXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI2_STX0,
+		.event_id = DMA_REQ_SSI2_TX1,
+		.peripheral_type = SSI,
+	},
+};
+
+static imx_pcm_dma_params_t imx_ssi2_pcm_stereo_in = {
+	.name			= "SSI2 PCM Stereo in",
+	.params = {
+		.bd_number = 1,
+		.transfer_type = per_2_emi,
+		.watermark_level = SDMA_RXFIFO_WATERMARK,
+		.word_size = TRANSFER_16BIT, // maybe add this in setup func
+		.per_address = SSI2_SRX0,
+		.event_id = DMA_REQ_SSI2_RX1,
+		.peripheral_type = SSI,
+	},
+};
+
+
+static int imx_ssi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (!rtd->cpu_dai->active) {
+
+	}
+
+	return 0;
+}
+
+static int imx_ssi1_hw_tx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 bfs, div;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
+
+	SSI1_STCR = 0;
+	SSI1_STCCR = 0;
+
+	/* DAI mode */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		SSI1_STCR |= SSI_STCR_TSCKP | SSI_STCR_TFSI |
+			SSI_STCR_TEFS | SSI_STCR_TXBIT0;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		SSI1_STCR |= SSI_STCR_TSCKP | SSI_STCR_TFSI | SSI_STCR_TXBIT0;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		SSI1_STCR |= SSI_STCR_TEFS; // data 1 bit after sync
+	case SND_SOC_DAIFMT_DSP_A:
+		SSI1_STCR |= SSI_STCR_TFSL; // frame is 1 bclk long
+
+		/* DAI clock inversion */
+		switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_IB_IF:
+			SSI1_STCR |= SSI_STCR_TFSI | SSI_STCR_TSCKP;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			SSI1_STCR |= SSI_STCR_TSCKP;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:
+			SSI1_STCR |= SSI_STCR_TFSI;
+			break;
+		}
+		break;
+	}
+
+	/* DAI data (word) size */
+	switch(rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		SSI1_STCCR |= SSI_STCCR_WL(16);
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		SSI1_STCCR |= SSI_STCCR_WL(20);
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		SSI1_STCCR |= SSI_STCCR_WL(24);
+		break;
+	}
+
+	/* DAI clock master masks */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:
+		SSI1_STCR |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		SSI1_STCR |= SSI_STCR_TFDIR;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		SSI1_STCR |= SSI_STCR_TXDIR;
+		break;
+	}
+
+	/* DAI BCLK ratio to SYSCLK / MCLK */
+	/* prescaler modulus - todo */
+	switch (bfs) {
+	case 2:
+		break;
+	case 4:
+		break;
+	case 8:
+		break;
+	case 16:
+		break;
+	}
+
+	/* TDM - todo, only fifo 0 atm */
+	SSI1_STCR |= SSI_STCR_TFEN0;
+	SSI1_STCCR |= SSI_STCCR_DC(params_channels(params));
+
+	return 0;
+}
+
+static int imx_ssi1_hw_rx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 bfs, div;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
+
+	SSI1_SRCR = 0;
+	SSI1_SRCCR = 0;
+
+	/* DAI mode */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		SSI1_SRCR |= SSI_SRCR_RSCKP | SSI_SRCR_RFSI |
+			SSI_STCR_REFS | SSI_STCR_RXBIT0;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		SSI1_SRCR |= SSI_SRCR_RSCKP | SSI_SRCR_RFSI | SSI_SRCR_RXBIT0;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		SSI1_SRCR |= SSI_SRCR_REFS; // data 1 bit after sync
+	case SND_SOC_DAIFMT_DSP_A:
+		SSI1_SRCR |= SSI_SRCR_RFSL; // frame is 1 bclk long
+
+		/* DAI clock inversion */
+		switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_IB_IF:
+			SSI1_SRCR |= SSI_SRCR_TFSI | SSI_SRCR_TSCKP;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			SSI1_SRCR |= SSI_SRCR_RSCKP;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:
+			SSI1_SRCR |= SSI_SRCR_RFSI;
+			break;
+		}
+		break;
+	}
+
+	/* DAI data (word) size */
+	switch(rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		SSI1_SRCCR |= SSI_SRCCR_WL(16);
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		SSI1_SRCCR |= SSI_SRCCR_WL(20);
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		SSI1_SRCCR |= SSI_SRCCR_WL(24);
+		break;
+	}
+
+	/* DAI clock master masks */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK){
+	case SND_SOC_DAIFMT_CBM_CFM:
+		SSI1_SRCR |= SSI_SRCR_RFDIR | SSI_SRCR_RXDIR;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		SSI1_SRCR |= SSI_SRCR_RFDIR;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		SSI1_SRCR |= SSI_SRCR_RXDIR;
+		break;
+	}
+
+	/* DAI BCLK ratio to SYSCLK / MCLK */
+	/* prescaler modulus - todo */
+	switch (bfs) {
+	case 2:
+		break;
+	case 4:
+		break;
+	case 8:
+		break;
+	case 16:
+		break;
+	}
+
+	/* TDM - todo, only fifo 0 atm */
+	SSI1_SRCR |= SSI_SRCR_RFEN0;
+	SSI1_SRCCR |= SSI_SRCCR_DC(params_channels(params));
+
+	return 0;
+}
+
+static int imx_ssi1_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	/* clear register if not enabled */
+	if(!(SSI1_SCR & SSI_SCR_SSIEN))
+		SSI1_SCR = 0;
+
+	/* async */
+	if (rtd->cpu_dai->flags & SND_SOC_DAI_ASYNC)
+		SSI1_SCR |= SSI_SCR_SYN;
+
+	/* DAI mode */
+	switch(rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_LEFT_J:
+		SSI1_SCR |= SSI_SCR_NET;
+		break;
+	}
+
+	/* TDM  - to complete */
+
+	/* Tx/Rx config */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		return imx_ssi1_hw_tx_params(substream, params);
+	} else {
+		return imx_ssi1_hw_rx_params(substream, params);
+	}
+}
+
+
+
+static int imx_ssi1_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			SSI1_SCR |= SSI_SCR_TE;
+			SSI1_SIER |= SSI_SIER_TDMAE;
+		} else {
+			SSI1_SCR |= SSI_SCR_RE;
+			SSI1_SIER |= SSI_SIER_RDMAE;
+		}
+		SSI1_SCR |= SSI_SCR_SSIEN;
+
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSI1_SCR |= SSI_SCR_TE;
+		else
+			SSI1_SCR |= SSI_SCR_RE;
+	break
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			SSI1_SCR &= ~SSI_SCR_TE;
+		else
+			SSI1_SCR &= ~SSI_SCR_RE;
+	break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void imx_ssi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	/* shutdown SSI */
+	if (!rtd->cpu_dai->active) {
+		if(rtd->cpu_dai->id == 0)
+			SSI1_SCR &= ~SSI_SCR_SSIEN;
+		else
+			SSI2_SCR &= ~SSI_SCR_SSIEN;
+	}
+}
+
+#ifdef CONFIG_PM
+static int imx_ssi_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if(!dai->active)
+		return 0;
+
+	if(rtd->cpu_dai->id == 0)
+		SSI1_SCR &= ~SSI_SCR_SSIEN;
+	else
+		SSI2_SCR &= ~SSI_SCR_SSIEN;
+
+	return 0;
+}
+
+static int imx_ssi_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if(!dai->active)
+		return 0;
+
+	if(rtd->cpu_dai->id == 0)
+		SSI1_SCR |= SSI_SCR_SSIEN;
+	else
+		SSI2_SCR |= SSI_SCR_SSIEN;
+
+	return 0;
+}
+
+#else
+#define imx_ssi_suspend	NULL
+#define imx_ssi_resume	NULL
+#endif
+
+static unsigned int imx_ssi_config_pcm_sysclk(struct snd_soc_cpu_dai *iface,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	return clk;
+}
+
+struct snd_soc_cpu_dai imx_ssi_pcm_dai = {
+	.name = "imx-i2s-1",
+	.id = 0,
+	.type = SND_SOC_DAI_I2S,
+	.suspend = imx_ssi_suspend,
+	.resume = imx_ssi_resume,
+	.config_sysclk = imx_ssi_config_pcm_sysclk,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.ops = {
+		.startup = imx_ssi_startup,
+		.shutdown = imx_ssi_shutdown,
+		.trigger = imx_ssi1_trigger,
+		.hw_params = imx_ssi1_pcm_hw_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(imx_ssi_modes),
+		.mode = imx_ssi_modes,},
+},
+{
+	.name = "imx-i2s-2",
+	.id = 1,
+	.type = SND_SOC_DAI_I2S,
+	.suspend = imx_ssi_suspend,
+	.resume = imx_ssi_resume,
+	.config_sysclk = imx_ssi_config_pcm_sysclk,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,},
+	.ops = {
+		.startup = imx_ssi_startup,
+		.shutdown = imx_ssi_shutdown,
+		.trigger = imx_ssi1_trigger,
+		.hw_params = imx_ssi1_pcm_hw_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(imx_ssi_modes),
+		.mode = imx_ssi_modes,},
+};
+
+
+EXPORT_SYMBOL_GPL(imx_ssi_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("i.MX ASoC I2S driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/include/linux/i2c-id.h
===================================================================
--- linux-2.6-pxa-new.orig/include/linux/i2c-id.h
+++ linux-2.6-pxa-new/include/linux/i2c-id.h
@@ -116,6 +116,8 @@
 #define I2C_DRIVERID_KS0127	86	/* Samsung ks0127 video decoder */
 #define I2C_DRIVERID_TLV320AIC23B 87	/* TI TLV320AIC23B audio codec  */
 #define I2C_DRIVERID_ISL1208	88	/* Intersil ISL1208 RTC		*/
+#define I2C_DRIVERID_WM8731		89	/* Wolfson WM8731 audio codec */
+#define I2C_DRIVERID_WM8750		90	/* Wolfson WM8750 audio codec */
 
 #define I2C_DRIVERID_I2CDEV	900
 #define I2C_DRIVERID_ARP        902    /* SMBus ARP Client              */
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8976.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8976.c
@@ -0,0 +1,953 @@
+/*
+ * wm8976.c  --  WM8976 ALSA Soc Audio driver
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8976.h"
+
+#define AUDIO_NAME "wm8976"
+#define WM8976_VERSION "0.2"
+
+/*
+ * Debug
+ */
+
+#define WM8976_DEBUG 0
+
+#ifdef WM8976_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+struct snd_soc_codec_device soc_codec_dev_wm8976;
+
+/*
+ * wm8976 register cache
+ * We can't read the WM8976 register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8976_reg[WM8976_CACHEREGNUM] = {
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0050, 0x0000, 0x0140, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x00ff,
+    0x00ff, 0x0000, 0x0100, 0x00ff,
+    0x00ff, 0x0000, 0x012c, 0x002c,
+    0x002c, 0x002c, 0x002c, 0x0000,
+    0x0032, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0038, 0x000b, 0x0032, 0x0000,
+    0x0008, 0x000c, 0x0093, 0x00e9,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0033, 0x0010, 0x0010, 0x0100,
+    0x0100, 0x0002, 0x0001, 0x0001,
+    0x0039, 0x0039, 0x0039, 0x0039,
+    0x0001, 0x0001,
+};
+
+#define WM8976_DAIFMT \
+	(SND_SOC_DAIFMT_I2S  | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_RIGHT_J | \
+    SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_DSP_B  | SND_SOC_DAIFMT_NB_NF   | \
+    SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_IB_NF  | SND_SOC_DAIFMT_IB_IF)
+
+#define WM8976_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define WM8976_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000)
+
+#define WM8976_PCM_FORMATS \
+	(SNDRV_PCM_FORMAT_S16_LE | SNDRV_PCM_FORMAT_S20_3LE | \
+	SNDRV_PCM_FORMAT_S24_3LE | SNDRV_PCM_FORMAT_S24_LE  | \
+    SNDRV_PCM_FORMAT_S32_LE)
+
+#define WM8976_BCLK \
+	(SND_SOC_FSBD(1) | SND_SOC_FSBD(2) | SND_SOC_FSBD(4) | SND_SOC_FSBD(8) |\
+    SND_SOC_FSBD(16) | SND_SOC_FSBD(32))
+
+static struct snd_soc_dai_mode wm8976_modes[] = {
+	/* codec frame and clock master modes */
+	{
+		.fmt = WM8976_DAIFMT | SND_SOC_DAIFMT_CBM_CFM,
+		.pcmfmt = WM8976_PCM_FORMATS,
+		.pcmrate = WM8976_RATES,
+		.pcmdir = WM8976_DIR,
+		.flags = SND_SOC_DAI_BFS_DIV,
+		.fs = 256,
+		.bfs = WM8976_BCLK,
+	},
+
+	/* codec frame and clock slave modes */
+	{
+		.fmt = WM8976_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+        .pcmfmt = WM8976_PCM_FORMATS,
+        .pcmrate = WM8976_RATES,
+        .pcmdir = WM8976_DIR,
+        .fs = SND_SOC_FS_ALL,
+        .bfs = SND_SOC_FSB_ALL,
+	},
+};
+
+/*
+ * read wm8976 register cache
+ */
+static inline unsigned int wm8976_read_reg_cache(struct snd_soc_codec  *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == WM8976_RESET)
+		return 0;
+	if (reg >= WM8976_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8976 register cache
+ */
+static inline void wm8976_write_reg_cache(struct snd_soc_codec  *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= WM8976_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8976 register space
+ */
+static int wm8976_write(struct snd_soc_codec  *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8976 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8976_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -1;
+}
+
+#define wm8976_reset(c)	wm8976_write(c, WM8976_RESET, 0)
+
+static const char *wm8976_companding[] = {"Off", "NC", "u-law", "A-law" };
+static const char *wm8976_deemp[] = {"None", "32kHz", "44.1kHz", "48kHz" };
+static const char *wm8976_eqmode[] = {"Capture", "Playback" };
+static const char *wm8976_bw[] = {"Narrow", "Wide" };
+static const char *wm8976_eq1[] = {"80Hz", "105Hz", "135Hz", "175Hz" };
+static const char *wm8976_eq2[] = {"230Hz", "300Hz", "385Hz", "500Hz" };
+static const char *wm8976_eq3[] = {"650Hz", "850Hz", "1.1kHz", "1.4kHz" };
+static const char *wm8976_eq4[] = {"1.8kHz", "2.4kHz", "3.2kHz", "4.1kHz" };
+static const char *wm8976_eq5[] = {"5.3kHz", "6.9kHz", "9kHz", "11.7kHz" };
+static const char *wm8976_alc[] =
+    {"ALC both on", "ALC left only", "ALC right only", "Limiter" };
+
+static const struct soc_enum wm8976_enum[] = {
+	SOC_ENUM_SINGLE(WM8976_COMP, 1, 4, wm8976_companding), /* adc */
+	SOC_ENUM_SINGLE(WM8976_COMP, 3, 4, wm8976_companding), /* dac */
+	SOC_ENUM_SINGLE(WM8976_DAC,  4, 4, wm8976_deemp),
+	SOC_ENUM_SINGLE(WM8976_EQ1,  8, 2, wm8976_eqmode),
+
+	SOC_ENUM_SINGLE(WM8976_EQ1,  5, 4, wm8976_eq1),
+	SOC_ENUM_SINGLE(WM8976_EQ2,  8, 2, wm8976_bw),
+	SOC_ENUM_SINGLE(WM8976_EQ2,  5, 4, wm8976_eq2),
+	SOC_ENUM_SINGLE(WM8976_EQ3,  8, 2, wm8976_bw),
+
+	SOC_ENUM_SINGLE(WM8976_EQ3,  5, 4, wm8976_eq3),
+	SOC_ENUM_SINGLE(WM8976_EQ4,  8, 2, wm8976_bw),
+	SOC_ENUM_SINGLE(WM8976_EQ4,  5, 4, wm8976_eq4),
+	SOC_ENUM_SINGLE(WM8976_EQ5,  8, 2, wm8976_bw),
+
+	SOC_ENUM_SINGLE(WM8976_EQ5,  5, 4, wm8976_eq5),
+	SOC_ENUM_SINGLE(WM8976_ALC3,  8, 2, wm8976_alc),
+};
+
+static const struct snd_kcontrol_new wm8976_snd_controls[] = {
+SOC_SINGLE("Digital Loopback Switch", WM8976_COMP, 0, 1, 0),
+
+SOC_ENUM("ADC Companding", wm8976_enum[0]),
+SOC_ENUM("DAC Companding", wm8976_enum[1]),
+
+SOC_SINGLE("Jack Detection Enable", WM8976_JACK1, 6, 1, 0),
+
+SOC_DOUBLE("DAC Inversion Switch", WM8976_DAC, 0, 1, 1, 0),
+
+SOC_DOUBLE_R("Headphone Playback Volume", WM8976_DACVOLL, WM8976_DACVOLR, 0, 127, 0),
+
+SOC_SINGLE("High Pass Filter Switch", WM8976_ADC, 8, 1, 0),
+SOC_SINGLE("High Pass Filter Switch", WM8976_ADC, 8, 1, 0),
+SOC_SINGLE("High Pass Cut Off", WM8976_ADC, 4, 7, 0),
+
+SOC_DOUBLE("ADC Inversion Switch", WM8976_ADC, 0, 1, 1, 0),
+
+SOC_SINGLE("Capture Volume", WM8976_ADCVOL,  0, 127, 0),
+
+SOC_ENUM("Equaliser Function", wm8976_enum[3]),
+SOC_ENUM("EQ1 Cut Off", wm8976_enum[4]),
+SOC_SINGLE("EQ1 Volume", WM8976_EQ1,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ2 Bandwith", wm8976_enum[5]),
+SOC_ENUM("EQ2 Cut Off", wm8976_enum[6]),
+SOC_SINGLE("EQ2 Volume", WM8976_EQ2,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ3 Bandwith", wm8976_enum[7]),
+SOC_ENUM("EQ3 Cut Off", wm8976_enum[8]),
+SOC_SINGLE("EQ3 Volume", WM8976_EQ3,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ4 Bandwith", wm8976_enum[9]),
+SOC_ENUM("EQ4 Cut Off", wm8976_enum[10]),
+SOC_SINGLE("EQ4 Volume", WM8976_EQ4,  0, 31, 1),
+
+SOC_ENUM("Equaliser EQ5 Bandwith", wm8976_enum[11]),
+SOC_ENUM("EQ5 Cut Off", wm8976_enum[12]),
+SOC_SINGLE("EQ5 Volume", WM8976_EQ5,  0, 31, 1),
+
+SOC_SINGLE("DAC Playback Limiter Switch", WM8976_DACLIM1,  8, 1, 0),
+SOC_SINGLE("DAC Playback Limiter Decay", WM8976_DACLIM1,  4, 15, 0),
+SOC_SINGLE("DAC Playback Limiter Attack", WM8976_DACLIM1,  0, 15, 0),
+
+SOC_SINGLE("DAC Playback Limiter Threshold", WM8976_DACLIM2,  4, 7, 0),
+SOC_SINGLE("DAC Playback Limiter Boost", WM8976_DACLIM2,  0, 15, 0),
+
+SOC_SINGLE("ALC Enable Switch", WM8976_ALC1,  8, 1, 0),
+SOC_SINGLE("ALC Capture Max Gain", WM8976_ALC1,  3, 7, 0),
+SOC_SINGLE("ALC Capture Min Gain", WM8976_ALC1,  0, 7, 0),
+
+SOC_SINGLE("ALC Capture ZC Switch", WM8976_ALC2,  8, 1, 0),
+SOC_SINGLE("ALC Capture Hold", WM8976_ALC2,  4, 7, 0),
+SOC_SINGLE("ALC Capture Target", WM8976_ALC2,  0, 15, 0),
+
+SOC_ENUM("ALC Capture Mode", wm8976_enum[13]),
+SOC_SINGLE("ALC Capture Decay", WM8976_ALC3,  4, 15, 0),
+SOC_SINGLE("ALC Capture Attack", WM8976_ALC3,  0, 15, 0),
+
+SOC_SINGLE("ALC Capture Noise Gate Switch", WM8976_NGATE,  3, 1, 0),
+SOC_SINGLE("ALC Capture Noise Gate Threshold", WM8976_NGATE,  0, 7, 0),
+
+SOC_SINGLE("Capture PGA ZC Switch", WM8976_INPPGA,  7, 1, 0),
+SOC_SINGLE("Capture PGA Volume", WM8976_INPPGA,  0, 63, 0),
+
+SOC_DOUBLE_R("Headphone Playback ZC Switch", WM8976_HPVOLL,  WM8976_HPVOLR, 7, 1, 0),
+SOC_DOUBLE_R("Headphone Playback Switch", WM8976_HPVOLL,  WM8976_HPVOLR, 6, 1, 1),
+SOC_DOUBLE_R("Headphone Playback Volume", WM8976_HPVOLL,  WM8976_HPVOLR, 0, 63, 0),
+
+SOC_DOUBLE_R("Speaker Playback ZC Switch", WM8976_SPKVOLL,  WM8976_SPKVOLR, 7, 1, 0),
+SOC_DOUBLE_R("Speaker Playback Switch", WM8976_SPKVOLL,  WM8976_SPKVOLR, 6, 1, 1),
+SOC_DOUBLE_R("Speaker Playback Volume", WM8976_SPKVOLL,  WM8976_SPKVOLR, 0, 63, 0),
+
+SOC_SINGLE("Capture Boost(+20dB)", WM8976_ADCBOOST, 8, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm8976_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8976_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8976_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Left Output Mixer */
+static const snd_kcontrol_new_t wm8976_left_mixer_controls[] = {
+SOC_DAPM_SINGLE("Right PCM Playback Switch", WM8976_OUTPUT, 6, 1, 1),
+SOC_DAPM_SINGLE("Left PCM Playback Switch", WM8976_MIXL, 0, 1, 1),
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8976_MIXL, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8976_MIXL, 5, 1, 0),
+};
+
+/* Right Output Mixer */
+static const snd_kcontrol_new_t wm8976_right_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left PCM Playback Switch", WM8976_OUTPUT, 5, 1, 1),
+SOC_DAPM_SINGLE("Right PCM Playback Switch", WM8976_MIXR, 0, 1, 1),
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8976_MIXR, 1, 1, 0),
+SOC_DAPM_SINGLE("Aux Playback Switch", WM8976_MIXR, 5, 1, 0),
+};
+
+/* Left AUX Input boost vol */
+static const snd_kcontrol_new_t wm8976_laux_boost_controls =
+SOC_DAPM_SINGLE("Aux Volume", WM8976_ADCBOOST, 0, 3, 0);
+
+/* Left Input boost vol */
+static const snd_kcontrol_new_t wm8976_lmic_boost_controls =
+SOC_DAPM_SINGLE("Input Volume", WM8976_ADCBOOST, 4, 3, 0);
+
+/* Left Aux In to PGA */
+static const snd_kcontrol_new_t wm8976_laux_capture_boost_controls =
+SOC_DAPM_SINGLE("Capture Switch", WM8976_ADCBOOST,  8, 1, 0);
+
+/* Left Input P In to PGA */
+static const snd_kcontrol_new_t wm8976_lmicp_capture_boost_controls =
+SOC_DAPM_SINGLE("Input P Capture Boost Switch", WM8976_INPUT,  0, 1, 0);
+
+/* Left Input N In to PGA */
+static const snd_kcontrol_new_t wm8976_lmicn_capture_boost_controls =
+SOC_DAPM_SINGLE("Input N Capture Boost Switch", WM8976_INPUT,  1, 1, 0);
+
+// TODO Widgets
+static const struct snd_soc_dapm_widget wm8976_dapm_widgets[] = {
+#if 0
+//SND_SOC_DAPM_MUTE("Mono Mute", WM8976_MONOMIX, 6, 0),
+//SND_SOC_DAPM_MUTE("Speaker Mute", WM8976_SPKMIX, 6, 0),
+
+SND_SOC_DAPM_MIXER("Speaker Mixer", WM8976_POWER3, 2, 0,
+	&wm8976_speaker_mixer_controls[0],
+	ARRAY_SIZE(wm8976_speaker_mixer_controls)),
+SND_SOC_DAPM_MIXER("Mono Mixer", WM8976_POWER3, 3, 0,
+	&wm8976_mono_mixer_controls[0],
+	ARRAY_SIZE(wm8976_mono_mixer_controls)),
+SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8976_POWER3, 0, 0),
+SND_SOC_DAPM_ADC("ADC", "HiFi Capture", WM8976_POWER3, 0, 0),
+SND_SOC_DAPM_PGA("Aux Input", WM8976_POWER1, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkN Out", WM8976_POWER3, 5, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SpkP Out", WM8976_POWER3, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mono Out", WM8976_POWER3, 7, 0, NULL, 0),
+SND_SOC_DAPM_PGA("Mic PGA", WM8976_POWER2, 2, 0, NULL, 0),
+
+SND_SOC_DAPM_PGA("Aux Boost", SND_SOC_NOPM, 0, 0,
+	&wm8976_aux_boost_controls, 1),
+SND_SOC_DAPM_PGA("Mic Boost", SND_SOC_NOPM, 0, 0,
+	&wm8976_mic_boost_controls, 1),
+SND_SOC_DAPM_SWITCH("Capture Boost", SND_SOC_NOPM, 0, 0,
+	&wm8976_capture_boost_controls),
+
+SND_SOC_DAPM_MIXER("Boost Mixer", WM8976_POWER2, 4, 0, NULL, 0),
+
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8976_POWER1, 4, 0),
+
+SND_SOC_DAPM_INPUT("MICN"),
+SND_SOC_DAPM_INPUT("MICP"),
+SND_SOC_DAPM_INPUT("AUX"),
+SND_SOC_DAPM_OUTPUT("MONOOUT"),
+SND_SOC_DAPM_OUTPUT("SPKOUTP"),
+SND_SOC_DAPM_OUTPUT("SPKOUTN"),
+#endif
+};
+
+static const char *audio_map[][3] = {
+	/* Mono output mixer */
+	{"Mono Mixer", "PCM Playback Switch", "DAC"},
+	{"Mono Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Mono Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Speaker output mixer */
+	{"Speaker Mixer", "PCM Playback Switch", "DAC"},
+	{"Speaker Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Speaker Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Outputs */
+	{"Mono Out", NULL, "Mono Mixer"},
+	{"MONOOUT", NULL, "Mono Out"},
+	{"SpkN Out", NULL, "Speaker Mixer"},
+	{"SpkP Out", NULL, "Speaker Mixer"},
+	{"SPKOUTN", NULL, "SpkN Out"},
+	{"SPKOUTP", NULL, "SpkP Out"},
+
+	/* Boost Mixer */
+	{"Boost Mixer", NULL, "ADC"},
+	{"Capture Boost Switch", "Aux Capture Boost Switch", "AUX"},
+	{"Aux Boost", "Aux Volume", "Boost Mixer"},
+	{"Capture Boost", "Capture Switch", "Boost Mixer"},
+	{"Mic Boost", "Mic Volume", "Boost Mixer"},
+
+	/* Inputs */
+	{"MICP", NULL, "Mic Boost"},
+	{"MICN", NULL, "Mic PGA"},
+	{"Mic PGA", NULL, "Capture Boost"},
+	{"AUX", NULL, "Aux Input"},
+
+    /*  */
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8976_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8976_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8976_dapm_widgets[i]);
+	}
+
+	/* set up audio path map */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0], audio_map[i][1],
+            audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct pll_ {
+	unsigned int in_hz, out_hz;
+	unsigned int pre:4; /* prescale - 1 */
+	unsigned int n:4;
+	unsigned int k;
+};
+
+struct pll_ pll[] = {
+	{12000000, 11289600, 0, 7, 0x86c220},
+	{12000000, 12288000, 0, 8, 0x3126e8},
+	{13000000, 11289600, 0, 6, 0xf28bd4},
+	{13000000, 12288000, 0, 7, 0x8fd525},
+	{12288000, 11289600, 0, 7, 0x59999a},
+	{11289600, 12288000, 0, 8, 0x80dee9},
+	/* TODO: liam - add more entries */
+};
+
+static int set_pll(struct snd_soc_codec *codec, unsigned int in,
+	unsigned int out)
+{
+	int i;
+	u16 reg;
+
+	if(out == 0) {
+		reg = wm8976_read_reg_cache(codec, WM8976_POWER1);
+		wm8976_write(codec, WM8976_POWER1, reg & 0x1df);
+		return 0;
+	}
+
+	for(i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (in == pll[i].in_hz && out == pll[i].out_hz) {
+			wm8976_write(codec, WM8976_PLLN, (pll[i].pre << 4) | pll[i].n);
+			wm8976_write(codec, WM8976_PLLK1, pll[i].k >> 18);
+			wm8976_write(codec, WM8976_PLLK1, (pll[i].k >> 9) && 0x1ff);
+			wm8976_write(codec, WM8976_PLLK1, pll[i].k && 0x1ff);
+			reg = wm8976_read_reg_cache(codec, WM8976_POWER1);
+			wm8976_write(codec, WM8976_POWER1, reg | 0x020);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/* mclk dividers * 2 */
+static unsigned char mclk_div[] = {2, 3, 4, 6, 8, 12, 16, 24};
+
+/* we need 256FS to drive the DAC's and ADC's */
+static unsigned int wm8976_config_sysclk(struct snd_soc_codec_dai *dai,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	int i, j, best_clk = info->fs * info->rate;
+
+	/* can we run at this clk without the PLL ? */
+	for (i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if ((best_clk >> 1) * mclk_div[i] == clk) {
+			dai->pll_in = 0;
+			dai->clk_div = mclk_div[i];
+			dai->mclk = best_clk;
+			return dai->mclk;
+		}
+	}
+
+	/* now check for PLL support */
+	for (i = 0; i < ARRAY_SIZE(pll); i++) {
+		if (pll[i].in_hz == clk) {
+			for (j = 0; j < ARRAY_SIZE(mclk_div); j++) {
+				if (pll[i].out_hz == mclk_div[j] * (best_clk >> 1)) {
+					dai->pll_in = clk;
+					dai->pll_out = pll[i].out_hz;
+					dai->clk_div = mclk_div[j];
+					dai->mclk = best_clk;
+					return dai->mclk;
+				}
+			}
+		}
+	}
+
+	/* this clk is not supported */
+	return 0;
+}
+
+static int wm8976_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *dai = rtd->codec_dai;
+	u16 iface = 0, bfs, clk = 0, adn;
+	int fs = 48000 << 7, i;
+
+	bfs = SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+	switch (bfs) {
+	case 2:
+		clk |= 0x1 << 2;
+		break;
+	case 4:
+		clk |= 0x2 << 2;
+		break;
+	case 8:
+		clk |= 0x3 << 2;
+		break;
+	case 16:
+		clk |= 0x4 << 2;
+		break;
+	case 32:
+		clk |= 0x5 << 2;
+		break;
+	}
+
+	/* set master/slave audio interface */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clk |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	}
+
+	/* interface format */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0010;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0008;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x00018;
+		break;
+	}
+
+	/* bit size */
+	switch (rtd->codec_dai->dai_runtime.pcmfmt) {
+	case SNDRV_PCM_FMTBIT_S16_LE:
+		break;
+	case SNDRV_PCM_FMTBIT_S20_3LE:
+		iface |= 0x0020;
+		break;
+	case SNDRV_PCM_FMTBIT_S24_LE:
+		iface |= 0x0040;
+		break;
+	case SNDRV_PCM_FMTBIT_S32_LE:
+		iface |= 0x0060;
+		break;
+	}
+
+	/* clock inversion */
+	switch (rtd->codec_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0180;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0100;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0080;
+		break;
+	}
+
+	/* filter coefficient */
+	adn = wm8976_read_reg_cache(codec, WM8976_ADD) & 0x1f1;
+	switch (rtd->codec_dai->dai_runtime.pcmrate) {
+	case SNDRV_PCM_RATE_8000:
+		adn |= 0x5 << 1;
+		fs = 8000 << 7;
+		break;
+	case SNDRV_PCM_RATE_11025:
+		adn |= 0x4 << 1;
+		fs = 11025 << 7;
+		break;
+	case SNDRV_PCM_RATE_16000:
+		adn |= 0x3 << 1;
+		fs = 16000 << 7;
+		break;
+	case SNDRV_PCM_RATE_22050:
+		adn |= 0x2 << 1;
+		fs = 22050 << 7;
+		break;
+	case SNDRV_PCM_RATE_32000:
+		adn |= 0x1 << 1;
+		fs = 32000 << 7;
+		break;
+	case SNDRV_PCM_RATE_44100:
+		fs = 44100 << 7;
+		break;
+	}
+
+	/* do we need to enable the PLL */
+	if(dai->pll_in)
+		set_pll(codec, dai->pll_in, dai->pll_out);
+
+	/* divide the clock to 256 fs */
+	for(i = 0; i < ARRAY_SIZE(mclk_div); i++) {
+		if (dai->clk_div == mclk_div[i]) {
+			clk |= i << 5;
+			clk &= 0xff;
+			goto set;
+		}
+	}
+
+set:
+	/* set iface */
+	wm8976_write(codec, WM8976_IFACE, iface);
+	wm8976_write(codec, WM8976_CLOCK, clk);
+
+	return 0;
+}
+
+static int wm8976_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	set_pll(codec, 0, 0);
+	return 0;
+}
+
+static int wm8976_mute(struct snd_soc_codec *codec,
+	struct snd_soc_codec_dai *dai, int mute)
+{
+	u16 mute_reg = wm8976_read_reg_cache(codec, WM8976_DAC) & 0xffbf;
+	if(mute)
+		wm8976_write(codec, WM8976_DAC, mute_reg | 0x40);
+	else
+		wm8976_write(codec, WM8976_DAC, mute_reg);
+
+	return 0;
+}
+
+/* TODO: liam need to make this lower power with dapm */
+static int wm8976_dapm_event(struct snd_soc_codec *codec, int event)
+{
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* vref/mid, clk and osc on, dac unmute, active */
+		wm8976_write(codec, WM8976_POWER1, 0x1ff);
+		wm8976_write(codec, WM8976_POWER2, 0x1ff);
+		wm8976_write(codec, WM8976_POWER3, 0x1ff);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, dac mute, inactive */
+
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, dac mute, inactive */
+		wm8976_write(codec, WM8976_POWER1, 0x0);
+		wm8976_write(codec, WM8976_POWER2, 0x0);
+		wm8976_write(codec, WM8976_POWER3, 0x0);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+struct snd_soc_codec_dai wm8976_dai = {
+	.name = "WM8976 HiFi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+	},
+	.config_sysclk = wm8976_config_sysclk,
+	.digital_mute = wm8976_mute,
+	.ops = {
+		.prepare = wm8976_pcm_prepare,
+		.hw_free = wm8976_hw_free,
+	},
+	.caps = {
+		.num_modes = ARRAY_SIZE(wm8976_modes),
+		.mode = wm8976_modes,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8976_dai);
+
+static int wm8976_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8976_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8976_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8976_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8976_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8976_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8976 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8976_init(struct snd_soc_device* socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "WM8976";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8976_read_reg_cache;
+	codec->write = wm8976_write;
+	codec->dapm_event = wm8976_dapm_event;
+	codec->dai = &wm8976_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(wm8976_reg);
+	codec->reg_cache =
+			kzalloc(sizeof(u16) * ARRAY_SIZE(wm8976_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+	memcpy(codec->reg_cache, wm8976_reg,
+		sizeof(u16) * ARRAY_SIZE(wm8976_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm8976_reg);
+
+	wm8976_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0) {
+		kfree(codec->reg_cache);
+		return ret;
+	}
+
+	/* power on device */
+	wm8976_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8976_add_controls(codec);
+	wm8976_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if(ret < 0) {
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+	}
+
+	return ret;
+}
+
+static struct snd_soc_device *wm8976_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8976 2 wire address is 0x1a
+ */
+#define I2C_DRIVERID_WM8976 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8976_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int wm8976_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8976_socdev;
+	struct wm8976_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	memcpy(i2c, &client_template, sizeof(struct i2c_client));
+
+	i2c_set_clientdata(i2c, codec);
+
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if(ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8976_init(socdev);
+	if(ret < 0) {
+		err("failed to initialise WM8976\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+
+}
+
+static int wm8976_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+
+	i2c_detach_client(client);
+
+	kfree(codec->reg_cache);
+	kfree(client);
+
+	return 0;
+}
+
+static int wm8976_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8976_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8976_i2c_driver = {
+	.driver = {
+		.name = "WM8976 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8976,
+	.attach_adapter = wm8976_i2c_attach,
+	.detach_client =  wm8976_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8976",
+	.driver = &wm8976_i2c_driver,
+};
+#endif
+
+static int wm8976_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8976_setup_data *setup;
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	info("WM8976 Audio Codec %s", WM8976_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8976_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8976_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8976_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8976_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8976_i2c_driver);
+#endif
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8976 = {
+	.probe = 	wm8976_probe,
+	.remove = 	wm8976_remove,
+	.suspend = 	wm8976_suspend,
+	.resume =	wm8976_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8976);
+
+MODULE_DESCRIPTION("ASoC WM8976 driver");
+MODULE_AUTHOR("Graeme Gregory");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/codecs/wm8976.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/codecs/wm8976.h
@@ -0,0 +1,73 @@
+/*
+ * wm8976.h  --  WM8976 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8976_H
+#define _WM8976_H
+
+/* WM8976 register space */
+
+#define WM8976_RESET		0x0
+#define WM8976_POWER1		0x1
+#define WM8976_POWER2		0x2
+#define WM8976_POWER3		0x3
+#define WM8976_IFACE		0x4
+#define WM8976_COMP			0x5
+#define WM8976_CLOCK		0x6
+#define WM8976_ADD			0x7
+#define WM8976_GPIO			0x8
+#define WM8976_JACK1        0x9
+#define WM8976_DAC			0xa
+#define WM8976_DACVOLL	    0xb
+#define WM8976_DACVOLR      0xc
+#define WM8976_JACK2        0xd
+#define WM8976_ADC			0xe
+#define WM8976_ADCVOL		0xf
+#define WM8976_EQ1			0x12
+#define WM8976_EQ2			0x13
+#define WM8976_EQ3			0x14
+#define WM8976_EQ4			0x15
+#define WM8976_EQ5			0x16
+#define WM8976_DACLIM1		0x18
+#define WM8976_DACLIM2		0x19
+#define WM8976_NOTCH1		0x1b
+#define WM8976_NOTCH2		0x1c
+#define WM8976_NOTCH3		0x1d
+#define WM8976_NOTCH4		0x1e
+#define WM8976_ALC1			0x20
+#define WM8976_ALC2			0x21
+#define WM8976_ALC3			0x22
+#define WM8976_NGATE		0x23
+#define WM8976_PLLN			0x24
+#define WM8976_PLLK1		0x25
+#define WM8976_PLLK2		0x26
+#define WM8976_PLLK3		0x27
+#define WM8976_3D           0x29
+#define WM8976_BEEP         0x2b
+#define WM8976_INPUT		0x2c
+#define WM8976_INPPGA	  	0x2d
+#define WM8976_ADCBOOST		0x2f
+#define WM8976_OUTPUT		0x31
+#define WM8976_MIXL	        0x32
+#define WM8976_MIXR         0x33
+#define WM8976_HPVOLL		0x34
+#define WM8976_HPVOLR       0x35
+#define WM8976_SPKVOLL      0x36
+#define WM8976_SPKVOLR      0x37
+#define WM8976_OUT3MIX		0x38
+#define WM8976_MONOMIX      0x39
+
+#define WM8976_CACHEREGNUM 	58
+
+struct wm8976_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8976_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8976;
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/imx/imx21-pcm.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/imx21-pcm.c
@@ -0,0 +1,454 @@
+/*
+ * linux/sound/arm/mxc-pcm.c -- ALSA SoC interface for the Freescale i.MX CPU's
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * Based on pxa2xx-pcm.c by	Nicolas Pitre, (C) 2004 MontaVista Software, Inc.
+ * and on mxc-alsa-mc13783 (C) 2006 Freescale.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Revision history
+ *    29th Aug 2006   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <asm/dma.h>
+#include <asm/hardware.h>
+
+#include "imx-pcm.h"
+
+/* debug */
+#define IMX_DEBUG 0
+#if IMX_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+static const struct snd_pcm_hardware mxc_pcm_hardware = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				   SNDRV_PCM_INFO_MMAP |
+				   SNDRV_PCM_INFO_MMAP_VALID |
+				   SNDRV_PCM_INFO_PAUSE |
+				   SNDRV_PCM_INFO_RESUME),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+					SNDRV_PCM_FMTBIT_S24_LE,
+	.buffer_bytes_max	= 32 * 1024,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 8 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 255,
+	.fifo_size		= 0,
+};
+
+struct mxc_runtime_data {
+	int dma_ch;
+	struct mxc_pcm_dma_param *dma_params;
+};
+
+/*!
+  * This function stops the current dma transfert for playback
+  * and clears the dma pointers.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  */
+static void audio_stop_dma(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int dma_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned int offset  dma_size * s->periods;
+	unsigned long flags;
+
+	spin_lock_irqsave(&prtd->dma_lock, flags);
+
+	dbg("MXC : audio_stop_dma active = 0\n");
+	prtd->active = 0;
+	prtd->period = 0;
+	prtd->periods = 0;
+
+	/* this stops the dma channel and clears the buffer ptrs */
+	mxc_dma_stop(prtd->dma_wchannel);
+	if(substream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_TO_DEVICE);
+	else
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_FROM_DEVICE);
+
+	spin_unlock_irqrestore(&prtd->dma_lock, flags);
+}
+
+/*!
+  * This function is called whenever a new audio block needs to be
+  * transferred to mc13783. The function receives the address and the size
+  * of the new block and start a new DMA transfer.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  */
+static int dma_new_period(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime =  substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int dma_size;
+	unsigned int offset;
+	int ret=0;
+	dma_request_t sdma_request;
+
+	if (prtd->active){
+		memset(&sdma_request, 0, sizeof(dma_request_t));
+		dma_size = frames_to_bytes(runtime, runtime->period_size);
+	    dbg("s->period (%x) runtime->periods (%d)\n",
+			s->period,runtime->periods);
+		dbg("runtime->period_size (%d) dma_size (%d)\n",
+			(unsigned int)runtime->period_size,
+			runtime->dma_bytes);
+
+       	offset = dma_size * prtd->period;
+		snd_assert(dma_size <= DMA_BUF_SIZE, );
+		if(substream == SNDRV_PCM_STREAM_PLAYBACK)
+			sdma_request.sourceAddr = (char*)(dma_map_single(NULL,
+				runtime->dma_area + offset, dma_size, DMA_TO_DEVICE));
+		else
+			sdma_request.destAddr = (char*)(dma_map_single(NULL,
+				runtime->dma_area + offset, dma_size, DMA_FROM_DEVICE));
+		sdma_request.count = dma_size;
+
+		dbg("MXC: Start DMA offset (%d) size (%d)\n", offset,
+						 runtime->dma_bytes);
+
+       	mxc_dma_set_config(prtd->dma_wchannel, &sdma_request, 0);
+		if((ret = mxc_dma_start(prtd->dma_wchannel)) < 0) {
+			dbg("audio_process_dma: cannot queue DMA buffer\
+							(%i)\n", ret);
+			return err;
+		}
+		prtd->tx_spin = 1; /* FGA little trick to retrieve DMA pos */
+		prtd->period++;
+		prtd->period %= runtime->periods;
+    }
+	return ret;
+}
+
+
+/*!
+  * This is a callback which will be called
+  * when a TX transfer finishes. The call occurs
+  * in interrupt context.
+  *
+  * @param	dat	pointer to the structure of the current stream.
+  *
+  */
+static void audio_dma_irq(void *data)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	struct mxc_runtime_data *prtd;
+	unsigned int dma_size;
+	unsigned int previous_period;
+	unsigned int offset;
+
+	substream = data;
+	runtime = substream->runtime;
+	prtd = runtime->private_data;
+	previous_period  = prtd->periods;
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	offset = dma_size * previous_period;
+
+	prtd->tx_spin = 0;
+	prtd->periods++;
+	prtd->periods %= runtime->periods;
+
+	/*
+	  * Give back to the CPU the access to the non cached memory
+	  */
+	if(substream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_TO_DEVICE);
+	else
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_FROM_DEVICE);
+	/*
+	  * If we are getting a callback for an active stream then we inform
+	  * the PCM middle layer we've finished a period
+	  */
+ 	if (prtd->active)
+		snd_pcm_period_elapsed(substream);
+
+	/*
+	  * Trig next DMA transfer
+	  */
+	dma_new_period(substream);
+}
+
+/*!
+  * This function configures the hardware to allow audio
+  * playback operations. It is called by ALSA framework.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  * @return              0 on success, -1 otherwise.
+  */
+static int
+snd_mxc_prepare(struct snd_pcm_substream *substream)
+{
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int ret = 0;
+	prtd->period = 0;
+	prtd->periods = 0;
+
+	dma_channel_params params;
+	int channel = 0; // passed in ?
+
+	if ((ret  = mxc_request_dma(&channel, "ALSA TX SDMA") < 0)){
+		dbg("error requesting a write dma channel\n");
+		return ret;
+	}
+
+	/* configure DMA params */
+	memset(&params, 0, sizeof(dma_channel_params));
+	params.bd_number = 1;
+	params.arg = s;
+	params.callback = callback;
+	params.transfer_type = emi_2_per;
+	params.watermark_level = SDMA_TXFIFO_WATERMARK;
+	params.word_size = TRANSFER_16BIT;
+	//dbg(KERN_ERR "activating connection SSI1 - SDMA\n");
+	params.per_address = SSI1_BASE_ADDR;
+	params.event_id = DMA_REQ_SSI1_TX1;
+	params.peripheral_type = SSI;
+
+	/* set up chn with params */
+	mxc_dma_setup_channel(channel, &params);
+	s->dma_wchannel = channel;
+
+	return ret;
+}
+
+static int mxc_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	if((ret=snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
+		return ret;
+	runtime->dma_addr = virt_to_phys(runtime->dma_area);
+
+	return ret;
+}
+
+static int mxc_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int mxc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mxc_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->tx_spin = 0;
+		/* requested stream startup */
+		prtd->active = 1;
+        ret = dma_new_period(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		/* requested stream shutdown */
+		ret = audio_stop_dma(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		prtd->active = 0;
+		prtd->periods = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+		prtd->active = 1;
+		prtd->tx_spin = 0;
+		ret = dma_new_period(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		prtd->active = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		prtd->active = 1;
+		if (prtd->old_offset) {
+			prtd->tx_spin = 0;
+            ret = dma_new_period(substream);
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t mxc_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int offset = 0;
+
+	/* tx_spin value is used here to check if a transfert is active */
+	if (prtd->tx_spin){
+		offset = (runtime->period_size * (prtd->periods)) +
+						(runtime->period_size >> 1);
+		if (offset >= runtime->buffer_size)
+			offset = runtime->period_size >> 1;
+	} else {
+		offset = (runtime->period_size * (s->periods));
+		if (offset >= runtime->buffer_size)
+			offset = 0;
+	}
+
+	return offset;
+}
+
+
+static int mxc_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &mxc_pcm_hardware);
+
+	if ((err = snd_pcm_hw_constraint_integer(runtime,
+					SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &hw_playback_rates)) < 0)
+		return err;
+	msleep(10); // liam - why
+
+	/* setup DMA controller for playback */
+	if((err = configure_write_channel(&mxc_mc13783->s[SNDRV_PCM_STREAM_PLAYBACK],
+					audio_dma_irq)) < 0 )
+		return err;
+
+	if((prtd = kzalloc(sizeof(struct mxc_runtime_data), GFP_KERNEL)) == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	runtime->private_data = prtd;
+	return 0;
+
+ err1:
+	kfree(prtd);
+ out:
+	return ret;
+}
+
+static int mxc_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+//	mxc_mc13783_t *chip;
+	audio_stream_t *s;
+	device_data_t* device;
+	int ssi;
+
+	//chip = snd_pcm_substream_chip(substream);
+	s = &chip->s[substream->pstr->stream];
+	device = &s->stream_device;
+	ssi = device->ssi;
+
+	//disable_stereodac();
+
+	ssi_transmit_enable(ssi, false);
+	ssi_interrupt_disable(ssi, ssi_tx_dma_interrupt_enable);
+	ssi_tx_fifo_enable(ssi, ssi_fifo_0, false);
+	ssi_enable(ssi, false);
+
+	chip->s[substream->pstr->stream].stream = NULL;
+
+	return 0;
+}
+
+static int
+mxc_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops mxc_pcm_ops = {
+	.open		= mxc_pcm_open,
+	.close		= mxc_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= mxc_pcm_hw_params,
+	.hw_free	= mxc_pcm_hw_free,
+	.prepare	= mxc_pcm_prepare,
+	.trigger	= mxc_pcm_trigger,
+	.pointer	= mxc_pcm_pointer,
+	.mmap		= mxc_pcm_mmap,
+};
+
+static u64 mxc_pcm_dmamask = 0xffffffff;
+
+int mxc_pcm_new(struct snd_card *card, struct snd_soc_codec_dai *dai,
+	struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &mxc_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = mxc_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = mxc_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+struct snd_soc_platform mxc_soc_platform = {
+	.name		= "mxc-audio",
+	.pcm_ops 	= &mxc_pcm_ops,
+	.pcm_new	= mxc_pcm_new,
+	.pcm_free	= mxc_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(mxc_soc_platform);
+
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_DESCRIPTION("Freescale i.MX PCM DMA module");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/imx/imx21-pcm.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/imx21-pcm.h
@@ -0,0 +1,237 @@
+/*
+ * mxc-pcm.h :- ASoC platform header for Freescale i.MX
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _MXC_PCM_H
+#define _MXC_PCM_H
+
+struct {
+	char *name;			/* stream identifier */
+	dma_channel_params dma_params;
+} mxc_pcm_dma_param;
+
+extern struct snd_soc_cpu_dai mxc_ssi_dai[3];
+
+/* platform data */
+extern struct snd_soc_platform mxc_soc_platform;
+extern struct snd_ac97_bus_ops mxc_ac97_ops;
+
+/* temp until imx-regs.h is up2date */
+#define SSI1_STX0   __REG(IMX_SSI1_BASE + 0x00)
+#define SSI1_STX0_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x00)
+#define SSI1_STX1   __REG(IMX_SSI1_BASE + 0x04)
+#define SSI1_STX1_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x04)
+#define SSI1_SRX0   __REG(IMX_SSI1_BASE + 0x08)
+#define SSI1_SRX0_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x08)
+#define SSI1_SRX1   __REG(IMX_SSI1_BASE + 0x0c)
+#define SSI1_SRX1_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x0c)
+#define SSI1_SCR    __REG(IMX_SSI1_BASE + 0x10)
+#define SSI1_SISR   __REG(IMX_SSI1_BASE + 0x14)
+#define SSI1_SIER   __REG(IMX_SSI1_BASE + 0x18)
+#define SSI1_STCR   __REG(IMX_SSI1_BASE + 0x1c)
+#define SSI1_SRCR   __REG(IMX_SSI1_BASE + 0x20)
+#define SSI1_STCCR  __REG(IMX_SSI1_BASE + 0x24)
+#define SSI1_SRCCR  __REG(IMX_SSI1_BASE + 0x28)
+#define SSI1_SFCSR  __REG(IMX_SSI1_BASE + 0x2c)
+#define SSI1_STR    __REG(IMX_SSI1_BASE + 0x30)
+#define SSI1_SOR    __REG(IMX_SSI1_BASE + 0x34)
+#define SSI1_SACNT  __REG(IMX_SSI1_BASE + 0x38)
+#define SSI1_SACADD __REG(IMX_SSI1_BASE + 0x3c)
+#define SSI1_SACDAT __REG(IMX_SSI1_BASE + 0x40)
+#define SSI1_SATAG  __REG(IMX_SSI1_BASE + 0x44)
+#define SSI1_STMSK  __REG(IMX_SSI1_BASE + 0x48)
+#define SSI1_SRMSK  __REG(IMX_SSI1_BASE + 0x4c)
+
+#define SSI2_STX0   __REG(IMX_SSI2_BASE + 0x00)
+#define SSI2_STX0_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x00)
+#define SSI2_STX1   __REG(IMX_SSI2_BASE + 0x04)
+#define SSI2_STX1_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x04)
+#define SSI2_SRX0   __REG(IMX_SSI2_BASE + 0x08)
+#define SSI2_SRX0_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x08)
+#define SSI2_SRX1   __REG(IMX_SSI2_BASE + 0x0c)
+#define SSI2_SRX1_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x0c)
+#define SSI2_SCR    __REG(IMX_SSI2_BASE + 0x10)
+#define SSI2_SISR   __REG(IMX_SSI2_BASE + 0x14)
+#define SSI2_SIER   __REG(IMX_SSI2_BASE + 0x18)
+#define SSI2_STCR   __REG(IMX_SSI2_BASE + 0x1c)
+#define SSI2_SRCR   __REG(IMX_SSI2_BASE + 0x20)
+#define SSI2_STCCR  __REG(IMX_SSI2_BASE + 0x24)
+#define SSI2_SRCCR  __REG(IMX_SSI2_BASE + 0x28)
+#define SSI2_SFCSR  __REG(IMX_SSI2_BASE + 0x2c)
+#define SSI2_STR    __REG(IMX_SSI2_BASE + 0x30)
+#define SSI2_SOR    __REG(IMX_SSI2_BASE + 0x34)
+#define SSI2_SACNT  __REG(IMX_SSI2_BASE + 0x38)
+#define SSI2_SACADD __REG(IMX_SSI2_BASE + 0x3c)
+#define SSI2_SACDAT __REG(IMX_SSI2_BASE + 0x40)
+#define SSI2_SATAG  __REG(IMX_SSI2_BASE + 0x44)
+#define SSI2_STMSK  __REG(IMX_SSI2_BASE + 0x48)
+#define SSI2_SRMSK  __REG(IMX_SSI2_BASE + 0x4c)
+
+#define SSI_SCR_CLK_IST        (1 << 9)
+#define SSI_SCR_TCH_EN         (1 << 8)
+#define SSI_SCR_SYS_CLK_EN     (1 << 7)
+#define SSI_SCR_I2S_MODE_NORM  (0 << 5)
+#define SSI_SCR_I2S_MODE_MSTR  (1 << 5)
+#define SSI_SCR_I2S_MODE_SLAVE (2 << 5)
+#define SSI_SCR_SYN            (1 << 4)
+#define SSI_SCR_NET            (1 << 3)
+#define SSI_SCR_RE             (1 << 2)
+#define SSI_SCR_TE             (1 << 1)
+#define SSI_SCR_SSIEN          (1 << 0)
+
+#define SSI_SISR_CMDAU         (1 << 18)
+#define SSI_SISR_CMDDU         (1 << 17)
+#define SSI_SISR_RXT           (1 << 16)
+#define SSI_SISR_RDR1          (1 << 15)
+#define SSI_SISR_RDR0          (1 << 14)
+#define SSI_SISR_TDE1          (1 << 13)
+#define SSI_SISR_TDE0          (1 << 12)
+#define SSI_SISR_ROE1          (1 << 11)
+#define SSI_SISR_ROE0          (1 << 10)
+#define SSI_SISR_TUE1          (1 << 9)
+#define SSI_SISR_TUE0          (1 << 8)
+#define SSI_SISR_TFS           (1 << 7)
+#define SSI_SISR_RFS           (1 << 6)
+#define SSI_SISR_TLS           (1 << 5)
+#define SSI_SISR_RLS           (1 << 4)
+#define SSI_SISR_RFF1          (1 << 3)
+#define SSI_SISR_RFF0          (1 << 2)
+#define SSI_SISR_TFE1          (1 << 1)
+#define SSI_SISR_TFE0          (1 << 0)
+
+#define SSI_SIER_RDMAE         (1 << 22)
+#define SSI_SIER_RIE           (1 << 21)
+#define SSI_SIER_TDMAE         (1 << 20)
+#define SSI_SIER_TIE           (1 << 19)
+#define SSI_SIER_CMDAU_EN      (1 << 18)
+#define SSI_SIER_CMDDU_EN      (1 << 17)
+#define SSI_SIER_RXT_EN        (1 << 16)
+#define SSI_SIER_RDR1_EN       (1 << 15)
+#define SSI_SIER_RDR0_EN       (1 << 14)
+#define SSI_SIER_TDE1_EN       (1 << 13)
+#define SSI_SIER_TDE0_EN       (1 << 12)
+#define SSI_SIER_ROE1_EN       (1 << 11)
+#define SSI_SIER_ROE0_EN       (1 << 10)
+#define SSI_SIER_TUE1_EN       (1 << 9)
+#define SSI_SIER_TUE0_EN       (1 << 8)
+#define SSI_SIER_TFS_EN        (1 << 7)
+#define SSI_SIER_RFS_EN        (1 << 6)
+#define SSI_SIER_TLS_EN        (1 << 5)
+#define SSI_SIER_RLS_EN        (1 << 4)
+#define SSI_SIER_RFF1_EN       (1 << 3)
+#define SSI_SIER_RFF0_EN       (1 << 2)
+#define SSI_SIER_TFE1_EN       (1 << 1)
+#define SSI_SIER_TFE0_EN       (1 << 0)
+
+#define SSI_STCR_TXBIT0        (1 << 9)
+#define SSI_STCR_TFEN1         (1 << 8)
+#define SSI_STCR_TFEN0         (1 << 7)
+#define SSI_STCR_TFDIR         (1 << 6)
+#define SSI_STCR_TXDIR         (1 << 5)
+#define SSI_STCR_TSHFD         (1 << 4)
+#define SSI_STCR_TSCKP         (1 << 3)
+#define SSI_STCR_TFSI          (1 << 2)
+#define SSI_STCR_TFSL          (1 << 1)
+#define SSI_STCR_TEFS          (1 << 0)
+
+#define SSI_SRCR_RXBIT0        (1 << 9)
+#define SSI_SRCR_RFEN1         (1 << 8)
+#define SSI_SRCR_RFEN0         (1 << 7)
+#define SSI_SRCR_RFDIR         (1 << 6)
+#define SSI_SRCR_RXDIR         (1 << 5)
+#define SSI_SRCR_RSHFD         (1 << 4)
+#define SSI_SRCR_RSCKP         (1 << 3)
+#define SSI_SRCR_RFSI          (1 << 2)
+#define SSI_SRCR_RFSL          (1 << 1)
+#define SSI_SRCR_REFS          (1 << 0)
+
+#define SSI_STCCR_DIV2         (1 << 18)
+#define SSI_STCCR_PSR          (1 << 15)
+#define SSI_STCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_STCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_STCCR_PM(x)        (((x) & 0xff) << 0)
+
+#define SSI_SRCCR_DIV2         (1 << 18)
+#define SSI_SRCCR_PSR          (1 << 15)
+#define SSI_SRCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_SRCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_SRCCR_PM(x)        (((x) & 0xff) << 0)
+
+
+#define SSI_SFCSR_RFCNT1(x)   (((x) & 0xf) << 28)
+#define SSI_SFCSR_TFCNT1(x)   (((x) & 0xf) << 24)
+#define SSI_SFCSR_RFWM1(x)    (((x) & 0xf) << 20)
+#define SSI_SFCSR_TFWM1(x)    (((x) & 0xf) << 16)
+#define SSI_SFCSR_RFCNT0(x)   (((x) & 0xf) << 12)
+#define SSI_SFCSR_TFCNT0(x)   (((x) & 0xf) <<  8)
+#define SSI_SFCSR_RFWM0(x)    (((x) & 0xf) <<  4)
+#define SSI_SFCSR_TFWM0(x)    (((x) & 0xf) <<  0)
+
+#define SSI_STR_TEST          (1 << 15)
+#define SSI_STR_RCK2TCK       (1 << 14)
+#define SSI_STR_RFS2TFS       (1 << 13)
+#define SSI_STR_RXSTATE(x)    (((x) & 0xf) << 8)
+#define SSI_STR_TXD2RXD       (1 <<  7)
+#define SSI_STR_TCK2RCK       (1 <<  6)
+#define SSI_STR_TFS2RFS       (1 <<  5)
+#define SSI_STR_TXSTATE(x)    (((x) & 0xf) << 0)
+
+#define SSI_SOR_CLKOFF        (1 << 6)
+#define SSI_SOR_RX_CLR        (1 << 5)
+#define SSI_SOR_TX_CLR        (1 << 4)
+#define SSI_SOR_INIT          (1 << 3)
+#define SSI_SOR_WAIT(x)       (((x) & 0x3) << 1)
+#define SSI_SOR_SYNRST        (1 << 0)
+
+#define SSI_SACNT_FRDIV(x)    (((x) & 0x3f) << 5)
+#define SSI_SACNT_WR          (x << 4)
+#define SSI_SACNT_RD          (x << 3)
+#define SSI_SACNT_TIF         (x << 2)
+#define SSI_SACNT_FV          (x << 1)
+#define SSI_SACNT_A97EN       (x << 0)
+
+
+/* AUDMUX registers */
+#define AUDMUX_HPCR1         __REG(IMX_AUDMUX_BASE + 0x00)
+#define AUDMUX_HPCR2         __REG(IMX_AUDMUX_BASE + 0x04)
+#define AUDMUX_HPCR3         __REG(IMX_AUDMUX_BASE + 0x08)
+#define AUDMUX_PPCR1         __REG(IMX_AUDMUX_BASE + 0x10)
+#define AUDMUX_PPCR2         __REG(IMX_AUDMUX_BASE + 0x14)
+#define AUDMUX_PPCR3         __REG(IMX_AUDMUX_BASE + 0x18)
+
+#define AUDMUX_HPCR_TFSDIR         (1 << 31)
+#define AUDMUX_HPCR_TCLKDIR        (1 << 30)
+#define AUDMUX_HPCR_TFCSEL_TX      (0 << 26)
+#define AUDMUX_HPCR_TFCSEL_RX      (8 << 26)
+#define AUDMUX_HPCR_TFCSEL(x)      (((x) & 0x7) << 26)
+#define AUDMUX_HPCR_RFSDIR         (1 << 25)
+#define AUDMUX_HPCR_RCLKDIR        (1 << 24)
+#define AUDMUX_HPCR_RFCSEL_TX      (0 << 20)
+#define AUDMUX_HPCR_RFCSEL_RX      (8 << 20)
+#define AUDMUX_HPCR_RFCSEL(x)      (((x) & 0x7) << 20)
+#define AUDMUX_HPCR_RXDSEL(x)      (((x) & 0x7) << 13)
+#define AUDMUX_HPCR_SYN            (1 << 12)
+#define AUDMUX_HPCR_TXRXEN         (1 << 10)
+#define AUDMUX_HPCR_INMEN          (1 <<  8)
+#define AUDMUX_HPCR_INMMASK(x)     (((x) & 0xff) << 0)
+
+#define AUDMUX_PPCR_TFSDIR         (1 << 31)
+#define AUDMUX_PPCR_TCLKDIR        (1 << 30)
+#define AUDMUX_PPCR_TFCSEL_TX      (0 << 26)
+#define AUDMUX_PPCR_TFCSEL_RX      (8 << 26)
+#define AUDMUX_PPCR_TFCSEL(x)      (((x) & 0x7) << 26)
+#define AUDMUX_PPCR_RFSDIR         (1 << 25)
+#define AUDMUX_PPCR_RCLKDIR        (1 << 24)
+#define AUDMUX_PPCR_RFCSEL_TX      (0 << 20)
+#define AUDMUX_PPCR_RFCSEL_RX      (8 << 20)
+#define AUDMUX_PPCR_RFCSEL(x)      (((x) & 0x7) << 20)
+#define AUDMUX_PPCR_RXDSEL(x)      (((x) & 0x7) << 13)
+#define AUDMUX_PPCR_SYN            (1 << 12)
+#define AUDMUX_PPCR_TXRXEN         (1 << 10)
+
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/imx/imx31-pcm.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/imx31-pcm.c
@@ -0,0 +1,454 @@
+/*
+ * linux/sound/arm/mxc-pcm.c -- ALSA SoC interface for the Freescale i.MX CPU's
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * Based on pxa2xx-pcm.c by	Nicolas Pitre, (C) 2004 MontaVista Software, Inc.
+ * and on mxc-alsa-mc13783 (C) 2006 Freescale.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Revision history
+ *    29th Aug 2006   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <asm/dma.h>
+#include <asm/hardware.h>
+
+#include "imx-pcm.h"
+
+/* debug */
+#define IMX_DEBUG 0
+#if IMX_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+static const struct snd_pcm_hardware mxc_pcm_hardware = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				   SNDRV_PCM_INFO_MMAP |
+				   SNDRV_PCM_INFO_MMAP_VALID |
+				   SNDRV_PCM_INFO_PAUSE |
+				   SNDRV_PCM_INFO_RESUME),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+					SNDRV_PCM_FMTBIT_S24_LE,
+	.buffer_bytes_max	= 32 * 1024,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 8 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 255,
+	.fifo_size		= 0,
+};
+
+struct mxc_runtime_data {
+	int dma_ch;
+	struct mxc_pcm_dma_param *dma_params;
+};
+
+/*!
+  * This function stops the current dma transfert for playback
+  * and clears the dma pointers.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  */
+static void audio_stop_dma(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int dma_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned int offset  dma_size * s->periods;
+	unsigned long flags;
+
+	spin_lock_irqsave(&prtd->dma_lock, flags);
+
+	dbg("MXC : audio_stop_dma active = 0\n");
+	prtd->active = 0;
+	prtd->period = 0;
+	prtd->periods = 0;
+
+	/* this stops the dma channel and clears the buffer ptrs */
+	mxc_dma_stop(prtd->dma_wchannel);
+	if(substream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_TO_DEVICE);
+	else
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_FROM_DEVICE);
+
+	spin_unlock_irqrestore(&prtd->dma_lock, flags);
+}
+
+/*!
+  * This function is called whenever a new audio block needs to be
+  * transferred to mc13783. The function receives the address and the size
+  * of the new block and start a new DMA transfer.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  */
+static int dma_new_period(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime =  substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int dma_size;
+	unsigned int offset;
+	int ret=0;
+	dma_request_t sdma_request;
+
+	if (prtd->active){
+		memset(&sdma_request, 0, sizeof(dma_request_t));
+		dma_size = frames_to_bytes(runtime, runtime->period_size);
+	    dbg("s->period (%x) runtime->periods (%d)\n",
+			s->period,runtime->periods);
+		dbg("runtime->period_size (%d) dma_size (%d)\n",
+			(unsigned int)runtime->period_size,
+			runtime->dma_bytes);
+
+       	offset = dma_size * prtd->period;
+		snd_assert(dma_size <= DMA_BUF_SIZE, );
+		if(substream == SNDRV_PCM_STREAM_PLAYBACK)
+			sdma_request.sourceAddr = (char*)(dma_map_single(NULL,
+				runtime->dma_area + offset, dma_size, DMA_TO_DEVICE));
+		else
+			sdma_request.destAddr = (char*)(dma_map_single(NULL,
+				runtime->dma_area + offset, dma_size, DMA_FROM_DEVICE));
+		sdma_request.count = dma_size;
+
+		dbg("MXC: Start DMA offset (%d) size (%d)\n", offset,
+						 runtime->dma_bytes);
+
+       	mxc_dma_set_config(prtd->dma_wchannel, &sdma_request, 0);
+		if((ret = mxc_dma_start(prtd->dma_wchannel)) < 0) {
+			dbg("audio_process_dma: cannot queue DMA buffer\
+							(%i)\n", ret);
+			return err;
+		}
+		prtd->tx_spin = 1; /* FGA little trick to retrieve DMA pos */
+		prtd->period++;
+		prtd->period %= runtime->periods;
+    }
+	return ret;
+}
+
+
+/*!
+  * This is a callback which will be called
+  * when a TX transfer finishes. The call occurs
+  * in interrupt context.
+  *
+  * @param	dat	pointer to the structure of the current stream.
+  *
+  */
+static void audio_dma_irq(void *data)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	struct mxc_runtime_data *prtd;
+	unsigned int dma_size;
+	unsigned int previous_period;
+	unsigned int offset;
+
+	substream = data;
+	runtime = substream->runtime;
+	prtd = runtime->private_data;
+	previous_period  = prtd->periods;
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	offset = dma_size * previous_period;
+
+	prtd->tx_spin = 0;
+	prtd->periods++;
+	prtd->periods %= runtime->periods;
+
+	/*
+	  * Give back to the CPU the access to the non cached memory
+	  */
+	if(substream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_TO_DEVICE);
+	else
+		dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+							DMA_FROM_DEVICE);
+	/*
+	  * If we are getting a callback for an active stream then we inform
+	  * the PCM middle layer we've finished a period
+	  */
+ 	if (prtd->active)
+		snd_pcm_period_elapsed(substream);
+
+	/*
+	  * Trig next DMA transfer
+	  */
+	dma_new_period(substream);
+}
+
+/*!
+  * This function configures the hardware to allow audio
+  * playback operations. It is called by ALSA framework.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  * @return              0 on success, -1 otherwise.
+  */
+static int
+snd_mxc_prepare(struct snd_pcm_substream *substream)
+{
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int ret = 0;
+	prtd->period = 0;
+	prtd->periods = 0;
+
+	dma_channel_params params;
+	int channel = 0; // passed in ?
+
+	if ((ret  = mxc_request_dma(&channel, "ALSA TX SDMA") < 0)){
+		dbg("error requesting a write dma channel\n");
+		return ret;
+	}
+
+	/* configure DMA params */
+	memset(&params, 0, sizeof(dma_channel_params));
+	params.bd_number = 1;
+	params.arg = s;
+	params.callback = callback;
+	params.transfer_type = emi_2_per;
+	params.watermark_level = SDMA_TXFIFO_WATERMARK;
+	params.word_size = TRANSFER_16BIT;
+	//dbg(KERN_ERR "activating connection SSI1 - SDMA\n");
+	params.per_address = SSI1_BASE_ADDR;
+	params.event_id = DMA_REQ_SSI1_TX1;
+	params.peripheral_type = SSI;
+
+	/* set up chn with params */
+	mxc_dma_setup_channel(channel, &params);
+	s->dma_wchannel = channel;
+
+	return ret;
+}
+
+static int mxc_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	if((ret=snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
+		return ret;
+	runtime->dma_addr = virt_to_phys(runtime->dma_area);
+
+	return ret;
+}
+
+static int mxc_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int mxc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mxc_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->tx_spin = 0;
+		/* requested stream startup */
+		prtd->active = 1;
+        ret = dma_new_period(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		/* requested stream shutdown */
+		ret = audio_stop_dma(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		prtd->active = 0;
+		prtd->periods = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+		prtd->active = 1;
+		prtd->tx_spin = 0;
+		ret = dma_new_period(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		prtd->active = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		prtd->active = 1;
+		if (prtd->old_offset) {
+			prtd->tx_spin = 0;
+            ret = dma_new_period(substream);
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t mxc_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int offset = 0;
+
+	/* tx_spin value is used here to check if a transfert is active */
+	if (prtd->tx_spin){
+		offset = (runtime->period_size * (prtd->periods)) +
+						(runtime->period_size >> 1);
+		if (offset >= runtime->buffer_size)
+			offset = runtime->period_size >> 1;
+	} else {
+		offset = (runtime->period_size * (s->periods));
+		if (offset >= runtime->buffer_size)
+			offset = 0;
+	}
+
+	return offset;
+}
+
+
+static int mxc_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &mxc_pcm_hardware);
+
+	if ((err = snd_pcm_hw_constraint_integer(runtime,
+					SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &hw_playback_rates)) < 0)
+		return err;
+	msleep(10); // liam - why
+
+	/* setup DMA controller for playback */
+	if((err = configure_write_channel(&mxc_mc13783->s[SNDRV_PCM_STREAM_PLAYBACK],
+					audio_dma_irq)) < 0 )
+		return err;
+
+	if((prtd = kzalloc(sizeof(struct mxc_runtime_data), GFP_KERNEL)) == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	runtime->private_data = prtd;
+	return 0;
+
+ err1:
+	kfree(prtd);
+ out:
+	return ret;
+}
+
+static int mxc_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+//	mxc_mc13783_t *chip;
+	audio_stream_t *s;
+	device_data_t* device;
+	int ssi;
+
+	//chip = snd_pcm_substream_chip(substream);
+	s = &chip->s[substream->pstr->stream];
+	device = &s->stream_device;
+	ssi = device->ssi;
+
+	//disable_stereodac();
+
+	ssi_transmit_enable(ssi, false);
+	ssi_interrupt_disable(ssi, ssi_tx_dma_interrupt_enable);
+	ssi_tx_fifo_enable(ssi, ssi_fifo_0, false);
+	ssi_enable(ssi, false);
+
+	chip->s[substream->pstr->stream].stream = NULL;
+
+	return 0;
+}
+
+static int
+mxc_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops mxc_pcm_ops = {
+	.open		= mxc_pcm_open,
+	.close		= mxc_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= mxc_pcm_hw_params,
+	.hw_free	= mxc_pcm_hw_free,
+	.prepare	= mxc_pcm_prepare,
+	.trigger	= mxc_pcm_trigger,
+	.pointer	= mxc_pcm_pointer,
+	.mmap		= mxc_pcm_mmap,
+};
+
+static u64 mxc_pcm_dmamask = 0xffffffff;
+
+int mxc_pcm_new(struct snd_card *card, struct snd_soc_codec_dai *dai,
+	struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &mxc_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = mxc_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = mxc_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+struct snd_soc_platform mxc_soc_platform = {
+	.name		= "mxc-audio",
+	.pcm_ops 	= &mxc_pcm_ops,
+	.pcm_new	= mxc_pcm_new,
+	.pcm_free	= mxc_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(mxc_soc_platform);
+
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_DESCRIPTION("Freescale i.MX PCM DMA module");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/imx/imx31-pcm.h
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/imx/imx31-pcm.h
@@ -0,0 +1,237 @@
+/*
+ * mxc-pcm.h :- ASoC platform header for Freescale i.MX
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _MXC_PCM_H
+#define _MXC_PCM_H
+
+struct {
+	char *name;			/* stream identifier */
+	dma_channel_params dma_params;
+} mxc_pcm_dma_param;
+
+extern struct snd_soc_cpu_dai mxc_ssi_dai[3];
+
+/* platform data */
+extern struct snd_soc_platform mxc_soc_platform;
+extern struct snd_ac97_bus_ops mxc_ac97_ops;
+
+/* temp until imx-regs.h is up2date */
+#define SSI1_STX0   __REG(IMX_SSI1_BASE + 0x00)
+#define SSI1_STX0_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x00)
+#define SSI1_STX1   __REG(IMX_SSI1_BASE + 0x04)
+#define SSI1_STX1_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x04)
+#define SSI1_SRX0   __REG(IMX_SSI1_BASE + 0x08)
+#define SSI1_SRX0_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x08)
+#define SSI1_SRX1   __REG(IMX_SSI1_BASE + 0x0c)
+#define SSI1_SRX1_PHYS   __PHYS_REG(IMX_SSI1_BASE + 0x0c)
+#define SSI1_SCR    __REG(IMX_SSI1_BASE + 0x10)
+#define SSI1_SISR   __REG(IMX_SSI1_BASE + 0x14)
+#define SSI1_SIER   __REG(IMX_SSI1_BASE + 0x18)
+#define SSI1_STCR   __REG(IMX_SSI1_BASE + 0x1c)
+#define SSI1_SRCR   __REG(IMX_SSI1_BASE + 0x20)
+#define SSI1_STCCR  __REG(IMX_SSI1_BASE + 0x24)
+#define SSI1_SRCCR  __REG(IMX_SSI1_BASE + 0x28)
+#define SSI1_SFCSR  __REG(IMX_SSI1_BASE + 0x2c)
+#define SSI1_STR    __REG(IMX_SSI1_BASE + 0x30)
+#define SSI1_SOR    __REG(IMX_SSI1_BASE + 0x34)
+#define SSI1_SACNT  __REG(IMX_SSI1_BASE + 0x38)
+#define SSI1_SACADD __REG(IMX_SSI1_BASE + 0x3c)
+#define SSI1_SACDAT __REG(IMX_SSI1_BASE + 0x40)
+#define SSI1_SATAG  __REG(IMX_SSI1_BASE + 0x44)
+#define SSI1_STMSK  __REG(IMX_SSI1_BASE + 0x48)
+#define SSI1_SRMSK  __REG(IMX_SSI1_BASE + 0x4c)
+
+#define SSI2_STX0   __REG(IMX_SSI2_BASE + 0x00)
+#define SSI2_STX0_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x00)
+#define SSI2_STX1   __REG(IMX_SSI2_BASE + 0x04)
+#define SSI2_STX1_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x04)
+#define SSI2_SRX0   __REG(IMX_SSI2_BASE + 0x08)
+#define SSI2_SRX0_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x08)
+#define SSI2_SRX1   __REG(IMX_SSI2_BASE + 0x0c)
+#define SSI2_SRX1_PHYS   __PHYS_REG(IMX_SSI2_BASE + 0x0c)
+#define SSI2_SCR    __REG(IMX_SSI2_BASE + 0x10)
+#define SSI2_SISR   __REG(IMX_SSI2_BASE + 0x14)
+#define SSI2_SIER   __REG(IMX_SSI2_BASE + 0x18)
+#define SSI2_STCR   __REG(IMX_SSI2_BASE + 0x1c)
+#define SSI2_SRCR   __REG(IMX_SSI2_BASE + 0x20)
+#define SSI2_STCCR  __REG(IMX_SSI2_BASE + 0x24)
+#define SSI2_SRCCR  __REG(IMX_SSI2_BASE + 0x28)
+#define SSI2_SFCSR  __REG(IMX_SSI2_BASE + 0x2c)
+#define SSI2_STR    __REG(IMX_SSI2_BASE + 0x30)
+#define SSI2_SOR    __REG(IMX_SSI2_BASE + 0x34)
+#define SSI2_SACNT  __REG(IMX_SSI2_BASE + 0x38)
+#define SSI2_SACADD __REG(IMX_SSI2_BASE + 0x3c)
+#define SSI2_SACDAT __REG(IMX_SSI2_BASE + 0x40)
+#define SSI2_SATAG  __REG(IMX_SSI2_BASE + 0x44)
+#define SSI2_STMSK  __REG(IMX_SSI2_BASE + 0x48)
+#define SSI2_SRMSK  __REG(IMX_SSI2_BASE + 0x4c)
+
+#define SSI_SCR_CLK_IST        (1 << 9)
+#define SSI_SCR_TCH_EN         (1 << 8)
+#define SSI_SCR_SYS_CLK_EN     (1 << 7)
+#define SSI_SCR_I2S_MODE_NORM  (0 << 5)
+#define SSI_SCR_I2S_MODE_MSTR  (1 << 5)
+#define SSI_SCR_I2S_MODE_SLAVE (2 << 5)
+#define SSI_SCR_SYN            (1 << 4)
+#define SSI_SCR_NET            (1 << 3)
+#define SSI_SCR_RE             (1 << 2)
+#define SSI_SCR_TE             (1 << 1)
+#define SSI_SCR_SSIEN          (1 << 0)
+
+#define SSI_SISR_CMDAU         (1 << 18)
+#define SSI_SISR_CMDDU         (1 << 17)
+#define SSI_SISR_RXT           (1 << 16)
+#define SSI_SISR_RDR1          (1 << 15)
+#define SSI_SISR_RDR0          (1 << 14)
+#define SSI_SISR_TDE1          (1 << 13)
+#define SSI_SISR_TDE0          (1 << 12)
+#define SSI_SISR_ROE1          (1 << 11)
+#define SSI_SISR_ROE0          (1 << 10)
+#define SSI_SISR_TUE1          (1 << 9)
+#define SSI_SISR_TUE0          (1 << 8)
+#define SSI_SISR_TFS           (1 << 7)
+#define SSI_SISR_RFS           (1 << 6)
+#define SSI_SISR_TLS           (1 << 5)
+#define SSI_SISR_RLS           (1 << 4)
+#define SSI_SISR_RFF1          (1 << 3)
+#define SSI_SISR_RFF0          (1 << 2)
+#define SSI_SISR_TFE1          (1 << 1)
+#define SSI_SISR_TFE0          (1 << 0)
+
+#define SSI_SIER_RDMAE         (1 << 22)
+#define SSI_SIER_RIE           (1 << 21)
+#define SSI_SIER_TDMAE         (1 << 20)
+#define SSI_SIER_TIE           (1 << 19)
+#define SSI_SIER_CMDAU_EN      (1 << 18)
+#define SSI_SIER_CMDDU_EN      (1 << 17)
+#define SSI_SIER_RXT_EN        (1 << 16)
+#define SSI_SIER_RDR1_EN       (1 << 15)
+#define SSI_SIER_RDR0_EN       (1 << 14)
+#define SSI_SIER_TDE1_EN       (1 << 13)
+#define SSI_SIER_TDE0_EN       (1 << 12)
+#define SSI_SIER_ROE1_EN       (1 << 11)
+#define SSI_SIER_ROE0_EN       (1 << 10)
+#define SSI_SIER_TUE1_EN       (1 << 9)
+#define SSI_SIER_TUE0_EN       (1 << 8)
+#define SSI_SIER_TFS_EN        (1 << 7)
+#define SSI_SIER_RFS_EN        (1 << 6)
+#define SSI_SIER_TLS_EN        (1 << 5)
+#define SSI_SIER_RLS_EN        (1 << 4)
+#define SSI_SIER_RFF1_EN       (1 << 3)
+#define SSI_SIER_RFF0_EN       (1 << 2)
+#define SSI_SIER_TFE1_EN       (1 << 1)
+#define SSI_SIER_TFE0_EN       (1 << 0)
+
+#define SSI_STCR_TXBIT0        (1 << 9)
+#define SSI_STCR_TFEN1         (1 << 8)
+#define SSI_STCR_TFEN0         (1 << 7)
+#define SSI_STCR_TFDIR         (1 << 6)
+#define SSI_STCR_TXDIR         (1 << 5)
+#define SSI_STCR_TSHFD         (1 << 4)
+#define SSI_STCR_TSCKP         (1 << 3)
+#define SSI_STCR_TFSI          (1 << 2)
+#define SSI_STCR_TFSL          (1 << 1)
+#define SSI_STCR_TEFS          (1 << 0)
+
+#define SSI_SRCR_RXBIT0        (1 << 9)
+#define SSI_SRCR_RFEN1         (1 << 8)
+#define SSI_SRCR_RFEN0         (1 << 7)
+#define SSI_SRCR_RFDIR         (1 << 6)
+#define SSI_SRCR_RXDIR         (1 << 5)
+#define SSI_SRCR_RSHFD         (1 << 4)
+#define SSI_SRCR_RSCKP         (1 << 3)
+#define SSI_SRCR_RFSI          (1 << 2)
+#define SSI_SRCR_RFSL          (1 << 1)
+#define SSI_SRCR_REFS          (1 << 0)
+
+#define SSI_STCCR_DIV2         (1 << 18)
+#define SSI_STCCR_PSR          (1 << 15)
+#define SSI_STCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_STCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_STCCR_PM(x)        (((x) & 0xff) << 0)
+
+#define SSI_SRCCR_DIV2         (1 << 18)
+#define SSI_SRCCR_PSR          (1 << 15)
+#define SSI_SRCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_SRCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_SRCCR_PM(x)        (((x) & 0xff) << 0)
+
+
+#define SSI_SFCSR_RFCNT1(x)   (((x) & 0xf) << 28)
+#define SSI_SFCSR_TFCNT1(x)   (((x) & 0xf) << 24)
+#define SSI_SFCSR_RFWM1(x)    (((x) & 0xf) << 20)
+#define SSI_SFCSR_TFWM1(x)    (((x) & 0xf) << 16)
+#define SSI_SFCSR_RFCNT0(x)   (((x) & 0xf) << 12)
+#define SSI_SFCSR_TFCNT0(x)   (((x) & 0xf) <<  8)
+#define SSI_SFCSR_RFWM0(x)    (((x) & 0xf) <<  4)
+#define SSI_SFCSR_TFWM0(x)    (((x) & 0xf) <<  0)
+
+#define SSI_STR_TEST          (1 << 15)
+#define SSI_STR_RCK2TCK       (1 << 14)
+#define SSI_STR_RFS2TFS       (1 << 13)
+#define SSI_STR_RXSTATE(x)    (((x) & 0xf) << 8)
+#define SSI_STR_TXD2RXD       (1 <<  7)
+#define SSI_STR_TCK2RCK       (1 <<  6)
+#define SSI_STR_TFS2RFS       (1 <<  5)
+#define SSI_STR_TXSTATE(x)    (((x) & 0xf) << 0)
+
+#define SSI_SOR_CLKOFF        (1 << 6)
+#define SSI_SOR_RX_CLR        (1 << 5)
+#define SSI_SOR_TX_CLR        (1 << 4)
+#define SSI_SOR_INIT          (1 << 3)
+#define SSI_SOR_WAIT(x)       (((x) & 0x3) << 1)
+#define SSI_SOR_SYNRST        (1 << 0)
+
+#define SSI_SACNT_FRDIV(x)    (((x) & 0x3f) << 5)
+#define SSI_SACNT_WR          (x << 4)
+#define SSI_SACNT_RD          (x << 3)
+#define SSI_SACNT_TIF         (x << 2)
+#define SSI_SACNT_FV          (x << 1)
+#define SSI_SACNT_A97EN       (x << 0)
+
+
+/* AUDMUX registers */
+#define AUDMUX_HPCR1         __REG(IMX_AUDMUX_BASE + 0x00)
+#define AUDMUX_HPCR2         __REG(IMX_AUDMUX_BASE + 0x04)
+#define AUDMUX_HPCR3         __REG(IMX_AUDMUX_BASE + 0x08)
+#define AUDMUX_PPCR1         __REG(IMX_AUDMUX_BASE + 0x10)
+#define AUDMUX_PPCR2         __REG(IMX_AUDMUX_BASE + 0x14)
+#define AUDMUX_PPCR3         __REG(IMX_AUDMUX_BASE + 0x18)
+
+#define AUDMUX_HPCR_TFSDIR         (1 << 31)
+#define AUDMUX_HPCR_TCLKDIR        (1 << 30)
+#define AUDMUX_HPCR_TFCSEL_TX      (0 << 26)
+#define AUDMUX_HPCR_TFCSEL_RX      (8 << 26)
+#define AUDMUX_HPCR_TFCSEL(x)      (((x) & 0x7) << 26)
+#define AUDMUX_HPCR_RFSDIR         (1 << 25)
+#define AUDMUX_HPCR_RCLKDIR        (1 << 24)
+#define AUDMUX_HPCR_RFCSEL_TX      (0 << 20)
+#define AUDMUX_HPCR_RFCSEL_RX      (8 << 20)
+#define AUDMUX_HPCR_RFCSEL(x)      (((x) & 0x7) << 20)
+#define AUDMUX_HPCR_RXDSEL(x)      (((x) & 0x7) << 13)
+#define AUDMUX_HPCR_SYN            (1 << 12)
+#define AUDMUX_HPCR_TXRXEN         (1 << 10)
+#define AUDMUX_HPCR_INMEN          (1 <<  8)
+#define AUDMUX_HPCR_INMMASK(x)     (((x) & 0xff) << 0)
+
+#define AUDMUX_PPCR_TFSDIR         (1 << 31)
+#define AUDMUX_PPCR_TCLKDIR        (1 << 30)
+#define AUDMUX_PPCR_TFCSEL_TX      (0 << 26)
+#define AUDMUX_PPCR_TFCSEL_RX      (8 << 26)
+#define AUDMUX_PPCR_TFCSEL(x)      (((x) & 0x7) << 26)
+#define AUDMUX_PPCR_RFSDIR         (1 << 25)
+#define AUDMUX_PPCR_RCLKDIR        (1 << 24)
+#define AUDMUX_PPCR_RFCSEL_TX      (0 << 20)
+#define AUDMUX_PPCR_RFCSEL_RX      (8 << 20)
+#define AUDMUX_PPCR_RFCSEL(x)      (((x) & 0x7) << 20)
+#define AUDMUX_PPCR_RXDSEL(x)      (((x) & 0x7) << 13)
+#define AUDMUX_PPCR_SYN            (1 << 12)
+#define AUDMUX_PPCR_TXRXEN         (1 << 10)
+
+
+#endif
Index: linux-2.6-pxa-new/sound/soc/s3c24xx/s3c24xx-i2s.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/s3c24xx/s3c24xx-i2s.c
@@ -0,0 +1,271 @@
+/*
+ * s3c24xx-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    10th Nov 2006   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/arch/regs-iis.h>
+#include <asm/arch/regs-gpio.h>
+#include <asm/arch/regs-clock.h>
+#include <asm/arch/audio.h>
+#include <asm/dma.h>
+#include <asm/arch/dma.h>
+
+#include "s3c24xx-pcm.h"
+
+/* used to disable sysclk if external crystal is used */
+static int extclk = 0;
+module_param(extclk, int, 0);
+MODULE_PARM_DESC(extclk, "set to 1 to disable s3c24XX i2s sysclk");
+
+#define S3C24XX_I2S_DAIFMT \
+	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF)
+
+#define S3C24XX_I2S_DIR \
+	(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)
+
+#define S3C24XX_I2S_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+/* priv is divider */
+static struct snd_soc_dai_mode s3c24xx_i2s_modes[] =
+{
+	/* s3c24xx I2S frame and clock master modes */
+	{
+		.fmt = S3C24XX_I2S_DAIFMT | SND_SOC_DAIFMT_CBS_CFS,
+		.pcmfmt = SNDRV_PCM_FMTBIT_S16_LE,
+		.pcmrate = SNDRV_PCM_RATE_44100,
+		.pcmdir = S3C24XX_I2S_DIR,
+		.flags = SND_SOC_DAI_BFS_RATE,
+		.fs = 384,
+		.bfs = 32,
+		.priv = 0x00
+	},
+};
+
+static struct s3c2410_dma_client s3c24xx_dma_client_out = {
+	.name = "I2S PCM Stereo out"
+};
+
+static struct s3c2410_dma_client s3c24xx_dma_client_in = {
+	.name = "I2S PCM Stereo in"
+};
+
+static s3c24xx_pcm_dma_params_t s3c24xx_i2s_pcm_stereo_out = {
+	.client		= &s3c24xx_dma_client_out,
+	.channel	= DMACH_I2S_OUT,
+	.dma_addr	= S3C2410_PA_IIS+S3C2410_IISFIFO
+};
+
+static s3c24xx_pcm_dma_params_t s3c24xx_i2s_pcm_stereo_in = {
+	.client		= &s3c24xx_dma_client_in,
+	.channel	= DMACH_I2S_IN,
+	.dma_addr	= S3C2410_PA_IIS+S3C2410_IISFIFO
+};
+
+
+struct s3c24xx_i2s_port {
+	int master;
+};
+static struct s3c24xx_i2s_port s3c24xx_i2s;
+
+/* Empty for the s3c24xx platforms */
+static int s3c24xx_i2s_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int s3c24xx_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	unsigned long iiscon;
+	unsigned long iismod;
+	unsigned long iisfcon;
+
+	s3c24xx_i2s.master = 0;
+	if(rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CBS_CFS)
+		s3c24xx_i2s.master = 1;
+
+	/* Configure the I2S pins in correct mode */
+	s3c2410_gpio_cfgpin(S3C2410_GPE0,S3C2410_GPE0_I2SLRCK);
+	if (s3c24xx_i2s.master && !extclk){
+		printk("Setting Clock Output as we are Master\n");
+		s3c2410_gpio_cfgpin(S3C2410_GPE1,S3C2410_GPE1_I2SSCLK);
+	}
+	s3c2410_gpio_cfgpin(S3C2410_GPE2,S3C2410_GPE2_CDCLK);
+	s3c2410_gpio_cfgpin(S3C2410_GPE3,S3C2410_GPE3_I2SSDI);
+	s3c2410_gpio_cfgpin(S3C2410_GPE4,S3C2410_GPE4_I2SSDO);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		rtd->cpu_dai->dma_data = &s3c24xx_i2s_pcm_stereo_out;
+	}
+	else
+	{
+		rtd->cpu_dai->dma_data = &s3c24xx_i2s_pcm_stereo_in;
+	}
+
+	/* Working copies of registers */
+	iiscon=readl(S3C24XX_VA_IIS+S3C2410_IISCON);
+	iismod=readl(S3C24XX_VA_IIS+S3C2410_IISMOD);
+	iisfcon=readl(S3C24XX_VA_IIS+S3C2410_IISFCON);
+	/* is port used by another stream */
+	if (!(iiscon & S3C2410_IISCON_IISEN)) {
+
+		/* Clear the registers */
+
+		iismod |= S3C2410_IISMOD_32FS | S3C2410_IISMOD_384FS;
+
+		if (!s3c24xx_i2s.master)
+			iismod |= S3C2410_IISMOD_SLAVE;
+
+		if (rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_LEFT_J)
+			iismod |= S3C2410_IISMOD_MSB;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		iismod |= S3C2410_IISMOD_TXMODE;
+		iiscon |= S3C2410_IISCON_TXDMAEN;
+		iisfcon |= S3C2410_IISFCON_TXDMA | S3C2410_IISFCON_TXENABLE;
+	}
+	else
+	{
+		iismod |= S3C2410_IISMOD_RXMODE;
+		iiscon |= S3C2410_IISCON_RXDMAEN;
+		iisfcon |= S3C2410_IISFCON_RXDMA | S3C2410_IISFCON_RXENABLE;
+	}
+
+	writel(iiscon, S3C24XX_VA_IIS+S3C2410_IISCON);
+	writel(iismod, S3C24XX_VA_IIS+S3C2410_IISMOD);
+	writel(iisfcon, S3C24XX_VA_IIS+S3C2410_IISFCON);
+
+	printk("IISCON: %lx IISMOD: %lx", iiscon, iismod);
+
+	return 0;
+}
+
+static int s3c24xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+	unsigned long iiscon;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		/* Enable the IIS unit */
+		iiscon = readl(S3C24XX_VA_IIS+S3C2410_IISCON);
+		iiscon |= S3C2410_IISCON_IISEN;
+		writel(iiscon, S3C24XX_VA_IIS+S3C2410_IISCON);
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void s3c24xx_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	unsigned long iismod, iiscon;
+
+	iismod=readl(S3C24XX_VA_IIS+S3C2410_IISMOD);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		iismod &= ~S3C2410_IISMOD_TXMODE;
+	} else {
+		iismod &= ~S3C2410_IISMOD_RXMODE;
+	}
+
+	writel(iismod,S3C24XX_VA_IIS+S3C2410_IISMOD);
+
+	iiscon=readl(S3C24XX_VA_IIS+S3C2410_IISCON);
+
+	if (iismod & ( S3C2410_IISMOD_TXMODE | S3C2410_IISMOD_RXMODE )) {
+		iiscon &= ! S3C2410_IISCON_IISEN;
+		writel(iiscon,S3C24XX_VA_IIS+S3C2410_IISCON);
+	}
+}
+
+#ifdef CONFIG_PM
+static int s3c24xx_i2s_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+}
+
+static int s3c24xx_i2s_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+}
+
+#else
+#define s3c24xx_i2s_suspend	NULL
+#define s3c24xx_i2s_resume	NULL
+#endif
+
+/* s3c24xx I2S sysclock is always 384 FS */
+static unsigned int s3c24xx_i2s_config_sysclk(struct snd_soc_cpu_dai *iface,
+	struct snd_soc_clock_info *info, unsigned int clk)
+{
+	return info->rate * 384;
+}
+
+struct snd_soc_cpu_dai s3c24xx_i2s_dai = {
+	.name = "s3c24xx-i2s",
+	.id = 0,
+	.type = SND_SOC_DAI_I2S,
+	.suspend = s3c24xx_i2s_suspend,
+	.resume = s3c24xx_i2s_resume,
+	.config_sysclk = s3c24xx_i2s_config_sysclk,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,},
+	.ops = {
+		.startup = s3c24xx_i2s_startup,
+		.shutdown = s3c24xx_i2s_shutdown,
+		.trigger = s3c24xx_i2s_trigger,
+		.hw_params = s3c24xx_i2s_hw_params,},
+	.caps = {
+		.num_modes = ARRAY_SIZE(s3c24xx_i2s_modes),
+		.mode = s3c24xx_i2s_modes,},
+};
+
+EXPORT_SYMBOL_GPL(s3c24xx_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Graeme Gregory, graeme.gregory@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("s3c24xx I2S SoC Interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/s3c24xx/s3c24xx-pcm.c
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/s3c24xx/s3c24xx-pcm.c
@@ -0,0 +1,362 @@
+/*
+ * s3c24xx-pcm.c  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    10th Nov 2006   Initial version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/audio.h>
+
+#include "s3c24xx-pcm.h"
+
+static const struct snd_pcm_hardware s3c24xx_pcm_hardware = {
+        .info                   = SNDRV_PCM_INFO_MMAP |
+                                  SNDRV_PCM_INFO_MMAP_VALID |
+                                  SNDRV_PCM_INFO_INTERLEAVED |
+                                  SNDRV_PCM_INFO_PAUSE |
+                                  SNDRV_PCM_INFO_RESUME,
+        .formats                = SNDRV_PCM_FMTBIT_S16_LE,
+        .period_bytes_min       = 32,
+        .period_bytes_max       = 8192,
+        .periods_min            = 1,
+        .periods_max            = 8192,
+        .buffer_bytes_max       = 256 * 1024,
+		.fifo_size				= 32,
+};
+
+struct s3c24xx_runtime_data {
+	dma_addr_t dma_buffer;
+	dma_addr_t dma_buffer_end;
+	size_t period_size;
+	dma_addr_t period_ptr;
+	s3c24xx_pcm_dma_params_t *params;
+};
+
+/* Move the pointer onto the next period, dealing with wrap around.
+ */
+void static next_period(struct s3c24xx_runtime_data *prtd)
+{
+	prtd->period_ptr+=prtd->period_size;
+	if(prtd->period_ptr>=prtd->dma_buffer_end)
+	{
+		prtd->period_ptr=prtd->dma_buffer;
+	}
+}
+
+void s3c24xx_audio_buffdone(struct s3c2410_dma_chan *channel,
+							void *dev_id, int size,
+							enum s3c2410_dma_buffresult result)
+{
+	struct snd_pcm_substream *substream = dev_id;
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+
+	if(result==S3C2410_RES_OK)
+	{
+		next_period(prtd);
+		s3c2410_dma_enqueue(prtd->params->channel, substream, prtd->period_ptr, prtd->period_size);
+	}
+	snd_pcm_period_elapsed(substream);
+
+}
+
+static int s3c24xx_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	s3c24xx_pcm_dma_params_t *dma = rtd->cpu_dai->dma_data;
+	int ret;
+
+	printk("Entered s3c24xx hw_params\n");
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	prtd->params=dma;
+	if(ret=s3c2410_dma_request(prtd->params->channel,
+								prtd->params->client,NULL))
+	{
+		printk("Failed to get dma channel %d for %s\n",prtd->params->channel,
+				prtd->params->client->name);
+		return ret;
+	}
+
+	//s3c2410_dma_setflags(prtd->params->channel,S3C2410_DMAF_AUTOSTART);
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		s3c2410_dma_devconfig(prtd->params->channel, S3C2410_DMASRC_MEM,
+								S3C2410_DISRCC_INC | S3C2410_DISRCC_APB,
+								prtd->params->dma_addr);
+	}
+	else
+	{
+		s3c2410_dma_devconfig(prtd->params->channel, S3C2410_DMASRC_HW,
+								S3C2410_DISRCC_INC | S3C2410_DISRCC_APB,
+								prtd->params->dma_addr);
+	}
+
+	s3c2410_dma_config(prtd->params->channel,2,S3C2410_DCON_HANDSHAKE);
+
+	s3c2410_dma_set_buffdone_fn(prtd->params->channel, s3c24xx_audio_buffdone);
+
+	prtd->dma_buffer = runtime->dma_addr;
+	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
+	prtd->period_size = params_period_bytes(params);
+
+	return 0;
+}
+
+static int s3c24xx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+
+	printk("Entered s3c24xx hw_free\n");
+
+	return 0;
+}
+
+static int s3c24xx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+
+	printk("Entered s3c24xx prepare\n");
+
+	/* Set the period that is to be queued in DMA */
+	prtd->period_ptr = prtd->dma_buffer;
+
+	/* queue the first period */
+	s3c2410_dma_enqueue(prtd->params->channel, substream, prtd->period_ptr, prtd->period_size);
+
+	/* Move to next period to be queued */
+	next_period(prtd);
+
+	/* queue the second buffer */
+	s3c2410_dma_enqueue(prtd->params->channel, substream, prtd->period_ptr, prtd->period_size);
+
+
+	return 0;
+}
+
+static int s3c24xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	printk("Entered s3c24xx trigger\n");
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_START);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_STOP);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t s3c24xx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+	dma_addr_t dst,src;
+	snd_pcm_uframes_t x;
+
+	printk("Entered s3c24xx pointer\n");
+
+	s3c2410_dma_getposition(prtd->params->channel, &src, &dst);
+
+	printk("DMA Position: %lx, %lx\n", src, dst);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		x = bytes_to_frames(runtime, src - prtd->dma_buffer);
+	}
+	else
+	{
+		x = bytes_to_frames(runtime, dst - prtd->dma_buffer);
+	}
+
+	if (x == runtime->buffer_size)
+		x=0;
+	return x;
+
+}
+
+static int s3c24xx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd;
+	int ret;
+
+	printk("Entered s3c24xx open\n");
+
+	snd_soc_set_runtime_hwparams(substream, &s3c24xx_pcm_hardware);
+
+	if((prtd = kzalloc(sizeof(struct s3c24xx_runtime_data), GFP_KERNEL)) == NULL)
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	runtime->private_data = prtd;
+	return 0;
+
+out:
+	return ret;
+}
+
+static int s3c24xx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+
+	printk("Entered s3c24xx close\n");
+
+	s3c2410_dma_free(prtd->params->channel, prtd->params->client);
+
+	return 0;
+}
+
+static int
+s3c24xx_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	printk("Entered s3c24xx mmap\n");
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+                                     runtime->dma_area,
+                                     runtime->dma_addr,
+                                     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops s3c24xx_pcm_ops = {
+	.open		= s3c24xx_pcm_open,
+	.close		= s3c24xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= s3c24xx_pcm_hw_params,
+	.hw_free	= s3c24xx_pcm_hw_free,
+	.prepare	= s3c24xx_pcm_prepare,
+	.trigger	= s3c24xx_pcm_trigger,
+	.pointer	= s3c24xx_pcm_pointer,
+	.mmap		= s3c24xx_pcm_mmap,
+};
+
+static int s3c24xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = s3c24xx_pcm_hardware.buffer_bytes_max;
+
+	printk("Entered s3c24xx preaccolate_dma_buffer\n");
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void s3c24xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	printk("Entered s3c24xx free_dma_buffers\n");
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 s3c24xx_pcm_dmamask = 0xffffffff;
+
+int s3c24xx_pcm_new(struct snd_card *card, struct snd_soc_codec_dai *dai,
+	struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	printk("Entered s3c24xx new\n");
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &s3c24xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = s3c24xx_pcm_preallocate_dma_buffer(pcm, SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = s3c24xx_pcm_preallocate_dma_buffer(pcm, SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+struct snd_soc_platform s3c24xx_soc_platform = {
+	.name		= "s3c24xx-audio",
+	.pcm_ops 	= &s3c24xx_pcm_ops,
+	.pcm_new	= s3c24xx_pcm_new,
+	.pcm_free	= s3c24xx_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(s3c24xx_soc_platform);
+
+MODULE_AUTHOR("Graeme Gregory");
+MODULE_DESCRIPTION("Samsung S3C24XX PCM DMA module");
+MODULE_LICENSE("GPL");
Index: linux-2.6-pxa-new/sound/soc/s3c24xx/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/s3c24xx/Kconfig
@@ -0,0 +1,26 @@
+menu "SoC Audio for the Atmel AT91"
+
+config SND_S3C24XX_SOC
+	tristate "SoC Audio for the Samsung S3C24xx System-on-Chip"
+	depends on ARCH_S3C2410 && SND
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the Samsung S3C24xx.
+
+config SND_S3C24XX_SOC_I2S
+	tristate
+
+config SND_S3C24XX_SOC_AC97
+	tristate
+
+# graeme - add mach dep
+config SND_S3C24XX_SOC_SMDK2440
+	tristate "SoC I2S Audio support for SMDK2440"
+	depends on SND_S3C24XX_SOC
+	select SND_S3C24XX_SOC_I2S
+	select SND_SOC_UDA1380
+	help
+	  Say Y if you want to add support for SoC audio on
+
+endmenu
Index: linux-2.6-pxa-new/sound/soc/s3c24xx/Makefile
===================================================================
--- /dev/null
+++ linux-2.6-pxa-new/sound/soc/s3c24xx/Makefile
@@ -0,0 +1,11 @@
+# S3C24xx Platform Support
+snd-soc-s3c24xx-objs := s3c24xx-pcm.o
+snd-soc-at91-i2s-objs := s3c24xx-i2s.o
+
+obj-$(CONFIG_SND_S3C24XX_SOC) += snd-soc-s3c24xx.o
+obj-$(CONFIG_SND_S3C24XX_SOC_I2S) += snd-soc-s3c24xx-i2s.o
+
+# S3C24xx Machine Support
+snd-soc-smdk2440-uda1380-objs := smdk2440_uda1380.o
+
+obj-$(CONFIG_SND_S3C24XX_SOC_SMDK2440) += snd-soc-smdk2440-uda1380.o
