diff --git a/configure.ac b/configure.ac
index f1284a0..9f0971b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -5,7 +5,7 @@ dnl
 dnl This file may be modified and/or distributed without restriction.
 
 AC_PREREQ(2.61)
-AC_INIT([GNU parted],[1.8.8],[bug-parted@gnu.org])
+AC_INIT([GNU parted],[1.8.9],[bug-parted@gnu.org])
 
 AC_CONFIG_SRCDIR(include/parted/parted.h)
 
@@ -24,7 +24,7 @@ dnl function signatures changed),
 dnl set PED_BINARY_AGE _and_ PED_INTERFACE_AGE to 0.
 PED_MAJOR_VERSION=1
 PED_MINOR_VERSION=8
-PED_MICRO_VERSION=8
+PED_MICRO_VERSION=9
 PED_INTERFACE_AGE=0
 PED_BINARY_AGE=0
 PED_VERSION_SUFFIX=
@@ -471,14 +471,7 @@ AC_CHECK_HEADER([execinfo.h], [
 	])
 ])
 
-dnl Checks for #defines.
-AC_COMPILE_IFELSE([
-	AC_LANG_PROGRAM([[
-	#if defined __s390__ || defined __s390x__
-	#  message s390 defined
-	#endif
-	]])], [compile_for_s390="no"], [compile_for_s390="yes"])
-AM_CONDITIONAL([COMPILE_FOR_S390], [test "$compile_for_s390" = "yes"])
+AM_CONDITIONAL([COMPILE_FOR_S390], [test "$host_cpu" = s390 || test "$host_cpu" = s390x])
 
 dnl check for "check", unit testing library/header
 PKG_CHECK_MODULES([CHECK], [check >= 0.9.3], have_check=yes, have_check=no)
diff --git a/doc/C/parted.8 b/doc/C/parted.8
index 7040402..fdf3d04 100644
--- a/doc/C/parted.8
+++ b/doc/C/parted.8
@@ -124,6 +124,18 @@ and a human-friendly form for output).
 .B version
 Display version information and a copyright message.
 .RE
+.SH KNOWN ISSUES
+ext3 filesystem resizing does not currently work, please use
+.BR resize2fs (8)
+instead.
+
+Resizing partitions with an ext3 filesystem will not generally work because
+of the above issue.  Use
+.BR resize2fs (8)
+to resize the filesystem and resize the partition manually using
+.BR fdisk (8)
+or a similar tool.  For LVM situations, you will need to use the LVM commands
+to resize the LVM elements.
 .SH REPORTING BUGS
 Report bugs to <bug-parted@gnu.org>
 .SH SEE ALSO
diff --git a/doc/parted.texi b/doc/parted.texi
index 139ea77..86ec076 100644
--- a/doc/parted.texi
+++ b/doc/parted.texi
@@ -14,7 +14,7 @@ resizing, checking and copy partitions and file systems on them.
 @ifnottex @c texi2pdf don't understand copying and insertcopying ???
 @c modifications must also be done in the titlepage
 @copying
-Copyright @copyright{} 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+Copyright @copyright{} 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 Free Software Foundation, Inc.
 
 Permission is granted to copy, distribute and/or modify this document
@@ -63,7 +63,7 @@ Free Documentation License''.
 
 @c WTF doesn't texi2html include the titlepage?
 @ifhtml
-@insertcopying 
+@insertcopying
 @end ifhtml
 
 This document describes the use of GNU Parted, a program for creating,
@@ -257,7 +257,7 @@ $ @kbd{make}
 However, there are a few options for @command{configure}:
 
 @table @code
-@item --without-readline		
+@item --without-readline
 turns off use of readline.  This is useful for making rescue disks,
 etc., where few libraries are available.
 
@@ -275,12 +275,12 @@ you don't need the flexibility.
 @item --disable-fs
 disable all file system support
 
-@item --disable-nls			
+@item --disable-nls
 turns off native language support.  This is useful for use with old
 versions of glibc, or a trimmed down version of glibc suitable for
 rescue disks.
 
-@item --disable-shared		
+@item --disable-shared
 turns off shared libraries.  This may be necessary for use with old
 versions of GNU libc, if you get a compile error about a ``spilled
 register''.  Also useful for boot/rescue disks.
@@ -301,7 +301,7 @@ disable writing (for debugging)
 
 @node Static binaries
 @section Using static binaries of GNU Parted
-@cindex static binary 
+@cindex static binary
 @cindex unsupported platforms
 @cindex resizing root device
 
@@ -320,7 +320,7 @@ of the latest GNU Parted version is available, which you can use thus:
 
 @subsection Creating the Parted disk
 @enumerate
-@item Boot your system 
+@item Boot your system
 
 @item Download @file{parted-static-VERSION.tgz} from @uref{ftp://ftp.gnu.org/gnu/parted/static}
 @item Unpack the tarball, resulting in a file called ``parted.static".
@@ -329,7 +329,7 @@ of the latest GNU Parted version is available, which you can use thus:
 
 @item Do a low-level format on it (on GNU/Linux this can be achieved with
       the tool ``fdformat" from the ``util-linux" package.
-      This is basically a sanity check because floppy disks often 
+      This is basically a sanity check because floppy disks often
       contain bad blocks.
 
 @item Create a file system. Example:
@@ -359,7 +359,7 @@ $ @kbd{umount /mnt/floppy}
 
 @subsection Using the Parted disk
 @enumerate
-@item Choose a rescue disk that suits you. 
+@item Choose a rescue disk that suits you.
 
 @item Boot off your rescue disk.  Mount the disk you copied Parted onto.
 
@@ -383,7 +383,7 @@ $ @kbd{umount /mnt/floppy}
 @end menu
 
 @node Partitioning
-@section Introduction to Partitioning 
+@section Introduction to Partitioning
 @cindex partitioning overview
 
 Unfortunately, partitioning your disk is rather complicated.  This is
@@ -566,7 +566,7 @@ Supported file systems:
 (provided the destination partition is larger than the source partition)
 
 @item fat16, fat32
-@item linux-swap	
+@item linux-swap
 (equivalent to mkswap on destination partition)
 @item reiserfs (if libreiserfs is installed)
 
@@ -918,7 +918,7 @@ partitions can be resized only so long as the new extended partition
 completely contains all logical partitions.
 
 Note that Parted can manipulate partitions whether or not they have been
-defragmented, so you do not need to defragmenting the disk before
+defragmented, so you do not need to defragment the disk before
 using Parted.
 
 Supported file systems:
@@ -1031,7 +1031,7 @@ Microsoft operating systems.
 
 @item raid
 (MS-DOS) - this flag can be enabled to tell linux the partition is a
-software RAID partition. 
+software RAID partition.
 
 @item LVM
 (MS-DOS) - this flag can be enabled to tell linux the partition is a
@@ -1109,59 +1109,59 @@ specified after an input number.  Input numbers can be followed by
 an unit (without any space or other character between them), in
 which case this unit apply instead of the default unit for this
 particular number, but CHS and cylinder units are not supported as
-a suffix.  If no suffix is given, then the default unit is assumed. 
+a suffix.  If no suffix is given, then the default unit is assumed.
 Parted will compute sensible ranges for the locations you specify
 (e.g. a range of +/- 500 MB when you specify the location in ``G'')
 and will select the nearest location in this range from the one you
 wrote that satisfies constraints from both the operation, the
 filesystem being worked on, the disk label, other partitions and so
 on.  Use the sector unit ``s'' to specify exact locations (if they
-do not satisfy all onstraints, Parted will ask you for the nearest 
+do not satisfy all onstraints, Parted will ask you for the nearest
 solution).  Note that negative numbers count back from the end of
-the disk, with ``-1s'' pointing to the end of the disk.  
+the disk, with ``-1s'' pointing to the end of the disk.
 
 Example:
 
 @example
 @group
-(parted) unit compact                                                     
-(parted) print                                                            
+(parted) unit compact
+(parted) print
 Disk geometry for /dev/hda: 0kB - 123GB
 Disk label type: msdos
 Number  Start   End     Size    Type      File system  Flags
 1       32kB    1078MB  1077MB  primary   reiserfs     boot
-2       1078MB  2155MB  1078MB  primary   linux-swap   
-3       2155MB  123GB   121GB   extended               
-5       2155MB  7452MB  5297MB  logical   reiserfs     
+2       1078MB  2155MB  1078MB  primary   linux-swap
+3       2155MB  123GB   121GB   extended
+5       2155MB  7452MB  5297MB  logical   reiserfs
 @end group
 @group
-(parted) unit chs print                                                   
+(parted) unit chs print
 Disk geometry for /dev/hda: 0,0,0 - 14946,225,62
 BIOS cylinder,head,sector geometry: 14946,255,63.  Each cylinder
 is 8225kB.
 Disk label type: msdos
 Number  Start       End         Type      File system  Flags
 1       0,1,0       130,254,62  primary   reiserfs     boot
-2       131,0,0     261,254,62  primary   linux-swap   
-3       262,0,0     14945,254,62 extended               
-5       262,2,0     905,254,62  logical   reiserfs     
+2       131,0,0     261,254,62  primary   linux-swap
+3       262,0,0     14945,254,62 extended
+5       262,2,0     905,254,62  logical   reiserfs
 @end group
 @group
-(parted) unit mb print                                                    
+(parted) unit mb print
 Disk geometry for /dev/hda: 0MB - 122942MB
 Disk label type: msdos
 Number  Start   End     Size    Type      File system  Flags
 1       0MB     1078MB  1077MB  primary   reiserfs     boot
-2       1078MB  2155MB  1078MB  primary   linux-swap   
-3       2155MB  122935MB 120780MB extended               
-5       2155MB  7452MB  5297MB  logical   reiserfs     
+2       1078MB  2155MB  1078MB  primary   linux-swap
+3       2155MB  122935MB 120780MB extended
+5       2155MB  7452MB  5297MB  logical   reiserfs
 @end group
 @end example
 
 @end deffn
 
 @node Related information
-@chapter Related information 
+@chapter Related information
 @cindex further reading
 @cindex related documentation
 
diff --git a/include/parted/constraint.h b/include/parted/constraint.h
index 7a39602..6496926 100644
--- a/include/parted/constraint.h
+++ b/include/parted/constraint.h
@@ -22,6 +22,7 @@
 typedef struct _PedConstraint	PedConstraint;
 
 #include <parted/device.h>
+#include <parted/geom.h>
 #include <parted/natmath.h>
 
 struct _PedConstraint {
diff --git a/include/parted/device.h b/include/parted/device.h
index cf32dba..e669688 100644
--- a/include/parted/device.h
+++ b/include/parted/device.h
@@ -26,6 +26,7 @@
 #ifndef PED_DEVICE_H_INCLUDED
 #define PED_DEVICE_H_INCLUDED
 
+#include <parted/constraint.h>
 #include <parted/timer.h>
 
 /** We can address 2^63 sectors */
@@ -45,9 +46,7 @@ typedef enum {
         PED_DEVICE_DASD         = 9,
         PED_DEVICE_VIODASD      = 10,
         PED_DEVICE_SX8          = 11,
-#ifdef ENABLE_DEVICE_MAPPER
         PED_DEVICE_DM           = 12,
-#endif
         PED_DEVICE_XVD          = 13
 } PedDeviceType;
 
diff --git a/include/parted/disk.h b/include/parted/disk.h
index b82ea0f..1b0133d 100644
--- a/include/parted/disk.h
+++ b/include/parted/disk.h
@@ -1,6 +1,6 @@
 /*
     libparted - a library for manipulating disk partitions
-    Copyright (C) 1999, 2000, 2001, 2002, 2007 Free Software Foundation, Inc.
+    Copyright (C) 1999, 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -52,10 +52,11 @@ enum _PedPartitionFlag {
         PED_PARTITION_HPSERVICE=8,
         PED_PARTITION_PALO=9,
         PED_PARTITION_PREP=10,
-        PED_PARTITION_MSFT_RESERVED=11
+        PED_PARTITION_MSFT_RESERVED=11,
+        PED_PARTITION_BIOS_GRUB=12
 };
 #define PED_PARTITION_FIRST_FLAG        PED_PARTITION_BOOT
-#define PED_PARTITION_LAST_FLAG         PED_PARTITION_MSFT_RESERVED
+#define PED_PARTITION_LAST_FLAG         PED_PARTITION_BIOS_GRUB
 
 enum _PedDiskTypeFeature {
         PED_DISK_TYPE_EXTENDED=1,       /**< supports extended partitions */
diff --git a/include/parted/linux.h b/include/parted/linux.h
index 52d28be..05a2f0e 100644
--- a/include/parted/linux.h
+++ b/include/parted/linux.h
@@ -22,7 +22,7 @@
 #include <parted/parted.h>
 #include <parted/device.h>
 
-#if defined __s390__ || defined __s390x__
+#if defined(__s390__) || defined(__s390x__)
 #  include <parted/fdasd.h>
 #endif
 
diff --git a/include/parted/natmath.h b/include/parted/natmath.h
index 32a6e28..e387833 100644
--- a/include/parted/natmath.h
+++ b/include/parted/natmath.h
@@ -30,6 +30,7 @@
 typedef struct _PedAlignment	PedAlignment;
 
 #include <parted/disk.h>
+#include <parted/device.h>
 
 #define PED_MIN(a, b)	( ((a)<(b)) ? (a) : (b) )
 #define PED_MAX(a, b)	( ((a)>(b)) ? (a) : (b) )
diff --git a/libparted/arch/linux.c b/libparted/arch/linux.c
index 462ab92..9876956 100644
--- a/libparted/arch/linux.c
+++ b/libparted/arch/linux.c
@@ -64,7 +64,7 @@
 #define HDIO_GETGEO             0x0301  /* get device geometry */
 #define HDIO_GET_IDENTITY       0x030d  /* get IDE identification info */
 
-#if defined(O_DIRECT) && (!defined(__s390__) || !defined(__s390x__))
+#if defined(O_DIRECT) && !(defined(__s390__) || defined(__s390x__))
 #define RD_MODE (O_RDONLY | O_DIRECT)
 #define WR_MODE (O_WRONLY | O_DIRECT)
 #define RW_MODE (O_RDWR | O_DIRECT)
@@ -986,7 +986,7 @@ error:
 }
 
 static int
-init_dasd (PedDevice* dev, char* model_name)
+init_dasd (PedDevice* dev, const char* model_name)
 {
         struct stat             dev_stat;
         struct hd_geometry      geo;
@@ -1042,7 +1042,7 @@ error:
 }
 
 static int
-init_generic (PedDevice* dev, char* model_name)
+init_generic (PedDevice* dev, const char* model_name)
 {
         struct stat             dev_stat;
         PedExceptionOption      ex_status;
diff --git a/libparted/cs/natmath.c b/libparted/cs/natmath.c
index b8b4a95..fd376cd 100644
--- a/libparted/cs/natmath.c
+++ b/libparted/cs/natmath.c
@@ -74,16 +74,16 @@ ped_round_down_to (PedSector sector, PedSector grain_size)
 	return sector - abs_mod (sector, grain_size);
 }
 
-inline PedSector
+PedSector
 ped_div_round_up (PedSector numerator, PedSector divisor)
 {
-                return (numerator + divisor - 1) / divisor;
+	return (numerator + divisor - 1) / divisor;
 }
 
-inline PedSector
+PedSector
 ped_div_round_to_nearest (PedSector numerator, PedSector divisor)
 {
-                return (numerator + divisor/2) / divisor;
+	return (numerator + divisor/2) / divisor;
 }
 
 /* Rounds a number up to the closest number that is a multiple of
diff --git a/libparted/disk.c b/libparted/disk.c
index 1582f26..c465d40 100644
--- a/libparted/disk.c
+++ b/libparted/disk.c
@@ -224,23 +224,24 @@ static int
 _add_duplicate_part (PedDisk* disk, PedPartition* old_part)
 {
 	PedPartition*	new_part;
-	PedConstraint*	constraint_exact;
+	int ret;
 
 	new_part = disk->type->ops->partition_duplicate (old_part);
 	if (!new_part)
 		goto error;
 	new_part->disk = disk;
 
-	constraint_exact = ped_constraint_exact (&new_part->geom);
-	if (!constraint_exact)
+	_disk_push_update_mode (disk);
+	ret = _disk_raw_add (disk, new_part);
+	_disk_pop_update_mode (disk);
+	if (!ret)
 		goto error_destroy_new_part;
-	if (!ped_disk_add_partition (disk, new_part, constraint_exact))
-       		goto error_destroy_constraint_exact;
-	ped_constraint_destroy (constraint_exact);
+#ifdef DEBUG
+	if (!_disk_check_sanity (disk))
+		goto error_destroy_new_part;
+#endif
 	return 1;
 
-error_destroy_constraint_exact:
-	ped_constraint_destroy (constraint_exact);
 error_destroy_new_part:
 	ped_partition_destroy (new_part);
 error:
@@ -2161,6 +2162,8 @@ ped_partition_flag_get_name (PedPartitionFlag flag)
 	switch (flag) {
 	case PED_PARTITION_BOOT:
 		return N_("boot");
+	case PED_PARTITION_BIOS_GRUB:
+		return N_("bios_grub");
 	case PED_PARTITION_ROOT:
 		return N_("root");
 	case PED_PARTITION_SWAP:
diff --git a/libparted/exception.c b/libparted/exception.c
index 0940d65..230a9b7 100644
--- a/libparted/exception.c
+++ b/libparted/exception.c
@@ -1,6 +1,6 @@
 /*
     libparted - a library for manipulating disk partitions
-    Copyright (C) 1999, 2000, 2007 Free Software Foundation, Inc.
+    Copyright (C) 1999, 2000, 2007-2008 Free Software Foundation, Inc.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -73,7 +73,7 @@ static PedExceptionHandler*	ex_handler = default_handler;
 static PedException*		ex = NULL;
 static int			ex_fetch_count = 0;
 
-static char*	type_strings [] = {
+static const char *const type_strings [] = {
 	N_("Information"),
 	N_("Warning"),
 	N_("Error"),
@@ -82,7 +82,7 @@ static char*	type_strings [] = {
 	N_("No Implementation")
 };
 
-static char*	option_strings [] = {
+static const char *const option_strings [] = {
 	N_("Fix"),
 	N_("Yes"),
 	N_("No"),
@@ -98,7 +98,7 @@ static char*	option_strings [] = {
 char*
 ped_exception_get_type_string (PedExceptionType ex_type)
 {
-	return type_strings [ex_type - 1];
+	return (char *) type_strings [ex_type - 1];
 }
 
 /* FIXME: move this out to the prospective math.c */
@@ -121,7 +121,7 @@ ped_log2 (int n)
 char*
 ped_exception_get_option_string (PedExceptionOption ex_opt)
 {
-	return option_strings [ped_log2 (ex_opt)];
+	return (char *) option_strings [ped_log2 (ex_opt)];
 }
 
 static PedExceptionOption
@@ -243,8 +243,8 @@ ped_exception_throw (PedExceptionType ex_type,
 	ex->type = ex_type;
 	ex->options = ex_opts;
 
-	while (1) {
-			ex->message = (char*) malloc (size);
+	while (message) {
+			ex->message = (char*) malloc (size * sizeof (char));
 			if (!ex->message)
 					goto no_memory;
 
@@ -256,6 +256,7 @@ ped_exception_throw (PedExceptionType ex_type,
 					break;
 
 			size += 10;
+			ped_free (ex->message);
 	}
 
 	return do_throw ();
diff --git a/libparted/fs/ext2/ext2.c b/libparted/fs/ext2/ext2.c
index 618fca9..79fc6f6 100644
--- a/libparted/fs/ext2/ext2.c
+++ b/libparted/fs/ext2/ext2.c
@@ -727,7 +727,10 @@ struct ext2_fs *ext2_open(struct ext2_dev_handle *handle, int state)
 			    EXT2_FEATURE_RO_COMPAT_LARGE_FILE)))
 	{
 		ped_exception_throw (PED_EXCEPTION_ERROR, PED_EXCEPTION_CANCEL,
-		     _("File system has an incompatible feature enabled."));
+		     _("File system has an incompatible feature enabled.  "
+		       "Compatible features are has_journal, dir_index, "
+		       "filetype, sparse_super and large_file.  "
+		       "Use tune2fs or debugfs to remove features."));
 		goto error_free_fs;
 	}
 
diff --git a/libparted/fs/ext2/ext2_block_relocator.c b/libparted/fs/ext2/ext2_block_relocator.c
index b75a4c5..60f3d50 100644
--- a/libparted/fs/ext2/ext2_block_relocator.c
+++ b/libparted/fs/ext2/ext2_block_relocator.c
@@ -691,10 +691,11 @@ static int ext2_block_relocator_flush(struct ext2_fs *fs, struct ext2_block_relo
 		{
 			/* FIXXXME gross hack */
 			fprintf(stderr, "relocating %s blocks",
-				((char *[4]){"direct",
-						     "singly indirect",
-						     "doubly indirect",
-						     "triply indirect"})[i]);
+				((const char *const [4])
+				 {"direct",
+				  "singly indirect",
+				  "doubly indirect",
+				  "triply indirect"})[i]);
 			fflush(stderr);
 		}
 
diff --git a/libparted/fs/ext2/ext2_mkfs.c b/libparted/fs/ext2/ext2_mkfs.c
index 19931dd..b1a8ce3 100644
--- a/libparted/fs/ext2/ext2_mkfs.c
+++ b/libparted/fs/ext2/ext2_mkfs.c
@@ -1,6 +1,6 @@
 /*
     ext2_mkfs.c -- ext2 fs creator
-    Copyright (C) 1999, 2000, 2001, 2007 Free Software Foundation, Inc.
+    Copyright (C) 1999, 2000, 2001, 2007-2008 Free Software Foundation, Inc.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -263,7 +263,7 @@ error:
 
 /* returns the offset into the buffer of the start of the next dir entry */
 static int _set_dirent(void* buf, int offset, int block_size, int is_last,
-		       uint32_t inode, char* name, int file_type)
+		       uint32_t inode, const char* name, int file_type)
 {
 	struct ext2_dir_entry_2 *dirent = (void*) (((char*)buf) + offset);
 	int name_len = strlen(name);
diff --git a/libparted/fs/fat/resize.c b/libparted/fs/fat/resize.c
index 7386948..5f24ec2 100644
--- a/libparted/fs/fat/resize.c
+++ b/libparted/fs/fat/resize.c
@@ -1,6 +1,6 @@
 /*
     libparted
-    Copyright (C) 1998, 1999, 2000, 2007 Free Software Foundation, Inc.
+    Copyright (C) 1998, 1999, 2000, 2007-2008 Free Software Foundation, Inc.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -481,8 +481,8 @@ ask_type (PedFileSystem* fs, int fat16_ok, int fat32_ok, FatType* out_fat_type)
 {
 	FatSpecific*		fs_info = FAT_SPECIFIC (fs);
 	PedExceptionOption	status;
-	char*			fat16_msg;
-	char*			fat32_msg;
+	const char*		fat16_msg;
+	const char*		fat32_msg;
 
 	if (fs_info->fat_type == FAT_TYPE_FAT16)
 		fat16_msg = _("If you leave your file system as FAT16, "
diff --git a/libparted/fs/fat/traverse.c b/libparted/fs/fat/traverse.c
index 3d2e2b5..4ef2044 100644
--- a/libparted/fs/fat/traverse.c
+++ b/libparted/fs/fat/traverse.c
@@ -120,7 +120,7 @@ fat_traverse_mark_dirty (FatTraverseInfo* trav_info)
 
 FatTraverseInfo*
 fat_traverse_begin (PedFileSystem* fs, FatCluster start_cluster,
-		    char* dir_name)
+		    const char* dir_name)
 {
 	FatSpecific*		fs_info = FAT_SPECIFIC (fs);
 	FatTraverseInfo*	trav_info;
diff --git a/libparted/fs/fat/traverse.h b/libparted/fs/fat/traverse.h
index 21e4c27..afb24a5 100644
--- a/libparted/fs/fat/traverse.h
+++ b/libparted/fs/fat/traverse.h
@@ -42,7 +42,8 @@ extern int fat_traverse_entries_per_buffer (FatTraverseInfo* trav_info);
 /* starts traversal at an arbitary cluster.  if start_cluster==0, then uses
    root directory */
 extern FatTraverseInfo* fat_traverse_begin (PedFileSystem* fs,
-				     FatCluster start_cluster, char* dir_name);
+					    FatCluster start_cluster,
+					    const char* dir_name);
 
 extern int fat_traverse_complete (FatTraverseInfo* trav_info);
 
diff --git a/libparted/labels/bsd.c b/libparted/labels/bsd.c
index f25353b..ee9aba0 100644
--- a/libparted/labels/bsd.c
+++ b/libparted/labels/bsd.c
@@ -108,6 +108,9 @@ typedef struct {
 
 typedef struct {
 	uint8_t		type;
+	int			boot;
+	int			raid;
+	int			lvm;
 } BSDPartitionData;
 
 static PedDiskType bsd_disk_type;
@@ -394,6 +397,9 @@ bsd_partition_new (const PedDisk* disk, PedPartitionType part_type,
 		if (!bsd_data)
 			goto error_free_part;
 		bsd_data->type = 0;
+		bsd_data->boot = 0;
+		bsd_data->raid = 0;
+		bsd_data->lvm  = 0;
 	} else {
 		part->disk_specific = NULL;
 	}
@@ -423,6 +429,9 @@ bsd_partition_duplicate (const PedPartition* part)
 	old_bsd_data = (BSDPartitionData*) part->disk_specific;
 	new_bsd_data = (BSDPartitionData*) new_part->disk_specific;
 	new_bsd_data->type = old_bsd_data->type;
+	new_bsd_data->boot = old_bsd_data->boot;
+	new_bsd_data->raid = old_bsd_data->raid;
+	new_bsd_data->lvm = old_bsd_data->lvm;
 	return new_part;
 }
 
@@ -456,14 +465,60 @@ bsd_partition_set_system (PedPartition* part, const PedFileSystemType* fs_type)
 static int
 bsd_partition_set_flag (PedPartition* part, PedPartitionFlag flag, int state)
 {
-	/* no flags for bsd */
+	PedDisk*			disk;
+//	PedPartition*		walk; // since -Werror, this unused variable would break build
+	BSDPartitionData*	bsd_data;
+
+	PED_ASSERT (part != NULL, return 0);
+	PED_ASSERT (part->disk_specific != NULL, return 0);
+	PED_ASSERT (part->disk != NULL, return 0);
+
+	bsd_data = part->disk_specific;
+	disk = part->disk;
+
+	switch (flag) {
+		case PED_PARTITION_BOOT:
+			bsd_data->boot = state;
+			return 1;
+		case PED_PARTITION_RAID:
+			if (state) {
+				bsd_data->lvm = 0;
+			}
+			bsd_data->raid = state;
+			return 1;
+		case PED_PARTITION_LVM:
+			if (state) {
+				bsd_data->raid = 0;
+			}
+			bsd_data->lvm = state;
+		default:
+			;
+	}
 	return 0;
 }
 
 static int
 bsd_partition_get_flag (const PedPartition* part, PedPartitionFlag flag)
 {
-	/* no flags for bsd */
+	BSDPartitionData*		bsd_data;
+
+	PED_ASSERT (part != NULL, return 0);
+	PED_ASSERT (part->disk_specific != NULL, return 0);
+
+	bsd_data = part->disk_specific;
+	switch (flag) {
+		case PED_PARTITION_BOOT:
+			return bsd_data->boot;
+
+		case PED_PARTITION_RAID:
+			return bsd_data->raid;
+
+		case PED_PARTITION_LVM:
+			return bsd_data->lvm;
+
+		default:
+			;
+	}
 	return 0;
 }
 
@@ -471,7 +526,14 @@ static int
 bsd_partition_is_flag_available (const PedPartition* part,
 				 PedPartitionFlag flag)
 {
-	/* no flags for bsd */
+	switch (flag) {
+		case PED_PARTITION_BOOT:
+		case PED_PARTITION_RAID:
+		case PED_PARTITION_LVM:
+			return 1;
+		default:
+			;
+	}
 	return 0;
 }
 
diff --git a/libparted/labels/dos.c b/libparted/labels/dos.c
index c686658..641257c 100644
--- a/libparted/labels/dos.c
+++ b/libparted/labels/dos.c
@@ -190,14 +190,16 @@ msdos_probe (const PedDevice *dev)
 	if (PED_LE16_TO_CPU (part_table->magic) != MSDOS_MAGIC)
 		goto probe_fail;
 
-	/* if this is a FAT fs, fail here.  Note that the Smart Boot Manager
-	 * Loader (SBML) signature indicates a partition table, not a file
-	 * system.
+	/* If this is a FAT fs, fail here.  Checking for the FAT signature
+	 * has some false positives; instead, do what the Linux kernel does
+	 * and ensure that each partition has a boot indicator that is
+	 * either 0 or 0x80.
 	 */
-	if ((!strncmp (part_table->boot_code + 0x36, "FAT", 3)
-	    && strncmp (part_table->boot_code + 0x40, "SBML", 4) != 0)
-	    || !strncmp (part_table->boot_code + 0x52, "FAT", 3))
-		goto probe_fail;
+	for (i = 0; i < 4; i++) {
+		if (part_table->partitions[i].boot_ind != 0
+		    && part_table->partitions[i].boot_ind != 0x80)
+			goto probe_fail;
+	}
 
 	/* If this is a GPT disk, fail here */
 	for (i = 0; i < 4; i++) {
diff --git a/libparted/labels/fdasd.c b/libparted/labels/fdasd.c
index e4ecf52..7adf12f 100644
--- a/libparted/labels/fdasd.c
+++ b/libparted/labels/fdasd.c
@@ -149,7 +149,7 @@ fdasd_error (fdasd_anchor_t *anc, enum fdasd_failure why, char * str)
 		case device_verification_failed:
 			sprintf(error, "fdasd: %s -- %s\n",
 				_("Device verification failed"),
-				_("The specified device is not a valid DASD device"));,
+				_("The specified device is not a valid DASD device"));
 			break;
 		default: 
 			sprintf(error, "fdasd: %s: %s\n", _("Fatal error"), str);
diff --git a/libparted/labels/gpt.c b/libparted/labels/gpt.c
index 4dc4f10..cb90d11 100644
--- a/libparted/labels/gpt.c
+++ b/libparted/labels/gpt.c
@@ -4,7 +4,7 @@
     original version by Matt Domsch <Matt_Domsch@dell.com>
     Disclaimed into the Public Domain
 
-    Portions Copyright (C) 2001, 2002, 2003, 2005, 2006, 2007
+    Portions Copyright (C) 2001, 2002, 2003, 2005, 2006, 2007, 2008
         Free Software Foundation, Inc.
 
     EFI GUID Partition Table handling
@@ -86,6 +86,10 @@ typedef struct {
     ((efi_guid_t) { PED_CPU_TO_LE32 (0xC12A7328), PED_CPU_TO_LE16 (0xF81F), \
     		    PED_CPU_TO_LE16 (0x11d2), 0xBA, 0x4B, \
 		    { 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B }})
+#define PARTITION_BIOS_GRUB_GUID \
+    ((efi_guid_t) { PED_CPU_TO_LE32 (0x21686148), PED_CPU_TO_LE16 (0x6449), \
+    		    PED_CPU_TO_LE16 (0x6E6f), 0x74, 0x4E, \
+		    { 0x65, 0x65, 0x64, 0x45, 0x46, 0x49 }})
 #define LEGACY_MBR_PARTITION_GUID \
     ((efi_guid_t) { PED_CPU_TO_LE32 (0x024DEE41), PED_CPU_TO_LE16 (0x33E7), \
 		    PED_CPU_TO_LE16 (0x11d3, 0x9D, 0x69, \
@@ -245,6 +249,7 @@ typedef struct _GPTPartitionData {
 	int		lvm;
 	int		raid;
 	int		boot;
+	int		bios_grub;
 	int		hp_service;
         int             hidden;
         int             msftres;
@@ -753,13 +758,16 @@ _parse_part_entry (PedDisk* disk, GuidPartitionEntry_t* pte)
         
         gpt_part_data->lvm = gpt_part_data->raid 
                 = gpt_part_data->boot = gpt_part_data->hp_service
-                = gpt_part_data->hidden = gpt_part_data->msftres = 0;
+                = gpt_part_data->hidden = gpt_part_data->msftres
+                = gpt_part_data->bios_grub = 0;
 
         if (pte->Attributes.RequiredToFunction & 0x1)
                 gpt_part_data->hidden = 1;
        
 	if (!guid_cmp (gpt_part_data->type, PARTITION_SYSTEM_GUID))
 		gpt_part_data->boot = 1;
+	else if (!guid_cmp (gpt_part_data->type, PARTITION_BIOS_GRUB_GUID))
+		gpt_part_data->bios_grub = 1;
 	else if (!guid_cmp (gpt_part_data->type, PARTITION_RAID_GUID))
 		gpt_part_data->raid = 1;
 	else if (!guid_cmp (gpt_part_data->type, PARTITION_LVM_GUID))
@@ -1130,6 +1138,7 @@ gpt_partition_new (const PedDisk* disk,
 	gpt_part_data->lvm = 0;
 	gpt_part_data->raid = 0;
 	gpt_part_data->boot = 0;
+	gpt_part_data->bios_grub = 0;
 	gpt_part_data->hp_service = 0;
         gpt_part_data->hidden = 0;
         gpt_part_data->msftres = 0;
@@ -1208,6 +1217,10 @@ gpt_partition_set_system (PedPartition* part, const PedFileSystemType* fs_type)
 		gpt_part_data->type = PARTITION_SYSTEM_GUID;
 		return 1;
 	}
+	if (gpt_part_data->bios_grub) {
+		gpt_part_data->type = PARTITION_BIOS_GRUB_GUID;
+		return 1;
+	}
 	if (gpt_part_data->hp_service) {
 		gpt_part_data->type = PARTITION_HPSERVICE_GUID;
 		return 1;
@@ -1306,6 +1319,16 @@ gpt_partition_set_flag(PedPartition *part,
 		if (state)
                         gpt_part_data->raid 
                                 = gpt_part_data->lvm
+                                = gpt_part_data->bios_grub
+                                = gpt_part_data->hp_service
+                                = gpt_part_data->msftres = 0;
+		return gpt_partition_set_system (part, part->fs_type);
+	case PED_PARTITION_BIOS_GRUB:
+		gpt_part_data->bios_grub = state;
+		if (state)
+                        gpt_part_data->raid 
+                                = gpt_part_data->lvm
+                                = gpt_part_data->boot
                                 = gpt_part_data->hp_service
                                 = gpt_part_data->msftres = 0;
 		return gpt_partition_set_system (part, part->fs_type);
@@ -1314,6 +1337,7 @@ gpt_partition_set_flag(PedPartition *part,
 		if (state)
                         gpt_part_data->boot
                                 = gpt_part_data->lvm
+                                = gpt_part_data->bios_grub
                                 = gpt_part_data->hp_service
                                 = gpt_part_data->msftres = 0;
 		return gpt_partition_set_system (part, part->fs_type);
@@ -1322,6 +1346,7 @@ gpt_partition_set_flag(PedPartition *part,
 		if (state)
                         gpt_part_data->boot
                                 = gpt_part_data->raid
+                                = gpt_part_data->bios_grub
                                 = gpt_part_data->hp_service
                                 = gpt_part_data->msftres = 0;
 		return gpt_partition_set_system (part, part->fs_type);
@@ -1331,6 +1356,7 @@ gpt_partition_set_flag(PedPartition *part,
                         gpt_part_data->boot
                                 = gpt_part_data->raid
                                 = gpt_part_data->lvm
+                                = gpt_part_data->bios_grub
                                 = gpt_part_data->msftres = 0;
 		return gpt_partition_set_system (part, part->fs_type);
         case PED_PARTITION_MSFT_RESERVED:
@@ -1339,6 +1365,7 @@ gpt_partition_set_flag(PedPartition *part,
                         gpt_part_data->boot
                                 = gpt_part_data->raid
                                 = gpt_part_data->lvm
+                                = gpt_part_data->bios_grub
                                 = gpt_part_data->hp_service = 0;
                 return gpt_partition_set_system (part, part->fs_type);
         case PED_PARTITION_HIDDEN:
@@ -1367,6 +1394,8 @@ gpt_partition_get_flag(const PedPartition *part, PedPartitionFlag flag)
 		return gpt_part_data->lvm;
 	case PED_PARTITION_BOOT:
 		return gpt_part_data->boot;
+	case PED_PARTITION_BIOS_GRUB:
+		return gpt_part_data->bios_grub;
 	case PED_PARTITION_HPSERVICE:
 		return gpt_part_data->hp_service;
         case PED_PARTITION_MSFT_RESERVED:
@@ -1390,6 +1419,7 @@ gpt_partition_is_flag_available(const PedPartition * part,
 	case PED_PARTITION_RAID:
 	case PED_PARTITION_LVM:
 	case PED_PARTITION_BOOT:
+	case PED_PARTITION_BIOS_GRUB:
 	case PED_PARTITION_HPSERVICE:
         case PED_PARTITION_MSFT_RESERVED:
         case PED_PARTITION_HIDDEN:        
diff --git a/libparted/labels/mac.c b/libparted/labels/mac.c
index f014194..538e0c0 100644
--- a/libparted/labels/mac.c
+++ b/libparted/labels/mac.c
@@ -1,6 +1,6 @@
 /*
     libparted - a library for manipulating disk partitions
-    Copyright (C) 2000, 2002, 2004, 2007 Free Software Foundation, Inc.
+    Copyright (C) 2000, 2002, 2004, 2007-2008 Free Software Foundation, Inc.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -376,19 +376,19 @@ mac_clobber (PedDevice* dev)
 #endif /* !DISCOVER_ONLY */
 
 static int
-_rawpart_cmp_type (MacRawPartition* raw_part, char* type)
+_rawpart_cmp_type (const MacRawPartition* raw_part, const char* type)
 {
 	return strncasecmp (raw_part->type, type, 32) == 0;
 }
 
 static int
-_rawpart_cmp_name (MacRawPartition* raw_part, char* name)
+_rawpart_cmp_name (const MacRawPartition* raw_part, const char* name)
 {
 	return strncasecmp (raw_part->name, name, 32) == 0;
 }
 
 static int
-_rawpart_is_partition_map (MacRawPartition* raw_part)
+_rawpart_is_partition_map (const MacRawPartition* raw_part)
 {
 	return _rawpart_cmp_type (raw_part, "Apple_partition_map");
 }
@@ -408,7 +408,7 @@ strncasestr (const char* haystack, const char* needle, int n)
 }
 
 static int
-_rawpart_is_boot (MacRawPartition* raw_part)
+_rawpart_is_boot (const MacRawPartition* raw_part)
 {
 	if (!strcasecmp(raw_part->type, "Apple_Bootstrap"))
 		return 1;
@@ -420,7 +420,7 @@ _rawpart_is_boot (MacRawPartition* raw_part)
 }
 
 static int
-_rawpart_is_driver (MacRawPartition* raw_part)
+_rawpart_is_driver (const MacRawPartition* raw_part)
 {
 	if (strncmp (raw_part->type, "Apple_", 6) != 0)
 		return 0;
@@ -430,7 +430,7 @@ _rawpart_is_driver (MacRawPartition* raw_part)
 }
 
 static int
-_rawpart_has_driver (MacRawPartition* raw_part, MacDiskData* mac_disk_data)
+_rawpart_has_driver (const MacRawPartition* raw_part, MacDiskData* mac_disk_data)
 {
 	MacDeviceDriver *driverlist;
 	uint16_t i, bsz;
diff --git a/libparted/tests/Makefile.am b/libparted/tests/Makefile.am
index 12ad29f..d526207 100644
--- a/libparted/tests/Makefile.am
+++ b/libparted/tests/Makefile.am
@@ -3,13 +3,17 @@
 #
 # This file may be modified and/or distributed without restriction.
 
-TESTS = t1000-label.sh
+TESTS = t1000-label.sh t2000-disk.sh
 EXTRA_DIST = $(TESTS)
-bin_PROGRAMS     = label
+bin_PROGRAMS     = label disk
 label_CFLAGS    = $(CHECK_CFLAGS) -I$(top_srcdir)/include
 label_LDADD     = $(CHECK_LIBS) $(top_builddir)/libparted/libparted.la
 label_SOURCES   = common.h common.c label.c
 
+disk_CFLAGS    = $(CHECK_CFLAGS) -I$(top_srcdir)/include
+disk_LDADD     = $(CHECK_LIBS) $(top_builddir)/libparted/libparted.la
+disk_SOURCES   = common.h common.c disk.c
+
 MAINTAINERCLEANFILES = Makefile.in
 
 CLEANFILES = init.sh
diff --git a/libparted/tests/disk.c b/libparted/tests/disk.c
new file mode 100644
index 0000000..295ec05
--- /dev/null
+++ b/libparted/tests/disk.c
@@ -0,0 +1,111 @@
+#include <config.h>
+#include <unistd.h>
+
+#include <check.h>
+
+#include <parted/parted.h>
+
+#include "common.h"
+
+static char* temporary_disk;
+
+static void
+create_disk (void)
+{
+        temporary_disk = _create_disk (20);
+        fail_if (temporary_disk == NULL, "Failed to create temporary disk");
+}
+
+static void
+destroy_disk (void)
+{
+        unlink (temporary_disk);
+        free (temporary_disk);
+}
+
+/* TEST: Create a disklabel on a simple disk image */
+START_TEST (test_duplicate)
+{
+        PedDevice* dev = ped_device_get (temporary_disk);
+        if (dev == NULL)
+                return;
+
+        PedDiskType* type;
+        PedDisk* disk;
+        PedDisk* disk_dup;
+        PedPartition *part;
+        PedPartition *part_dup;
+        PedConstraint *constraint;
+
+        int part_num[] = {1, 5, 6, 0};
+
+        disk = _create_disk_label (dev, ped_disk_type_get ("msdos"));
+
+        constraint = ped_constraint_any (dev);
+
+        /* Primary partition from 16,4kB to 15MB */
+        part = ped_partition_new (disk, PED_PARTITION_EXTENDED,
+                                  NULL,
+                                  32, 29311);
+        ped_disk_add_partition (disk, part, constraint);
+
+        /* Logical partition from 10MB to 15MB */
+        part = ped_partition_new (disk, PED_PARTITION_LOGICAL,
+                                  ped_file_system_type_get ("ext2"),
+                                  19584, 29311);
+        ped_disk_add_partition (disk, part, constraint);
+
+        /* Logical partition from 16,4kB to 4981kB */
+        part = ped_partition_new (disk, PED_PARTITION_LOGICAL,
+                                  ped_file_system_type_get ("ext2"),
+                                  32, 9727);
+        ped_disk_add_partition (disk, part, constraint);
+
+        ped_disk_commit (disk);
+
+        ped_constraint_destroy (constraint);
+
+        disk_dup = ped_disk_duplicate (disk);
+
+        /* Checks if both partitions match */
+        for (int *i = part_num; *i != 0; i++) {
+                part = ped_disk_get_partition (disk, *i);
+                part_dup = ped_disk_get_partition (disk_dup, *i);
+
+                fail_if (part->geom.start != part_dup->geom.start ||
+                         part->geom.end != part_dup->geom.end,
+                         "Duplicated partition %d doesn't match. "
+                         "Details are start: %d/%d end: %d/%d\n",
+                         *i, part->geom.start, part_dup->geom.start,
+                         part->geom.end, part_dup->geom.end);
+        }
+
+        ped_disk_destroy (disk);
+        ped_device_destroy (dev);
+}
+END_TEST
+
+int
+main (void)
+{
+        int number_failed;
+        Suite* suite = suite_create ("Disk");
+        TCase* tcase_duplicate = tcase_create ("Duplicate");
+
+        /* Fail when an exception is raised */
+        ped_exception_set_handler (_test_exception_handler);
+
+        tcase_add_checked_fixture (tcase_duplicate, create_disk, destroy_disk);
+        tcase_add_test (tcase_duplicate, test_duplicate);
+        /* Disable timeout for this test */
+        tcase_set_timeout (tcase_duplicate, 0);
+        suite_add_tcase (suite, tcase_duplicate);
+
+        SRunner* srunner = srunner_create (suite);
+        srunner_run_all (srunner, CK_VERBOSE);
+
+        number_failed = srunner_ntests_failed (srunner);
+        srunner_free (srunner);
+
+        return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/libparted/tests/t2000-disk.sh b/libparted/tests/t2000-disk.sh
new file mode 100755
index 0000000..7a85b98
--- /dev/null
+++ b/libparted/tests/t2000-disk.sh
@@ -0,0 +1,27 @@
+#!/bin/sh
+
+# Copyright (C) 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+test_description='run the disk unit tests in a directory supporting O_DIRECT'
+# This wrapper around the ./label binary is used to find a directory
+# in which one can open a file with the O_DIRECT flag.
+
+. ./init.sh
+
+test_expect_success \
+    'run the actual tests' 'disk'
+
+test_done
diff --git a/parted/parted.c b/parted/parted.c
index 6a606ae..2afc2c1 100644
--- a/parted/parted.c
+++ b/parted/parted.c
@@ -79,7 +79,7 @@ typedef struct {
         time_t  predicted_time_left;
 } TimerContext;
 
-static struct option    options[] = {
+static const struct option const options[] = {
         /* name, has-arg, string-return-val, char-return-val */
         {"help",        0, NULL, 'h'},
         {"list",        0, NULL, 'l'},
@@ -90,7 +90,7 @@ static struct option    options[] = {
         {NULL,          0, NULL, 0}
 };
 
-static char*    options_help [][2] = {
+static const char *const options_help [][2] = {
         {"help",        N_("displays this help message")},
         {"list",        N_("lists partition layout on all block devices")},
         {"machine",     N_("displays machine parseable output")},
@@ -107,26 +107,26 @@ int     opt_machine_mode = 0;
 int     disk_is_modified = 0;
 int     is_toggle_mode = 0;
 
-static char* number_msg = N_(
+static const char* number_msg = N_(
 "NUMBER is the partition number used by Linux.  On MS-DOS disk labels, the "
 "primary partitions number from 1 to 4, logical partitions from 5 onwards.\n");
 
-static char* label_type_msg_start = N_("LABEL-TYPE is one of: ");
-static char* flag_msg_start =   N_("FLAG is one of: ");
-static char* unit_msg_start =   N_("UNIT is one of: ");
-static char* part_type_msg =    N_("PART-TYPE is one of: primary, logical, "
+static const char* label_type_msg_start = N_("LABEL-TYPE is one of: ");
+static const char* flag_msg_start =   N_("FLAG is one of: ");
+static const char* unit_msg_start =   N_("UNIT is one of: ");
+static const char* part_type_msg =    N_("PART-TYPE is one of: primary, logical, "
                                    "extended\n");
-static char* fs_type_msg_start = N_("FS-TYPE is one of: ");
-static char* start_end_msg =    N_("START and END are disk locations, such as "
+static const char* fs_type_msg_start = N_("FS-TYPE is one of: ");
+static const char* start_end_msg =    N_("START and END are disk locations, such as "
                 "4GB or 10%.  Negative values count from the end of the disk.  "
                 "For example, -1s specifies exactly the last sector.\n");
-static char* state_msg =        N_("STATE is one of: on, off\n");
-static char* device_msg =       N_("DEVICE is usually /dev/hda or /dev/sda\n");
-static char* name_msg =         N_("NAME is any word you want\n");
-static char* resize_msg_start = N_("The partition must have one of the "
+static const char* state_msg =        N_("STATE is one of: on, off\n");
+static const char* device_msg =       N_("DEVICE is usually /dev/hda or /dev/sda\n");
+static const char* name_msg =         N_("NAME is any word you want\n");
+static const char* resize_msg_start = N_("The partition must have one of the "
                                    "following FS-TYPEs: ");
 
-static char* copyright_msg = N_(
+static const char* copyright_msg = N_(
 "Copyright (C) 1998 - 2006 Free Software Foundation, Inc.\n"
 "This program is free software, covered by the GNU General Public License.\n"
 "\n"
@@ -1226,7 +1226,7 @@ partition_print (PedPartition* part)
         putchar ('\n');
 
         flags = partition_print_flags (part);
-     
+
         printf (_("Minor: %d\n"), part->num);
         printf (_("Flags: %s\n"), flags);
         printf (_("File System: %s\n"), fs->type->name);
@@ -1264,15 +1264,17 @@ do_print (PedDevice** dev)
         int             has_free_arg = 0;
         int             has_list_arg = 0;
         int             has_num_arg = 0;
-        char*           transport[13] = {"unknown", "scsi", "ide", "dac960",
-                                         "cpqarray", "file", "ataraid", "i2o",
-                                         "ubd", "dasd", "viodasd", "sx8", "dm"};
+        const char *const transport[14] = {"unknown", "scsi", "ide", "dac960",
+					   "cpqarray", "file", "ataraid", "i2o",
+					   "ubd", "dasd", "viodasd", "sx8", "dm",
+					   "xvd"};
         char*           peek_word;
         char*           start;
         char*           end;
         char*           size;
         const char*     name;
         char*           tmp;
+        char*           flags;
         wchar_t*        table_rendered;
 
         disk = ped_disk_new (*dev);
@@ -1472,7 +1474,9 @@ do_print (PedDevice** dev)
                                     str_list_append (row, name);
                             }
 
-                            str_list_append (row, partition_print_flags (part));
+                            flags = partition_print_flags (part);
+                            str_list_append (row, flags);
+                            ped_free (flags);
                     } else {
                             if (has_extended)
                                     str_list_append (row, "");
@@ -1485,6 +1489,10 @@ do_print (PedDevice** dev)
                     //PED_ASSERT (row.cols == caption.cols)
                     table_add_row_from_strlist (table, row);
                     str_list_destroy (row);
+                    ped_free (tmp);
+                    ped_free (start);
+                    ped_free (end);
+                    ped_free (size);
             }
 
             table_rendered = table_render (table); 
diff --git a/parted/ui.c b/parted/ui.c
index a53643f..f854a54 100644
--- a/parted/ui.c
+++ b/parted/ui.c
@@ -154,17 +154,17 @@ struct siginfo_t {
 #  define ILL_BADSTK (INTMAX - 8)
 #endif
 
-char* prog_name = "GNU Parted " VERSION "\n";
+const char* prog_name = "GNU Parted " VERSION "\n";
 
-static char* banner_msg = N_(
+static const char* banner_msg = N_(
 "Welcome to GNU Parted! Type 'help' to view a list of commands.\n");
 
-static char* usage_msg = N_(
+static const char* usage_msg = N_(
 "Usage: parted [OPTION]... [DEVICE [COMMAND [PARAMETERS]...]...]\n"
 "Apply COMMANDs with PARAMETERS to DEVICE.  If no COMMAND(s) are given, "
 "run in\ninteractive mode.\n");
 
-static char* bug_msg = N_(
+static const char* bug_msg = N_(
 "\n\nYou found a bug in GNU Parted! Here's what you have to do:\n\n"
 "Don't panic! The bug has most likely not affected any of your data.\n"
 "Help us to fix this bug by doing the following:\n\n"
@@ -218,7 +218,7 @@ screen_width ()
 
 /* HACK: don't specify termcap separately - it'll annoy the users. */
 #ifdef HAVE_LIBREADLINE
-        width = tgetnum ("co");
+        width = tgetnum ((char *) "co");
 #endif
 
         if (width <= 0)
@@ -569,7 +569,9 @@ _readline (const char* prompt, const StrList* possibilities)
                         fputs (line, stdout);
                         fflush (stdout);
 #endif
-                        line [strlen (line) - 1] = 0;    /* kill trailing CR */
+                        /* kill trailing NL */
+                        if (strlen (line))
+                                line [strlen (line) - 1] = 0;
                 } else {
                         free (line);
                         line = NULL;
diff --git a/parted/ui.h b/parted/ui.h
index f5cf760..77bb194 100644
--- a/parted/ui.h
+++ b/parted/ui.h
@@ -1,6 +1,6 @@
 /*
     parted - a frontend to libparted
-    Copyright (C) 1999, 2000, 2001, 2007 Free Software Foundation, Inc.
+    Copyright (C) 1999, 2000, 2001, 2007-2008 Free Software Foundation, Inc.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
 
 #include "strlist.h"
 
-extern char*	prog_name;
+extern const char *prog_name;
 
 extern int init_ui ();
 extern int non_interactive_mode (PedDevice** dev, Command* cmd_list[],
diff --git a/tests/Makefile.am b/tests/Makefile.am
index 0a42a8d..3a694fe 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -5,8 +5,10 @@ TESTS = \
   t1100-busy-label.sh \
   t1500-small-ext2.sh \
   t2000-mkfs.sh \
+  t2200-dos-label-recog.sh \
   t3000-constraints.sh \
-  t3100-resize-ext2-partion.sh
+  t3100-resize-ext2-partion.sh \
+  t5000-tags.sh
 
 EXTRA_DIST = \
   $(TESTS) test-lib.sh mkdtemp
diff --git a/tests/t2200-dos-label-recog.sh b/tests/t2200-dos-label-recog.sh
new file mode 100755
index 0000000..d5d2670
--- /dev/null
+++ b/tests/t2200-dos-label-recog.sh
@@ -0,0 +1,61 @@
+#!/bin/sh
+
+# Copyright (C) 2008 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+test_description='improved MSDOS partition-table recognition'
+
+. ./init.sh
+
+######################################################################
+# With vestiges of a preceding FAT file system boot sector in the MBR,
+# parted 1.8.8.1.29 and earlier would fail to recognize a DOS
+# partition table.
+######################################################################
+N=100k
+dev=loop-file
+test_expect_success \
+    'create a file to simulate the underlying device' \
+    'dd if=/dev/null of=$dev bs=1 seek=$N 2> /dev/null'
+
+test_expect_success \
+    'label the test disk' \
+    'parted -s $dev mklabel msdos > out 2>&1'
+test_expect_success 'expect no output' '$compare out /dev/null'
+
+test_expect_success \
+    'create two partition' \
+    '
+    parted -s $dev mkpart primary  1s 40s > out 2>&1 &&
+    parted -s $dev mkpart primary 41s 80s > out 2>&1
+
+    '
+test_expect_success 'expect no output' '$compare out /dev/null'
+
+test_expect_success \
+    'write "FAT" where it would cause trouble' \
+    'printf FAT|dd bs=1c seek=82 count=3 of=$dev conv=notrunc'
+
+test_expect_success \
+    'print the partition table' \
+    '
+    parted -m -s $dev unit s p > out &&
+    tail -2 out > k && mv k out &&
+    printf "1:1s:40s:40s:::;\n2:41s:80s:40s:::;\n" > exp
+
+    '
+test_expect_success 'expect two partitions' '$compare out exp'
+
+test_done
diff --git a/tests/t5000-tags.sh b/tests/t5000-tags.sh
new file mode 100755
index 0000000..dab48ae
--- /dev/null
+++ b/tests/t5000-tags.sh
@@ -0,0 +1,81 @@
+#!/bin/sh
+
+# Copyright (C) 2007,2008 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+test_description="test bios_grub flag in gpt labels"
+
+. ./init.sh
+
+dev=loop-file
+
+test_expect_success \
+    "setup: create zeroed device" \
+    '{ dd if=/dev/zero bs=1024 count=64; } > $dev'
+
+test_expect_success \
+    'create gpt label' \
+    'parted -s $dev mklabel gpt >out 2>&1'
+
+test_expect_success \
+    'add a partition' \
+    'parted -s $dev mkpart primary 0 1 >>out 2>&1'
+
+test_expect_success \
+    'print the table (before manual modification)' \
+    'parted -s $dev print >>out 2>&1'
+
+# Using bios_boot_magic='\x48\x61' looks nicer, but isn't portable.
+# dash's builtin printf doesn't recognize such \xHH hexadecimal escapes.
+bios_boot_magic='\110\141\150\41\111\144\157\156\164\116\145\145\144\105\106\111'
+
+printf "$bios_boot_magic" | dd of=$dev bs=1024 seek=1 conv=notrunc
+
+test_expect_success \
+    'print the table (after manual modification)' \
+    'parted -s $dev print >>out 2>&1'
+
+pwd=`pwd`
+
+fail=0
+{
+  cat <<EOF
+Model:  (file)
+Disk .../$dev: 65.5kB
+Sector size (logical/physical): 512B/512B
+Partition Table: gpt
+
+Number  Start   End     Size    File system  Name     Flags
+ 1      17.4kB  48.6kB  31.2kB               primary       
+
+Model:  (file)
+Disk .../$dev: 65.5kB
+Sector size (logical/physical): 512B/512B
+Partition Table: gpt
+
+Number  Start   End     Size    File system  Name     Flags    
+ 1      17.4kB  48.6kB  31.2kB               primary  bios_grub
+
+EOF
+} > exp || fail=1
+
+test_expect_success \
+    'prepare actual and expected output' \
+    'test $fail = 0 &&
+     mv out o2 && sed "s,^Disk .*/$dev:,Disk .../$dev:," o2 > out'
+
+test_expect_success 'check for expected output' '$compare out exp'
+
+test_done
